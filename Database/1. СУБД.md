## Базы данных

В самом широком определении базой данных является любой набор взаимосвязанной информации. 

В контексте информатики **база данных** — это организованная и определенным образом структурированная коллекция данных, обеспечивающая эффективное хранение, управление и обработку большого количества информации.

Современные базы данных обладают широкими возможностями в вопросах управления информацией, обеспечивая эффективное хранение данных, их систематизацию и доступ к ним:
- **Хранение и организация больших объемов данных.** Базы данных позволяют хранить огромное количество информации, обеспечивая эффективное использование ресурсов хранения.
- **Систематизация и структурирование данных.** Базы данных позволяют организовывать данные в согласованную структуру, определяя типы хранимых данных, связи между ними и различные правила целостности.
- **Обеспечение доступа к данным.** Базы данных поддерживают специальные языки запросов для быстрого и удобного доступа к данным.

**СУБД (система управления базами данных)** — это комплексное программное обеспечение, которое служит интерфейсом между базой данных и разработчиком, конечным пользователем или программой, предоставляя им возможность удобно взаимодействовать с базой данных и выполнять с ней все необходимые действия.

### Расположение базы данных

В зависимости от расположения базы данных СУБД разделяют на **локальные** и **распределенные**. Локальные СУБД хранят базу данных на одном сервере (или устройстве), в то время как в распределенных СУБД данные хранятся на нескольких серверах, которые физически могут находиться в разных местах.

## Модели БД
#### Иерархическая модель

В 1960-х годах была разработана **иерархическая модель** баз данных, которая используется для организации данных с иерархической структурой. В ней данные представляются в виде древовидной структуры, где каждая запись имеет родительскую запись, кроме верхнего уровня. Это позволяет эффективно организовывать данные с иерархическими связями, но требует заранее определенной структуры данных.

![[Pasted image 20240805142420.png]]

Основным недостатком иерархической модели данных является ее неуниверсальность. Реальный мир не может быть легко представлен в виде древовидной структуры с одним корневым сегментом. Иерархическая модель применима, когда между объектами существуют реальные иерархические связи.

#### Сетевая модель

**Сетевая модель** баз данных была разработана в 1960 — 1970-х годах и представляет собой расширение иерархической модели. В этой модели данные представляются в виде сети, где каждая запись может быть связана с несколькими другими записями.

![[Pasted image 20240805142516.png]]

Сетевая модель универсальна и имеет гораздо большие возможности моделирования связей между объектами по сравнению с иерархической. Основным ее недостатком является сложность. В сетевых базах данных сложно проводить изменения структуры, так как приходится перестраивать множество различных связей. Сетевую модель трудно реализовывать, так как необходимо знать все связи между разнородными объектами.

#### Реляционная модель

**Реляционная модель**, которая стала широко распространена в 1970-х годах, до сих пор остается основной и наиболее используемой. Она была разработана для управления структурированными данными с использованием табличной модели. Основная цель реляционных баз данных — обеспечить надежное хранение, организацию и доступ к данным в структурированной форме.

Реляционные базы данных организованы в виде набора связанных таблиц. Каждый столбец таблицы имеет **имя** и определенный **тип** (текст, число, дата). Каждая строка таблицы представляет собой набор связанных значений, относящихся к одной сущности. Помимо этого, каждая строка помечается уникальным идентификатором, а строки из нескольких таблиц могут быть связаны между собой с помощью этих идентификаторов.

![[Pasted image 20240805143951.png]]

Гибкость реляционных баз данных объясняется тем, что таблицы, хранящие данные, в значительной степени независимы друг от друга. Можно добавлять данные в таблицу, удалять их из нее, вносить в них изменения, при этом не затрагивая данные из других таблиц.

#### Модель ключ **—** значение

В начале 2000-х годов была создана модель **ключ —** **значение**, более известная сегодня как **хеш-таблица**. В базах данных этого типа данные хранятся в виде пар ключ — значение. Каждому значению сопоставляется уникальный ключ, по которому оно может быть получено или обновлено.

![[Pasted image 20240805144125.png]]

Базы данных вида **ключ** **—** **значение** обеспечивают быстрый доступ к данным и простую структуру хранения. Модель **ключ —** **значение** часто используется для хранения и обработки данных, где производительность и масштабируемость являются приоритетом: например, для [кеширования данных](https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88). Она не очень подходит для сложной обработки или анализа данных, но годится для приложений, где важен быстрый доступ к информации.

#### Документная модель

**Документная** или **документоориентированная** **модель** появилась в начале 2000-х годов как ответ на требования таких областей, как веб-разработка и социальные сети, которые нуждаются в высокой масштабируемости и гибкости при работе с неструктурированными данными. Основная идея этой модели заключается в хранении данных в виде **документов**, которые обычно представлены файлами в форматах вроде JSON или XML. Каждый документ представляет собой самодостаточную единицу данных, содержащую полную информацию о своей сущности. Документы могут иметь различную структуру в зависимости от требований.

![[Pasted image 20240805144355.png]]

Организация документных баз данных основывается на коллекциях или контейнерах, в которых хранятся документы. Коллекции могут содержать произвольное количество документов, и каждый документ может быть проиндексирован или иметь уникальный идентификатор для быстрого доступа к нему.

![[Pasted image 20240805144513.png]]
Документные базы данных эффективны для хранения каталожной информации. Например, в интернет-магазинах разные товары обычно имеют различное количество параметров. При использовании документной базы данных параметры каждого товара можно описать в одном документе. Изменение параметров одного товара не повлияет на другие товары.

## Реляционные базы данных

Реляционная модель представляет собой совокупность данных, состоящую из набора **таблиц**. В теории множеств, которая легла в основу этой модели, таблице соответствует термин **отношение** (relation), а таблица является его физическим представлением. Отсюда и название модели — реляционная.

Любая таблица в реляционной базе данных состоит из строк, которые называют **записями**, и столбцов, которые называют **полями**. На пересечении строк и столбцов находятся конкретные значения. Запись представляет собой набор значений, содержащий информацию о конкретной сущности, полем же является отдельная характеристика сущности.

Например, в таблице ниже содержатся 3 записи, 4 поля и 12 значений:
![[Pasted image 20240805151755.png]]
Таблица в реляционной базе данных обладает рядом свойств, отличающих ее от обычных таблиц. Например, каждое поле таблицы всегда имеет уникальное имя и тип данных, хранимых в этом поле. Если поле используется для хранения имени, то его тип будет строковым, а если для хранения возраста — числовым. Так как таблица в базе данных зачастую не одна, каждая из них обладает уникальным именем, идентифицирующим ее, и никакая другая таблица в базе данных не может носить то же самое имя.

Поле (или несколько полей), значения которого однозначно определяют записи таблицы, называется **первичным ключом**. То есть **первичный ключ** — это такое поле, значения которого в таблице не повторяются. Так, в таблице выше с полями `ID, Имя, Фамилия` и `Дата рождения` в качестве первичного ключа выступает поле `ID`, представляющее уникальный идентификатор определенного человека. В качестве первичного ключа также можно было бы выбрать сочетание полей `Имя` и `Фамилия`, однако у людей могут быть одинаковые имена и фамилии, поэтому для однозначности в таблицу было включено поле `ID`.

>Первичный ключ, состоящий из одного поля, обычно называют **простым**. Если же первичный ключ включает несколько полей, его называют **составным**.

Таблица может содержать информацию, используемую для связи с другой таблицей. Осуществляется такая навигация с помощью **внешних ключей**.

С помощью первичных и внешних ключей устанавливаются связи между таблицами. Группа связанных таблиц называется **схемой данных**. Зачастую она изображается в виде таблиц, соединенных линиями или стрелками, которые и показывают имеющиеся между таблицами связи. Например, для рассмотренных выше таблиц схема будет иметь следующий вид:

![[Pasted image 20240805152656.png]]

## Нормализация данных

**Нормализация** — это процесс организации данных в реляционной базе данных в соответствии с определенными правилами, которые делают базу данных более гибкой, устраняя избыточность данных и потенциальные ошибки.

Избыточность данных означает наличие повторяющейся или лишней информации в различных частях базы данных. Она приводит к непродуктивному расходованию ресурсов хранилища и затрудняет обслуживание базы данных. Так, в таблице ниже содержится избыточная информация:

| **ID** | **Имя** | **Фамилия** | **Предмет** |
| ------ | ------- | ----------- | ----------- |
| 1      | Билл    | Гейтс       | Информатика |
| 2      | Алан    | Тьюринг     | Информатика |
| 3      | Эдгар   | Кодд        | Математика  |

Если, например, название предмета **Информатика** изменится на **Компьютерные науки**, то его нужно будет заменить во всех записях о тех студентах, которые изучают данный предмет. Потенциальная же ошибка может заключаться, например, в потере информации. Если Эдгар решит больше не изучать математику, то придется удалить запись со сведениями о нем, и тогда информация о данном предмете будет полностью потеряна.

## Нормальные формы

Существует несколько наборов правил нормализации баз данных. Каждый такой набор называется **нормальной формой**. Выражение "привести к нормальной форме" нередко применяется как к отдельной таблице, так и к базе данных в целом. Во втором случае понимается преобразование всех таблиц базы данных так, чтобы каждая из них удовлетворяла необходимым условиям.

Каждая следующая нормальная форма содержит более строгие правила и критерии. Приводя базу данных к определенной нормальной форме, мы устраняем определенный спектр проблем. Таким образом, процесс перехода от одной нормальной формы к следующей представляет собой усовершенствование базы данных. Если база данных находится в какой-либо нормальной форме, это означает, что она **лишена определенного вида аномалий**.

Существует пять основных нормальных форм: **первая, вторая, третья, четвертая** и **пятая** нормальные формы. Иногда выделяют еще три дополнительные формы:
- шестая нормальная форма
- нормальная форма Бойса-Кодда
- доменно-ключевая нормальная форма

База данных считается **нормализованной**, если она находится **как минимум в третьей нормальной форме**. Нормализация до третьей нормальной формы является стандартной практикой, так как она устраняет достаточное количество аномалий. Ситуации, при которых требуется нормализовать базу данных до четвертой нормальной формы, встречаются достаточно редко.

Все последующие нормальные формы относятся скорее к теоретическим нормальным формам, и на практике трудно представить ситуации, при которых потребуется нормализовать до них базу.

## Первая нормальная форма

Первая нормальная форма является начальным уровнем нормализации данных. Она включает следующие правила:
- **в таблице не должно быть полей с одинаковым смыслом**
- **в каждой ячейке таблицы должно находиться одиночное несоставное значение**
- **таблица должна иметь первичный ключ**

В качестве примера приведения к первой нормальной форме рассмотрим следующую таблицу:

| **ID** | **Имя** | **Фамилия** | **Первый предмет** | **Второй предмет** |
| ------ | ------- | ----------- | ------------------ | ------------------ |
| 1      | Билл    | Гейтс       | Информатика        | Маркетинг          |
| 2      | Алан    | Тьюринг     | Криптография       | Математика         |
| 3      | Эдгар   | Кодд        | Информатика        | Математика         |

Данная таблица не соответствует первой нормальной форме, так как содержит поля с одинаковым смыслом: `Первый предмет` и `Второй предмет`. В подобных таблицах сложно обеспечивать согласованность данных. Например, если появится студент, изучающий три или четыре предмета, придется целиком изменять структуру таблицы. Потенциальным решением проблемы может являться группировка схожих полей:

| **ID** | **Имя** | **Фамилия** | **Предметы**                  |
| ------ | ------- | ----------- | ----------------------------- |
| 1      | Билл    | Гейтс       | Информатика,  <br>Маркетинг   |
| 2      | Алан    | Тьюринг     | Криптография,  <br>Математика |
| 3      | Эдгар   | Кодд        | Информатика,  <br>Математика  |

Однако таблица по-прежнему не находится в первой нормальной форме, так как теперь некоторые ее ячейки содержат составные значения. Решением может быть дублирование записей таким образом, чтобы каждое составное значение стало одиночным:

| **ID** | **Имя** | **Фамилия** | **Предмет**  |
| ------ | ------- | ----------- | ------------ |
| 1      | Билл    | Гейтс       | Информатика  |
| 1      | Билл    | Гейтс       | Маркетинг    |
| 2      | Алан    | Тьюринг     | Криптография |
| 2      | Алан    | Тьюринг     | Математика   |
| 3      | Эдгар   | Кодд        | Информатика  |
| 3      | Эдгар   | Кодд        | Математика   |

Теперь таблица находится в первой нормальной форме, так как она не имеет схожих по смыслу полей, в каждой ее ячейке находится одиночное значение, а первичным ключом в ней является сочетание полей `ID` и `Предмет`. Несмотря на это, она подвержена аномалиям. В частности, в данную таблицу нельзя внести информацию о студенте, не указав хотя бы один изучаемый предмет, а также невозможно удалить информацию обо всех изучаемых студентом предметах, не удалив информацию о нем самом.

## Вторая нормальная форма

Вторая нормальная форма является продолжением первой нормальной формы и включает следующие правила:
- **таблица должна находиться в первой нормальной форме**
- **каждое неключевое поле таблицы должно зависеть только от полного первичного ключа, то есть от всех его полей**

В качестве примера приведения ко второй нормальной форме рассмотрим предложенную ранее таблицу, которая уже находится в первой нормальной форме, однако для большей наглядности последующих рассуждений добавим в нее еще одно поле:

| **ID** | **Имя** | **Фамилия** | **Предмет**  | **Оценка** |
| ------ | ------- | ----------- | ------------ | ---------- |
| 1      | Билл    | Гейтс       | Информатика  | 5          |
| 1      | Билл    | Гейтс       | Маркетинг    | 4          |
| 2      | Алан    | Тьюринг     | Криптография | 5          |
| 2      | Алан    | Тьюринг     | Математика   | 5          |
| 3      | Эдгар   | Кодд        | Информатика  | 5          |
| 3      | Эдгар   | Кодд        | Математика   | 5          |

Данная таблица не находится во второй нормальной форме. Например, в ней существуют зависимость поля `Оценка` от полей `ID` и `Предмет` (оценка зависит от студента и предмета), а также зависимость полей `Имя` и `Фамилия` от поля `ID` (персональная информация студента зависит только от него самого). Таким образом, поля `Имя` и `Фамилия` зависят не от полного первичного ключа, а лишь от его части, так как первичным ключом является сочетание полей `ID` и `Предмет`, но при этом поле `Предмет` можно убрать без потери зависимости.

Чтобы привести данную таблицу ко второй нормальной форме, необходимо разбить ее на несколько таблиц с учетом всех неполных зависимостей. В нашем случае неполную зависимость образуют поля `Имя` и `Фамилия`, поэтому их следует вынести в отдельную таблицу:

| **ID** | **Имя** | **Фамилия** |
| ------ | ------- | ----------- |
| 1      | Билл    | Гейтс       |
| 2      | Алан    | Тьюринг     |
| 3      | Эдгар   | Кодд        |

Тогда исходная таблица примет следующий вид:

| **ID** | **Предмет**  | **Оценка** |
| ------ | ------------ | ---------- |
| 1      | Информатика  | 5          |
| 1      | Маркетинг    | 4          |
| 2      | Криптография | 5          |
| 2      | Математика   | 5          |
| 3      | Информатика  | 5          |
| 3      | Математика   | 5          |

Теперь мы имеем две таблицы, каждая из которых находится во второй нормальной форме. Также можно заметить, что после этого разбиения персональные данные студента и информация о его успеваемости стали независимыми. Это значит, что больше нет части аномалий, свойственных первой нормальной форме: вставка и удаление данных не затрагивают информацию, не связанную с ними напрямую.

> Процесс разбиения одной большой таблицы на несколько меньших таблиц называется **декомпозицией**.

## Третья нормальная форма

Третья нормальная форма исправляет оставшиеся после приведения ко второй нормальной форме аномалии и включает следующие правила: 

- **таблица должна находиться во второй нормальной форме**
- **каждое неключевое поле таблицы должно зависеть только от первичного ключа и ни от какого другого неключевого поля**

Другими словами, третья нормальная форма говорит о том, что неключевые поля не должны вести себя как первичные ключи. Они не должны давать возможности получить данные из других полей, так как их задачей является лишь предоставление той информации, которая находится в них самих.

В качестве примера приведения к третьей нормальной форме рассмотрим следующую таблицу, которая уже находится во второй нормальной форме:

| **ID** | **Имя** | **Фамилия** | **Должность** | **Зарплата** |
| ------ | ------- | ----------- | ------------- | ------------ |
| 1      | Билл    | Гейтс       | Программист   | 120 000      |
| 2      | Алан    | Тьюринг     | Криптограф    | 100 000      |
| 3      | Эдгар   | Кодд        | Программист   | 120 000      |

Данная таблица содержит список сотрудников с указанием их должностей и размеров заработной платы. Первичным ключом в ней является поле `ID`. При этом известно, что размер заработной платы сотрудника полностью определяется занимаемой должностью. Следовательно, существует зависимость поля `Зарплата` от поля `Должность`, что делает таблицу не соответствующей требованиям третьей нормальной формы, и в ней есть аномалии модификации. Например, если Алан решит стать программистом, его зарплата все равно останется на прежнем уровне.

Таблица во второй нормальной форме приводится к третьей способом, похожим на то, как первая нормальная форма приводится ко второй — путем декомпозиции с учетом всех неудовлетворяющих зависимостей. В нашем случае неудовлетворяющую зависимость образует поле `Зарплата`, поэтому его следует вынести в отдельную таблицу:

| **Код должности** | **Должность** | **Зарплата** |
| ----------------- | ------------- | ------------ |
| 1                 | Программист   | 120 000      |
| 2                 | Криптограф    | 100 000      |

Тогда исходная таблица примет следующий вид:

| **ID** | **Имя** | **Фамилия** | **Код занимаемой должности** |
| ------ | ------- | ----------- | ---------------------------- |
| 1      | Билл    | Гейтс       | 1                            |
| 2      | Алан    | Тьюринг     | 2                            |
| 3      | Эдгар   | Кодд        | 1                            |

Теперь мы имеем две таблицы, каждая из которых находится в третьей нормальной форме. Благодаря этому аномалия модификации больше не проявляется, и любой сотрудник после смены должности автоматически получит корректное изменение заработной платы.

Также следует заметить, что в таблице с информацией о должностях каждой должности был присвоен уникальный код, который используется в таблице с работниками для указания занимаемой должности. Теперь если мы решим переименовать должность **Программист** в **Разработчик**, это нужно будет сделать лишь единожды, а не изменять должность каждого работника, являющегося программистом.

> Приводить базу данных к третьей нормальной форме для устранения всех зависимостей не всегда практично. Значительное увеличение числа маленьких таблиц может привести к снижению производительности при работе с базой данных.

## Язык SQL

SQL является слабоструктурированным языком. SQL-запросы напоминают обычные предложения английского языка и содержат слова-пустышки, не влияющие на функциональную часть запроса, но облегчающие его чтение.

```sql
SELECT title
FROM Movies
WHERE rating BETWEEN 7 AND 9
```

SQL является декларативным языком, то есть с помощью SQL программист описывает только то, какие данные нужно извлечь или модифицировать. Каким образом это сделать, решает СУБД непосредственно при обработке SQL-запроса.

## Группы операторов SQL

С точки зрения реализации язык SQL представляет собой набор операторов, которые делятся на определенные группы, и у каждой группы есть свое назначение. В сокращенном виде эти группы называются **DDL, DML, DCL** и **TCL.**

### DDL – Data Definition Language

**Data Definition Language (DDL)** – это группа операторов определения данных. Другими словами, с помощью операторов, входящих в эту группу, мы определяем структуру базы данных и работаем с объектами этой базы, то есть создаем, изменяем и удаляем их.

В эту группу входят следующие операторы:

- `CREATE` – используется для создания объектов базы данных
- `ALTER` – используется для изменения объектов базы данных
- `DROP` – используется для удаления объектов базы данных

### DML – Data Manipulation Language

**Data Manipulation Language (DML)** – это группа операторов для манипуляции данными. С помощью этих операторов мы можем добавлять, изменять, удалять и выгружать данные из базы, то есть манипулировать ими.

В эту группу входят самые распространенные операторы языка SQL:
- `SELECT` – осуществляет выборку данных
- `INSERT` – добавляет новые данные
- `UPDATE` – изменяет существующие данные
- `DELETE` – удаляет данные

### DCL – Data Control Language

**Data Control Language (DCL)** – группа операторов определения доступа к данным. Иными словами, это операторы для управления разрешениями. С их помощью мы можем разрешать или запрещать выполнение определенных операций над объектами базы данных.

Сюда входят:

- `GRANT` – предоставляет пользователю или группе пользователей разрешения на определенные операции с объектом
- `REVOKE` – отзывает выданные разрешения
- `DENY`– задает запрет, имеющий приоритет над разрешением

### TCL – Transaction Control Language

**Transaction Control Language (TCL)** – группа операторов для управления транзакциями. Транзакция – это команда или блок команд, которые выполняются как единое целое. Если транзакция выполнена успешно, все модификации данных, сделанные в течение транзакции, принимаются и становятся постоянной частью базы данных. Если в результате выполнения транзакции происходит ошибка, все выполненные модификации данных будут отменены.

Группа операторов TCL предназначена для реализации и управления транзакциями. Сюда можно отнести:

- `BEGIN TRANSACTION` – служит для определения начала транзакции
- `COMMIT TRANSACTION` – применяет транзакцию
- `ROLLBACK TRANSACTION` – откатывает все изменения, сделанные в контексте текущей транзакции
- `SAVE TRANSACTION` – устанавливает промежуточную точку сохранения внутри транзакции