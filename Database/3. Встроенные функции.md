### Функции

Как и практически любой язык программирования, SQL имеет множество встроенных функций, которые позволяют выполнять различные манипуляции с данными. Все встроенные функции можно разбить на четыре основных типа:

- **Текстовые функции.** Используются для обработки текста, например, для отсечения пробелов или преобразования символов в верхний регистр.
- **Числовые функции.** Используются для выполнения математических операций над числовыми данными: например, возведения в степень или извлечения квадратного корня.
- **Функции даты и времени.** Используются для обработки даты и времени, это может быть определение разницы между датами или проверка даты на корректность.
- **Системные функции.** Используются для получения специфичной для конкретной СУБД информации, к примеру, сведений об учетной записи пользователя.

#### Функция CHAR_LENGTH()

Функция `CHAR_LENGTH()` используется для вычисления длины строки. Она принимает в качестве аргумента строку и возвращает количество символов в ней.

```sql
SELECT CHAR_LENGTH(''),
       CHAR_LENGTH('b'),
       CHAR_LENGTH('bee'),
       CHAR_LENGTH('beegeek');
```
#### Функция LOWER()

Функция `LOWER()` используется для перевода строки в нижний регистр. Она принимает в качестве аргумента строку, преобразует все ее символы в нижний регистр и возвращает полученный результат.

```sql
SELECT LOWER('beegeek'),
       LOWER('BeeGeek'),
       LOWER('BEEGEEK');
```
#### Функция UPPER()

Функция `UPPER()` используется для перевода строки в верхний регистр. Она принимает в качестве аргумента строку, преобразует все ее символы в верхний регистр и возвращает полученный результат.

```sql
SELECT UPPER('beegeek'),
       UPPER('BeeGeek'),
       UPPER('BEEGEEK');
```
#### Функции LTRIM() и RTRIM()

Функция `LTRIM()` используется для отсечения ведущих пробелов. Она принимает в качестве аргумента строку, удаляет все пробелы из ее левой части и возвращает полученный результат.

```sql
SELECT LTRIM(' bee'),
       LTRIM('  bee'),
       LTRIM('   bee');
```

Похожим образом работает функция `RTRIM()` за исключением того, что она удаляет пробелы из правой части строки, а не левой.

#### Функция REVERSE()

Функция `REVERSE()` используется для переворота строки. Она принимает в качестве аргумента строку и возвращает ее с обратным порядком символов.

Результатом приведенного ниже запроса:

```sql
SELECT REVERSE('b'),
       REVERSE('bee'),
       REVERSE('beegeek');
```
#### Функция REPEAT()

Функция `REPEAT()` используется для повторения строки. Она принимает два аргумента в следующем порядке:

- `str` — исходная строка
- `count` — количество повторений

Функция возвращает строку, состоящую из строки `str`, повторяющейся `count` раз.

```sql
SELECT REPEAT('bee', 1),
       REPEAT('bee', 2),
       REPEAT('bee', 3);
```

является:

```no-highlight
+------------------+------------------+------------------+
| REPEAT('bee', 1) | REPEAT('bee', 2) | REPEAT('bee', 3) |
+------------------+------------------+------------------+
| bee              | beebee           | beebeebee        |
+------------------+------------------+------------------+
```

Если количество повторов меньше `1`, то функция `REPEAT()` вернет пустую строку.
#### Функции LPAD() и RPAD()

Функция `LPAD()` используется для увеличения длины строки до определенного значения путем добавления в ее начало другой строки. Она принимает три аргумента в следующем порядке:

- `str` — исходная строка
- `len` — желаемая длина строки
- `padstr` — дополняющая строка

Функция добавляет строку `padstr` в начало строки `str` до тех пор, пока длина второй не станет равна `len`, и возвращает полученный результат.

```sql
SELECT LPAD('bee', 5, '-'),
       LPAD('bee', 7, '-'),
       LPAD('bee', 9, '-+');
```

является:

```no-highlight
+---------------------+---------------------+----------------------+
| LPAD('bee', 5, '-') | LPAD('bee', 7, '-') | LPAD('bee', 9, '-+') |
+---------------------+---------------------+----------------------+
| --bee               | ----bee             | -+-+-+bee            |
+---------------------+---------------------+----------------------+
```

Если длина исходной строки после добавления в ее начало дополняющей строки превышает желаемую длину, то функция `LPAD()` сокращает дополняющую строку путем отбрасывания правых символов.

```sql
SELECT LPAD('bee', 4, '-+-+'),
       LPAD('bee', 5, '-+-+'),
       LPAD('bee', 6, '-+-+');
```

является:

```no-highlight
+------------------------+------------------------+------------------------+
| LPAD('bee', 4, '-+-+') | LPAD('bee', 5, '-+-+') | LPAD('bee', 6, '-+-+') |
+------------------------+------------------------+------------------------+
| -bee                   | -+bee                  | -+-bee                 |
+------------------------+------------------------+------------------------+
```

Если желаемая длина строки меньше длины исходной строки, то функция `LPAD()` сокращает исходную строку путем отбрасывания правых символов.

Результатом приведенного ниже запроса:

```SQL
SELECT LPAD('bee', 2, '-'),
       LPAD('bee', 1, '-');
```

является:

```no-highlight
+---------------------+---------------------+
| LPAD('bee', 2, '-') | LPAD('bee', 1, '-') |
+---------------------+---------------------+
| be                  | b                   |
+---------------------+---------------------+
```

Похожим образом себя ведет функция `RPAD()` за исключением того, что она дополняет строку не слева, а справа.

Результатом приведенного ниже запроса:

```sql
SELECT RPAD('bee', 5, '-'),
       RPAD('bee', 7, '-+'),
       RPAD('bee', 6, '-+-+'),
       RPAD('bee', 2, '-');
```

является: 

```no-highlight
+---------------------+----------------------+------------------------+---------------------+
| RPAD('bee', 5, '-') | RPAD('bee', 7, '-+') | RPAD('bee', 6, '-+-+') | RPAD('bee', 2, '-') |
+---------------------+----------------------+------------------------+---------------------+
| bee--               | bee-+-+              | bee-+-                 | be                  |
+---------------------+----------------------+------------------------+---------------------+
```

> Функции `CHAR_LENGTH(), LOWER(), UPPER(), LTRIM(), RTRIM(), REVERSE(), REPEAT(), LPAD()` и `RPAD()` при вызове с аргументом `NULL` возвращают значение `NULL`.

> Функции могут применяться как в блоке оператора `SELECT`, так и в блоках операторов `WHERE` и `ORDER BY`.

> Несмотря на то что функции `CHAR_LENGTH(), REVERSE(), REPEAT(), LPAD()` и `RPAD()` в первую очередь предназначены для работы со строковыми значениями, они также могут обрабатывать и числовые данные.

#### Функция LEFT()

Функция `LEFT()` используется для извлечения определенного количества символов из начала строки. Она принимает два аргумента в следующем порядке:

- `str` — исходная строка
- `count` — количество извлекаемых символов

Функция возвращает строку, состоящую из первых `count` символов строки `str`.

```sql
SELECT LEFT('beegeek', 1),
       LEFT('beegeek', 3),
       LEFT('beegeek', 7);
```

```no-highlight
+--------------------+--------------------+--------------------+
| LEFT('beegeek', 1) | LEFT('beegeek', 3) | LEFT('beegeek', 7) |
+--------------------+--------------------+--------------------+
| b                  | bee                | beegeek            |
+--------------------+--------------------+--------------------+
```

> Если количество извлекаемых символов меньше `1`, функция `LEFT()` вернет пустую строку.

#### Функция RIGHT()

Функция `RIGHT()` используется для извлечения определенного количества символов из конца строки. Она принимает два аргумента в следующем порядке:

- `str` — исходная строка
- `count` — количество извлекаемых символов

Функция возвращает строку, состоящую из последних `count` символов строки `str`.

```sql
SELECT RIGHT('beegeek', 1),
       RIGHT('beegeek', 3),
       RIGHT('beegeek', 7);
```

```no-highlight
+---------------------+---------------------+---------------------+
| RIGHT('beegeek', 1) | RIGHT('beegeek', 3) | RIGHT('beegeek', 7) |
+---------------------+---------------------+---------------------+
| k                   | eek                 | beegeek             |
+---------------------+---------------------+---------------------+
```

> Аналогично функции `LEFT()`, если количество извлекаемых символов меньше `1`, функция `RIGHT()` вернет пустую строку, если больше длины строки — всю строку.

#### Функция LOCATE()

Функция `LOCATE()` используется для определения местоположения подстроки в строке. Она принимает три аргумента в следующем порядке:

- `substr` — искомая подстрока
- `str` — исходная строка
- `start` — позиция начала поиска (может не указываться, в таком случае поиск выполняется с начала строки)

Функция выполняет поиск подстроки `substr` в строке `str`, начиная с позиции `start`, и возвращает позицию ее первого вхождения.

```sql
SELECT LOCATE('e', 'beegeek'),
       LOCATE('g', 'beegeek'),
       LOCATE('eg', 'beegeek'),
       LOCATE('geek', 'beegeek');
```

>  при использовании функции `LOCATE()` символы исходной строки нумеруются с `1`, а не с `0`.

> Если искомой подстроки в строке нет, функция `LOCATE()` вернет значение `0`.

#### Функция REPLACE()

Функция `REPLACE()` используется для замены подстроки в строке. Она принимает три аргумента в следующем порядке:

- `str` — исходная строка
- `from_str` — заменяемая подстрока
- `to_str` — заменяющая подстрока

Функция заменяет все вхождения подстроки `from_str` в строке `str` на подстроку `to_str` и возвращает полученный результат.

```sql
SELECT REPLACE('beegeek', 'e', 'i'),
       REPLACE('beegeek', 'geek', 'g'),
       REPLACE('beegeek', 'geek', 'Geek');
```

> Если заменяемой подстроки в строке нет, функция `REPLACE()` вернет строку в исходном виде.

#### Функция SUBSTRING()

Функция `SUBSTRING()` используется для извлечения подстроки из строки. Она принимает три аргумента в следующем порядке:

- `str` — исходная строка
- `start` — позиция первого извлекаемого символа
- `len` — длина извлекаемой подстроки (может не указываться, в таком случае подстрока извлекается до конца)

Функция извлекает из строки `str` подстроку длины `len`, начиная с символа с позицией `start`, и возвращает полученный результат.

```sql
SELECT SUBSTRING('beegeek', 1),
       SUBSTRING('beegeek', 4),
       SUBSTRING('beegeek', 4, 2);
```

```no-highlight
+--------------------+-------------------+-----------------------+
| beegeek            | geek              | ge                    |
+--------------------+-------------------+-----------------------+
```

> при использовании функции `SUBSTRING()` символы исходной строки нумеруются с `1`, а не с `0`.

Позиция первого извлекаемого символа может быть отрицательным числом, в таком случае символы нумеруются с конца. Последнему символу соответствует позиция `-1`, предпоследнему — `-2`, и так далее.

```sql
SELECT SUBSTRING('beegeek', -7),
       SUBSTRING('beegeek', -4),
       SUBSTRING('beegeek', -4, 3);
```

```no-highlight
+-----------------+-----------------+--------------------+
| ('beegeek', -7) | ('beegeek', -4) | ('beegeek', -4, 3) |
+-----------------+-----------------+--------------------+
| beegeek         | geek            | gee                |
+-----------------+-----------------+--------------------+
```
## Функция SUBSTRING_INDEX()

Функция `SUBSTRING_INDEX()` используется для извлечения подстроки из строки с помощью разделителя. Она принимает три аргумента в следующем порядке:

- `str` — исходная строка
- `delimiter` — разделитель
- `count` — количество появлений разделителя

Функция возвращает подстроку, входящую в `str`, перед `count` появлением разделителя `delimiter`.

```
SELECT SUBSTRING_INDEX('g-e-e-k', '-', 1),
       SUBSTRING_INDEX('g-e-e-k', '-', 2),
       SUBSTRING_INDEX('g-e-e-k', '-', 3);
```

является:

```no-highlight
+---------------------+---------------------+---------------------+
| ('g-e-e-k', '-', 1) | ('g-e-e-k', '-', 2) | ('g-e-e-k', '-', 3) |
+---------------------+---------------------+---------------------+
| g                   | g-e                 | g-e-e               |
+---------------------+---------------------+---------------------+
```

> Если указанное количество появлений разделителя больше количества раз, которое разделитель встречается в строке, функция `SUBSTRING_INDEX()` вернет всю строку.

> Если разделителя в строке нет, функция `SUBSTRING_INDEX()` вернет строку в исходном виде.

#### Функция TRIM()

Функция `TRIM()` используется для удаления всех вхождений подстроки из начала и/или конца строки. Синтаксис данной функции несколько отличается от предыдущих, так как при ее вызове аргументы не указываются через запятую, а связываются с помощью ключевого слова `FROM`:

```css
TRIM(<ключевое слово LEADING, TRAILING или BOTH> <удаляемая подстрока> FROM <исходная строка>)
```

Ключевые слова `LEADING, TRAILING` и `BOTH` определяют, откуда будет происходить удаление подстроки:

- `LEADING` — из начала строки
- `TRAILING`  — из конца строки
- `BOTH` — из начала и конца строки

```sql
SELECT TRIM(LEADING '-' FROM '--bee--'),
       TRIM(TRAILING '-' FROM '--bee--'),
       TRIM(BOTH '-' FROM '--bee--');
```

```no-highlight
+------------------+----------------------+-------------+
| bee--            | --bee                | bee         |
+------------------+----------------------+-------------+
```

Ключевые слова `LEADING, TRAILING` и `BOTH` могут не указываться, в таком случае удаление подстроки происходит из начала и конца строки.

```sql
SELECT TRIM('-' FROM '--bee--');
```

```no-highlight
+--------------------------+
| TRIM('-' FROM '--bee--') |
+--------------------------+
| bee                      |
+--------------------------+
```

Удаляемая подстрока также может быть опущена, в таком случае ею считается пробел
## Числовые функции

#### Операторы DIV и MOD

Оператор `DIV` используется для целочисленного деления одного числа на другое.

```sql
SELECT 11 DIV 2,
       11 DIV 3,
       11 DIV 4;
```

```no-highlight
+----------+----------+----------+
| 11 DIV 2 | 11 DIV 3 | 11 DIV 4 |
+----------+----------+----------+
| 5        | 3        | 2        |
+----------+----------+----------+
```

Оператор `MOD` используется для вычисления остатка от деления одного числа на другое.

```sql
SELECT 11 MOD 2,
       11 MOD 3,
       11 MOD 4;
```

```no-highlight
+----------+----------+----------+
| 11 MOD 2 | 11 MOD 3 | 11 MOD 4 |
+----------+----------+----------+
| 1        | 2        | 3        |
+----------+----------+----------+
```

Помимо оператора `MOD`, для вычисления остатка от деления можно использовать оператор `%` или функцию `MOD()`.

```sql
SELECT 11 MOD 3,
       11 % 3,
       MOD(11, 3);
```

```no-highlight
+----------+--------+------------+
| 11 MOD 3 | 11 % 3 | MOD(11, 3) |
+----------+--------+------------+
| 2        | 2      | 2          |
+----------+--------+------------+
```
#### Функция ABS()

Функция `ABS()` используется для вычисления модуля числа. Она принимает в качестве аргумента число и возвращает его модуль.

```python
SELECT ABS(-1),
       ABS(-2.1234),
       ABS(0),
       ABS(35);
```

```no-highlight
+---------+--------------+--------+---------+
| ABS(-1) | ABS(-2.1234) | ABS(0) | ABS(35) |
+---------+--------------+--------+---------+
| 1       | 2.1234       | 0      | 35      |
+---------+--------------+--------+---------+
```
#### Функция ROUND()

Функция `ROUND()` используется для округления числа. Она принимает два аргумента в следующем порядке:

- `num` — число
- `decimals` — количество знаков после запятой

Функция возвращает число `num`, округленное до `decimals` знаков после запятой.

```sql
SELECT ROUND(23.1653, 3),
       ROUND(23.1653, 2),
       ROUND(23.1653, 1),
       ROUND(23.1653, 0);
```

```no-highlight
+--------------+--------------+--------------+--------------+
| (23.1653, 3) | (23.1653, 2) | (23.1653, 1) | (23.1653, 0) |
+--------------+--------------+--------------+--------------+
| 23.165       | 23.17        | 23.2         | 23           |
+--------------+--------------+--------------+--------------+
```

Функция `ROUND()` округляет число согласно математическим правилам округления, то есть в большую по модулю сторону.

```sql
SELECT ROUND(23.165, 2),
       ROUND(-23.165, 2);
```

```no-highlight
+------------------+-------------------+
| ROUND(23.165, 2) | ROUND(-23.165, 2) |
+------------------+-------------------+
| 23.17            | -23.17            |
+------------------+-------------------+
```

Количество знаков после запятой может быть не указано, в таком случае функция `ROUND()` выполнит округление до целого числа.

>  Помимо функции `ROUND()`, SQL поддерживает две дополнительные функции для округления чисел: `FLOOR()` и `CEILING()`. Первая функция используется для округления числа в меньшую сторону, вторая — в большую сторону.
#### Функция POW()

Функция `POW()` используется для возведения числа в определенную степень. Она принимает два аргумента в следующем порядке:

- `num` — число
- `degree` — показатель степени

Функция возвращает число `num`, возведенное в степень`degree`.

```sql
SELECT POW(2, 3),
       POW(3, 5),
       POW(4, 0),
       POW(5, -1);
```

```no-highlight
+-----------+-----------+-----------+------------+
| POW(2, 3) | POW(3, 5) | POW(4, 0) | POW(5, -1) |
+-----------+-----------+-----------+------------+
| 8.0       | 243.0     | 1.0       | 0.2        |
+-----------+-----------+-----------+------------+
```

#### Функция SQRT()

Функция `SQRT()` используется для вычисления квадратного корня. Она принимает в качестве аргумента число, извлекает из него квадратный корень и возвращает полученный результат.

```sql
SELECT SQRT(0),
       SQRT(9),
       SQRT(20);
```

```no-highlight
+---------+---------+------------------+
| SQRT(0) | SQRT(9) | SQRT(20)         |
+---------+---------+------------------+
| 0.0     | 3.0     | 4.47213595499958 |
+---------+---------+------------------+
```

> Если переданное в качестве аргумента число меньше нуля, функция `SQRT()` вернет значение `NULL`.
#### Функция RAND()

Функция `RAND()` используется для генерации случайных чисел. При вызове без аргументов она возвращает случайное число с плавающей точкой в диапазоне `[0, 1)`.

```sql
SELECT RAND(),
       RAND(),
       RAND();
```

```no-highlight
+-------------------+--------------------+---------------------+
| RAND()            | RAND()             | RAND()              |
+-------------------+--------------------+---------------------+
| 0.338787759038422 | 0.8266121575856694 | 0.11669754154672617 |
+-------------------+--------------------+---------------------+
```

> Функция `RAND()` в комбинации с операторами `ORDER BY` и `LIMIT` позволяет извлекать из таблицы определенное количество случайных записей.

```sql
SELECT *
FROM SQLTeam
ORDER BY RAND()
LIMIT 2;
```

#### Функции DEGREES() и RADIANS()

Функция `DEGREES()` используется для перевода значения из радиан в градусы. Она принимает в качестве аргумента значение в радианах, конвертирует его в градусы и возвращает полученный результат.

```sql
SELECT DEGREES(1),
       DEGREES(3.14),
       DEGREES(6.28);
```

```no-highlight
+-------------------+-------------------+------------------+
| DEGREES(1)        | DEGREES(3.14)     | DEGREES(6.28)    |
+-------------------+-------------------+------------------+
| 57.29577951308232 | 179.9087476710785 | 359.817495342157 |
+-------------------+-------------------+------------------+
```

Похожим образом себя ведет функция `RADIANS()` за тем исключением, что она выполняет обратный перевод — из градусов в радианы.

```sql
SELECT RADIANS(57),
       RADIANS(180),
       RADIANS(360);
```

```no-highlight
+--------------------+-------------------+-------------------+
| RADIANS(57)        | RADIANS(180)      | RADIANS(360)      |
+--------------------+-------------------+-------------------+
| 0.9948376736367679 | 3.141592653589793 | 6.283185307179586 |
+--------------------+-------------------+-------------------+
```
#### Функции PI(), SIN(), COS() и TAN()

Функция `PI()` используется для получения числа пи (�π). Она не принимает никаких аргументов и возвращает число пи с точностью до шести знаков после запятой.

```sql
SELECT PI();
```

```no-highlight
+----------+
| PI()     |
+----------+
| 3.141593 |
+----------+
```

Функции `SIN(), COS()` и `TAN()` используются для вычисления синуса, косинуса и тангенса соответственно. Каждая функция принимает в качестве аргумента значение в радианах и возвращает соответствующую тригонометрическую величину.

```sql
SELECT SIN(PI()),
       COS(PI()),
       TAN(PI());
```

```no-highlight
+-----------+-----------+-----------+
| SIN(PI()) | COS(PI()) | TAN(PI()) |
+-----------+-----------+-----------+
| 0         | -1        | 0         |
+-----------+-----------+-----------+
```
#### Функции LEAST() и GREATEST()

Функция `LEAST()` используется для поиска минимального значения. Она принимает переменное количество аргументов (не меньше двух) и возвращает наименьший из них.

```sql
SELECT LEAST(2, 1, 3, 5, 4);
```

```no-highlight
+----------------------+
| LEAST(2, 1, 3, 5, 4) |
+----------------------+
| 1                    |
+----------------------+
```

Если поиск минимального значения происходит среди действительных (типы `FLOAT` и `DOUBLE`) и целых чисел, функция `LEAST()` сначала преобразует все числа в действительные.

```sql
SELECT LEAST(2, 1, 3.0, 5, 4);
```

```no-highlight
+------------------------+
| LEAST(2, 1, 3.0, 5, 4) |
+------------------------+
| 1.0                    |
+------------------------+
```

Если хотя бы один из аргументов, переданных в функцию `LEAST()`, является строкой, функция перед поиском минимального значения сначала преобразует все аргументы в строки.

```sql
SELECT LEAST(100, '11');
```

```no-highlight
+------------------+
| LEAST(100, '11') |
+------------------+
| 100              |
+------------------+
```

Если хотя бы один из аргументов, переданных в функцию `LEAST()`, равняется `NULL`, возвращаемым значением функции также будет `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT LEAST(2, 1, NULL, 5, 4);
```

Похожим образом себя ведет функция `GREATEST()` за тем исключением, что она выполняет поиск наибольшего значения, а не наименьшего.

```sql
SELECT GREATEST(2, 1, 3, 5, 4);
```

```no-highlight
+-------------------------+
| GREATEST(2, 1, 3, 5, 4) |
+-------------------------+
| 5                       |
+-------------------------+
```
#### Функция CONV()

Функция `CONV()` используется для перевода числа из одной системы счисления в другую. Она принимает три аргумента в следующем порядке:

- `num` — число
- `from_base` — система счисления, в которой представлено число
- `to_base` — система счисления, в которую нужно перевести число

Функция переводит число `num` из системы счисления `from_base` в систему счисления `to_base` и возвращает полученный результат в виде строки.

Результатом приведенного ниже запроса:

```sql
SELECT CONV(5, 10, 2),
       CONV(101, 2, 10),
       CONV(100, 10, 16),
       CONV('F', 16, 10),
       CONV('10F', 16, 2);
```

```no-highlight
+-------+---------+--------+-------+-------------+
| 101   | 5       | 64     | 15    | 100001111   |
+-------+---------+--------+-------+-------------+
```
#### Функция FORMAT()

Функция `FORMAT()` используется для округления и форматирования числа. Она принимает два аргумента в следующем порядке:

- `num` — число
- `decimals` — количество знаков после запятой

Функция округляет число `num` до `decimals` знаков после запятой, форматирует его путем разбиения на разряды и возвращает полученный результат в виде строки.

```sql
SELECT FORMAT(1000000.1653, 3),
       FORMAT(1000000.1653, 2),
       FORMAT(1000000.1653, 1),
       FORMAT(1000000.1653, 0);
```

Если указанное количество знаков после запятой больше фактического количества знаков у числа, функция `FORMAT()` заполнит недостающие знаки незначащими нулями.

Результатом приведенного ниже запроса:

```sql
SELECT FORMAT(1000000.1653, 5),
       FORMAT(1000000.1653, 7);
```

```no-highlight
+-------------------------+-------------------------+
| FORMAT(1000000.1653, 5) | FORMAT(1000000.1653, 7) |
+-------------------------+-------------------------+
| 1,000,000.16530         | 1,000,000.1653000       |
+-------------------------+-------------------------+
```
## Функции даты и времени

#### Временные интервалы

В SQL для работы с датой и временем часто используются временные интервалы. Они представляют собой некоторый промежуток времени, выраженный в тех или иных единицах измерения (день, год, минута), и используются для выполнения арифметических операций с датой и временем.

Для записи временных интервалов применяется следующий синтаксис:

```css
INTERVAL <величина интервала> <единица измерения>
```

Единица измерения во временном интервале определяется ключевым словом. Например, день — это `DAY`, год — это `YEAR`, год и месяц — это `YEAR_MONTH`. Формат величины интервала напрямую зависит от единицы измерения. Для одиночных единиц измерения, таких как день или год, форматом величины является целое число. 

К примеру, интервал в `1` год определяется следующим образом:

```css
INTERVAL 1 YEAR
```

Для составных единиц измерения, таких как год и месяц, форматом величины является строка определенного вида, в которой перечислены все необходимые значения компонентов.

К примеру, интервал в `10` лет и `2` месяца определяется следующим образом:

```css
INTERVAL '10-2' YEAR_MONTH
```

##### Поддерживаемые единицы измерения

SQL поддерживает большое количество единиц измерения.

Первая таблица включает все поддерживаемые одиночные единицы измерения:

| **Единица измерения** | **Ключевое слово** |
| --------------------- | ------------------ |
| микросекунда          | `MICROSECOND`      |
| секунда               | `SECOND`           |
| минута                | `MINUTE`           |
| час                   | `HOUR`             |
| день                  | `DAY`              |
| неделя                | `WEEK`             |
| месяц                 | `MONTH`            |
| квартал               | `QUARTER`          |
| год                   | `YEAR`             |

Вторая таблица включает все поддерживаемые составные единицы измерения, а также формат величины для каждой из единиц:

| **Единица измерения**                     | **Ключевое слово**   | **Формат величины**                    |
| ----------------------------------------- | -------------------- | -------------------------------------- |
| секунда и микросекунда                    | `SECOND_MICROSECOND` | `секунды.микросекунды`                 |
| минута, секунда и микросекунда            | `MINUTE_MICROSECOND` | `минуты:секунды.микросекунды`          |
| минута и секунда                          | `MINUTE_SECOND`      | `минуты:секунды`                       |
| час, минута, секунда и микросекунда       | `HOUR_MICROSECOND`   | `часы:минуты:секунды.микросекунды`     |
| час, минута и секунда                     | `HOUR_SECOND`        | `часы:минуты:секунды`                  |
| час и минута                              | `HOUR_MINUTE`        | `часы:минуты`                          |
| день, час, минута, секунда и микросекунда | `DAY_MICROSECOND`    | `дни часы:минуты:секунды.микросекунды` |
| день, час, минута и секунда               | `DAY_SECOND`         | `дни часы:минуты:секунды`              |
| день, час и минута                        | `DAY_MINUTE`         | `дни часы:минуты`                      |
| день и час                                | `DAY_HOUR`           | `дни часы`                             |
| год и месяц                               | `YEAR_MONTH`         | `годы-месяцы`                          |

##### Примеры использования временных интервалов

**Пример 1.** Прибавим к дате `2023-01-01` интервал в `10` лет и `2` месяца.

```sql
SELECT '2023-01-01' + INTERVAL '10-2' YEAR_MONTH;
```

```no-highlight
+-------------------------------------------+
| '2023-01-01' + INTERVAL '10-2' YEAR_MONTH |
+-------------------------------------------+
| 2033-03-01                                |
+-------------------------------------------+
```

**Пример 2.** Вычтем из даты и времени `2023-01-01 14:00:00` интервал в `1` час и `30` минут.

```sql
SELECT '2023-01-01 14:00:00' - INTERVAL '01:30' HOUR_MINUTE;
```

```no-highlight
+------------------------------------------------------+
| '2023-01-01 14:00:00' - INTERVAL '01:30' HOUR_MINUTE |
+------------------------------------------------------+
| 2023-01-01 12:30:00                                  |
+------------------------------------------------------+
```

**Пример 3.** Прибавим к дате и времени `2023-01-01 14:00:00` интервал в `4` дня и `2` часа.

```sql
SELECT '2023-01-01 14:00:00' + INTERVAL '4 2' DAY_HOUR;
```

```no-highlight
+-------------------------------------------------+
| '2023-01-01 14:00:00' + INTERVAL '4 2' DAY_HOUR |
+-------------------------------------------------+
| 2023-01-05 16:00:00                             |
+-------------------------------------------------+
```

**Пример 4.** Вычтем из даты `2023-01-01` интервал в `1` час.

```sql
SELECT '2023-01-01' - INTERVAL 1 HOUR;
```

```no-highlight
+--------------------------------+
| '2023-01-01' - INTERVAL 1 HOUR |
+--------------------------------+
| 2022-12-31 23:00:00            |
+--------------------------------+
```

Обратите внимание, что из даты без времени допускается вычитать временное значение. Во время выполнения такой операции считается, что дата имеет нулевые значения по всем компонентам времени — `0` часов, `0` минут и `0` секунд. Аналогичное справедливо и при прибавлении временного значения к дате без времени.

#### Функции NOW(), CURDATE() и CURTIME()

Функция `NOW()` используется для получения текущей даты и времени. Она не принимает никаких аргументов и возвращает текущую дату и время в локальном часовом поясе, например, в том, который используется в операционной системе.

```sql
SELECT NOW();
```

```no-highlight
+---------------------+
| NOW()               |
+---------------------+
| 2023-06-27 10:14:48 |
+---------------------+
```

Похожим образом себя ведут функции `CURDATE()` и `CURTIME()` за тем исключением, что они возвращают текущую дату и текущее время соответственно.

```sql
SELECT CURTIME(),
       CURDATE();
```

```no-highlight
+-----------+------------+
| CURTIME() | CURDATE()  |
+-----------+------------+
| 10:23:15  | 2023-06-27 |
+-----------+------------+
```
#### Функции UTC_TIMESTAMP(), UTC_DATE() и UTC_TIME()

Функция `UTC_TIMESTAMP()` используется для получения текущей даты и времени. Она не принимает никаких аргументов и возвращает текущую дату и время в UTC, то есть в нулевом часовом поясе.

```css
SELECT UTC_TIMESTAMP();
```

```no-highlight
+---------------------+
| UTC_TIMESTAMP()     |
+---------------------+
| 2023-06-28 05:44:53 |
+---------------------+
```

Похожим образом себя ведут функции `UTC_DATE()` и `UTC_TIME()` за тем исключением, что они возвращают текущую дату и текущее время соответственно.

```css
SELECT UTC_DATE(),
       UTC_TIME();
```

```no-highlight
+------------+------------+
| UTC_DATE() | UTC_TIME() |
+------------+------------+
| 2023-10-17 | 13:57:34   |
+------------+------------+
```
#### Функция MAKEDATE()

Функция `MAKEDATE()` используется для создания даты. Она принимает два аргумента в следующем порядке:

- `year` — год
- `day` — номер дня в году

Функция возвращает дату, которая имеет порядковый номер `day` в году `year`.

```sql
SELECT MAKEDATE(2023, 1),
       MAKEDATE(2023, 255),
       MAKEDATE(2023, 365);
```

```no-highlight
+-------------------+---------------------+---------------------+
| MAKEDATE(2023, 1) | MAKEDATE(2023, 255) | MAKEDATE(2023, 365) |
+-------------------+---------------------+---------------------+
| 2023-01-01        | 2023-09-12          | 2023-12-31          |
+-------------------+---------------------+---------------------+
```

Если указанный номер дня в году больше количества дней в этом году, функция `MAKEDATE()` преобразует каждые `365-366` дней в полный год.

```sql
SELECT MAKEDATE(2023, 366),
       MAKEDATE(2023, 732);
```

```no-highlight
+---------------------+---------------------+
| MAKEDATE(2023, 366) | MAKEDATE(2023, 732) |
+---------------------+---------------------+
| 2024-01-01          | 2025-01-01          |
+---------------------+---------------------+
```
#### Функция MAKETIME()

Функция `MAKETIME()` используется для создания временного значения. Она принимает три аргумента в следующем порядке:

- `hours` — часы
- `minutes` — минуты
- `seconds` — секунды

Функция возвращает временное значение, состоящее из `hours` часов, `minutes` минут и `seconds` секунд.

```sql
SELECT MAKETIME(12, 33, 1),
       MAKETIME(0, 1, 2),
       MAKETIME(21, 11, 42);
```

```no-highlight
+---------------------+-------------------+----------------------+
| MAKETIME(12, 33, 1) | MAKETIME(0, 1, 2) | MAKETIME(21, 11, 42) |
+---------------------+-------------------+----------------------+
| 12:33:01            | 00:01:02          | 21:11:42             |
+---------------------+-------------------+----------------------+
```

Функция `MAKETIME()` может обрабатывать значение часов больше, чем есть в сутках, но не может обрабатывать значение минут и секунд больше `59`. Если количество минут или секунд больше `59`, функция вернет значение `NULL`.

```sql
SELECT MAKETIME(222, 50, 11),
       MAKETIME(10, 60, 12),
       MAKETIME(5, 33, 79);
```

```no-highlight
+-----------------------+----------------------+---------------------+
| MAKETIME(222, 50, 11) | MAKETIME(10, 60, 12) | MAKETIME(5, 33, 79) |
+-----------------------+----------------------+---------------------+
| 222:50:11             | NULL                 | NULL                |
+-----------------------+----------------------+---------------------+
```
> Если хотя бы один из аргументов, переданных в функции `MAKEDATE()` и `MAKETIME()`, являeтся значением `NULL`, функции вернут значение `NULL`.

#### Функция TIME_TO_SEC() и SEC_TO_TIME()

Функция `TIME_TO_SEC()` используется для преобразования временного значения в секунды. Она принимает в качестве аргумента временное значение, преобразует его в количество секунд и возвращает полученный результат.

```sql
SELECT TIME_TO_SEC('00:00:25'),
       TIME_TO_SEC('00:01:30'),
       TIME_TO_SEC('01:00:00');
```

```no-highlight
+-----+------+------+
| 25  | 90   | 3600 |
+-----+------+------+
```

Похожим образом себя ведет функция `SEC_TO_TIME()` за тем исключением, что она выполняет обратное преобразование — количество секунд во временное значение.

```sql
SELECT SEC_TO_TIME(25),
       SEC_TO_TIME(90),
       SEC_TO_TIME(3600);
```

```no-highlight
+-----------------+-----------------+-------------------+
| SEC_TO_TIME(25) | SEC_TO_TIME(90) | SEC_TO_TIME(3600) |
+-----------------+-----------------+-------------------+
| 00:00:25        | 00:01:30        | 01:00:00          |
+-----------------+-----------------+-------------------+
```
#### Функции TO_DAYS() и TO_SECONDS()

Функция `TO_DAYS()` используется для преобразования даты в количество дней. Она принимает в качестве аргумента дату, преобразует ее в количество дней и возвращает полученный результат.

```sql
SELECT TO_DAYS('2023-04-01'),
       TO_DAYS('0001-01-01'),
       TO_DAYS('0000-01-01');
```

```no-highlight
+---------+--------+------+
| 738976  | 366    | 1    |
+---------+--------+------+
```

Обратите внимание, что отсчет количества дней начинается с нулевого года.

Похожим образом себя ведет функция `TO_SECONDS()`, за тем исключением, что она преобразует дату в количество секунд, а не дней.

```sql
SELECT TO_SECONDS('2023-04-01'),
       TO_SECONDS('0001-01-01'),
       TO_SECONDS('0000-01-01');
```

```no-highlight
+--------------+--------------+-------------+
| 63847526400  | 31622400     | 86400       |
+--------------+--------------+-------------+
```

#### Функция LAST_DAY()

Функция `LAST_DAY()` используется для замены дня на последний день месяца. Она принимает в качестве аргумента дату, заменяет в ней день на последний день месяца этой даты и возвращает полученный результат.

```sql
SELECT LAST_DAY('2023-02-14'),
       LAST_DAY('2023-03-14'),
       LAST_DAY('2023-04-14');
```

```no-highlight
+--------------+--------------+---------------+
| 2023-02-28   | 2023-03-31   | 2023-04-30    |
+--------------+--------------+---------------+
```

> Функции `TIME_TO_SEC(), SEC_TO_TIME(), TO_DAYS(), TO_SECONDS()` и `LAST_DAY()` при вызове с аргументом `NULL` возвращают значение `NULL`.

#### Функции DATE() и TIME()

Функция `DATE()` используется для получения даты из даты и времени. Она принимает в качестве аргумента дату и время, извлекает из него дату и возвращает полученный результат.

```sql
SELECT DATE('2023-10-20 12:30:00'),
       DATE('2023-12-31 10:00:20');
```

```no-highlight
+-----------------------------+-----------------------------+
| DATE('2023-10-20 12:30:00') | DATE('2023-12-31 10:00:20') |
+-----------------------------+-----------------------------+
| 2023-10-20                  | 2023-12-31                  |
+-----------------------------+-----------------------------+
```

Если аргументом функции `DATE()` является дата без времени, функция вернет ее в исходном виде.

Похожим образом себя ведет функция `TIME()` за тем исключением, что она извлекает временное значение, а не дату.

```sql
SELECT TIME('2023-10-20 12:30:00'),
       TIME('2023-12-31 10:00:20'),
       TIME('12:30:00');
```

```no-highlight
+-----------+------------+------------------+
| 12:30:00  | 10:00:20   | 12:30:00         |
+-----------+------------+------------------+
```
#### Функции HOUR(), MINUTE(), SECOND() и MICROSECOND()

Функция `HOUR()` используется для определения количества часов во времени. Она принимает в качестве аргумента временное значение, извлекает из него часы и возвращает полученный результат.

```sql
SELECT HOUR('12:30:10'),
       HOUR('18:20:00');
```

```no-highlight
+------------------+------------------+
| HOUR('12:30:10') | HOUR('18:20:00') |
+------------------+------------------+
| 12               | 18               |
+------------------+------------------+
```

Похожим образом себя ведут функции `MINUTE(), SECOND()` и `MICROSECOND()` за тем исключением, что они извлекают минуты, секунды и микросекунды соответственно.
#### Функции YEAR(), MONTH() и DAY()

Функция `YEAR()` используется для извлечения значения года из даты. Она принимает в качестве аргумента дату, извлекает из нее год и возвращает полученный результат.

```sql
SELECT YEAR('2023-10-20'),
       YEAR('2027-12-31');
```

```no-highlight
+--------------------+--------------------+
| YEAR('2023-10-20') | YEAR('2027-12-31') |
+--------------------+--------------------+
| 2023               | 2027               |
+--------------------+--------------------+
```

Похожим образом себя ведут функции `MONTH()` и `DAY()` за тем исключением, что они извлекают месяц и день соответственно.
#### Функция DAYOFYEAR()

Функция `DAYOFYEAR()` используется для вычисления номера дня в году (от `1` до `366`) на основе даты. Она принимает в качестве аргумента дату, определяет, какой по счету день в году соответствует переданной дате, и возвращает полученный результат.

```sql
SELECT DAYOFYEAR('2023-01-01'),
       DAYOFYEAR('2023-02-01'),
       DAYOFYEAR('2023-12-31');
```

```no-highlight
+--------+-------------------------+-------------------------+
| 1      | 32                      | 365                     |
+--------+-------------------------+-------------------------+
```

#### Функция WEEK()

Функция `WEEK()` используется для вычисления номера недели в году на основе даты. Она принимает в качестве аргумента дату, определяет, какая по счету неделя в году соответствует переданной дате, и возвращает полученный результат.

```sql
SELECT WEEK('2023-01-01'),
       WEEK('2023-01-08'),
       WEEK('2023-12-31');
```

```no-highlight
+--------------------+--------------------+--------------------+
| WEEK('2023-01-01') | WEEK('2023-01-08') | WEEK('2023-12-31') |
+--------------------+--------------------+--------------------+
| 1                  | 2                  | 53                 |
+--------------------+--------------------+--------------------+
```

#### Функция WEEKDAY()

Функция `WEEKDAY()` используется для вычисления номера дня недели (от `0` до `6`) на основе даты. Она принимает в качестве аргумента дату, определяет день недели, который соответствует переданной дате, и возвращает его номер.

```sql
SELECT WEEKDAY('2023-10-16'),      -- понедельник
       WEEKDAY('2023-10-17'),      -- вторник
       WEEKDAY('2023-10-18'),      -- среда
       WEEKDAY('2023-10-23');      -- понедельник
```

```no-highlight

+-------------+--------------+-----------+------------+
| 0           | 1            | 2         | 0          |
+-------------+--------------+-----------+------------+
```
#### Функция QUARTER()

Функция `QUARTER()` используется для вычисления номера квартала (от `1` до `4`) на основе даты. Она принимает в качестве аргумента дату, определяет квартал, в котором находится переданная дата, и возвращает его номер.

```sql
SELECT QUARTER('2023-01-01'),      -- январь
       QUARTER('2023-04-01'),      -- апрель
       QUARTER('2023-07-01'),      -- июль
       QUARTER('2023-10-01');      -- октябрь
```

```no-highlight
+------------+--------------+-------------+-----------------------+
| 1          | 2            | 3           | 4                     |
+------------+--------------+-------------+-----------------------+
```
#### Функция DAYNAME()

Функция `DAYNAME()` используется для вычисления названия дня недели на основе даты. Она принимает в качестве аргумента дату, определяет день недели, который соответствует переданной дате, и возвращает его полное название.

```sql
SELECT DAYNAME('2023-10-16'),      -- понедельник
       DAYNAME('2023-10-17'),      -- вторник
       DAYNAME('2023-10-18');      -- среда
```

```no-highlight
+-------------+---------------+---------------+
| Monday      | Tuesday       | Wednesday     |
+-------------+---------------+---------------+
```
#### Функция MONTHNAME()

Функция `MONTHNAME()` используется для определения названия месяца на основе даты. Она принимает в качестве аргумента дату и возвращает полное название ее месяца.

```sql
SELECT MONTHNAME('2023-01-01'),    -- январь
       MONTHNAME('2023-04-01'),    -- апрель
       MONTHNAME('2023-07-01');    -- июль
```

```no-highlight
+--------------+-------------+------------+
| January      | April       | July       |
+--------------+-------------+------------+
```
#### Функции ADDDATE() и SUBDATE()

Функция `ADDDATE()` используется для прибавления временного интервала к дате и времени. Она принимает два аргумента в следующем порядке:

- `datetime` — дата и время
- `interval` — временной интервал

Функция прибавляет временной интервал `interval` к дате и времени `datetime` и возвращает полученный результат.

```sql
SELECT ADDDATE('2023-10-20 07:30:00', INTERVAL 4 DAY),
       ADDDATE('2023-10-20 07:30:00', INTERVAL 4 HOUR);
```

Похожим образом себя ведет функция `SUBDATE()` за тем исключением, что она вычитает временной интервал из даты и времени, а не прибавляет.

```sql
SELECT SUBDATE('2023-10-20 07:30:00', INTERVAL 4 DAY),
       SUBDATE('2023-10-20 07:30:00', INTERVAL 4 HOUR);
```
#### Функции ADDTIME() и SUBTIME()

Функция `ADDTIME()` используется для прибавления временного значения к дате и времени. Она принимает два аргумента в следующем порядке:

- `datetime` — дата и время
- `time` — временное значение

Функция прибавляет временное значение `time` к дате и времени `datetime` и возвращает полученный результат.

```sql
SELECT ADDTIME('2023-10-20 21:00:00', '02:00:00'),
       ADDTIME('2023-10-20 21:00:00', '06:00:00');
```
#### Функция DATEDIFF()

Функция `DATEDIFF()` используется для вычисления разницы в днях между двумя значениями даты и времени. Она принимает два аргумента в следующем порядке:

- `datetime1` — первая дата и время
- `datetime2` — вторая дата и время

Функция возвращает количество дней между значениями даты и времени `datetime1` и `datetime2`.

```sql
SELECT DATEDIFF('2023-10-20 7:30:00', '2023-10-20 8:00:00'),
       DATEDIFF('2023-10-26 7:30:00', '2023-10-20 8:00:00');
```

является:

```no-highlight
+--------------+--------------+
| 0            | 6            |
+--------------+--------------+
```

Если первая дата и время, переданная в функцию `DATEDIFF()`, **меньше** второй, функция вернет отрицательный результат.

#### Функция TIMESTAMP()

Функция `TIMESTAMP()` используется для объединения даты и временного значения. Она принимает два аргумента в следующем порядке:

- `date` — дата
- `time` — временное значение

Функция объединяет дату `date` и время `time` и возвращает полученный результат в виде единого объекта.

```sql
SELECT TIMESTAMP('2023-10-20', '08:00'),
       TIMESTAMP('2023-10-20', '28:00');
```

```no-highlight
+---------------------------------+----------------------------------+
| TIMESTAMP('2023-10-20', '08:00')| TIMESTAMP('2023-10-20', '28:00') |
+---------------------------------+----------------------------------+
| 2023-10-20 08:00:00             | 2023-10-21 04:00:00              |
+----------------------------------+---------------------------------+
```

Обратите внимание, что функция `TIMESTAMP()` автоматически конвертирует каждые `24` часа в `1` день.

Временное значение может не указываться, в таком случае оно будет принято равным `00:00:00`.

```sql
SELECT TIMESTAMP('2023-10-20');
```

```no-highlight
+-------------------------+
| TIMESTAMP('2023-10-20') |
+-------------------------+
| 2023-10-20 00:00:00     |
+-------------------------+
```

#### Форматирование

По умолчанию вывод даты и времени осуществляется в ISO-формате. Например, дата в таком формате записывается в виде `2023-10-25` (год, месяц, день). Однако для конечного пользователя такой формат может быть не всегда удобен.

SQL позволяет определить любой необходимый формат отображения даты и времени c помощью **строк формата**. Например, дата `2023-10-25` при форматировании в соответствии со строкой формата `%d.%m.%Y` будет иметь вид `25.10.2023`. Значения `%d, %m` и `%Y` в строке формата называются **спецификаторами формата**. Каждый из них представляет собой символ, предваренный знаком процента (`%`), который обозначает какую-либо компоненту даты и времени. Например, `%d` обозначает день месяца, а `%m` и `%Y` — номер месяца и год соответственно.

В таблице ниже представлены основные спецификаторы формата:

|   |   |
|---|---|
|**Спецификатор**|**Описание**|
|`%M`|Полное название месяца (`January`..`December`)|
|`%b`|Сокращенное название месяца (`Jan`..`Dec`)|
|`%W`|Полное название дня недели (`Sunday`..`Saturday`)|
|`%a`|Сокращенное название дня недели (`Sun`..`Sat`)|
|`%Y`|Год (`0000`..`9999`)|
|`%m`|Номер месяца (`00`..`12`)|
|`%d`|День месяца (`00`..`31`)|
|`%w`|Номер дня недели (`0`..`6`)|
|`%H`|Часы (`00`..`23`)|
|`%i`|Минуты (`00`..`59`)|
|`%S`|Секунды (`00`..`59`)|
|`%f`|Микросекунды (`000000`..`999999`)|
|`%T`|Время в формате `HH:MM:SS`|
#### Функция DATE_FORMAT()

Функция `DATE_FORMAT()` используется для форматирования даты и времени. Она принимает два аргумента в следующем порядке:

- `datetime` — дата и время
- `format` — строка формата

Функция преобразует дату и время `datetime` в строку в соответствии с форматом `format` и возвращает полученный результат.

```sql
SELECT DATE_FORMAT('2023-10-20 07:30:00', '%H:%i, %d.%m.%Y');
```

```no-highlight
+-------------------------------------------------------+
| DATE_FORMAT('2023-10-20 07:30:00', '%H:%i, %d.%m.%Y') |
+-------------------------------------------------------+
| 07:30, 20.10.2023                                     |
+-------------------------------------------------------+
```

Функция `DATE_FORMAT()` в качестве первого аргумента может принимать не только дату и время, но и просто дату. Во втором случае считается, что дата имеет нулевые значения по всем компонентам времени.

```sql
SELECT DATE_FORMAT('2023-10-20', '%d.%m.%Y'),
       DATE_FORMAT('2023-10-20', '%H:%i, %d.%m.%Y');
```

```no-highlight
+----------------+---------------------+
| 20.10.2023     | 00:00, 20.10.2023   |
+----------------+---------------------+
```
#### Функция TIME_FORMAT()

Функция `TIME_FORMAT()` используется для форматирования времени. Она принимает два аргумента в следующем порядке:

- `time` — временное значение
- `format` — строка формата

Функция преобразует временное значение `time` в строку в соответствии с форматом `format` и возвращает полученный результат.

```sql
SELECT TIME_FORMAT('12:30:00', '%H::%i::%s'),
       TIME_FORMAT('12:30:00', 'Time: %H:%i');
```

```no-highlight
+--------------+----------------+
| 12::30::00   | Time: 12:30    |
+--------------+----------------+
```
#### Функция STR_TO_DATE()

Функция `STR_TO_DATE()` используется для выполнения операции, обратной форматированию. Она принимает два аргумента в следующем порядке:

- `string` — строка с компонентами даты и времени
- `format` — строка формата

Функция извлекает из строки `string` компоненты даты и времени в соответствии с форматом `format` и возвращает дату и время на основе извлеченных компонентов.

```sql
SELECT STR_TO_DATE('07:30, 20.10.2023', '%H:%i, %d.%m.%Y');
```

```no-highlight
+-----------------------------------------------------+
| STR_TO_DATE('07:30, 20.10.2023', '%H:%i, %d.%m.%Y') |
+-----------------------------------------------------+
| 2023-10-20 07:30:00                                 |
+-----------------------------------------------------+
```

Если в строке с компонентами представлены только компоненты даты, функция `STR_TO_DATE()` вернет дату без времени, если только компоненты времени — время без даты.

```sql
SELECT STR_TO_DATE('20.10.2023', '%d.%m.%Y'),
       STR_TO_DATE('Time: 07:30', 'Time: %H:%i');
```

```no-highlight
+-------------+-------------+
| 2023-10-20  | 07:30:00    |
+-------------+-------------+
```

При этом для создания даты или даты и времени должны быть определены все компоненты даты (год, месяц, число), и если хотя бы один компонент пропущен, функция вернет значение `NULL`. В случае с временным значением достаточно одного любого компонента, остальные по умолчанию примут значение `0`.

```sql
SELECT STR_TO_DATE('20.10', '%d.%m'),
       STR_TO_DATE('Time: 07', 'Time: %H');
```

```no-highlight
+------------------------------+-------------------------------------+
| STR_TO_DATE('20.10', '%d.%m')| STR_TO_DATE('Time: 07', 'Time: %H') |
+------------------------------+-------------------------------------+
| NULL                         | 7:00:00                             |
+-------------------------------+------------------------------------+
```

Во время использования функции `STR_TO_DATE()` необходимо следить за тем, чтобы строка с компонентами даты и времени полностью соответствовала строке формата, в противном случае функция вернет значение `NULL`.

```sql
SELECT STR_TO_DATE('20.10.2023', '%d-%m-%Y'),
       STR_TO_DATE('Time: 07:30', '%H:%i');
```

```no-highlight
+-------+-------+
| NULL  | NULL  |
+-------+-------+
```
#### Функция GET_FORMAT()

Функция `GET_FORMAT()` используется для получения определенной строки формата для даты, времени или даты и времени. Она принимает два аргумента в следующем порядке:

- `type` — тип объекта, для которого требуется строка формата (`DATE, TIME` или `DATETIME`)
- `format` — непосредственно формат (`USA, JIS, ISO` или `EUR`)

Функция возвращает строку формата `format` для объекта типа `type`.

```sql
SELECT GET_FORMAT(DATE, 'EUR'),
       GET_FORMAT(TIME, 'EUR'),
       GET_FORMAT(DATETIME, 'EUR');
```

```no-highlight
+-----------+----------+-------------------+
| %d.%m.%Y  | %H.%i.%s | %Y-%m-%d %H.%i.%s |
+-----------+----------+-------------------+
```

Функцию `GET_FORMAT()` удобно использовать совместно с функциями `DATE_FORMAT()` и `TIME_FORMAT()`.

```sql
SELECT DATE_FORMAT('2023-10-20', GET_FORMAT(DATE, 'USA')),
       TIME_FORMAT('07:30:00', GET_FORMAT(TIME, 'USA'));
```

#### Функция ISNULL()

Функция `ISNULL()` используется для проверки значения на `NULL`. Она принимает в качестве аргумента произвольное значение и возвращает `1`, если переданным значением является `NULL`, или `0` в противном случае.

```sql
SELECT ISNULL(0),
       ISNULL(1),
       ISNULL(1.1),
       ISNULL(''),
       ISNULL('bee'),
       ISNULL(NULL);
```

```no-highlight
+-------+-------+-------+------+------+------+
| 0     | 0     | 0     | 0    | 0    | 1    |
+-------+-------+-------+------+------+------+
```

#### Функция IF()

Функция `IF()` используется для выбора одного из двух значений в зависимости от результата некоторого условного выражения. Она принимает три аргумента в следующем порядке:

- `condition` — условное выражение
- `value1` — произвольное значение
- `value2` — произвольное значение

Функция возвращает значение `value1`, если условное выражение `condition` истинно, или значение `value2` в противном случае.

```sql
SELECT IF(1 > 0, 'bee', 'geek'),
       IF(1 < 0, 'bee', 'geek');
```

```no-highlight
+--------------------------+--------------------------+
| IF(1 > 0, 'bee', 'geek') | IF(1 < 0, 'bee', 'geek') |
+--------------------------+--------------------------+
| bee                      | geek                     |
+--------------------------+--------------------------+
```
#### Функция COALESCE()

Функция `COALESCE()` используется для поиска первого непустого значения. Она принимает переменное количество аргументов и возвращает первый из них, не равный `NULL`.

```sql
SELECT COALESCE(1, 2, 3),
       COALESCE(NULL, 2, 3),
       COALESCE(1, NULL, 3),
       COALESCE(NULL, NULL, 3);
```

```no-highlight
+---+---+---+---+
| 1 | 2 | 1 | 3 |
+---+---+---+---+
```

Если все аргументы, переданные в функцию `COALESCE()`, являются значением `NULL`, возвращаемым значением функции также будет значение `NULL`.

```sql
SELECT COALESCE(NULL),
       COALESCE(NULL, NULL);
```

```no-highlight
+----------------+----------------------+
| COALESCE(NULL) | COALESCE(NULL, NULL) |
+----------------+----------------------+
| NULL           | NULL                 |
+----------------+----------------------+
```
#### Функция IFNULL()

Функция `IFNULL()` используется для замены некоторого значения на альтернативное, если исходное значение равняется `NULL`. Она принимает два аргумента в следующем порядке:

- `value` — исходное значение
- `alternative_value` — альтернативное значение

Функция возвращает значение `value`, если оно не равняется `NULL`, или значение `alternative_value` в противном случае.

```sql
SELECT IFNULL(NULL, 'geek'),
       IFNULL('bee', 'geek');
```

```no-highlight
+----------------------+-----------------------+
| IFNULL(NULL, 'geek') | IFNULL('bee', 'geek') |
+----------------------+-----------------------+
| geek                 | bee                   |
+----------------------+-----------------------+
```
#### Функция NULLIF()

Функция `NULLIF()` используется для сравнения двух значений. Она принимает два аргумента в следующем порядке:

- `value1` — произвольное значение
- `value2` — произвольное значение

Функция возвращает значение `NULL`, если значения `value1` и `value2` совпадают, или значение `value1` в противном случае.

```sql
SELECT NULLIF('bee', 'bee'),
       NULLIF('bee', 'geek');
```

```no-highlight
+----------------------+-----------------------+
| NULLIF('bee', 'bee') | NULLIF('bee', 'geek') |
+----------------------+-----------------------+
| NULL                 | bee                   |
+----------------------+-----------------------+
```
#### Функции CONVERT() и CAST()

Во время выполнения операций со значениями разных типов происходит автоматическое приведение этих значений к одному типу. Например, при попытке сложить число и строку СУБД сначала конвертирует прибавляемую строку в число.

```sql
SELECT 1 + '15';
```

```no-highlight
+----------+
| 1 + '15' |
+----------+
| 16.0     |
+----------+
```

Однако не всегда СУБД может автоматически привести используемые значения к нужному типу для корректного выполнения операции, поэтому иногда это приходится делать вручную. В SQL для преобразования типов используются функции `CONVERT()` и `CAST()`.

Функция `CONVERT()` принимает два аргумента в следующем порядке:

- `value` — значение, которое необходимо преобразовать
- `type` — желаемый тип

Функция приводит значение `value` к типу `type` и возвращает полученный результат.

```sql
SELECT CONVERT(100.78, DECIMAL(4, 1)),
       CONVERT(100.78, DECIMAL(3, 0));
```

```no-highlight
+--------------------------------+--------------------------------+
| CONVERT(100.78, DECIMAL(4, 1)) | CONVERT(100.78, DECIMAL(3, 0)) |
+--------------------------------+--------------------------------+
| 100.8                          | 101                            |
+--------------------------------+--------------------------------+
```

Функция `CONVERT()` умеет приводить значение к следующим типам:

| **Тип**         | **Описание**                           |
| --------------- | -------------------------------------- |
| `DATE`          | значение типа `DATE`                   |
| `DATETIME`      | значение типа `DATETIME`               |
| `TIME`          | значение типа `TIME`                   |
| `DECIMAL(M, D)` | значение типа `DECIMAL`                |
| `CHAR(N)`       | значение типа `CHAR`                   |
| `SIGNED`        | значение типа `BIGINT` с учетом знака  |
| `UNSIGNED`      | значение типа `BIGINT` без учета знака |
| `YEAR`          | значение типа `YEAR`                   |

Значение, приводимое к определенному типу, должно соответствовать формату этого типа, в противном случае функция `CONVERT()` вернет значение `NULL`. 

```sql
SELECT CONVERT('2023-01-01', DATE),
       CONVERT('beegeek', DATE);
```

```no-highlight
+-----------------------------+--------------------------+
| CONVERT('2023-01-01', DATE) | CONVERT('beegeek', DATE) |
+-----------------------------+--------------------------+
| 2023-01-01                  | NULL                     |
+-----------------------------+--------------------------+
```

Однако при попытке привести несоответствующее формату значение к числовому типу функция `CONVERT()` вернет значение `0`.

```sql
SELECT CONVERT('beegeek', SIGNED),
       CONVERT('beegeek', UNSIGNED),
       CONVERT('beegeek', DECIMAL(5, 2));
```

Похожим образом себя ведет функция `CAST()` за тем исключением, что она разделяет передаваемые аргументы не запятой, а ключевым словом `AS`.

```sql
SELECT CAST(100.78 AS DECIMAL(4, 1)),
       CAST(100.78 AS DECIMAL(3, 0));
```

## Условные конструкции

#### Оператор CASE

Для решения задач, в которых необходимо выполнить проверку нескольких условий и в зависимости от истинности одного из них вернуть соответствующее значение, используется оператор `CASE`.

Оператор `CASE` поддерживает две формы записи: простую и усложненную. Простая форма имеет следующий синтаксис:

```
CASE <значение>
    WHEN <первое сравниваемое значение> THEN <результат>
    WHEN <второе сравниваемое значение> THEN <результат>
    ...
    WHEN <n-oe сравниваемое значение> THEN <результат>
    ELSE <значение по умолчанию>
END
```

Простая форма подразумевает, что после оператора `CASE` указывается некоторое значение, которое последовательно сравнивается на равенство с другими значениями. Каждое сравниваемое значение указывается после ключевого слова `WHEN`, а результат, который будет возвращен, если исходное значение и сравниваемое окажутся равными, — после ключевого слова `THEN`. Если исходное значение не совпадет ни с одним из сравниваемых значений, результатом будет значение по умолчанию, которое указывается после ключевого слова `ELSE`.

Усложненная форма оператора `CASE` имеет следующий синтаксис:

```
CASE
    WHEN <первое условие> THEN <результат>
    WHEN <второе условие> THEN <результат>
    ...
    WHEN <n-oe условие> THEN <результат>
    ELSE <значение по умолчанию>
END AS <псевдоним>
```

Ключевая разница усложненной формы от простой заключается в том, что она не требует какого-либо значения, которое будет сравниваться с другими. По сути усложненная форма представляет собой набор произвольных условий, которые последовательно проверяются на истинность. Если проверяемое условие истинно, то результатом будет соответствующее ему значение, если ложно — проверка перейдет к следующему условию. Если все условия окажутся ложными, результатом будет значение по умолчанию.

Усложненная форма позволяет писать более гибкие и компактные условные конструкции. В качестве демонстрации преимущества усложненной формы напишем запрос, выполняющий ровно ту же задачу, что выполнял предыдущий запрос с оператором `CASE` в простой форме.