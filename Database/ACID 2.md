
## Атомарность (Atomicity)

Атомарность переводит базу данных из одного согласованного состояния в другое.

```sql
CREATE TABLE balances ( 
	id serial PRIMARY KEY, 
	user_id int, 
	amount int CHECK (amount >= 0)
);

INSERT INTO balances (user_id, amount) 
VALUES (1, 100), (2, 100);
```

Проведем перевод между счетами

```sql
BEGIN;

UPDATE balances SET amount = amount - 100 WHERE id = 1;
--- В данный момент может произойти отключение электроэнергии и БД упадет
UPDATE balances SET amount = amount + 100 WHERE id = 2;

COMMIT;
```

 не может чтобы одна операция выполнилась а другая - нет. Выполнятся либо все, либо ни одна.

## Консистентность (Consistency)

После выполнения операций БД должна остается в согласованном состоянии, т.е. после завершения транзакции данные в базе следуют всем ограничениям наложенным на эту БД

```sql
BEGIN;

UPDATE balances SET amount = amount - 200 WHERE id = 1;
UPDATE balances SET amount = amount + 200 WHERE id = 2;

COMMIT;
```

Сейчас в БД не находится в согласованном состоянии (общая сумма всех счетов положительна, но счету первого окажется отрицательная сумма, что противоречит ограничению `CHECK (amount >= 0)`). Транзакция не выполнится.

После выполнения транзакции - все данные согласованны и соответствуют заданным в БД ограничениям.

## Изоляция (Isolation)

Изоляция начинает действовать тогда, когда есть одновременные (параллельные) транзакции затрагивающие одни и те же данные.

Существует несколько уровней изоляции:

1. Грязное чтение (`read uncommited`)

Пример: одновременные транзакции

| Транзакция пользователя А                       | Транзакция пользователя B                                             |
| ----------------------------------------------- | --------------------------------------------------------------------- |
| BEGIN;<br>INSERT INTO table (value) VALUES (1); |                                                                       |
|                                                 | BEGIN;<br>SELECT * FROM table<br>---пользователь B уже увидит value=1 |
| ROLLBACK;                                       |                                                                       |
В большинстве баз данных грязное чтение отключено по умолчанию. т.к. транзакция пользователя А может быть отменена, а транзакция пользователя B думает что получены актуальные данные.

2. Подтвержденное чтение (`read commited`)

Пример: одновременные транзакции

| Транзакция пользователя А                       | Транзакция пользователя B                                                                                      |
| ----------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| BEGIN;<br>INSERT INTO table (value) VALUES (1); |                                                                                                                |
|                                                 | BEGIN;<br>SELECT * FROM table<br>---пользователь B НЕ увидит value=1                                           |
| COMMIT;                                         |                                                                                                                |
|                                                 | BEGIN;<br>SELECT * FROM table<br>--- После завершения транзакции пользователя А, пользователь B увидит value=1 |

В большинстве баз данных `read commited` используется по умолчанию

3. Повторяющееся чтение (`repeatable read`)

Включение режима:

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

В данном режиме БД будет делать "снимок" своего состояния и отдавать только его в пределах одной транзакции.

В данном режиме дополнительно расходуются оперативная память и жесткий диск, что может повлиять на производительность БД и приложения.

4. Сериалиуемый (`serializable`)

На этом уровне БД самостоятельно отлавливает аномалии параллельных транзакций.

Включение режима:

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

Пример: одновременные транзакции без `serializable`

| Транзакция пользователя А                                                                       | Транзакция пользователя B                                                                     |
| ----------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| BEGIN;<br>SELECT * FROM balances b UPDATE balances SET amount = 200 WHERE user_id=1;<br>COMMIT; | BEGIN;<br>SELECT * FROM balances b UPDATE balances SET amount = 0 WHERE user_id=1;<br>COMMIT; |
В данном случае в поле `amount` запишется значение той транзакции, которая завершится последней.

Пример: одновременные транзакции с `serializable`

| Транзакция пользователя А                                                                                                                        | Транзакция пользователя B                                                                                                                      |
| ------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| BEGIN;<br>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>SELECT * FROM balances b UPDATE balances SET amount = 200 WHERE user_id=1;<br>COMMIT; | BEGIN;<br>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>SELECT * FROM balances b UPDATE balances SET amount = 0 WHERE user_id=1;<br>COMMIT; |

В режиме `serializable` БД отслеживает одновременно изменяемые поля и при одновременном запуске транзакций не даст завершиться ни одной