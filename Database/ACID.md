
Требования ACID — набор требований, которые обеспечивают сохранность данных.

### Atomicity — Атомарность

Атомарность гарантирует, что каждая транзакция будет выполнена **полностью** или **не будет выполнена совсем**. Не допускаются промежуточные состояния.

![[Pasted image 20240130121643.png]]

Как только в транзакции возникает ошибка атомарность становится очень важна.

Если мы отправляем отдельные запросы, система не может связать их между собой. Запрос упал с ошибкой? Система его отменяет. Но только его, ведь она не знает о том, что запрос «списание со счёта» связан с ошибочным «зачисление на счёт». Транзакция же позволяет сгруппировать запросы, то есть фактически показывает базе на взаимосвязи между ними. База сама о связях ничего не знает. 

Но, если падает запрос внутри транзакции, база откатывает всю транзакцию. И приходит в состояние «как было до начала транзакции». Даже если там внутри было много запросов — сломался один, откатятся все.

### Consistency — Согласованность

> Транзакция, достигающая своего нормального завершения (_EOT — end of transaction_, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты ​ [wikipedia](https://ru.wikipedia.org/wiki/ACID)

Это свойство вытекает из предыдущего. Благодаря тому, что транзакция не допускает промежуточных результатов, база остается **согласованной**. Есть такое определение транзакции: «Упорядоченное множество операций, **переводящих базу данных из одного согласованного состояния в другое**». То есть до выполнения операции и после база остается **согласованной**.

![[Pasted image 20240130122931.png]]
Например, пользователь в системе заполняет карточку:

- ФИО
    
- Дата рождения
    
- ИНН
    
- Телефон — отдельно код страны, города и номер
    
- Адрес — тоже разбит на несколько полей
    

В базе данных у нас есть несколько таблиц:

- client
    
- phone
    
- address
    

Так что когда пользователь заполнил форму и нажал «сохранить», система отправляет в базу данных 3 запроса:

```sql
insert into client… -- вставить в таблицу клиентов такие-то данные

insert into phone…

insert into address…
```

![[Pasted image 20240130123035.png]]
Можно отправить 3 разных запроса, но лучше сделать одну **транзакцию**, внутри которой будут эти 3 запроса.

Атомарность гарантирует, что не получится такого, что адрес с телефоном сохранились, а сам клиент — нет. Это сделало бы базу несогласованной, ведь у нас бы появились атрибуты, «висящие в воздухе», никому не принадлежащие. Что, в свою очередь, приведет к ошибкам в системе.

За согласованностью должен следить разработчик. Ведь это вопрос скорее бизнес-логики, чем технологий. База об ограничениях не знает ничего, если ей не рассказать. И она легко пропустит запрос «добавь в базу телефон без ссылки на клиента», если сам по себе запрос корректный, а разработчик не повесил на таблицу _foreign key_.

### Isolation — Изолированность

Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат.

Если у нас система строго для одного человека, проблем не будет. А если пользователей несколько? Тогда транзакции запускают в параллель — для ускорения работы системы. А иначе представьте себе, что вы делаете заказ в интернет-магазине и система вам говорит: «Вы в очереди, перед вами еще 100 человек хотят заказ оформить, подождите». Бред же? Бред!

Вот и приходится распараллеливать запросы. Но к каким эффектам может привести параллельная работа двух транзакций?

**1 эффект: "Потерянная запись"**

![[Pasted image 20240130123554.png]]
Есть некий счет А, на котором лежит 500 у.е.

Кассир 1 (К1 на рисунке) списал с него 300 у.е. Обозначим его действия рыжими стрелками. Списал 300, на выходе получает 200 = 500 - 300.

Кассир 2 (К2) тоже решил обратиться к этому же счету, и записал туда 300 у.е., пока К1 еще не успел закрыть свою транзакцию. Так как первая транзакция не закрыта, сумма на счете до сих пор 500, получаем 500 + 300 = 800.

Итог — мы "потеряли запись" первого кассира, ведь на выходе у нас А = 800, хотя должно быть 500. "Кто последний вписал результат - того и тапки".

**2 эффект: "Грязное чтение"**

![[Pasted image 20240130123723.png]]
Есть некий счет А, на котором лежит 500 у.е.

Кассир 1 списал с него 300 у.е. Обозначим его действия рыжими стрелками. Списал 300. Потом передумал и сделал откат - на выходе остались те же 500 у.е.

Кассиру 2 (К2) понадобилась информация по этому счету и он ее считал до того, как К1 закрыл свою транзакцию.

Итог — второй кассир считал неверную сумму, построил неверный отчет/отказал в визе платежеспособному гражданину и т.д.

**3 эффект: "Повторимое чтение"**

![[Pasted image 20240130123826.png]]
Есть некие данные.

Кассир 1 строит отчет. Операции идут последовательно для каждой колонки. Система считала данные, записала в первую колонку (например, взяв минимум от них).

Обозначим получение данных зеленым цветом, а изменение - рыжим.

Кассир 2 влез в эту таблицу данных и изменил некоторые счета в ней.

У кассира 1 продолжается построение отчета. И во вторую колонку система считывает уже новые данные.

Итог - отчет построен на основании разных данных.

**4 эффект: "Фантомы"**

![[Pasted image 20240130123932.png]]
Есть некие данные.

Кассир 1 строит отчет. Операции идут последовательно для каждой колонки. Система считала данные, записала в первую колонку (например, взяв минимум от них).

Обозначим получение данных зеленым цветом, а изменение - рыжим.

Кассир 2 влез в эту таблицу данных и добавил новые счета/удалил некоторые старые.

У кассира 1 продолжается построение отчета. И во вторую колонку система считывает уже новые данные.

Итог — отчет построен на основании разных данных.

Разница между 3-им и 4-ым эффектами в том, что в одном случае данные _изменяются_, а во втором — _добавляются/удаляются_. То есть меняется ещё и их количество.

##### Как бороться

Нужно изолировать транзакцию. Способов есть несколько, но основные — блокировки и версии.

**Блокировки** — это когда мы блокируем данные в базе. Можно заблокировать одну строку в таблице, а можно всю таблицу. Можно заблокировать данные на редактирование, а можно и на чтение тоже.

**Версии** — это когда внутри базы при каждом обновлении создается новая версия данных и сохраняется старая. Версионирование скрыто от разработчика, то есть мы не видим в базе никаких номеров версий и данных по ним. Просто пока транзакция, обновляющая запись, не зафиксирует свое изменение, остальные потребители читают старую версию записи и не блокируются.

### Durability — Надёжность

Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя. Обесточилась система, произошел сбой в оборудовании? На выполненную транзакцию это не повлияет.