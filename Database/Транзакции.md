![[Pasted image 20240130134840.png]]

Транзакция — это набор операций по работе с базой данных (БД), объединенных в одну атомарную логическую единицу.

Транзакционные базы данных (базы, работающие через транзакции) выполняют требования [[ACID]], которые обеспечивают безопасность данных.

### Что такое транзакция

Представьте, что вы решили послать другу 10 файликов в мессенджере. Какие есть варианты:

1. Кинуть каждый файлик отдельно.
2. Сложить их в архив и отправить архив.

Вроде бы разницы особой нет. Но что, если что-то пойдет не так? Соединение оборвется на середине, сервер уйдет в ребут или просто выдаст ошибку...

В первом случае ваш друг получит 9 файлов, но не получит один.

Во втором не получит ничего. Нет промежуточных состояний. Или получил всё, или не получил ничего. Но зато если произошла ошибка, вы снова перешлете сообщение. И друг получит все файлики разом, не придется проверять «не потерялся ли кто».

Транзакция — это тот же архив для запросов. Принцип «всё, или ничего». Или выполнены все запросы, которые разработчик упаковал в одну транзакцию, или ни один.

Если говорить по-научному, то транзакция — упорядоченное множество операций, переводящих базу данных из одного согласованного состояния в другое. Согласованное состояние — это состояние, которое подходит под бизнес-логику системы. То есть у нас не остается отрицательный баланс после перевода денег, номер счета не «зависает в воздухе», не привязанный к человеку, и тому подобное.

> транзакцией называется множество операций, которые переводят базу данных из одного корректного состояния в другое корректное состояние (согласованность) при условии, что транзакция выполнена полностью (атомарность) и без помех со стороны других транзакций (изоляция).

### Как отправить транзакцию

Чтобы обратиться к базе данных, сначала надо открыть соединение с ней. Это называется коннект (от англ. _connection_, соединение). Коннект — это просто труба, по которой мы посылаем запросы.

Чтобы сгруппировать запросы в одну атомарную пачку, используем транзакцию. Транзакцию надо:

1. Открыть.
2. Выполнить все операции внутри.
3. Закрыть.

Как только мы закрыли транзакцию, труба освободилась. И ее можно переиспользовать, отправив следующую транзакцию.

При настройке приложения администратор указывает, сколько максимально открытых соединений с базой может быть в один момент времени. Это называется пул соединений — количество свободных труб.

Разработчик берет соединение из пула и отправляет по нему транзакцию. Как только транзакция закрывается (неважно, успешно она прошла или откатилась), соединение возвращается в пул, и его может использовать следующая бизнес-операция.

##### Как открыть транзакцию

Зависит от базы данных. В Oracle транзакция открывается сама, по факту первой изменяющей операции. А в MySql надо явно писать «start transaction».

##### Как закрыть транзакцию

Тут есть 2 варианта:

1. **COMMIT** — подтверждаем все внесенные изменения;
    
2. **ROLLBACK** — откатываем их;
    

И вся фишка транзакционной базы в том, что база сначала применяет запрос «виртуально», реально ничего в базе не изменив.

Делая комит, мы заканчиваем одну бизнес-операцию, и возвращаем соединение в пул без открытой транзакции. То есть просто освобождаем трубу для других. Следующая бизнес-операция берет эту трубу и посылает в нее свои операции. Поэтому важно сделать _rollback_, если изменения сохранять не надо. Не откатите и вернете соединение в пул? Его возьмет кто-то другой и сделает коммит. Своих изменений, и ваших, неоткаченных.

> Ситуации, когда корректные транзакции некорректно работают вместе, называются **аномалиями** одновременного выполнения.

### Аномалии в стандарте SQL

**Потерянное обновление** 

Аномалия потерянного обновления (lost update) возникает, когда две транзакции читают одну и ту же строку таблицы, затем одна из них обновляет эту строку, после чего вторая обновляет эту же строку, не учитывая изменений, сделанных первой транзакцией. 

>Например, две транзакции собираются увеличить сумму на одном и том же счете на 100 ₽. Первая транзакция читает текущее значение (1000 ₽), затем вторая транзакция читает то же самое значение. Первая увеличивает сумму (получается 1100 ₽) и записывает в базу это новое значение. Вторая поступает так же: получает те же 1100 ₽ и записывает их. В результате клиент потерял 100 ₽. 

Потерянное обновление не допускается стандартом ни на одном уровне изоляции.

**Грязное чтение и Read Uncommitted** 

Аномалия грязного чтения (dirty read) возникает, когда транзакция читает еще не зафиксированные изменения, сделанные другой транзакцией.

>Например, первая транзакция переводит 100 ₽ на пустой счет клиента, но не фиксирует изменение. Другая транзакция читает состояние счета (обновленное, но не зафиксированное) и позволяет клиенту снять наличные — несмотря на то, что первая транзакция прерывается и отменяет свои изменения, так что никаких денег на счете клиента нет. 

Грязное чтение допускается стандартом на уровне Read Uncommitted.

**Неповторяющееся чтение и Read Committed**

Аномалия неповторяющегося чтения (non-repeatable read) возникает, когда транзакция читает одну и ту же строку два раза, а в промежутке между чтениями вторая транзакция изменяет (или удаляет) эту строку и фиксирует изменения. Тогда первая транзакция получит разные результаты. 

> Например, пусть правило согласованности запрещает отрицательные суммы на счетах клиентов. Первая транзакция собирается уменьшить сумму на счете на 100 ₽. Она проверяет текущее значение, получает 1000 ₽ и решает, что уменьшение возможно. В это время вторая транзакция уменьшает сумму на счете до нуля и фиксирует изменения. Если бы теперь первая транзакция повторно проверила сумму, она получила бы 0 ₽ (но она уже приняла решение уменьшить значение, и счет «уходит в минус»). 

Неповторяющееся чтение допускается стандартом на уровнях Read Uncommitted и Read Committed.

**Фантомное чтение и Repeatable Read**

Аномалия фантомного чтения (*phantom read*) возникает, когда одна транзакция два раза читает набор строк по одинаковому условию, а в промежутке между чтениями другая транзакция добавляет строки, удовлетворяющие этому условию, и фиксирует изменения. Тогда первая транзакция получит разные наборы строк. 

> Например, пусть правило согласованности запрещает клиенту иметь более трех счетов. Первая транзакция собирается открыть новый счет, проверяет их текущее количество (скажем,два) и решает, что открытие возможно. В это время вторая транзакция тоже открывает клиенту новый счет и фиксирует изменения. Если бы теперь первая транзакция перепроверила количество, она получила бы три (но она уже выполняет открытие еще одного счета, и у клиента их оказывается четыре). 

Фантомное чтение допускается стандартом на уровнях *Read Uncommitted*, *Read Committed* и *Repeatable Read*.

**Отсутствие аномалий и Serializable** 

Стандарт определяет и уровень, на котором не допускаются никакие аномалии, — *Serializable*. И это совсем не то же самое, что запрет на потерянное обновление и на грязное, неповторяющееся и фантомное чтение. Дело в том, что существует значительно больше известных аномалий, чем перечислено в стандарте, и еще неизвестное число пока неизвестных. Уровень *Serializable* должен предотвращать любые аномалии. Это означает, что на таком уровне разработчику приложения не надо думать об изоляции. Если транзакции выполняют корректные последовательности операторов, работая в одиночку, данные останутся согласованными и при одновременной работе этих транзакций.

|  | Потерянные изменения | Грязное чтение | Неповторяющееся чтение | Фантомное чтение | Другие аномалии |
| ---- | ---- | ---- | ---- | ---- | ---- |
| **Read Uncommitted** | - | Да | Да | Да | Да |
| **Read Committed** | - | - | Да | Да | Да |
| **Repeatable Read** | - | - | - | Да | Да |
| **Serializable** | - | - | - | - | - |

## Уровни изоляции

1. **Read Uncommitted (Неподтвержденное чтение)** — Этот уровень позволяет транзакциям читать неподтвержденные данные других транзакций. Он не обеспечивает никакой изоляции. Невозможны потерянные изменения (lost changes), возможны грязное чтение (dirty read), неповторяемое чтение и фантомы.
2. **Read Committed (Подтвержденное чтение)** — Этот уровень гарантирует, что транзакция будет видеть только подтвержденные изменения других транзакций. Возможны проблемы, такие как "неповторяющееся чтение" или "фантомное чтение".
3. **Repeatable Read, Snapshot (Повторяемое чтение)** — транзакция видит только те данные, которые были прочитаны в начале транзакции. Это предотвращает "неповторяющееся чтение" и "фантомное чтение", но по-прежнему может возникнуть проблема "затерянной модификации".
4. **Serializable (Сериализуемость)** — Этот уровень обеспечивает полную изоляцию транзакций. Он гарантирует, что транзакции будут выполняться последовательно, как если бы они выполнялись одна за другой. Это предотвращает все проблемы, связанные с изоляцией транзакций, но может снизить производительность базы данных.

Реализация полной изоляции — технически сложная задача, сопряженная с уменьшением производительности системы. Поэтому на практике почти всегда применяется ослабленная изоляция, которая предотвращает некоторые, но не все аномалии. А это означает, что часть работы по обеспечению согласованности данных ложится на приложение. Именно поэтому очень важно понимать, какой уровень изоляции используется в системе, какие гарантии он дает, а какие — нет, и как в таких условиях писать корректный код.

## Пример транзакции

|Транзакция A|
|---|
|Начать транзакцию A|
|Прочесть баланс на счете А|
|Уменьшить баланс на 10 денежных единиц|
|Сохранить новый баланс счёта А|
|Прочесть баланс на счете B|
|Увеличить баланс счёта B на 10 денежных единиц|
|Сохранить новый баланс счёта B|
|Закончить транзакцию А|

## Пример взаимоблокировки

2 одновременных транзакции. А переводит деньги B, B переводит деньги А

|Транзакция A|Транзакция B|
|---|---|
|Начать транзакцию A|Начать транзакцию B|
|Заблокировать другим транзакциям баланс на счёте А|Заблокировать другим транзакциям баланс на счёте B|
|Прочесть баланс на счете А|Прочесть баланс на счете B|
|Уменьшить баланс на 10 денежных единиц|Уменьшить баланс на 10 денежных единиц|
|Сохранить новый баланс счёта А|Сохранить новый баланс счёта B|
|Прочесть баланс на счете B|Прочесть баланс на счете А|
|Дождаться, когда счёт B освободится для записи|Дождаться, когда счёт А освободится для записи|
|Увеличить баланс счёта B на 10 денежных единиц|Увеличить баланс счёта А на 10 денежных единиц|
|Сохранить новый баланс счёта B|Сохранить новый баланс счёта А|
|Закончить транзакцию А|Закончить транзакцию В|
## Пример на SQL

```sql
BEGIN; -- начало транзакции

-- выполнение операции чтения
SELECT * FROM megaschema.employee WHERE name = 'Иван';

-- выполнение операции записи
INSERT INTO megaschema.employee ("name", surname, patronymic, date_of_employment)
VALUES('Иван', 'Иванов', 'Иванович', '03-01-2024');

COMMIT; -- фиксация (подтверждение) транзакции
```

## Изменить уровень изоляции транзакций. Пример:

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

## Примеры изоляций на PostgreSQL

**Отсутствие грязного чтения**. Легко убедиться в том, что грязные данные прочитать невозможно. Начнем транзакцию. По умолчанию она использует
уровень изоляции **`Read Committed`**

```sql
=> BEGIN;
=> SHOW transaction_isolation;
transaction_isolation
−−−−−−−−−−−−−−−−−−−−−−−
read committed
(1 row)
```

Итак, в открытой транзакции снимаем средства со счета, но не фиксируем
изменения. Свои собственные изменения транзакция всегда видит:

```sql
=> UPDATE accounts SET amount = amount - 200 WHERE id = 1;
=> SELECT * FROM accounts WHERE client = 'alice';
id | client | amount
−−−−+−−−−−−−−+−−−−−−−−
1 | alice | 800.00
(1 row)
```

Во втором сеансе начинаем еще одну транзакцию с тем же уровнем `Read Committed`:

```sql
=> BEGIN;
=> SELECT * FROM accounts WHERE client = 'alice';
id | client | amount
−−−−+−−−−−−−−+−−−−−−−−−
1 | alice | 1000.00
(1 row)
```

Как и ожидалось, другая транзакция не видит незафиксированные изменения — грязное чтение не допускается.

**Неповторяющееся чтение**. Пусть теперь первая транзакция зафиксирует изменения, а вторая повторно выполнит тот же самый запрос:

1-я транзакция: 

```sql
=> COMMIT;
```

2-я транзакция: 

```sql
=> SELECT * FROM accounts WHERE client = 'alice';
id | client | amount
−−−−+−−−−−−−−+−−−−−−−−
1 | alice | 800.00
(1 row)
=> COMMIT;
```

Запрос получает уже новые данные — это и есть аномалия **неповторяющегося**
**чтения**, которая допускается на уровне `Read Committed`

**Несогласованное чтение**. Допустим, первая транзакция начала перевод средств с одного счета Боба на другой:

```sql
=> BEGIN;
=> UPDATE accounts SET amount = amount - 100 WHERE id = 2;
```

В это время другая транзакция подсчитывает баланс Боба, причем подсчет
выполняется в цикле по всем счетам Боба. Фактически транзакция начинает
с первого счета (и, разумеется, видит прежнее состояние):

```sql
=> BEGIN;
=> SELECT amount FROM accounts WHERE id = 2;
amount
−−−−−−−−
100.00
(1 row)
```

В этот момент первая транзакция успешно завершается:

```sql
=> UPDATE accounts SET amount = amount + 100 WHERE id = 3;
=> COMMIT;
```

А другая читает состояние второго счета (и видит уже новое значение):

```sql
=> SELECT amount FROM accounts WHERE id = 3;
amount
−−−−−−−−−
1000.00
(1 row)
=> COMMIT;
```

В итоге вторая транзакция получила в сумме 1100 ₽, то есть прочитала
некорректные данные. Такая аномалия называется **несогласованным чтением** (read skew).

Как избежать этой аномалии, оставаясь на уровне `Read Committed`? Конечно,
использовать один оператор. Например, так:

```sql
SELECT sum(amount) FROM accounts WHERE client = 'bob';
```

**Потерянное обновление.**

Приложение читает и запоминает (вне базы данных) текущий баланс счета Алисы:

1-я транзакция: 

```sql
=> BEGIN;
=> SELECT amount FROM accounts WHERE id = 1;
amount
−−−−−−−−
800.00
(1 row)
```

В это время другая транзакция действует так же: 

```sql
=> BEGIN;
=> SELECT amount FROM accounts WHERE id = 1;
amount
−−−−−−−−
800.00
(1 row)
```

Первая транзакция увеличивает запомненное ранее значение на 100 ₽ и записывает в базу:

```sql
=> UPDATE accounts SET amount = 800.00 + 100 WHERE id = 1
RETURNING amount;
amount
−−−−−−−−
900.00
(1 row)
UPDATE 1
=> COMMIT;
```

И вторая транзакция тоже:

```sql
=> UPDATE accounts SET amount = 800.00 + 100 WHERE id = 1
RETURNING amount;
amount
−−−−−−−−
900.00
(1 row)
UPDATE 1
=> COMMIT;
```

К сожалению, Алиса недосчиталась 100 ₽. СУБД ничего не знает о том, что
запомненное значение 800 ₽ как-то связано с `accounts.amount`, и допускает аномалию потерянного изменения. На уровне изоляции `Read Committed`
такой код некорректен.

**Repeatable Read**

Само название уровня изоляции `Repeatable Read` говорит о повторяемости чтения

```sql
=> BEGIN;
=> UPDATE accounts SET amount = 200.00 WHERE id = 2;
=> UPDATE accounts SET amount = 800.00 WHERE id = 3;
=> INSERT INTO accounts VALUES
(4, 'charlie', 100.00);
=> SELECT * FROM accounts ORDER BY id;
id | client | amount
−−−−+−−−−−−−−−+−−−−−−−−
1 | alice | 900.00
2 | bob | 200.00
3 | bob | 800.00
4 | charlie | 100.00
(4 rows)
```

Во втором сеансе начнем транзакцию с уровнем `Repeatable Read`, указав его
в команде `BEGIN` (уровень первой транзакции не важен):

```sql
=> BEGIN ISOLATION LEVEL REPEATABLE READ;
=> SELECT * FROM accounts ORDER BY id;
id | client | amount
−−−−+−−−−−−−−+−−−−−−−−−−
1 | alice | 900.00
2 | bob | 202.0000
3 | bob | 707.0000
(3 rows)
```

Теперь первая транзакция фиксирует изменения, а вторая повторно выполняет тот же самый запрос:

1-я транзакция: 

```sql
COMMIT;
```

2-я транзакция:

```sql
=> SELECT * FROM accounts ORDER BY id;
id | client | amount
−−−−+−−−−−−−−+−−−−−−−−−−
1 | alice | 900.00
2 | bob | 202.0000
3 | bob | 707.0000
(3 rows)
=> COMMIT;
```

Вторая транзакция продолжает видеть ровно те же данные, что и в начале:
не видно ни изменений в существующих строках, ни новых строк. На таком
уровне можно не беспокоиться о том, что между двумя операторами что-то
поменяется.

**Serializable**

На уровне `Serializable` предотвращаются все возможные аномалии. Фактически `Serializable` реализован как надстройка над изоляцией на основе снимков данных. Те аномалии, которые не возникают при `Repeatable Read` (такие
как грязное, неповторяемое, фантомное чтение), не возникают и на уровне
`Serializable`. А те две аномалии, которые возникают (несогласованная запись
и аномалия только читающей транзакции), специальным образом обнаруживаются, и в этом случае транзакция обрывается: возникает ошибка сериализации.

## Какой уровень изоляции использовать?

Уровень изоляции `Read Committed` используется в PostgreSQL по умолчанию,
и, по всей видимости, именно этот уровень применяется в абсолютном большинстве приложений. Он удобен тем, что на нем обрыв транзакции возможен только в случае сбоя, но для предотвращения несогласованности обрыв не применяется. Иными словами, ошибка сериализации возникнуть не может, и о повторении транзакций заботиться не надо.