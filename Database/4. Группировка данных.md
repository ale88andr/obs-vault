## Агрегатные функции

Нередко при извлечении данных бывает необходимо не просто отобразить их в исходном или форматированном виде, а выполнить с ними определенного рода итоговые вычисления, например, определить сумму возвращенных значений или найти среди них минимальное. В SQL для этого предусмотрены **агрегатные функции** — функции, которые выполняют вычисления на наборе значений и возвращают одиночное значение. Запросы с такими функциями часто используются для анализа данных и создания отчетов.
#### Функция AVG()

Функция `AVG()` используется для вычисления среднего арифметического числовых значений поля. Например, с помощью данной функции мы можем определить среднее количество прослушиваний всех песен.

```sql
SELECT AVG(streams) AS avg_streams
FROM Songs;
```

```no-highlight
+-------------+
| avg_streams |
+-------------+
| 271191.3000 |
+-------------+
```

Запрос выше возвращает единственное значение, соответствующее среднему количеству прослушиваний всех десяти песен. Дополнительно можно воспользоваться блоком `WHERE` и найти среднее значение на основе не всех значений поля, а лишь тех, что удовлетворяют определенным условиям.
#### Функция COUNT()

Функция `COUNT()` используется для подсчета количества записей в таблице или количества значений в поле. Для определения количества записей в таблице в функцию `COUNT()` в качестве аргумента необходимо передать звездочку (`*`).

```sql
SELECT COUNT(*) AS num_of_songs
FROM Songs;
```

```no-highlight
+--------------+
| num_of_songs |
+--------------+
| 10           |
+--------------+
```

Аналогично функции `AVG()`, функция `COUNT()` может использоваться для подсчета количества записей, удовлетворяющих определенным условиям. К примеру, мы можем определить, сколько песен принадлежит исполнителю `Morrisey`.

```sql
SELECT COUNT(*) AS num_of_songs
FROM Songs
WHERE artist = 'Morrissey';
```

```no-highlight
+--------------+
| num_of_songs |
+--------------+
| 3            |
+--------------+
```

Для определения количества значений в поле функции `COUNT()` в качестве аргумента необходимо передать это поле.

```sql
SELECT COUNT(trackname) AS num_of_tracknames
FROM Songs;
```

Важным отличием между вызовами `COUNT(*)` и `COUNT(<название поля>)` является то, что в первом случае возвращается количество записей в таблице без учета значений в этих записях, в то время как во втором случае возвращается количество значений в поле, причем значения `NULL` не учитываются.

```sql
SELECT COUNT(*) AS num_of_songs,
       COUNT(release_year) AS num_of_years
FROM Songs;
```

```no-highlight
+--------------+--------------+
| num_of_songs | num_of_years |
+--------------+--------------+
| 10           | 8            |
+--------------+--------------+
```
#### Функции MIN() и MAX()

Функции `MIN()` и `MAX()` используются для поиска минимального и максимального значений в поле соответственно. Например, с помощью функции `MIN()` мы можем найти продолжительность самой короткой песни.

```sql
SELECT MIN(length) AS min_length
FROM Songs;
```

```no-highlight
+------------+
| min_length |
+------------+
| 195        |
+------------+
```

Функции `MIN()` и `MAX()`, как и другие агрегатные функции, могут использоваться не на всех значениях поля, а лишь на определенных. К примеру, с помощью функции `MAX()` можно определить продолжительность самой долгой песни группы `The Sounds`.

```sql
SELECT MAX(length) AS max_length
FROM Songs
WHERE artist = 'The Sounds';
```

```no-highlight
+------------+
| max_length |
+------------+
| 266        |
+------------+
```
#### Функция SUM()

Функция `SUM()` используется для вычисления суммы числовых значений поля. Например, с помощью данной функции мы можем определить количество прослушиваний всех десяти песен.

```sql
SELECT SUM(streams) AS sum_streams
FROM Songs;
```

```no-highlight
+-------------+
| sum_streams |
+-------------+
| 2711913     |
+-------------+
```

Аналогично предыдущим примерам, можно дополнительно воспользоваться блоком `WHERE`, чтобы вычислить количество прослушиваний не всех песен, а лишь определенного исполнителя, например, `Morrissey`.

```sql
SELECT SUM(streams) AS sum_streams
FROM Songs
WHERE artist = 'Morrissey';
```

```no-highlight
+-------------+
| sum_streams |
+-------------+
| 532824      |
+-------------+
```
#### Функция GROUP_CONCAT()

Функция `GROUP_CONCAT()` используется для перечисления значений поля через запятую. Например, с помощью данной функции мы можем перечислить названия первых пяти песен.

```sql
SELECT GROUP_CONCAT(trackname) AS songs
FROM Songs
WHERE id <= 5;
```

Перечисляемые функцией `GROUP_CONCAT()` значения можно сортировать. Для этого после названия поля, значения которого необходимо перечислить, нужно указать оператор `ORDER BY`, а затем предоставить одно или несколько полей, по которым должна быть выполнена сортировка.

```sql
SELECT GROUP_CONCAT(trackname ORDER BY trackname) AS songs
FROM Songs
WHERE id <= 5;
```

Запятая является разделителем по умолчанию, и его можно изменить. Чтобы задать собственный разделитель, необходимо воспользоваться ключевым словом `SEPARATOR`, после которого предоставить строку, содержащую разделитель.

Результатом приведенного ниже запроса:

```sql
SELECT GROUP_CONCAT(trackname SEPARATOR '; ') AS songs
FROM Songs
WHERE id <= 5;
```

При совместном использовании операторов `ORDER BY` и `SEPARATOR` внутри функции `GROUP_CONCAT()` важно соблюдать их расположение относительно друг друга: сначала указываются правила сортировки, после определяется разделитель.

```sql
SELECT GROUP_CONCAT(trackname ORDER BY trackname SEPARATOR '; ') AS songs
FROM Songs
WHERE id <= 5;
```

Внутри функций `AVG(), COUNT(), SUM()` и `GROUP_CONCAT()` можно использовать ключевое слово `DISTINCT`, чтобы в итоговых вычислениях участвовали лишь уникальные значения поля:

```
    ... AVG(DISTINCT <название поля>)
```

```css
    ... COUNT(DISTINCT <название поля>)
```

```css
    ... SUM(DISTINCT <название поля>)
```

```css
    ... GROUP_CONCAT(DISTINCT <название поля>)
```

#### Группировка данных

Агрегатные функции позволяют выполнить ряд итоговых вычислений с данными. Например, с помощью функции `COUNT()` мы можем определить количество песен, принадлежащих группе `Green Day`.

```
SELECT COUNT(*) AS num_of_songs
FROM Songs
WHERE artist = 'Green Day';
```

```no-highlight
+--------------+
| num_of_songs |
+--------------+
| 3            |
+--------------+
```

Аналогичным образом мы можем определить количество песен, принадлежащих какому-либо другому определенному исполнителю. Однако если нам понадобится вычислить количество песен, принадлежащих каждому исполнителю, сделать это лишь с помощью агрегатных функций не выйдет.

Для решения подобной задачи используются **группы**. Группировка дает возможность разделить все данные на логические наборы, благодаря чему становится возможным выполнение итоговых вычислений отдельно по каждой группе.
#### Создание групп

Группа представляет собой набор записей, которые определенным образом связаны друг с другом. Создание групп выполняется с помощью оператора `GROUP BY`, после которого указывается название поля, определяющего принцип группировки. Так, две записи попадают в одну группу, если их значения поля, указанного после оператора `GROUP BY`, совпадают.

```sql
SELECT artist,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY artist;
```

```no-highlight
+------------+--------------+
| artist     | num_of_songs |
+------------+--------------+
| Green Day  | 3            |
| Heart      | 1            |
| Blondie    | 2            |
| The Smiths | 1            |
| The Sounds | 3            |
+------------+--------------+
```

Часть запроса `GROUP BY artist` говорит о том, что записи при извлечении должны быть сгруппированы по полю `artist`, в результате чего в части запроса `SELECT artist, COUNT(*) AS num_of_songs` выполняется работа не со всеми записями из таблицы, а с определенной группой записей. Таким образом, для каждой группы определяются значения полей `artist` и `num_of_songs`, первое из которых содержит название исполнителя, второе — количество записей в группе, что соответствует количеству песен исполнителя.
#### Группировка по нескольким полям

После оператора `GROUP BY` не обязательно должно указываться единственное поле, их может быть несколько, и в таком случае группировка будет выполняться по всем перечисленным полям. Другими словами, две записи попадут в одну группу, если их значения по всем полям, указанным после оператора `GROUP BY`, совпадают.

Группировка по нескольким полям позволяет распределять данные более строго. Например, рассмотренные ранее музыкальные песни мы можем разбить на группы не только по исполнителям, но и по альбомам, которым эти песни принадлежат.

```sql
SELECT artist, album,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY artist, album;
```

```no-highlight
+------------+--------------------------+--------------+
| artist     | album                    | num_of_songs |
+------------+--------------------------+--------------+
| Green Day  | American Idiot           | 3            |
| Heart      | Dreamboat Annie          | 1            |
| Blondie    | No Exit                  | 1            |
| The Smiths | The Queen Is Dead        | 1            |
| The Sounds | Crossing the Rubicon     | 2            |
| Blondie    | Pollinator               | 1            |
| The Sounds | Dying to Say This to You | 1            |
+------------+--------------------------+--------------+
```
#### Группировка по вычисляемому полю

Поля, указываемые после оператора `GROUP BY`, могут быть вычисляемыми. Например, для группировки записей по полям `artist` и `album` мы можем не просто перечислить их после оператора `GROUP BY`, а использовать их конкатенацию.

```sql
SELECT CONCAT(artist, ', ', album) AS artist_and_album,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY CONCAT(artist, ', ', album);
```

```no-highlight
+--------------------------------------+--------------+
| artist_and_album                     | num_of_songs |
+--------------------------------------+--------------+
| Green Day, American Idiot            | 3            |
| Heart, Dreamboat Annie               | 1            |
| Blondie, No Exit                     | 1            |
| The Smiths, The Queen Is Dead        | 1            |
| The Sounds, Crossing the Rubicon     | 2            |
| Blondie, Pollinator                  | 1            |
| The Sounds, Dying to Say This to You | 1            |
+--------------------------------------+--------------+
```

Записи при выполнении запроса выше группируются по возвращаемому значению функции `CONCAT()`, а не прямым значениям полей `artist` и `album`, то есть при такой группировке две записи попадают в одну группу в том случае, если их значения, возвращаемые функцией `CONCAT()`, совпадают.
#### Особенности группировки

При использовании оператора `GROUP BY` мы работаем не с одиночными записями, а с наборами записей, в связи с чем возникает ряд ограничений. Например, нельзя извлечь поле, не участвующее в группировке, так как у двух записей в группе могут быть разные значения по этому полю.

```sql
SELECT artist, trackname
FROM Songs
GROUP BY artist;
```

является ошибка:

```no-highlight
ERROR 1055: Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'stepik_T2WUgrEW.Songs.trackname' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
```

Таким образом, при использовании группировки для извлечения доступен лишь ограниченный объем данных, а именно: поля группировки, результаты агрегатных функций и константы. Наиболее полезными являются поля группировки и результаты агрегатных функций, поскольку первые характеризуют каждую группу и позволяют отличить одну группу от другой, а благодаря вторым появляется возможность выполнять различные манипуляции с группами.

```sql
SELECT artist,
       SUM(streams) AS streams
FROM Songs
GROUP BY artist;
```

```no-highlight
+------------+---------+
| artist     | streams |
+------------+---------+
| Green Day  | 51870   |
| Heart      | 44371   |
| Blondie    | 180184  |
| The Smiths | 42700   |
| The Sounds | 208801  |
+------------+---------+
```

Запрос выше группирует записи по полю `artist` и для каждой группы определяет сумму значений поля `streams`, тем самым извлекает данные о каждом исполнителе и количестве прослушиваний всех его песен.
#### Фильтрация групп

Данные при извлечении можно не только группировать, но и фильтровать, то есть определять, какие группы должны быть включены в результат запроса, а какие — исключены. К примеру, при извлечении музыкальных исполнителей и суммарного количества прослушиваний их песен нам могут понадобиться лишь те, число прослушиваний которых превышает определенное значение.

Нам уже знаком оператор `WHERE`, однако для фильтрации групп он не подходит, так как его задачей является фильтрация записей при извлечении из таблицы. Для фильтрации групп в SQL используется оператор `HAVING`. В качестве примера использования этого оператора напишем запрос, решающий рассмотренную выше ситуацию по извлечению музыкальных исполнителей, суммарное количество прослушиваний песен которых превышает заданное число.

```sql
SELECT artist,
       SUM(streams) AS streams
FROM Songs
GROUP BY artist
HAVING SUM(streams) > 50000;
```

```no-highlight
+------------+---------+
| artist     | streams |
+------------+---------+
| Green Day  | 51870   |
| Blondie    | 180184  |
| The Sounds | 208801  |
+------------+---------+
```

Как и прежде, в этом запросе записи сперва группируются по полю `artist`, однако в результирующую таблицу попадают не все группы, а лишь те, сумма значений поля `streams` которых превышает `50000`. Несложно понять, что оператор `WHERE` для подобной фильтрации не подходит, так как данная фильтрация основана на итоговом значении группы, а не на значениях извлеченных из таблицы записей.

> Оператор `WHERE` фильтрует записи до того, как данные будут сгруппированы, а оператор `HAVING` — после того, как данные были сгруппированы.

Поскольку операторы `WHERE` и `HAVING` предназначены для разных задач, они могут быть использованы вместе. Примером их совместной работы может быть ситуация, в которой нам необходимо определить исполнителей, которые имеют как минимум две песни с определенным количеством прослушиваний.

```sql
SELECT artist,
       COUNT(*) AS num_of_songs
FROM Songs
WHERE streams > 40000
GROUP BY artist
HAVING COUNT(*) > 1;
```

```no-highlight
+------------+--------------+
| artist     | num_of_songs |
+------------+--------------+
| Blondie    | 2            |
| The Sounds | 3            |
+------------+--------------+
```

Выполнение данного запроса начинается с извлечения записей, значение поля `streams` которых превышает `40000`. Затем полученные записи группируются по полю `artist`. После выполняется фильтрация сформированных групп путем исключения тех, которые состоят из одной и менее записей. Завершается запрос формированием результирующей таблицы, которая включает поле `artist`, содержащее название исполнителя, и поле `num_of_songs`, содержащее количество песен исполнителя, число прослушиваний которых превышает `40000`.

> Оператор `HAVING` следует использовать только вместе с оператором `GROUP BY`, а оператор `WHERE`— для стандартной фильтрации на уровне записей.
#### Сортировка групп

Сгруппированные данные при извлечении могут быть не только отфильтрованы, но и отсортированы. Для сортировки групп не предусмотрен какой-либо отдельный оператор, поэтому она выполняется с помощью уже изученного ранее оператора `ORDER BY`.

В качестве примера совместного использования операторов группировки и сортировки дополним предложенный в начале урока запрос по определению количества песен, принадлежащих каждому исполнителю, сортировкой по количеству песен.

```sql
SELECT artist,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY artist
ORDER BY COUNT(*);
```

```no-highlight
+------------+--------------+
| artist     | num_of_songs |
+------------+--------------+
| Heart      | 1            |
| The Smiths | 1            |
| Blondie    | 2            |
| Green Day  | 3            |
| The Sounds | 3            |
+------------+--------------+
```

Здесь, как и в предыдущих запросах, записи сперва группируются по полю `artist`, однако затем сортируются по количеству записей в полученных группах.
#### Порядок обработки и выполнения операторов

При формировании SQL-запроса всегда необходимо соблюдать порядок используемых операторов. К примеру, оператор `FROM` должен быть указан после оператора `SELECT`. В таблице ниже перечислены все изученные нами на данный момент операторы в том порядке, в котором они должны располагаться в запросе:

| **Оператор** | **Описание**                   |
| ------------ | ------------------------------ |
| `SELECT`     | Данные для извлечения          |
| `FROM`       | Таблица для извлечения данных  |
| `WHERE`      | Фильтрация на уровне записей   |
| `GROUP BY`   | Создание групп                 |
| `HAVING`     | Фильтрация на уровне групп     |
| `ORDER BY`   | Порядок сортировки результатов |
| `LIMIT`      | Ограничение количества записей |

При выполнении SQL-запроса операторы выполняются в определенном порядке. В таблице ниже представлен порядок их выполнения:

| **Оператор** | **Описание**                   |
| ------------ | ------------------------------ |
| `FROM`       | Таблица для извлечения данных  |
| `WHERE`      | Фильтрация на уровне записей   |
| `GROUP BY`   | Создание групп                 |
| `HAVING`     | Фильтрация на уровне групп     |
| `SELECT`     | Данные для извлечения          |
| `ORDER BY`   | Порядок сортировки результатов |
| `LIMIT`      | Ограничение количества записей |
> Для оператора `GROUP BY` все значения `NULL` трактуются как равные. Таким образом, при группировке по полю, содержащему значения `NULL`, все такие записи попадут в одну группу.

Если группировка записей выполняется по вычисляемому полю, причем этому полю присвоен псевдоним, то в операторе `GROUP BY` можно воспользоваться этим псевдонимом.

```sql
SELECT CONCAT(artist, ', ', album) AS artist_and_album,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY artist_and_album;
```

```no-highlight
+--------------------------------------+--------------+
| artist_and_album                     | num_of_songs |
+--------------------------------------+--------------+
| Green Day, American Idiot            | 3            |
| Heart, Dreamboat Annie               | 1            |
| Blondie, No Exit                     | 1            |
| The Smiths, The Queen Is Dead        | 1            |
| The Sounds, Crossing the Rubicon     | 2            |
| Blondie, Pollinator                  | 1            |
| The Sounds, Dying to Say This to You | 1            |
+--------------------------------------+--------------+
```



