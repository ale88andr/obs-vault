## Типы данных

Типы данных играют ключевую роль в определении правил хранения и представления информации. Есть несколько причин, почему их использование является необходимым:

- **Ограничение диапазона данных.** Типы данных позволяют определить, какие значения могут быть сохранены в определенных полях. Например, числовые поля могут принимать только числовые значения, что исключает возможность хранения текста в этих полях.
- **Эффективное управление хранением данных.** Использование различных типов данных позволяет более компактно хранить информацию. Например, числовые значения и дата/время могут быть сохранены в более оптимизированном формате по сравнению со строковыми.
- **Сортировка данных.** Множество типов данных позволяет определить собственные правила сравнения для каждого типа. Например, строковые значения сравниваются лексикографически, причем сравнение происходит посимвольно.

При проектировании таблиц необходимо обращать особое внимание на используемые типы данных. Некорректные типы данных могут существенно замедлить работу базы данных, а их изменение для уже имеющихся и заполненных полей может привести к потере данных.

## Строковые типы данных

**Строковые типы данных** используются чаще всего. Значения, принадлежащие этим типам, обычно называют **строками**. К ним относятся хранимые в базах данных имена людей, их фамилии, названия городов и любая подобная текстовая информация.

Строки бывают двух видов: **фиксированной** и **переменной** длины.

> Несмотря на то, что строки переменной длины обладают большей гибкостью и хранят столько символов, сколько необходимо, СУБД манипулирует строками фиксированной длины намного быстрее.

Существуют два основных строковых типа данных — `CHAR` и `VARCHAR`:

- `CHAR(n)`, где `n` – число в диапазоне `[0; 255]`, представляющее допустимую длину строки. Хранит строку **фиксированной** длины, которая задается на этапе создания таблицы. Если строка имеет длину меньше, чем `n`, то оставшиеся символы заполняются пробелами.
- `VARCHAR(n)`, где `n` – число в диапазоне `[0; 65535]`, представляющее допустимую длину строки. Хранит строку **переменной** длины, которая также задается на этапе создания таблицы. В отличие от `CHAR`, строка не заполняется пробелами, если ее длина меньше, чем `n`.

В отличие от типов данных `CHAR(n)` и `VARCHAR(n)`, где мы указываем максимальную длину строки (значение `n`), мы также можем использовать следующие типы данных:

| **Тип**      | **Размер (в байтах)** | **Максимальное количество символов** |
| ------------ | --------------------- | ------------------------------------ |
| `TINYTEXT`   | `255`                 | `255`                                |
| `TEXT`       | `65535`               | `2^16 - 1`                           |
| `MEDIUMTEXT` | `16777215`            | `2^24 - 1`                           |
| `LONGTEXT`   | `4294967295`          | `2^32 - 1`                           |

Для этих типов не указывается максимальная длина, она ограничивается только самим типом данных.
### Целые числа

**Целые числа** хранят только числа без дробной части. Они делятся на числа со знаком (**signed)** и числа без знака (**unsigned)**. Типы signed позволяют хранить как положительные, так и отрицательные значения, а типы unsigned хранят только положительные числа, но поддерживают больший диапазон значений.

| **Тип**     | **Размер (в байтах)** | **Диапазон signed** | **Диапазон unsigned** |
| ----------- | --------------------- | ------------------- | --------------------- |
| `TINYINT`   | `1`                   | `[-128; 127]`       | `[0; 255]`            |
| `SMALLINT`  | `2`                   | `[-2^15; 2^15 - 1]` | `[0; 2^16 - 1]`       |
| `MEDIUMINT` | `3`                   | `[-2^23; 2^23 - 1]` | `[0; 2^24 - 1]`       |
| `INT`       | `4`                   | `[-2^31; 2^31 - 1]` | `[0; 2^32 - 1]`       |
| `BIGINT`    | `8`                   | `[-2^63; 2^63 - 1]` | `[0; 2^64 - 1]`       |
### **Числа с плавающей точкой**

**Числа с плавающей точкой** хранят приблизительные значения. Они не резервируют определенное количество бит для целочисленной или дробной частей, поэтому у всех значений в таблице количество цифр до и после запятой будет разным.

| **Тип**  | **Размер (в байтах)** | **Диапазон**                    |
| -------- | --------------------- | ------------------------------- |
| `FLOAT`  | `4`                   | `[1.17 * 10^-38; 3.4 * 10^38]`  |
| `DOUBLE` | `8`                   | `[2.2 * 10^-308; 1.7 * 10^308]` |
### Числа с фиксированной точкой

**Числа с фиксированной точкой** используются для сохранения заданной точности. Такие числа резервируют определенное количество бит для целочисленной и дробной частей. Независимо от того, насколько большое или маленькое число, оно всегда будет использовать одно и то же количество бит для сохранения каждой части.

> Числа с фиксированной точкой необходимы в случаях, когда важна точность, например, при работе с денежными средствами или научными и инженерными вычислениями.

В MySQL для хранения чисел с фиксированной точкой используются типы `DECIMAL(M, D)` и `NUMERIC(M, D)`. Эти типы являются синонимами, поэтому можно использовать любой из них. Диапазон значений задается параметрами `M` и `D`, где `M` – общее количество цифр, `D` – количество цифр, используемое для дробной части. Значение параметра `M` ограничено диапазоном `[1; 65]`.

Например, `DECIMAL(5, 2)` означает, что в поле могут храниться числа, имеющие максимум `5` цифр, причем `2` из них отведены под десятичную часть. Другими словами, в этом поле могут храниться значения в диапазоне `[-999.99; 999.99]`.
## Типы данных даты и времени

Все СУБД поддерживают типы данных, предназначенные для хранения значений даты и времени. Аналогично числовым типам, в большинстве СУБД имеется несколько типов данных даты и времени, каждый из которых имеет свой диапазон.

К основным типам данных даты и времени относятся:

| **Тип**     | **Формат**            | **Диапазон значений**                       | **Размер (в байтах)** |
| ----------- | --------------------- | ------------------------------------------- | --------------------- |
| `DATE`      | `YYYY-MM-DD`          | `1000-01-01 – 9999-12-31`                   | `3`                   |
| `TIME`      | `HH:MM:SS`            | `00:00:00 – 23:59:59`                       | `3`                   |
| `DATETIME`  | `YYYY-MM-DD HH:MM:SS` | `1000-01-01 00:00:00 – 9999-12-31 23:59:59` | `8`                   |
| `TIMESTAMP` | `YYYY-MM-DD HH:MM:SS` | `1970-01-01 00:00:00 – 2038-01-19 03:14:07` | `4`                   |
| `YEAR`      | `YYYY`                | `1901 – 2155`                               | `1`                   |
### Типы данных DATETIME и TIMESTAMP

На первый взгляд типы `DATETIME` и `TIMESTAMP` очень похожи. Они предназначены для хранения даты и времени и имеют одинаковый формат. Но у них есть ряд отличий, с помощью которых можно определить, какой из этих типов следует использовать.

`DATETIME` хранит значения от `1000-01-01 00:00:00` до `9999-12-31 23:59:59` включительно и не зависит от временной зоны. Он всегда отображается ровно в таком виде, в котором был установлен и в котором хранится в базе данных. Другими словами, при изменении часового пояса отображение времени не изменится.

`TIMESTAMP` хранит информацию о том, сколько прошло секунд с начала эпохи, то есть с `1970-01-01 00:00:00`. При создании записи в поле, использующем этот тип данных, значение сохраняется по **нулевому** часовому поясу, а при выборке из базы данных отображается с учетом **текущего** часового пояса, который задается в настройках операционной системы, где работает MySQL, в глобальных настройках MySQL или в конкретной сессии.
## Тип данных NULL

Тип данных `NULL` — это специальное значение, которое используется в MySQL для обозначения отсутствия данных. Оно отличается от пустой строки или нулевого значения, так как в действительности означает полное отсутствие данных, в то время как ноль является допустимым числовым значением, а пустая строка — допустимой строкой нулевой длины.

## Оператор SELECT

Задачи, которые обычно приходится выполнять с базой данных, чаще всего сводятся к извлечению из нее необходимой информации. За все подобные задачи, связанные с извлечением данных, отвечает всего один оператор — `SELECT`.

> Операторы нечувствительны к регистру, поэтому, например, записи `SELECT, select` и `Select` эквивалентны. Чаще всего разработчики применяют верхний регистр для операторов и нижний регистр для имен полей.

Для извлечения нескольких полей таблицы после оператора `SELECT` необходимо через запятую перечислить их имена.

```sql
SELECT trackname, artist, streams
FROM Songs;
```

Следует заметить, что поля возвращаются именно в том порядке, в котором они указываются в самом запросе.

Помимо извлечения конкретных полей, с помощью оператора `SELECT` можно запросить все поля, не указывая каждое из них. Для этого вместо имен полей следует указать специальный групповой символ `*`.

Чтобы извлечь только уникальные записи, необходимо воспользоваться ключевым словом `DISTINCT`, которое указывается непосредственно перед именами полей.

```sql
SELECT DISTINCT trackname, artist FROM Songs;
```

ключевое слово `DISTINCT` применяется ко всем полям, а не только к тому, перед которым оно стоит, поэтому при его использовании для двух и более полей одинаковыми будут считаться лишь те записи, которые имеют одинаковые значения по всем полям.

#### Ограничение результатов запроса

Иногда при извлечении данных из таблицы может потребоваться получить лишь первую запись или некоторое определенное количество записей. Сделать это можно с помощью ключевого слова `LIMIT`.

```sql
SELECT trackname
FROM Songs
LIMIT 3;
```

Если необходимо получить следующие три записи, можно задать начальную точку извлечения с помощью ключевого слова `OFFSET`.

```sql
SELECT trackname
FROM Songs
LIMIT 3
OFFSET 2;
```

Выражение `LIMIT 3 OFFSET 2` говорит о том, что должно быть извлечено три записи, начиная с записи с индексом два. Таким образом, первое число — это количество строк для извлечения, а второе — начальная точка.

> Записи при использовании ключевого слова `OFFSET` индексируются с нуля
#### Псевдонимы

При извлечении различных полей таблицы они сохраняют свои исходные имена в результирующей таблице, однако при необходимости можно воспользоваться **псевдонимами**, чтобы дать им альтернативные имена. Делается это с помощью ключевого слова `AS`, которое располагается между исходным именем поля и новым.

```sql
SELECT trackname AS 'Song name',
       artist AS Artist
FROM Songs;
```

> если псевдоним состоит из нескольких слов, он должен быть представлен строкой, заключенной в апострофы.
#### Комментарии

Как и многие другие языки, SQL поддерживает несколько видов комментариев: однострочные и многострочные. Однострочные комментарии обозначаются двумя дефисами (`--`):

```sql
-- это комментарий

SELECT trackname    -- это комментарий
FROM Songs;
```

Многострочные комментарии обрамляются сочетанием символов `/*`:

```sql
/* это
многострочный
комментарий */

SELECT trackname
FROM Songs;
```
## Сортировка данных

#### Оператор ORDER BY

Чтобы извлечь информацию из базы данных в отсортированном виде, достаточно дополнить запрос оператором `ORDER BY` и указать название поля, по которому необходимо осуществить сортировку.

```sql
SELECT artist, trackname, release_date
FROM Songs
ORDER BY release_date;
```

> по умолчанию оператор `ORDER BY` выполняет сортировку именно по возрастанию.
#### Сортировка по нескольким полям

Часто сортировки лишь по одному полю бывает недостаточно, поскольку несколько записей могут содержать одно и то же значение в том поле, по которому выполняется сортировка. Чтобы выполнить сортировку по нескольким полям, нужно перечислить их через запятую.

```sql
SELECT artist, trackname, streams
FROM Songs
ORDER BY artist, streams;
```

Запрос выше выполняет сортировку сначала по полю `artist`, затем по полю `streams`. Если какие-либо две записи имеют разные значения в поле `artist`, они сортируются согласно этим значениям. Если какие-либо две записи имеют одинаковые значения в поле `artist`, они сортируются согласно значениям в поле `streams`.
#### Сортировка по положению поля

Вместо имен полей оператор `ORDER BY` позволяет указывать порядковые номера полей, по которым необходимо выполнить сортировку. Однако сортировка таким методом возможна только по тем полям, которые присутствуют в результирующей таблице. Нумеруются поля с единицы: первое поле результирующей таблицы имеет порядковый номер `1`, второе — `2` и так далее.

```sql
SELECT artist, trackname, streams
FROM Songs
ORDER BY artist, streams;
```

можно переписать следующим образом:

```sql
SELECT artist, trackname, streams
FROM Songs
ORDER BY 1, 3;
```
#### Указание направления сортировки

Сортировать данные можно не только по возрастанию, но и по убыванию. Чтобы сортировка выполнялась в порядке убывания, необходимо после имени поля указать ключевое слово `DESC`.

```sql
SELECT place, trackname
FROM Songs
ORDER BY place DESC;
```

> Важной особенностью ключевого слова `DESC` является то, что оно применяется только к тому полю, после которого стоит. Это необходимо учитывать, когда сортировка выполняется по нескольким полям.

## Фильтрация данных

#### Оператор WHERE

В таблицах баз данных обычно содержится очень много информации, и необходимость извлекать все записи из таблицы возникает довольно редко. Гораздо чаще требуется извлечь лишь некоторую их часть. Для этого используется оператор `WHERE`, который позволяет указывать определенные условия при извлечении записей. Если запись удовлетворяет этим условиям, то она попадает в результирующую таблицу, в противном случае отбрасывается.

```sql
SELECT *
FROM Songs
WHERE artist = 'The Sounds';
```

Также в примере выше следует обратить внимание на расположение оператора `WHERE` в запросе: он указывается после названия таблицы. Также оператор `WHERE` может использоваться совместно с оператором `ORDER BY`, в таком случае оператор `ORDER BY` должен располагаться после оператора `WHERE`.

#### Операторы сравнения

Условие после оператора `WHERE` может являться не только проверкой на равенство. В SQL поддерживается целый набор операторов сравнения, которые перечислены в таблице ниже:

| **Оператор**  | **Проверка**         |
| ------------- | -------------------- |
| `=`           | Равенство            |
| `<=>`         | Эквивалентность      |
| `!=` или `<>` | Неравенство          |
| `<`           | Меньше               |
| `<=`          | Меньше или равно     |
| `>`           | Больше               |
| `>=`          | Больше или равно     |
| `BETWEEN`     | Вхождение в диапазон |
| `IS NULL`     | Значение `NULL`      |
| `IS NOT NULL` | Не значение `NULL`   |
> Фильтрация данных может выполняться после извлечения на уровне приложения, работающего с этими данными. Но такой метод обычно не приветствуется, так как базы данных оптимизированы для быстрой и эффективной фильтрации, и выполнение приложением функций базы данных приведет к значительному снижению его производительности.

> результатом сравнения любого значения с `NULL` является `NULL`.

По умолчанию операторы сравнения не учитывают регистр при сравнении строковых значений.

Результатом приведенного ниже запроса:

```sql
SELECT 'bee' = 'Bee',
       'bee' <=> 'Bee',
       'bee' > 'Bee',
       'bee' < 'Bee';
```

является:

```no-highlight
+---------------+-----------------+---------------+---------------+
| 'bee' = 'Bee' | 'bee' <=> 'Bee' | 'bee' > 'Bee' | 'bee' < 'Bee' |
+---------------+-----------------+---------------+---------------+
| 1             | 1               | 0             | 0             |
+---------------+-----------------+---------------+---------------+
```

Для учета регистра необходимо преобразовать одну из сравниваемых строк в тип данных `BINARY` с помощью функций `CAST()` или `CONVERT()`. `BINARY` — это строковый тип данных аналогичный типу `CHAR` за исключением того, что он хранит строки в двоичном виде.

Результатом приведенного ниже запроса:

```sql
SELECT CAST('bee' AS BINARY) = 'Bee' AS `'bee' = Bee'`,
       CAST('Bee' AS BINARY) = 'Bee' AS `'Bee' = Bee'`,
       CAST('bee' AS BINARY) <=> 'Bee' AS `'bee' <=> Bee'`,
       CONVERT('bee', BINARY) > 'Bee' AS `'bee' > Bee'`,
       CONVERT('bee', BINARY) < 'Bee' AS `'bee' < Bee'`;
```

является:

```no-highlight
+--------------+--------------+----------------+--------------+--------------+
| 'bee' = Bee' | 'Bee' = Bee' | 'bee' <=> Bee' | 'bee' > Bee' | 'bee' < Bee' |
+--------------+--------------+----------------+--------------+--------------+
| 0            | 1            | 0              | 1            | 0            |
+--------------+--------------+----------------+--------------+--------------+
```

Оператор  `LIMIT`  при его использовании совместно с оператором  `WHERE`  или сочетанием операторов `WHERE` и `ORDER BY` должен располагаться после них.

```sql
SELECT place, trackname, artist
FROM Songs
WHERE place <= 4
ORDER BY place
LIMIT 2;
```

Это связано с порядком, в котором запрос выполняет свои операции: сначала запрос извлекает из таблицы записи, удовлетворяющие заданным условиям, затем сортирует и только после этого ограничивает определенным количеством.
#### Операторы AND и OR

Фильтрация данных при их извлечении не ограничивается лишь одним критерием. В SQL, как и во многих других языках программирования, можно использовать несколько условий, чтобы создавать более сложные фильтры. Для этого предназначены логические операторы `AND` и `OR`.
#### Оператор AND

Чтобы отфильтровать данные по нескольким полям, необходимо воспользоваться оператором `AND`. Он используется для извлечения только тех записей, которые удовлетворяют **всем** указанным условиям.

```sql
SELECT trackname, artist, streams, release_date
FROM Songs
WHERE streams > 50000 AND release_date >= '2000-01-01';
```
#### Оператор OR

Действие оператора `OR` противоположно действию оператора `AND`. Он говорит о том, что должны быть извлечены только те записи, которые удовлетворяют **хотя бы одному** условию.

```sql
SELECT trackname, artist
FROM Songs
WHERE artist = 'Heart' OR artist = 'Kate Bush';
```

> В большинстве СУБД при использовании оператора `OR` второе условие не рассматривается, если выполняется первое.

#### Порядок обработки операторов

После оператора `WHERE` может содержаться любое количество логических операторов `AND` и `OR`. Комбинируя их, можно создавать сложные фильтры. Однако при комбинировании операторов `AND` и `OR` возникает одна проблема. Для ее понимания рассмотрим запрос, который, как кажется на первый взгляд, извлекает данные о песнях, исполнителями которых являются `The Sounds` или `Kate Bush` и количество прослушиваний которых превышает `50000`.

```sql
SELECT trackname, artist, streams
FROM Songs
WHERE artist = 'The Sounds' OR artist = 'Kate Bush' AND streams > 50000;
```

Чтобы составить корректный запрос, необходимо воспользоваться скобками и точно сгруппировать необходимые условия. В нашем случае в скобки нужно заключить часть условия с оператором `OR`, чтобы она имела больший приоритет и выполнялась первой. 

```sql
SELECT trackname, artist, streams
FROM Songs
WHERE (artist = 'The Sounds' OR artist = 'Kate Bush') AND streams > 50000;
```
#### Оператор IN

Оператор `IN` позволяет определить, совпадает ли значение поля с одним из перечисленных значений.

```sql
SELECT trackname, artist
FROM Songs
WHERE artist IN ('Heart', 'Kate Bush', 'Morrissey');
```

Можно предположить, что оператор `IN` выполняет ту же функцию, что и логический оператор `OR`, и это действительно так. Приведенный выше запрос равносилен следующему запросу:

```sql
SELECT trackname, artist
FROM Songs
WHERE artist = 'Heart' OR artist = 'Kate Bush' OR artist = 'Morrissey';
```

Однако оператор `IN` имеет некоторое преимущество перед оператором `OR`. Например, при работе с большим количеством значений синтаксис логического оператора `IN` гораздо понятнее. Также при использовании оператора `IN` совместно с операторами `AND` и `OR` намного легче управлять порядком их обработки.
#### Оператор NOT

Логический оператор `NOT` служит только одной цели — отрицать условие, следующее за ним. Например, с помощью данного оператора мы можем извлечь данные о тех песнях, исполнителем которых не является группа `The Sounds`.

```sql
SELECT trackname, artist
FROM Songs
WHERE NOT artist = 'The Sounds';
```

> Логический оператор `NOT` отрицает только то условие, перед которым указан.
#### Оператор NOT IN

Связка операторов `NOT` и `IN` хоть и довольно полезна, но недостаточно наглядна. На практике для определения несоответствия списку значений используется более очевидный оператор `NOT IN`, выполняющий ровно то же, что и связка операторов `NOT` и `IN`.

```sql
SELECT trackname, artist
FROM Songs
WHERE artist NOT IN ('Heart', 'Kate Bush', 'Morrissey');
```

Логические операторы `AND, OR, NOT, IN` и `NOT IN` имеют разный приоритет. В таблице ниже они представлены в порядке уменьшения их приоритета:

| **Оператор**  |
| ------------- |
| `IN , NOT IN` |
| `NOT`         |
| `AND`         |
| `OR`          |
#### Метасимволы и оператор LIKE

Операторы сравнения (`=, >, BETWEEN` и другие) позволяют достаточно точно фильтровать данные, однако они несколько ограничены в своем функционале, так как выполняют фильтрацию по известным значениям. Например, если бы нам было необходимо среди множества музыкальных исполнителей отыскать только тех, названия которых начинаются с последовательности символов `The`, с помощью обычных операторов сравнения мы бы это сделать не смогли. Для подобных случаев предусмотрен поиск с использованием **метасимволов**, которые позволяют создавать **шаблоны поиска** и находить значения, соответствующие не чему-либо конкретному, а именно этим шаблонам.

Метасимволы сами по себе являются специальными знаками, которые трактуются языком особым образом. Чтобы использовать их в условиях отбора записей, необходимо задействовать оператор `LIKE`, который говорит о том, что следующий шаблон поиска необходимо анализировать с учетом метасимволов, а не искать точные совпадения.

> Шаблоны поиска представляют собой строки, состоящие из обычных символов, метасимволов или любой их комбинации, поэтому поиск с использованием метасимволов может осуществляться только в строковых полях.

#### Метасимвол %

Наиболее часто используемым метасимволом является знак процента (`%`), который в шаблоне поиска соответствует последовательности любых символов, причем число символов в последовательности может быть от `0` и более. Например, чтобы найти информацию о песнях, названия исполнителей которых начинаются с последовательности символов `The`, можно составить следующий шаблон поиска: `The%`.

```sql
SELECT trackname, artist
FROM Songs
WHERE artist LIKE 'The%';
```

`The%` соответствует как строкам `The Smiths` и `The Sounds`, так и строке `Theredsunband`. Если бы требовалось получить информацию лишь о тех песнях, названия исполнителей которых начинаются с артикля `The`, шаблон поиска было бы необходимо дополнить символом пробела `'The %'`.

Метасимволы могут встречаться в любом месте шаблона поиска, причем в неограниченном количестве. Например, c помощью шаблона `%You%` можно отыскать информацию о песнях, названия которых включают слово `You`.

#### Метасимвол _

Еще одним полезным метасимволом является знак нижнего подчеркивания (`_`), который в шаблоне поиска соответствует одному любому символу. Например, с его помощью можно составить запрос, который поможет отыскать информацию о песнях, названия которых начинаются с какого-либо четырехсимвольного слова.

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE '____ %';
```

#### Регистрозависимость

Важной особенностью оператора `LIKE` является то, что при поиске с его помощью строк, соответствующих шаблону, не учитывается регистр символов, используемых в этом шаблоне. Например, один из рассмотренных нами шаблонов поиска `%You%` мы могли записать в виде `%you%` или `%YOU%`, и результат остался бы прежним.

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE '%you%';
```

Безусловно, такое поведение удобно, однако не всегда нужно. Поэтому в случаях, когда регистр символов важен, шаблон поиска необходимо преобразовать в тип данных `BINARY` с помощью функций `CAST()` или `CONVERT()`.

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE CAST('%You%' AS BINARY);
```

> Метасимволы — очень мощный механизм. Но за эту мощь приходится платить, так как на поиск с использованием метасимволов уходит больше времени, чем на любые другие виды поиска. Поэтому если можно использовать другой оператор поиска, то следует задействовать именно его.

### Вычисляемые поля

Данные, хранимые в таблицах базы данных, часто бывают представлены не в том виде, в котором они необходимы. Например, в таблице, хранящей персональные данные людей, имя и фамилия человека могут находиться в разных полях, однако нам может потребоваться указать их в одном поле. 

Если встает задача получения информации, которая не хранится в базе данных в явном виде, однако может быть получена путем различных манипуляций. Для решения подобной задачи используются **вычисляемые поля** — поля, значения которых не хранятся в таблице базы данных, а вычисляются автоматически на основе данных из других полей таблицы. Вычисляемые поля используются для извлечения информации с дополнительными преобразованиями, подсчетами или форматированием.

Вычисляемые поля определяются с использованием выражений, которые могут включать математические операции и вызовы различных функций. И если математические операции знакомы практически всем, то функции у неопытных студентов могут вызвать трудности.
#### Объединение значений полей

Наиболее простым примером вычисляемого поля является поле, которое содержит объединение значений из нескольких полей таблицы.

В SQL для объединения нескольких значений используется функция `CONCAT()`. Она принимает переменное количество аргументов, выполняет их конкатенацию и возвращает полученный результат. Результатом функции `CONCAT()` всегда является строка, однако аргументы функции могут принадлежать любым типам, поскольку функция неявно преобразует все аргументы в строки перед объединением.

```sql
SELECT CONCAT(artist, ' - ', trackname)
FROM Songs;
```

```no-highlight
+----------------------------------+
| CONCAT(artist, ' - ', trackname) |
+----------------------------------+
| Heart - Crazy On You             |
| The Sounds - My Lover            |
| Kate Bush - Running up That Hill |
| The Sounds - Thrill              |
| Morrissey - Spent the Day in Bed |
+----------------------------------+
```

Именовать вычисляемые поля полезно не только для улучшения внешнего вида результирующей таблицы, но и для возможности удобно обращаться к ним в рамках запроса, например, во время сортировки записей.

```sql
SELECT CONCAT(artist, ' - ', trackname) as song
FROM Songs
ORDER BY song DESC;
```

является:

```no-highlight
+----------------------------------+
| song                             |
+----------------------------------+
| The Sounds - Thrill              |
| The Sounds - My Lover            |
| Morrissey - Spent the Day in Bed |
| Kate Bush - Running up That Hill |
| Heart - Crazy On You             |
+----------------------------------+
```

>  Если хотя бы один из аргументов, переданных в функцию `CONCAT()`, равняется `NULL`, функция вернет значение `NULL`.
#### Функция CONCAT_WS()

Для конкатенации значений в SQL существует дополнительная функция — `CONCAT_WS()`. В отличие от функции `CONCAT()`, она не только объединяет значения, но и добавляет между ними разделитель. Разделитель указывается в качестве первого аргумента, объединяемые значения — в качестве всех остальных.

```sql
SELECT CONCAT_WS(', ', id, artist, trackname) AS song
FROM Songs;
```

является:

```no-highlight
+------------------------------------+
| song                               |
+------------------------------------+
| 1, Heart, Crazy On You             |
| 2, The Sounds, My Lover            |
| 3, Kate Bush, Running up That Hill |
| 4, The Sounds, Thrill              |
| 5, Morrissey, Spent the Day in Bed |
+------------------------------------+
```

> Функция `CONCAT_WS()`, как и функция `CONCAT()`, умеет работать с аргументами любых типов, поскольку перед объединением неявно преобразует все аргументы в строки.

> Если одно из объединяемых значений, переданных в функцию `CONCAT_WS()`, равняется `NULL`, при объединении оно будет проигнорировано.

#### Выполнение математических вычислений

C помощью вычисляемых полей можно решать задачи, требующие выполнения математических операций над извлекаемыми данными. 

```sql
SELECT artist, trackname,
       price * quantity AS revenue
FROM Songs;
```

> В SQL поддерживаются основные математические операторы: `+` (сложение), `-` (вычитание), `*` (умножение) и `/` (деление). Для управления порядком обработки операторов можно использовать круглые скобки.



