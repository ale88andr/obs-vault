В рамках одного запроса данные из таблицы могут извлекаться несколько раз, и для выполнения таких вспомогательных операций извлечения используются **подзапросы**.

**Подзапрос** — это запрос, вложенный в другой запрос. Подзапрос всегда заключен в круглые скобки и обычно выполняется перед основным запросом. Подзапросы являются обычными запросами, и для них не предусмотрен какой-либо отдельный синтаксис, поэтому для составления подзапросов достаточно уметь составлять обычные запросы.

### Подзапросы с одним полем и одной записью

```sql
SELECT *
FROM Books
WHERE price > (SELECT AVG(price)
               FROM Books);
```

Здесь в условии фильтрации значение поля `price` сравнивается с результатом подзапроса. Подзапрос обращается к таблице `Books` и вычисляет среднее арифметическое всех значений ее поля `price`. Таблица, получаемая в результате подзапроса, состоит из одной записи и одного поля, то есть содержит единственное значение, с которым и происходит последующее сравнение значения поля `price`.

Подзапросы могут использоваться не только для фильтрации записей, но и для фильтрации групп.

```sql
SELECT author, AVG(price) AS avg_price
FROM Books
GROUP BY author
HAVING AVG(price) > (SELECT AVG(price)
                     FROM Books);
```
### Подзапросы с одним полем и несколькими записями

Как было сказано выше, сравнение одиночного значения с таблицей возможно только в том случае, если эта таблица состоит из одного поля и одной записи, то есть содержит единственное значение. Однако с помощью ключевых слов `ALL` и `ANY` можно выполнять сравнение с таблицей, содержащей одно поле и произвольное количество записей, то есть сравнивать одиночное значение с набором значений.

#### Ключевое слово ALL

При использовании ключевого слова `ALL` условие в операции сравнения должно быть истинно для всех значений, которые возвращаются подзапросом. Например, с помощью данного ключевого слова мы можем составить запрос, извлекающий данные о книгах, цена которых больше, чем у каждой книги за авторством `Chuck Palahniuk`.

```sql
SELECT title, author, price
FROM Books
WHERE price > ALL (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```

В данном примере подзапрос возвращает таблицу, состоящую из одного поля `price` и нескольких записей. Сравнение значения поля `price` с этой таблицей выполняется путем его последовательного сравнения с каждым значением таблицы. Если результатом всех операций сравнения является истина, запись попадает в результирующую таблицу, если же хотя бы один результат является ложным, запись отбрасывается.
#### Ключевое слово ANY

При использовании ключевого слова `ANY` условие в операции сравнения должно быть истинно хотя бы для одного из значений, которые возвращаются подзапросом.

```sql
SELECT title, author, price
FROM Books
WHERE price < ANY (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```

Сравнение значения поля `price` с этой таблицей выполняется путем его последовательного сравнения с каждым значением таблицы. Если результатом хотя бы одной операции сравнения является истина, запись попадает в результирующую таблицу, если же все результаты являются ложными, запись отбрасывается.

> Так как результатом подзапроса является таблица, она может быть указана после ключевого слова `FROM`. В таком случае основной запрос будет работать с той таблицей, которую вернул подзапрос.

> Если результатом подзапроса является пустая таблица, она приравнивается к значению `NULL`.
#### Некоррелированные подзапросы

Подзапросы, рассмотренные выше, были независимыми. Они могли выполняться автономно от основного запроса, и перед тем как их результат будет использоваться в основном запросе, мы могли посмотреть, что они возвращают. Такие подзапросы называются **некоррелированными**.

> В некоррелированных запросах - результат остается неизменным во время выполнения всего основного запроса.

Если какой-либо запрос включает в себя некоррелированный подзапрос. Перед тем как приступить к выполнению основного запроса, СУБД единожды определяет результат подзапроса, а затем лишь использует его. Таким образом, обработка запроса, содержащего некоррелированный подзапрос, происходит в два этапа:
1. выполняется подзапрос, определяется его результат
2. полностью выполняется основной запрос с использованием результата подзапроса
#### Коррелированные подзапросы

Несмотря на то что некоррелированный подзапрос является достаточно мощным инструментом, он может справиться не с любой задачей. Предположим, нам требуется написать запрос, извлекающий данные о книгах, пользовательская оценка которых больше, чем у предыдущей книги в таблице, то есть у книги с идентификатором на один меньше.

Схематически необходимый запрос мы можем показать следующим образом:

```sql
SELECT title, user_score
FROM Books
WHERE user_score > <оценка предыдущей книги>;
```

Проблема данной задачи заключается в том, что для ее решения нам необходимо, чтобы для каждой записи справа от знака `>` располагалось соответствующее именно ей значение (оценка книги с идентификатором на один меньше), а не какое-либо фиксированное значение.

Реализовать это можно с помощью **коррелированного** подзапроса. Он используется в том случае, когда для каждой записи, анализируемой основным запросом, подзапрос должен вернуть результат, зависящий от значений в этой записи. Иными словами, коррелированный подзапрос отвечает на вопрос, ответ на который зависит от обрабатываемой основным запросом записи.

С применением коррелированного подзапроса мы можем показать необходимый нам запрос более точно, однако по-прежнему схематически:

```sql
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books
                    WHERE <поле id внутренней таблицы> = <поле id внешней таблицы> - 1);
```

Проблема, возникающая на данном этапе проектирования запроса, связана с именованием полей. Поскольку коррелированный подзапрос, помимо значений полей собственной таблицы, использует значения полей таблицы, принадлежащей основному запросу, должна быть возможность различать эти поля, если они имеют одинаковые названия.

Для этого при обращении к полю явно указывают название таблицы, например, `Books.id` (поле `id` таблицы `Books`). Если и основной запрос, и подзапрос обращаются к одной и той же таблице, то одной из таблиц дают псевдоним.

Теперь мы можем показать окончательный вариант необходимого нам запроса:

```sql
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books AS InnerBooks
                    WHERE id = Books.id - 1);
```

Итак, основной запрос здесь извлекает записи из таблицы `Books`, а также фильтрует их с помощью подзапроса. Значение подзапроса не вычисляется единожды, а определяется для каждой рассматриваемой основным запросом записи отдельно, поскольку оно напрямую зависит от этой записи.

> Таким образом, коррелированный подзапрос выполняется для каждой записи отдельно (сперва для первой, затем для второй и так далее) и для каждой записи возвращает результат, полученный на основе ее значений.
#### Подзапросы с несколькими полями

При сравнении некоторого значения с результатом подзапроса требуется, чтобы этим результатом была таблица из одного поля и одной записи или из одного поля и нескольких записей. Однако SQL позволяет сравнивать не только одиночные значения, но и пары значений. В подобных случаях используются подзапросы, возвращающие таблицы из нескольких полей.

```sql
SELECT title, critic_score, user_score
FROM Books
WHERE (critic_score, user_score) = (SELECT MIN(critic_score), MIN(user_score)
                                    FROM Books);
```

> Если с результатом подзапроса сравнивается не одно поле, а несколько, эти поля должны быть заключены в скобки.

> Обращение к полю с явным указанием таблицы (например, `Books.id`) является лишь обращением по **полному имени**. Полные имена применяются в тех случаях, когда может возникнуть неопределенность в именовании полей, к примеру, когда поле подзапроса сравнивается с полем основного запроса и эти поля имеют одинаковые имена.

> Если таблице присвоен псевдоним, то и обращение к полям этой таблицы по полному имени должно происходить только с помощью данного псевдонима.

>  Использование коррелированных подзапросов может вызвать проблемы с производительностью, так как коррелированный подзапрос выполняется для каждой записи основного запроса отдельно.

### Подзапросы при работе с несколькими таблицами

```sql
SELECT COUNT(*) AS num_of_users
FROM BooksRental
WHERE book_id = (SELECT id
                 FROM Books
                 WHERE title = 'It');
```

> Некоррелированные подзапросы, если их несколько, всегда обрабатываются начиная с самого вложенного, то есть в направлении изнутри наружу.

