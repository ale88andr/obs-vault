
**Сервис** - определяет, что делает сетевой уровень

**Интерфейс** - определяет как использовать возможности сетевого уровня

**Протокол** - как сетевой уровень реализует возможности (набор правил)

**Архитектура сети** - набор уровней и протоколов (интерфейсы не входят в архитектуру)

**Стек протоколов** - иерархически организованный набор протоколов, достаточный для организации сетевого взаимодействия

**Инкапсуляция** - включение сообщения вышестоящего уровня в сообщение нижестоящего уровня

# 1. Модели сети

## 1.1 OSI

Модель взаимодействия открытых систем (Open System Interconnection Reference Model), где открытая система - это система построенная в соответствии с открытыми требованиями

![[Pasted image 20250507111734.png]]

1. **Физический уровень** (Physical layer) - Занимается передачей битов по физическому каналу связи (основная задача - передача потока бит без искажений в соответствии с заданной частотой)
2. **Канальный уровень** (Data Link layer) - Организовывает сетевое взаимодействие внутри одного сегмента сети. (задачи: управление доступом к среде передачи данных, установление логического соединения, согласование скоростей, надежная передача и коррекция ошибок)
3. **Сетевой уровень** (Network layer) - Служит для объединения нескольких сетей в крупную составную сеть. (задачи: адресация, определение маршрута отправки пакетов в составной сети, согласование характеристик сетей)
4. **Транспортный уровень** (Transport layer) - Обеспечивает передачу данных между процессами на устройствах с требуемым уровнем надежности. Сетенезависимый уровень (напрямую соединяются процессы которые находятся  на отправителе и получателе)
5. **Сеансовый уровень** (Session layer) - Позволяет устанавливать сеансы связи
6. **Уровень представления** (Presentation layer) - Обеспечивает согласование синтаксиса и семантики передаваемых данных (форматы представления символов, чисел и т.п.), а так же шифрование и дешифрование(`TLS`)
7. **Прикладной уровень** (Application layer)  - Используется пользовательскими приложениями для передачи запросов/данных

На практике модель не используется(применяется в качестве общего языка для описания и сопоставления различных коммуникационных сетей), а применяется модель и стек протоколов `TCP/IP`.

## 1.2 TCP/IP

![[Pasted image 20250506171636.png]]

1. **Уровень сетевых интерфейсов** (Link layer) - взаимодействие с сетями разных технологий. Объединяет **Физический** и **Канальный** уровень модели `OSI`.
2. **Уровень межсетевого взаимодействия** (Network layer) - Совпадает с **Сетевым** уровнем модели `OSI`
3. **Транспортный уровень** (Transport layer) - Совпадает с **Транспортным** уровнем модели `OSI`
4. **Прикладной уровень** (Application layer) - Объединяет **Сеансовый**, **Прикладной** и **Уровень представления** модели `OSI`.

`TCP/IP` широко используется на практике

## 1.3 Стандарты 

Цель стандартизации сетей - обеспечить возможность работать вместе оборудованию и ПО различных производителей.

Стандарты технологий передачи данных `IEEE`, рабочая группа `802`:
- `IEEE 802.11` - беспроводные сети Wi-Fi
- `IEEE 802.3` - проводные сети Ethernet
- `IEEE 802.15.1` - персональные сети Bluetooth
- `IEEE 802.15.4` - беспроводные сети интернета вещей
- `IEEE 802.16` - беспроводные сети WiMax

Группа проектирования Интернет `IETF` - выпускает документы с описанием сетевых протоколов (`RFC` - Request for comments):
- `RFC 2616` - протокол HTTP
- `RFC 793` - протокол TCP
- `RFC 791` - протокол IP
- `RFC 792` - протокол ICMP
- `RFC 826` - протокол ARP

## 1.4. Организация сетей TCP/IP

### 1.4.1 Уровень сетевых интерфейсов (Link layer)

Самая популярная технология проводной сети - `Ethernet` в ней используются коммутаторы, которые используют **физическую (аппаратную) адресацию** `MAC`, чтобы определить кому передавать данные.

`MAC` адреса:
- используются для идентификации узлов сети Wi-Fi и Ethernet
- регламентируются стандартом `IEEE 802`
- формат адреса `6` байт(`48` бит)
- форма записи `1C-75-08-D2-46-45` (`IEEE`), `1C-75-08-D2-46-45` (`EITF`)
- каждый сетевой адаптер имеет встроенный MAC адрес
- MAC адрес в сети должен быть уникальным

### 1.4.2 Уровень межсетевого взаимодействия (Network layer)

Объединение сетей(подсетей) построенных по разным технологиям (например, Ethernet и Wi-Fi) посредством добавления в сеть **маршрутизатора** (router).

Одна из важнейших задач уровня - это поиск маршрута в составной сети через промежуточные устройства сети(маршрутизаторы)

На этом уровне используются глобальные сетевые адреса:
- не привязаны к сетевой технологии
- используются для уникальной идентификации компьютера в составной сети

**IP-адреса**:
- глобальные сетевые адреса протоколов TCP\IP
- формат записи - 4 десятичных числа от 0 до 255
- IP-адреса должны быть уникальны во всем мире

Распределением IP-адресов в мире занимается `IANA`, за регион России отвечает региональный регистратор `IANA` - `RIPE`.

### 1.4.3 Транспортный уровень (Transport layer)

Транспортный уровень - обеспечивает взаимодействие процессов устройств по сети

Адресация на транспортном уровне осуществляется с помощью **портов** - идентификатор процесса ОС на устройстве

**Порты**:
- число в диапазоне от `1` до `65535`
- адрес процесса на транспортном уровне
- каждое сетевой приложение имеет свой порт
- номера портов у приложений не повторяются
- формат записи 192.168.1.1 `:8080`

**Типы портов**:
- Широко известные порты (well-known): от `0` до `1023`
- Зарегистрированные порты (registered): от `1024` до `4951`
- Динамические или частные (private): от `49152` до `65535`

именно с помощью номера порта ОС понимает для какого процесса(приложения) предназначен пакет.

Протоколы транспортного уровня:
1. `TCP` (`Transmission Control Protocol`) - получает поток байт, делит её на части, передавая её по сети и обеспечивает гарантию передачи до получателя в правильном порядке
	- обеспечивает надежную передачу потока байтов
	- протокол управления передачей
	- устанавливает сетевое соединение
2. `UDP` (`User Datagram Protocol`)
	- Протокол дейтаграмм(коротких сообщений) пользователя
	- обеспечивает ненадежную передачу коротких сообщений
	- соединение не устанавливается

Транспортный уровень - сетенезависимый уровень.

**Надежность на транспортном уровне**

Транспортный уровень может обеспечить надежность передачи данных выше, чем у сети в его основе

Гарантия доставки данных:
- Подтверждение получения;
- Повторная отправка не подтвержденных данных;
- Гарантия сохранения порядка следования сообщений;

Интерфейс транспортного уровня - **сокет** (`ip-адрес`:`порт`)
### 1.4.4 Прикладной уровень (Application layer)

Уровень взаимодействия сетевых приложений

На этом уровне работают протоколы совершающие обмен данными, ради которых строятся сети (`HTTP`, `HTTPS`, `DNS`, `SMTP` и т.д.)

Протоколы прикладного уровня не углубляются (изолированы) в то, как именно данные передаются по сети (как будто приложения на разных хостах передают данные напрямую друг другу)

### 1.4.5 Выводы

**Сетевое оборудование уровней TCP/IP**

| Уровень TCP/IP              | Сетевое оборудование                     |
| --------------------------- | ---------------------------------------- |
| Уровень сетевых интерфейсов | Точка доступа Wi-Fi, Ethernet коммутатор |
| Сетевой уровень             | Маршрутизатор                            |

**Адресация уровней TCP/IP**

| Уровень TCP/IP              | Адресация |
| --------------------------- | --------- |
| Уровень сетевых интерфейсов | МАС-адрес |
| Сетевой уровень             | IP-адрес  |
| Транспортный уровень        | Порт      |
| Уровень приложений*         | Протокол* |

## 1.5. Сетевой анализатор Wireshark

Главное окно программы

![[Pasted image 20250507104336.png]]

Пример передачи `HTTP` запроса на сервер `10.92.192.100:8000`:
- введем фильтр по протоколу `http` и найдем нужный пакет

![[Pasted image 20250507112539.png]]

- смотрим, что передается на разных уровнях `TCP/IP`

![[Pasted image 20250507113431.png]]

- смотрим как происходит инкапсуляция при передачи данных по сети:

Заголовок уровня сетевых интерфейсов
![[Pasted image 20250507113934.png]]
Заголовок уровня сети
![[Pasted image 20250507114108.png]]Заголовок транспортного уровня
![[Pasted image 20250507114146.png]]

### Понимание и применение базовых фильтров отображения

В этом шаге мы рассмотрим фильтры отображения (display filters) в Wireshark. Фильтры отображения — это важные инструменты для анализа сетевого трафика. Они помогают вам сосредоточиться на определенных типах пакетов, вместо того чтобы просматривать все захваченные данные.
#### Что такое фильтры отображения

При анализе сетевого трафика просмотр каждого захваченного пакета может быть утомительным. Обычно вы хотите сосредоточиться на определенных типах пакетов. Именно здесь на помощь приходят фильтры отображения Wireshark. Они позволяют отображать только те пакеты, которые соответствуют определенным критериям. Это делает процесс анализа намного более эффективным, поскольку вы не тратите время на нерелевантные данные.

Фильтры отображения в Wireshark используют специальный синтаксис. Этот синтаксис позволяет фильтровать пакеты на основе различных атрибутов, таких как протоколы, IP-адреса, порты и даже содержимое пакетов. Понимание этого синтаксиса является ключом к эффективному использованию фильтров отображения.

#### Панель фильтров (Filter Toolbar)

Взгляните на верхнюю часть окна Wireshark. Вы заметите текстовое поле. Оно может быть помечено как "Apply a display filter..." или просто показывать "Expression...". Это место, где вы будете вводить свои фильтры отображения. После ввода фильтра и нажатия Enter Wireshark будет использовать этот фильтр для отображения только релевантных пакетов.

![Wireshark Filter Toolbar Location](https://file.labex.io/namespace/33fa8aba-d546-42e9-9692-64968aeaf0cc/cybersecurity/ws_display_filters/lab-cyber-sleuthing-with-wiresharkfilters/assets/fig2.png)

#### Базовые фильтры протоколов (Basic Protocol Filters)

Начнем с простого примера. Предположим, вы хотите просмотреть только HTTP-трафик. HTTP — это протокол, используемый для просмотра веб-страниц. Для этого вы введете фильтр в панель фильтров. Введите следующий фильтр и нажмите Enter:

```plaintext
http
```

![Wireshark HTTP Filter Output](https://file.labex.io/namespace/33fa8aba-d546-42e9-9692-64968aeaf0cc/cybersecurity/ws_display_filters/lab-cyber-sleuthing-with-wiresharkfilters/assets/screenshot-20250325-hRfPO10R@2x.png)

После применения этого фильтра Wireshark будет отображать только HTTP-пакеты.

Теперь вывод должен показывать только пакеты, связанные с HTTP-трафиком. Обычно это включает веб-запросы (когда вы запрашиваете информацию с веб-сайта) и ответы (когда веб-сайт отправляет вам информацию). Если вы не видите HTTP-трафик в образце файла, вы можете попробовать другие протоколы, которые могут присутствовать, такие как TCP, UDP или DNS:

```plaintext
tcp
```
#### Фильтры IP-адресов (IP Address Filters)

После того, как вы определили IP-адрес, который часто встречается в вашем захвате (например, предположим, что вы видите `192.168.1.1`), вы можете использовать его для создания фильтра. Введите следующий фильтр в панель фильтров, чтобы увидеть только пакеты от этого источника:

```plaintext
ip.src == 192.168.3.131
```

![Wireshark IP Address Filter Example](https://file.labex.io/namespace/33fa8aba-d546-42e9-9692-64968aeaf0cc/cybersecurity/ws_display_filters/lab-cyber-sleuthing-with-wiresharkfilters/assets/screenshot-20250325-8KYCuqB9@2x.png)

Если вы хотите снова увидеть все пакеты, вы можете очистить текущий фильтр. Просто нажмите кнопку "Clear" (X) в правой части панели фильтров.

#### Фильтры портов (Port Filters)

Многие сетевые службы работают на определенных портах. Порт — это как дверь на устройстве, которая позволяет определенным типам сетевого трафика входить или выходить. Например, HTTP обычно использует порт 80. Чтобы отфильтровать пакеты по номеру порта, вы можете использовать следующий фильтр:

```plaintext
tcp.port == 80
```

Этот фильтр будет показывать как входящие, так и исходящие пакеты, использующие TCP-порт 80. Вы также можете попробовать другие распространенные порты, такие как 443 (HTTPS) или 53 (DNS), в зависимости от того, что доступно в вашем захвате.

#### Комбинирование фильтров (Combining Filters)

Вы можете сделать свои фильтры более мощными, комбинируя их с помощью логических операторов, таких как `and` (и) и `or` (или). Например, если вы хотите показывать только HTTP-трафик, использующий порт 80, вы можете использовать следующий фильтр:

```plaintext
http and tcp.port == 80
```

![Example of combined filter in Wireshark](https://file.labex.io/namespace/33fa8aba-d546-42e9-9692-64968aeaf0cc/cybersecurity/ws_display_filters/lab-cyber-sleuthing-with-wiresharkfilters/assets/screenshot-20250325-6gAynlHP@2x.png)

### Продвинутые методы фильтрации (Advanced Filtering Techniques)

В этом шаге мы рассмотрим, как создавать более сложные фильтры для детального анализа сетевого трафика. 
#### Сложные фильтры с несколькими условиями (Complex Filters with Multiple Conditions)

Wireshark дает вам возможность создавать сложные фильтры, объединяя несколько условий. Это очень полезно, когда вы хотите быть более точным в своем анализе трафика. Давайте начнем с создания фильтра для поиска HTTP GET-запросов.

```plaintext
http.request.method == "GET"
```

Этот фильтр предназначен для отображения только HTTP-пакетов, содержащих GET-запросы. 

Если ваш образец файла не содержит HTTP GET-запросов, попробуйте этот альтернативный фильтр для поиска TCP SYN-пакетов, которые указывают на попытки подключения:

```plaintext
tcp.flags.syn == 1
```

Теперь давайте сделаем наш фильтр более конкретным. Мы добавим условие порта.

```plaintext
tcp.port == 80 and http.request.method == "GET"
```

Этот новый фильтр показывает только HTTP GET-запросы, которые происходят на стандартном HTTP-порту (80). Стандартный HTTP-порт широко используется для незашифрованного веб-трафика. Добавляя это условие порта, мы сужаем наш поиск только до тех GET-запросов, которые используют типичный канал связи HTTP.
#### Фильтрация на основе размера пакета (Filtering Based on Packet Size)

Сетевые атаки часто включают пакеты с необычными размерами. Злоумышленники могут использовать большие или маленькие пакеты, чтобы скрыть вредоносные данные или нарушить нормальное функционирование сети. Чтобы фильтровать на основе размера пакета, мы используем определенный синтаксис.

```plaintext
tcp.len >= 100 and tcp.len <= 500
```

Этот фильтр отображает TCP-пакеты с длиной полезной нагрузки (payload length) от 100 до 500 байт. Вы можете настроить эти значения в соответствии со своими потребностями. Например, если вы подозреваете, что атака включает более крупные пакеты, вы можете увеличить верхний предел. Фильтруя на основе размера пакета, мы можем выявить аномальные модели трафика, которые могут указывать на атаку.
#### Фильтрация на основе определенного содержимого (Filtering Based on Specific Content)

Вы также можете фильтровать трафик на основе определенного содержимого внутри пакетов. Это очень полезно, когда вы ищете трафик, связанный с определенным веб-сайтом или службой. Например, давайте найдем HTTP-трафик, связанный с определенным веб-сайтом.

```plaintext
http.host contains "google"
```

![Wireshark HTTP Host Filter](https://file.labex.io/namespace/33fa8aba-d546-42e9-9692-64968aeaf0cc/cybersecurity/ws_display_filters/lab-cyber-sleuthing-with-wiresharkfilters/assets/screenshot-20250325-OVzlfftt@2x.png)

Этот фильтр показывает только HTTP-трафик, где заголовок host (host header) содержит "google". Вы можете заменить "google" любым доменом, который вам интересно проанализировать. Заголовок host в HTTP-запросе сообщает серверу, к какому веб-сайту пытается получить доступ клиент. Фильтруя на основе заголовка host, мы можем сосредоточиться на трафике, связанном с определенным доменом.
#### Использование оператора "contains" для поиска текста (Using the "contains" Operator for Text Searching)

Оператор `contains` — это удобный инструмент для поиска определенных текстовых строк в пакетах. Он позволяет нам искать определенные ключевые слова в данных пакета.

```plaintext
frame contains "password"
```

Этот фильтр показывает пакеты, содержащие слово "password" где-либо в данных пакета. Это может быть очень полезно для выявления возможных проблем с безопасностью. Например, если пароли отправляются в открытом виде (что является большим риском для безопасности), этот фильтр может помочь нам обнаружить эти пакеты.

Или попробуйте этот фильтр:

```plaintext
frame contains "login"
```

![Wireshark Password Filter Example](https://file.labex.io/namespace/33fa8aba-d546-42e9-9692-64968aeaf0cc/cybersecurity/ws_display_filters/lab-cyber-sleuthing-with-wiresharkfilters/assets/screenshot-20250325-yUC9MYu9@2x.png)

#### Отрицание фильтров (Negating Filters)

Иногда вам может потребоваться увидеть весь трафик, за исключением определенных типов. Именно здесь на помощь приходит оператор `not`.

```plaintext
not arp
```

Этот фильтр скрывает все ARP-пакеты. ARP (Address Resolution Protocol) используется для сопоставления IP-адресов с MAC-адресами в локальной сети. Иногда ARP-трафик может быть очень распространенным и может загромождать ваш анализ. Используя оператор `not`, мы можем исключить этот тип трафика и сосредоточиться на других, более релевантных пакетах.
#### Сохранение и применение закладок фильтров (Saving and Applying Filter Bookmarks)

Если вы часто используете определенные фильтры, вам не нужно вводить их каждый раз. Вы можете сохранить их в виде закладок. Вот как это сделать:

1. Введите фильтр в панель фильтров. Это место, где вы вводите выражения фильтров, которые мы изучали.
2. Нажмите кнопку "+" в правой части панели фильтров. Эта кнопка используется для сохранения текущего фильтра в качестве закладки.
3. Дайте своему фильтру имя и нажмите "OK". Название фильтра облегчает его идентификацию в дальнейшем.

После того, как вы сохранили свой фильтр, вы можете применить его, щелкнув его имя в раскрывающемся меню фильтров. Это экономит ваше время и усилия, особенно когда вы проводите повторный анализ.

### Анализ трафика, связанного с безопасностью (Analyzing Security-Related Traffic)

В этом шаге мы сосредоточимся на использовании фильтров Wireshark для анализа безопасности. Анализ безопасности имеет решающее значение в мире кибербезопасности, поскольку он помогает нам выявлять потенциально вредоносные действия в сетевом трафике. К концу этого раздела вы сможете идентифицировать различные типы угроз безопасности с помощью определенных фильтров Wireshark.
#### Выявление действий по сканированию портов (Identifying Port Scanning Activities)

Сканирование портов (port scanning) — это распространенный метод, используемый злоумышленниками для сбора информации о целевой системе. Злоумышленники используют его для поиска открытых портов в сети, которые затем можно использовать. Чтобы обнаружить потенциальное сканирование портов, мы ищем большое количество попыток подключения от одного источника к нескольким портам.

Давайте используем конкретный фильтр для выявления таких действий. Попробуйте этот фильтр в Wireshark:

```plaintext
tcp.flags.syn == 1 and tcp.flags.ack == 0
```

Этот фильтр показывает SYN-пакеты без флага ACK. В TCP-соединении SYN-пакет является первым, отправленным для инициирования соединения, а ACK-пакет используется для подтверждения соединения. Когда мы видим много SYN-пакетов без ACK от одного источника к разным портам назначения, это является сильным признаком сканирования портов.
#### Обнаружение подозрительного DNS-трафика (Detecting Suspicious DNS Traffic)

DNS-туннелирование (DNS tunneling) и другие атаки на основе DNS становятся все более распространенными. Эти атаки используют протокол DNS для сокрытия вредоносных действий, таких как эксфильтрация данных (data exfiltration) или связь команд и управления (command and control communication). Чтобы обнаружить такие атаки, нам нужно искать необычный DNS-трафик.

Используйте этот фильтр для изучения DNS-запросов:

```plaintext
dns
```

После применения этого фильтра ищите необычно длинные доменные имена или большой объем DNS-запросов к одному и тому же домену. Это могут быть признаки эксфильтрации данных или связи команд и управления.
#### Выявление попыток перебора паролей (Identifying Password Brute Force Attempts)

Атаки перебором паролей (password brute force attacks) — это распространенный способ для злоумышленников получить несанкционированный доступ к таким службам, как SSH или FTP. В атаке перебором злоумышленник пытается использовать несколько комбинаций паролей, пока не найдет правильный.

Чтобы обнаружить потенциальные попытки перебора паролей, мы можем отфильтровать неудачные попытки входа в систему. Используйте этот фильтр:

```plaintext
ftp contains "530" or ssh contains "Failed"
```

Этот фильтр показывает FTP- и SSH-пакеты, содержащие общие сообщения об ошибках. Если вы видите несколько сбоев от одного и того же источника, это может указывать на попытку перебора.
#### Анализ ответов об ошибках HTTP (Analyzing HTTP Error Responses)

Атаки на веб-приложения часто генерируют ответы об ошибках HTTP. Злоумышленники могут попытаться использовать уязвимости в веб-приложениях, и эти попытки могут привести к ответам об ошибках от сервера.

Отфильтруйте эти ответы об ошибках с помощью:

```plaintext
http.response.code >= 400
```

Этот фильтр показывает пакеты HTTP-ответов с кодами состояния 400 или выше. Все эти коды состояния представляют ответы об ошибках. Изучая эти пакеты, мы можем выявить попытки использования веб-уязвимостей.
#### Поиск учетных данных в открытом виде (Finding Clear-Text Credentials)

Передача учетных данных в открытом виде (clear text) является серьезным риском для безопасности. Если злоумышленник перехватит эти учетные данные, он может получить несанкционированный доступ к системе.

Чтобы обнаружить учетные данные в открытом виде, используйте этот фильтр:

```plaintext
http contains "user" or http contains "pass" or http contains "login"
```

![Wireshark Clear-Text Cred Filter](https://file.labex.io/namespace/33fa8aba-d546-42e9-9692-64968aeaf0cc/cybersecurity/ws_display_filters/lab-cyber-sleuthing-with-wiresharkfilters/assets/screenshot-20250325-BLx7Lahp@2x.png)

Этот фильтр помогает нам найти HTTP-трафик, который может содержать информацию для входа в систему. Внимательно изучите пакеты, соответствующие этому фильтру, чтобы выявить потенциальные риски для безопасности.
#### Практический сценарий: анализ образца трафика и генерация нового трафика

Теперь, когда вы изучили различные фильтры, ориентированные на безопасность, пришло время применить свои знания на практике. Вы можете либо проанализировать предоставленный образец файла, либо сгенерировать и проанализировать новый трафик.


# 2. Протоколы

## 2.1 Протокол HTTP

`HTTP` - Hypertext Transfer Protocol (протокол передачи гипертекста)

Сейчас используется в основном `HTTP 1.1`:
- Кеширование, постоянное соединение, аутентификация

Работает в режиме `Запрос - Ответ (Клиент - Сервер)` в текстовом режиме для `HTTP 1.1`, в версиях `HTTP/ 2` и `HTTP/ 3` - в бинарном

На транспортном уровне протокол `HTTP` использует `TCP` порт `80`, `HTTPS` - (`443`)

`URL` - Единообразный определитель местонахождения ресурса

Формат URL:

```
[протокол]://[адрес.сервера]/[страница]
https://ya.ru/search/?q=
```

### 2.1.1 Сообщения HTTP. Запрос

- **Запрос**
	``` GET /courses HTTP/1.1	``` 
	Формат: 
	```[МЕТОД] [СТРАНИЦА] [ВЕРСИЯ HTTP]```
- **Заголовки** (не обязательно)
	``` Host: ya.ru ``` (обязательно в `HTTP 1.1`)
	Формат:
	```[НАИМЕНОВАНИЕ ЗАГОЛОВКА]:[ЗНАЧЕНИЕ]```
- **Тело сообщения** (не обязательно)
	``` параметры введенные пользователем ```

### 2.1.2 Основные методы HTTP

- `GET` - запрос данных
- `POST` - передача данных
- `HEAD` - запрос заголовка страницы
- `PUT` - помещение страницы на сервер
- `DELETE` - запрос на удаление данных
- `OPTIONS` - запрос поддерживаемых методов `HTTP` для ресурса

### 2.1.3 Сообщения HTTP. Ответ

- **Статус ответа**
	```200 OK```
- **Заголовки** (не обязательно)
	```Content-Type: text/html; charset utf-8```
	```Content-Length: 5432```
- **Тело сообщения**
	```Страница HTML```

### 2.1.4 Сообщения HTTP. Ответ

- `1XX` - информация
- `2XX` - успешное выполнение
- `3XX` - перенаправление
- `4XX` - Ошибка на стороне клиента
- `5XX` - Ошибка сервера

### 2.1.5 Пример запроса и ответа HTTP

- подключение по `TCP` к порту `80` корневой страницы сервера `ya.ru`

```
GET / HTTP/1.1
Host: ya.ru
```

- ответ сервера

```
HTTP/1.1 200 OK
Server: ya.ru
Content-Type: text/html; charset=utf-8
Content-Length: 236

<html>
<h1>Заголовок</h1>
<p>Текст</p>
</html>
```

### 2.1.6 Кэширование в HTTP

- Кеширование сокращает время загрузки страницы
- Поддержка встроена в протокол `HTTP`
- Web-боаузеры поддерживают кэширование редко меняющихся ресурсов:
	- Web-страницы
	- Изображения
	- CSS
	- JavaScript

Как браузеру определить, можно ли брать страницу из кэша:
- По заголовку `Expires` в ответе от сервера
- Указывает до какого времени можно использовать ресурс из кэша
- Web-серверы не всегда устанавливают этот заголовок

В `HTTP` есть заголовок для управления кэшированием:

```
Cache-Control: private, max-age=600
```

Возможные значения:
- `no-store`
- `no-cache`
- `private`
- `public`
- `max-age=N`

Каким образом можно понять изменилась страница(ресурс) или нет:

- Запрос `GET` с условием - запрос серверу передать ресурс, если он изменился
- Варианты обнаружения изменений:
	- `ETag` - токен(обычно хэш содержимого файла) `ETag:"634af215-ed"`
	- Дата изменений `Last-Modified`

### 2.1.7 HTTP в Wireshark

обращение к серверу `10.92.239.85`:

```
GET /reports/index.cgi HTTP/1.1\r\n
```

![[Pasted image 20250512133125.png]]

**Прикладной уровень**

![[Pasted image 20250512133649.png]]

**Транспортный уровень**

![[Pasted image 20250512133830.png]]

**Уровень межсетевого взаимодействия**

![[Pasted image 20250512133935.png]]

**Уровень сетевых интерфейсов**

![[Pasted image 20250512134022.png]]

Ответ сервера

![[Pasted image 20250512134159.png]]

![[Pasted image 20250512134216.png]]

При повторном запросе, страница возьмется из кэша:

![[Pasted image 20250512134657.png]]

## 2.2 Протокол DNS

Система доменных имен - позволяет преобразовать имена компьютеров в IP-адреса

#### Утилита nslookup

Поиск в пространстве имен

```
nslookup habr.com
```

в Linux есть более продвинутые утилиты `host` и `dig`

#### Откуда берется информация о преобразованиях

1. Из файлов ОС:
	- Linux: `/etc/host`
	- Windows: `C:\Windows\System32\drivers\etc\host`

	Недостатки:
	- быстро увеличивается размер 
	- сложно вносить изменения
	- возможны конфликты имен
2. DNS:
	- Распределенная система
		- Нет единого сервера, на котором описываются имена хостов
	- Делегирование ответственности
		- Пространство имен разделено на отдельные части- домены
		- За каждый домен отвечает отдельная организация
	- Надежность
		- Дублирование серверов DNS

#### Структура доменного имени

```
www.ya.ru
```

`ru` - Домен верхнего уровня
`ya` - Домен второго уровня
`www` - Имя сервера (www - веб сервер)

`DNS resolver` - сервер который преобразует имя в адрес, он обращается к дереву доменных имен и находит соответствие. При этом resolver сохраняет найденное значение в кэше.

`DNS` работает по принципу **клиент-сервер** на **транспортном** уровне преимущественно по протоколу `UDP` или `TCP` на порту `53`

#### Режимы работы DNS

- **Итеративный**:
	- Если сервер отвечает за доменную зону, то он возвращает ответ
	- Если сервер не отвечает за доменную зону, то он возвращает адрес `DNS` сервера, у которого есть более точная информация
- **Рекурсивный**
	- Сервер сам выполняет запросы к другим серверам, чтобы найти нужный адрес

#### Типы ответов

- **Авторитетный** (заслуживающий доверия)
	- Ответ от сервера, обслуживающего доменную зону
	- Получен из файлов на диске сервера
- **Неавторитетный** (не заслуживающий доверия)
	- Ответ от сервера, который не обслуживает доменную зону
	- Получен из кэша, данные могли устареть

#### Формат пакета DNS

![[Pasted image 20250519104031.png]]

Безопасность DNS

- Данные передаются в открытом виде
- Защищенные протоколы DNS:
	- Domain Name System Security (`DNSSec`)
	- DNS over HTTPS (`DoH`)
	- DNS over TLS (`DoT`)

### Тип записи DNS

Каждая DNS (Resource Record, `RR`) запись имеет:
- Тип записи - для чего предназначена запись
- Класс записи - в каких сетях используется (На сегодняшний день используется `IN` - Интернет)

Типы записей для IP-адресов:
- `A` - IPv4 адрес
- `AAAA` - IPv6 адрес

```
nslookup -type=A ksc-avp
nslookup -type=AAAA ksc-avp
```

DNS псевдонимы

- Запись типа `CNAME` (Canonical Name Record)
	- Определяет псевдоним для другого доменного имени
	- `www.example.com` -> `example.com`
- Альтернативный способ:
	- Задать несколько `A` записей для одного IP-адреса

```
nslookup -type=cname ksc-avp
```

Типы `DNS` зон:
- Прямая - определение IP-адреса по доменному имени
- Обратная(reverse) - определение доменного имени по IP-адресу

Специальное доменное имя для обратных зон:
- `in-addr.arpa.`
- IP-адрес записывается в обратном порядке
- `77.88.55.88` -> `88.55.88.77.in-addr.arpa.`

Запись типа PTR (Pointer)
- `88.55.88.77.in-addr.arpa.` -> `yandex.ru.`

**Запрос записей разных типов**

- `nslookup -type=XXX yandex.ru`
- `dig -t=XXX yandex.ru`
- `host -t=XXX yandex.ru`
## 2.3 Протокол UDP

**User Datagram Protocol** (`UDP`) - протокол дейтаграмм пользователя

Сообщение UDP - дейтаграмма (аналогия с телеграммой)

Особенности UDP:
- Нет соединения
- Нет гарантии доставки данных
- Нет гарантии сохранения порядка следования сообщений

Области применения:

- Короткие клиент-серверные взаимодействия (режим запрос-ответ)
- Передача видео и голоса (потеря данных не критична)

Задача по контролю доставки UDP дейтаграмм ложится на протоколы вышестоящего уровня

> Скорость работы UDP - выше чем TCP!
#### Формат заголовка UDP

![[Pasted image 20250520151346.png]]

#### UDP в Wireshark

![[Pasted image 20250520154743.png]]

## 2.4 Протокол TCP

**Transmission Control Protocol** (`TCP`) - протокол управления передачей

Стандарты `TCP`:
- `RFC 793` - 1981
- `RFC 9293` - 2022

Сервис `TCP` - надежная передача потока байт

`TCP` получает от приложения поток байт и делит его на отдельные части (**сегменты**). Каждый сегмент передается по сети независимо друг от друга. Получатель собирает все сегменты и формирует поток байт и передает его приложению на вышестоящем уровне.

`TCP` обеспечивает надежную доставку данных. При этом `TCP` считает, что передает данные через ненадежную среду.

Проблемы при передаче по ненадежной сети:
- Потеря сегментов
- Нарушение порядка следования сегментов
- Дублирование сегментов

Гарантии `TCP`:
- Гарантия доставки данных
- Гарантия сохранения порядка сегментов

Принцип подтверждения:
1. отправитель посылает сегмент получателю
2. получатель при получении сегмента отправляет подтверждение (`ACK`)
3. после получения подтверждения, отправитель посылает следующий сегмент

![[Pasted image 20250520160616.png]]

На практике для повышения производительности `TCP` подтверждает не каждый сегмент, а несколько сегментов, отправленных друг за другом, используя механизм **скользящего окна**.

#### Подтверждение доставки

Варианты подтверждения доставки:
- Остановка и ожидание (канальный уровень)
- Скользящее окно (транспортный уровень)

Размер окна - кол-во байт данных, которые могут быть переданы без получения подтверждения.
#### Нумерация сегментов

В TCP используется нумерация байт

![[Pasted image 20250520161751.png]]
![[Pasted image 20250520162132.png]]
#### Соединение TCP

Перед отправкой данных по `TCP` необходимо установить соединение.

Процесс передачи данных `TCP`:
- Установка соединение
- Передача данных
- Разрыв соединения

**Задачи соединения**:
- Убедиться, что отправитель и получатель хотят передавать данные
- Договориться о нумерации потока байт (синхронизация)
- Договориться о параметрах соединения

После завершения передачи данных соединения разрывается.

Установка соединения:
1. Отправитель передает сообщение в заголовке которого установлен флаг `SYN` 
2. Получатель в ответ отправляет пакет c флагами `SYN` и `ACK`
3. Отправитель передаёт сообщение с флагом `ACK`

Разрыв соединения:
- Чтобы разорвать TCP соединение, необходимо отправить сегмент с флагом `FIN` + `ACK` или `RST`

## Формат заголовка TCP

Формат заголовка TCP очень сложен и предназначен для реализации всех функций надежности передачи данных, которые заложены в протокол

![[Pasted image 20250616144323.png]]

1. Порт отправителя\получателя - это адреса на транспортном уровне
2. Порядковый номер сообщения
3. Номер подтверждения - номер следующего байта, которое ожидается в следующем сообщении
4. Смещение данных - говорит, где начинаются данные
5. Резерв
6. Биты флагов



