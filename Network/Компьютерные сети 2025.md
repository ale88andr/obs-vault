
**Сервис** - определяет, что делает сетевой уровень

**Интерфейс** - определяет как использовать возможности сетевого уровня

**Протокол** - как сетевой уровень реализует возможности (набор правил)

**Архитектура сети** - набор уровней и протоколов (интерфейсы не входят в архитектуру)

**Стек протоколов** - иерархически организованный набор протоколов, достаточный для организации сетевого взаимодействия

**Инкапсуляция** - включение сообщения вышестоящего уровня в сообщение нижестоящего уровня

# 1. Модели сети

## 1.1 OSI

Модель взаимодействия открытых систем (Open System Interconnection Reference Model), где открытая система - это система построенная в соответствии с открытыми требованиями

![[Pasted image 20250507111734.png]]

1. **Физический уровень** (Physical layer) - Занимается передачей битов по физическому каналу связи (основная задача - передача потока бит без искажений в соответствии с заданной частотой)
2. **Канальный уровень** (Data Link layer) - Организовывает сетевое взаимодействие внутри одного сегмента сети. (задачи: управление доступом к среде передачи данных, установление логического соединения, согласование скоростей, надежная передача и коррекция ошибок)
3. **Сетевой уровень** (Network layer) - Служит для объединения нескольких сетей в крупную составную сеть. (задачи: адресация, определение маршрута отправки пакетов в составной сети, согласование характеристик сетей)
4. **Транспортный уровень** (Transport layer) - Обеспечивает передачу данных между процессами на устройствах с требуемым уровнем надежности. Сетенезависимый уровень (напрямую соединяются процессы которые находятся  на отправителе и получателе)
5. **Сеансовый уровень** (Session layer) - Позволяет устанавливать сеансы связи
6. **Уровень представления** (Presentation layer) - Обеспечивает согласование синтаксиса и семантики передаваемых данных (форматы представления символов, чисел и т.п.), а так же шифрование и дешифрование(`TLS`)
7. **Прикладной уровень** (Application layer)  - Используется пользовательскими приложениями для передачи запросов/данных

На практике модель не используется(применяется в качестве общего языка для описания и сопоставления различных коммуникационных сетей), а применяется модель и стек протоколов `TCP/IP`.

## 1.2 TCP/IP

![[Pasted image 20250506171636.png]]

1. **Уровень сетевых интерфейсов** (Link layer) - взаимодействие с сетями разных технологий. Объединяет **Физический** и **Канальный** уровень модели `OSI`.
2. **Уровень межсетевого взаимодействия** (Network layer) - Совпадает с **Сетевым** уровнем модели `OSI`
3. **Транспортный уровень** (Transport layer) - Совпадает с **Транспортным** уровнем модели `OSI`
4. **Прикладной уровень** (Application layer) - Объединяет **Сеансовый**, **Прикладной** и **Уровень представления** модели `OSI`.

`TCP/IP` широко используется на практике

## 1.3 Стандарты 

Цель стандартизации сетей - обеспечить возможность работать вместе оборудованию и ПО различных производителей.

Стандарты технологий передачи данных `IEEE`, рабочая группа `802`:
- `IEEE 802.11` - беспроводные сети Wi-Fi
- `IEEE 802.3` - проводные сети Ethernet
- `IEEE 802.15.1` - персональные сети Bluetooth
- `IEEE 802.15.4` - беспроводные сети интернета вещей
- `IEEE 802.16` - беспроводные сети WiMax

Группа проектирования Интернет `IETF` - выпускает документы с описанием сетевых протоколов (`RFC` - Request for comments):
- `RFC 2616` - протокол HTTP
- `RFC 793` - протокол TCP
- `RFC 791` - протокол IP
- `RFC 792` - протокол ICMP
- `RFC 826` - протокол ARP

## 1.4. Организация сетей TCP/IP

### 1.4.1 Уровень сетевых интерфейсов (Link layer)

Самая популярная технология проводной сети - `Ethernet` в ней используются коммутаторы, которые используют **физическую (аппаратную) адресацию** `MAC`, чтобы определить кому передавать данные.

`MAC` адреса:
- используются для идентификации узлов сети Wi-Fi и Ethernet
- регламентируются стандартом `IEEE 802`
- формат адреса `6` байт(`48` бит)
- форма записи `1C-75-08-D2-46-45` (`IEEE`), `1C-75-08-D2-46-45` (`EITF`)
- каждый сетевой адаптер имеет встроенный MAC адрес
- MAC адрес в сети должен быть уникальным

### 1.4.2 Уровень межсетевого взаимодействия (Network layer)

Объединение сетей(подсетей) построенных по разным технологиям (например, Ethernet и Wi-Fi) посредством добавления в сеть **маршрутизатора** (router).

Одна из важнейших задач уровня - это поиск маршрута в составной сети через промежуточные устройства сети(маршрутизаторы)

На этом уровне используются глобальные сетевые адреса:
- не привязаны к сетевой технологии
- используются для уникальной идентификации компьютера в составной сети

**IP-адреса**:
- глобальные сетевые адреса протоколов TCP\IP
- формат записи - 4 десятичных числа от 0 до 255
- IP-адреса должны быть уникальны во всем мире

Распределением IP-адресов в мире занимается `IANA`, за регион России отвечает региональный регистратор `IANA` - `RIPE`.

### 1.4.3 Транспортный уровень (Transport layer)

Транспортный уровень - обеспечивает взаимодействие процессов устройств по сети

Адресация на транспортном уровне осуществляется с помощью **портов** - идентификатор процесса ОС на устройстве

**Порты**:
- число в диапазоне от `1` до `65535`
- адрес процесса на транспортном уровне
- каждое сетевой приложение имеет свой порт
- номера портов у приложений не повторяются
- формат записи 192.168.1.1 `:8080`

Протоколы транспортного уровня:
1. `TCP` (`Transmission Control Protocol`) - получает поток байт, делит её на части, передавая её по сети и обеспечивает гарантию передачи до получателя в правильном порядке
	- обеспечивает надежную передачу потока байтов
	- протокол управления передачей
	- устанавливает сетевое соединение
2. `UDP` (`User Datagram Protocol`)
	- Протокол дейтаграмм(коротких сообщений) пользователя
	- обеспечивает ненадежную передачу коротких сообщений
	- соединение не устанавливается

### 1.4.4 Прикладной уровень (Application layer)

Уровень взаимодействия сетевых приложений

На этом уровне работают протоколы совершающие обмен данными, ради которых строятся сети (`HTTP`, `HTTPS`, `DNS`, `SMTP` и т.д.)

Протоколы прикладного уровня не углубляются (изолированы) в то, как именно данные передаются по сети (как будто приложения на разных хостах передают данные напрямую друг другу)

### 1.4.5 Выводы

**Сетевое оборудование уровней TCP/IP**

| Уровень TCP/IP              | Сетевое оборудование                     |
| --------------------------- | ---------------------------------------- |
| Уровень сетевых интерфейсов | Точка доступа Wi-Fi, Ethernet коммутатор |
| Сетевой уровень             | Маршрутизатор                            |

**Адресация уровней TCP/IP**

| Уровень TCP/IP              | Адресация |
| --------------------------- | --------- |
| Уровень сетевых интерфейсов | МАС-адрес |
| Сетевой уровень             | IP-адрес  |
| Транспортный уровень        | Порт      |
| Уровень приложений*         | Протокол* |

## 1.5. Сетевой анализатор Wireshark

Главное окно программы

![[Pasted image 20250507104336.png]]

Пример передачи `HTTP` запроса на сервер `10.92.192.100:8000`:
- введем фильтр по протоколу `http` и найдем нужный пакет

![[Pasted image 20250507112539.png]]

- смотрим, что передается на разных уровнях `TCP/IP`

![[Pasted image 20250507113431.png]]

- смотрим как происходит инкапсуляция при передачи данных по сети:

Заголовок уровня сетевых интерфейсов
![[Pasted image 20250507113934.png]]
Заголовок уровня сети
![[Pasted image 20250507114108.png]]Заголовок транспортного уровня
![[Pasted image 20250507114146.png]]и т.д.

# 2. Протоколы

## 2.1 Протокол HTTP

`HTTP` - Hypertext Transfer Protocol (протокол передачи гипертекста)

Сейчас используется в основном `HTTP 1.1`:
- Кеширование, постоянное соединение, аутентификация

Работает в режиме `Запрос - Ответ (Клиент - Сервер)` в текстовом режиме для `HTTP 1.1`, в версиях `HTTP/ 2` и `HTTP/ 3` - в бинарном

На транспортном уровне протокол `HTTP` использует `TCP` порт `80`, `HTTPS` - (`443`)

`URL` - Единообразный определитель местонахождения ресурса

Формат URL:

```
[протокол]://[адрес.сервера]/[страница]
https://ya.ru/search/?q=
```

### 2.1.1 Сообщения HTTP. Запрос

- **Запрос**
	``` GET /courses HTTP/1.1	``` 
	Формат: 
	```[МЕТОД] [СТРАНИЦА] [ВЕРСИЯ HTTP]```
- **Заголовки** (не обязательно)
	``` Host: ya.ru ``` (обязательно в `HTTP 1.1`)
	Формат:
	```[НАИМЕНОВАНИЕ ЗАГОЛОВКА]:[ЗНАЧЕНИЕ]```
- **Тело сообщения** (не обязательно)
	``` параметры введенные пользователем ```

### 2.1.2 Основные методы HTTP

- `GET` - запрос данных
- `POST` - передача данных
- `HEAD` - запрос заголовка страницы
- `PUT` - помещение страницы на сервер
- `DELETE` - запрос на удаление данных
- `OPTIONS` - запрос поддерживаемых методов `HTTP` для ресурса

### 2.1.3 Сообщения HTTP. Ответ

- **Статус ответа**
	```200 OK```
- **Заголовки** (не обязательно)
	```Content-Type: text/html; charset utf-8```
	```Content-Length: 5432```
- **Тело сообщения**
	```Страница HTML```

### 2.1.4 Сообщения HTTP. Ответ

- `1XX` - информация
- `2XX` - успешное выполнение
- `3XX` - перенаправление
- `4XX` - Ошибка на стороне клиента
- `5XX` - Ошибка сервера

### 2.1.5 Пример запроса и ответа HTTP

- подключение по `TCP` к порту `80` корневой страницы сервера `ya.ru`

```
GET / HTTP/1.1
Host: ya.ru
```

- ответ сервера

```
HTTP/1.1 200 OK
Server: ya.ru
Content-Type: text/html; charset=utf-8
Content-Length: 236

<html>
<h1>Заголовок</h1>
<p>Текст</p>
</html>
```

### 2.1.6 Кэширование в HTTP

- Кеширование сокращает время загрузки страницы
- Поддержка встроена в протокол `HTTP`
- Web-боаузеры поддерживают кэширование редко меняющихся ресурсов:
	- Web-страницы
	- Изображения
	- CSS
	- JavaScript

Как браузеру определить, можно ли брать страницу из кэша:
- По заголовку `Expires` в ответе от сервера
- Указывает до какого времени можно использовать ресурс из кэша
- Web-серверы не всегда устанавливают этот заголовок

В `HTTP` есть заголовок для управления кэшированием:

```
Cache-Control: private, max-age=600
```

Возможные значения:
- `no-store`
- `no-cache`
- `private`
- `public`
- `max-age=N`

Каким образом можно понять изменилась страница(ресурс) или нет:

- Запрос `GET` с условием - запрос серверу передать ресурс, если он изменился
- Варианты обнаружения изменений:
	- `ETag` - токен(обычно хэш содержимого файла) `ETag:"634af215-ed"`
	- Дата изменений `Last-Modified`

### 2.1.7 HTTP в Wireshark

обращение к серверу `10.92.239.85`:

```
GET /reports/index.cgi HTTP/1.1\r\n
```

![[Pasted image 20250512133125.png]]

**Прикладной уровень**

![[Pasted image 20250512133649.png]]

**Транспортный уровень**

![[Pasted image 20250512133830.png]]

**Уровень межсетевого взаимодействия**

![[Pasted image 20250512133935.png]]

**Уровень сетевых интерфейсов**

![[Pasted image 20250512134022.png]]

Ответ сервера

![[Pasted image 20250512134159.png]]

![[Pasted image 20250512134216.png]]

При повторном запросе, страница возьмется из кэша:

![[Pasted image 20250512134657.png]]

## 2.1 Протокол DNS

Система доменных имен - позволяет преобразовать имена компьютеров в IP-адреса

#### Утилита nslookup

Поиск в пространстве имен

```
nslookup habr.com
```

в Linux есть более продвинутые утилиты `host` и `dig`

#### Откуда берется информация о преобразованиях

1. Из файлов ОС:
	- Linux: `/etc/host`
	- Windows: `C:\Windows\System32\drivers\etc\host`

	Недостатки:
	- быстро увеличивается размер 
	- сложно вносить изменения
	- возможны конфликты имен
2. DNS:
	- Распределенная система
		- Нет единого сервера, на котором описываются имена хостов
	- Делегирование ответственности
		- Пространство имен разделено на отдельные части- домены
		- За каждый домен отвечает отдельная организация
	- Надежность
		- Дублирование серверов DNS

#### Структура доменного имени

```
www.ya.ru
```

`ru` - Домен верхнего уровня
`ya` - Домен второго уровня
`www` - Имя сервера (www - веб сервер)

`DNS resolver` - сервер который преобразует имя в адрес, он обращается к дереву доменных имен и находит соответствие. При этом resolver сохраняет найденное значение в кэше.

`DNS` работает по принципу **клиент-сервер** на **транспортном** уровне преимущественно по протоколу `UDP` или `TCP` на порту `53`

#### Режимы работы DNS

- **Итеративный**:
	- Если сервер отвечает за доменную зону, то он возвращает ответ
	- Если сервер не отвечает за доменную зону, то он возвращает адрес `DNS` сервера, у которого есть более точная информация
- **Рекурсивный**
	- Сервер сам выполняет запросы к другим серверам, чтобы найти нужный адрес

#### Типы ответов

- **Авторитетный** (заслуживающий доверия)
	- Ответ от сервера, обслуживающего доменную зону
	- Получен из файлов на диске сервера
- **Неавторитетный** (не заслуживающий доверия)
	- Ответ от сервера, который не обслуживает доменную зону
	- Получен из кэша, данные могли устареть

