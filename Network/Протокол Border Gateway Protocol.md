Первоначально **BGP** был разработан как протокол Внешнего шлюза (Exterior Gateway Protocol - **EGP**), что означает, что он предназначался для подключения сетей или автономных систем (AS), а не устройств. Если BGP является EGP, это должно означать, что другие протоколы маршрутизации, такие как RIP, EIGRP, OSPF и IS-IS, должны быть протоколами внутренних шлюзов (Interior Gateway Protocols- IGP). Четкое определение внутренних и внешних шлюзов оказалось полезным при проектировании и эксплуатации крупномасштабных сетей. BGP является уникальным среди широко распространенных протоколов в том, что касается расчета пути без петель. Существует три широко используемых протокола векторов расстояний (Spanning Tree, RIP и EIGRP). Существует два широко используемых протокола состояния канала связи (OSPF и IS-IS). И есть еще много примеров этих двух типов протоколов, разработанных и внедренных в то, что можно было бы считать нишевыми рынками. BGP, однако, является единственным широко развернутым протоколом вектора пути.

Каковы наиболее важные цели EGP? Первый - это, очевидно, выбор путей без петель, но это явно не означает кратчайшего пути. Причина, по которой кратчайший путь не так важен в EGP, как в IGP, заключается в том, что EGP используются для соединения объектов, таких как поставщики услуг, поставщики контента и корпоративные сети. Подключение сетей на этом уровне означает сосредоточение внимания на политике, а не на эффективности - с точки зрения сложности, повышение состояния с помощью механизмов политики при одновременном снижении общей оптимизации сети с точки зрения передачи чистого трафика.

---

### BGP-пиринг

BGP не обеспечивает надежной передачи информации. Вместо этого BGP полагается на TCP для передачи информации между одноранговыми узлами BGP. Использование TCP гарантирует:

- Обнаружение MTU обрабатывается даже для соединений, пересекающих несколько переходов (или маршрутизаторов).
- Управление потоком осуществляется базовым транспортом, поэтому BGP не нуждается в непосредственном управлении потоком (хотя большинство реализаций BGP действительно взаимодействуют со стеком TCP на локальном хосте, чтобы повысить пропускную способность, в частности, для BGP).
- Двусторонняя связь между одноранговыми узлами обеспечивается трехсторонним рукопожатием, реализованным в TCP.

Несмотря на то, что BGP полагается на базовое TCP-соединение для многих функций, которые плоскости управления должны решать при построении смежности, по-прежнему существует ряд функций, которые TCP не может предоставить. Следовательно, необходимо более подробно рассмотреть процесс пиринга BGP.

Рисунок 1 позволяет изучить этот процесс.
![[Pasted image 20240122121112.png]]
1. Сеанс пиринга BGP начинается в состоянии ожидания (idle state).
2. A отправляет TCP open на порт 179. B отвечает на временный порт (ephemeral port) на A. После завершения трехстороннего подтверждения TCP (сеанс TCP успешен), BGP перемещает состояние пиринга для подключения. Если пиринговый сеанс формируется через какой-либо тип фильтрации на основе состояния, такой как брандмауэр, важно, чтобы открытое TCP-сообщение передавалось «изнутри» фильтрующего устройства.
3. В случае сбоя TCP-соединения состояние пиринга BGP переводится в активное.
4. A отправляет BGP open в B и переводит B в состояние opensent. В этот момент A ожидает от B отправки сообщения keepalive. Если B не отправляет сообщение keepalive в течение определенного периода, A вернет сеанс обратно в состояние ожидания (idle state). Открытое сообщение содержит ряд параметров, например, какие семейства адресов поддерживают два спикера BGP и hold timer. Это называется согласованием возможностей. Самый низкий (минимальный) hold timer из двух объявленных выбирается в качестве hold timer для однорангового сеанса.
5. Когда B отправляет A сообщение keepalive, A переводит B в состояние openconfirm.
6. На этом этапе A отправит B сообщение keepalive для проверки соединения. Когда A и B получают сообщения поддержки активности друг друга, пиринговый сеанс переходит в established state.
7. Два узла BGP обмениваются маршрутами, поэтому их таблицы обновлены. A и B обмениваются только своими лучшими путями, если какая-либо форма многонаправленного распространения BGP не поддерживается и не настроена на двух спикерах.
8. Чтобы уведомить A, что он завершил отправку всей своей локальной таблицы, B отправляет A сигнал End of Table (EOT) или End of RIB (EOR).

Существует два типа пиринговых отношений BGP: одноранговые узлы BGP в одной и той же автономной системе (AS, что обычно означает набор маршрутизаторов в одном административном домене, хотя это довольно общее определение) называются внутренними одноранговыми узлами BGP (internal BGP - iBGP) и Одноранговые узлы BGP между автономными системами называются внешними (или внешними - exterior) узлами BGP (eBGP). Хотя два типа пиринговых отношений BGP построены одинаково, у них разные правила объявления.

---

### Процесс выбора оптимального пути BGP

Поскольку BGP предназначен для соединения автономных систем, алгоритм наилучшего пути ориентирован в первую очередь на политику, а не на отсутствие петель. Фактически, если вы изучите какое-либо стандартное объяснение процесса наилучшего пути BGP, то, является ли конкретный путь свободным от петель, вообще не будет учитываться в процессе принятия решения. Как же тогда BGP определяет, что конкретный узел объявляет маршрут без петель? Рисунок 2 демонстрирует это.

![[Pasted image 20240122121128.png]]
На рисунке 2 каждый маршрутизатор находится в отдельной AS, поэтому каждая пара спикеров BGP будет формировать сеанс пиринга eBGP. A, который подключен к 2001: db8: 3e8: 100 :: / 64, объявляет этот маршрут к B и C. Объявления маршрута BGP несут ряд атрибутов, одним из которых является путь AS. Перед тем, как A объявит 100 :: / 64 для B, он добавляет свой номер AS в атрибут AS Path. B получает маршрут и объявляет его D. Перед объявлением маршрута к D он добавляет AS65001 к AS Path. Тогда путь AS, прослеживающийся от A до C, на каждом шаге выглядит примерно так:

- Получено B: [AS65000]
- Получено C: [AS65000, AS65001]
- Получено D: [AS65000, AS65001, AS65003]

Когда D получил маршрут от B, он анонсирует его обратно в C (в BGP нет split horizon). Предположим, что C, в свою очередь, объявляет обратный маршрут к A по какой-то причине (в этой ситуации это не так, потому что путь через A был бы лучшим путем к месту назначения, а просто для демонстрации предотвращения петель), A будет проверять AS Path и обнаружение его локальной AS находится в AS Path. Это явно петля, поэтому A просто игнорирует маршрут. Поскольку этот маршрут игнорируется, он никогда не помещается в таблицу топологии BGP. Следовательно, с использованием процесса наилучшего пути BGP сравниваются только маршруты без петель.

В большинстве реализаций процесс наилучшего пути BGP состоит из 13 шагов (первый шаг реализуется не всегда, так как это локальное решение со стороны узла BGP):

1. Выбирается маршрут с наибольшим весом. Некоторые реализации не используют вес маршрута.
2. Выбирается маршрут с наивысшим местным предпочтением (local preference- LOCAL PREF). Local preference собой политику выхода локальной AS - какую точку выхода из доступных точек выхода предпочел бы владелец этой AS, как и узел BGP.
3. Предпочитайте маршрут с локальным происхождением, то есть на этом узле BGP. Этот шаг редко используется в процессе принятия решения.
4. Предпочитайте путь с самым коротким AS Path. Этот шаг предназначен для выбора наиболее эффективного пути через объединенную сеть, выбора пути, который будет проходить через наименьшее количество автономных систем для достижения пункта назначения. Операторы часто добавляют записи AS Path, чтобы повлиять на этот шаг в процессе принятия решения.
5. Предпочитайте путь с наименьшим значением координат. Маршруты, которые перераспределяются из IGP, предпочтительнее маршрутов с неизвестным происхождением. Этот шаг редко оказывает какое - либо влияние на процесс принятия решений.
6. Предпочитайте путь с самым низким multiexit discriminator (MED). MED представляет входную политику удаленной AS. Таким образом, MED сравнивается только в том случае, если от одной и той же соседней AS было получено несколько маршрутов. Если один и тот же маршрут получен от двух разных соседних автономных систем, MED игнорируется.
7. Предпочитайте маршруты eBGP маршрутам iBGP.
8. Предпочитайте маршрут с наименьшей стоимостью IGP до следующего перехода. Если политика локального выхода не задана (в форме локального предпочтения), и соседняя AS не установила политику входа (в форме MED), то путь с ближайшим выходом из локального маршрутизатора выбирается как точка выхода.
9. Определите, следует ли устанавливать несколько путей в таблице маршрутизации (настроена некоторая форма multipath).
10. При сравнении двух внешних маршрутов (полученных от однорангового узла eBGP) предпочтите самый старый маршрут или маршрут, изученный первым. Это правило предотвращает отток маршрутов только потому, что маршруты обновляются.
11. Предпочитайте маршрут, полученный от однорангового узла с наименьшим идентификатором маршрутизатора. Это просто средство разрешения конфликтов для предотвращения оттока в таблице маршрутизации.
12. Предпочитайте маршрут с наименьшей длиной кластера.
13. Предпочитайте маршрут, полученный от однорангового узла с наименьшим адресом пиринга. Это, опять же, просто тай-брейк, выбранный произвольно, чтобы предотвратить ненужные связи и вызвать отток в таблице маршрутизации, и обычно используется, когда два одноранговых узла BGP соединены по двум параллельным каналам.

Хотя это кажется долгим процессом, почти каждое решение наилучшего пути в BGP сводится к четырем факторам: локальному предпочтению (local preference), MED, длине AS Path и стоимости IGP.

---

### Правила объявления BGP

BGP имеет два простых правила для определения того, где объявлять маршрут:

- Объявляйте лучший путь к каждому пункту назначения каждому узлу eBGP.
- Объявляйте лучший путь, полученный от однорангового узла eBGP, для каждого однорангового узла iBGP.

Еще один способ сформулировать эти два правила: никогда не объявлять маршрут, полученный от iBGP, другому узлу iBGP. Рассмотрим рисунок 3.

![[Pasted image 20240122121148.png]]
На рисунке 3 A и B - это одноранговые узлы eBGP, а B и C, а также C и D - одноранговые узлы iBGP. Предположим, A объявляет 2001: db8: 3e8: 100 :: / 64 для B. Поскольку B получил это объявление маршрута от однорангового узла eBGP, он объявит 100 :: / 64 на C, который является одноранговым узлом iBGP. C, изучив этот маршрут, не будет объявлять маршрут к D, поскольку C получил маршрут от однорангового узла iBGP, а D также является одноранговым узлом iBGP. Таким образом, на этом рисунке D не узнает о 100 :: / 64. Это не очень полезно в реальном мире, однако ограничение присутствует не просто так.

Рассмотрим, как BGP предотвращает образование петель маршрутизации - передавая список автономных систем, через которые прошел маршрут, в самом объявлении маршрута. При объявлении маршрута от одного спикера iBGP к другому AS Path не изменяется. Если узлы iBGP объявляют маршруты, полученные от одноранговых узлов iBGP, одноранговым узлам iBGP, петли маршрутизации могут быть легко сформированы. Одним из решений этой проблемы является простое построение многоуровневых пиринговых отношений между B и D (помните, что BGP работает поверх TCP. Пока существует IP-соединение между двумя узлами BGP, они могут построить пиринговые отношения). Предположим, что B строит пиринговые отношения с D через C, и ни B, ни D не строят пиринговые отношения с C. Что произойдет, когда трафик переключается на 100 :: / 64 посредством D на C? Что будет с пакетами в этом потоке на C? У C не будет маршрута к 100 :: / 64, поэтому он сбросит трафик. Это может быть решено несколькими способами - например, B и D могут туннелировать трафик через C, поэтому C не обязательно должен иметь доступность к внешнему пункту назначения. BGP также можно настроить для перераспределения маршрутов в любой основной запущенный IGP (это плохо - не делайте этого).

Для решения этой проблемы были стандартизированы рефлекторы маршрутов BGP. Рисунок 4 иллюстрирует работу отражателей маршрута.
![[Pasted image 20240122121201.png]]
На рисунке 4 E сконфигурирован как рефлектор маршрута. B, C и D настроены как клиенты рефлектора маршрутов (в частности, как клиенты E). A объявляет маршрут 2001: db8: 3e8: 100 :: / 64 к B. B объявляет этот маршрут E, потому что он был получен от однорангового узла eBGP, а E является одноранговым узлом iBGP. E добавляет новый атрибут к маршруту, список кластеров, который указывает путь обновления в AS через кластеры отражателя маршрута. Затем E объявит маршрут каждому из своих клиентов. Предотвращение зацикливания в этом случае обрабатывается списком кластеров.

---

### Подведение итогов о BGP

Хотя изначально BGP был разработан для соединения автономных систем, его использование распространилось на центры обработки данных, передачу информации о виртуальных частных сетях. Фактически, использование BGP практически безгранично. Постепенно BGP превратился в очень сложный протокол.

BGP можно описать как:

- Проактивный протокол, который узнает о достижимых местах назначения через конфигурацию, локальную информацию и другие протоколы.
- Протокол вектора пути, который объявляет только лучший путь к каждому соседу и не предотвращает образование петель в автономной системе (если не развернуты рефлекторы маршрута или какая-либо дополнительная функция)
- Выбор путей без петель путем изучения пути, по которому может быть достигнут пункт назначения
- Проверка двустороннего подключения и MTU за счет использования TCP в качестве основы для передачи информации.


**BGP (Border Gateway Protocol)** - это протокол граничного шлюза, предназначенный для обмена информацией о маршрутизации и доступности между автономными системами (**AS**) в Интернете. Пока не пугайся - к тому, что такое автономная система мы еще вернемся.

Упрощая: BGP - это метод маршрутизации, который позволяет интернету функционировать. Без него вы бы не смогли выполнять поиск в гугле, даже посмотреть эту статью. Можно уверенно сказать, что BGP, наряду с DNS, являются самыми важными для Интернета протоколами.

Существует 2 типа BGP - **iBGP** для маршрутизации внутри сети, где _i_ обозначает **Internal** и **eBGP** для внешней (**External**) маршрутизации, хотя его обычно называют просто - BGP.

---

### Немного истории

Когда-то во всем интернете было всего лишь несколько сетей, связанных друг с другом статичными маршрутами. То есть админы вручную на роутерах прописывали маршрут до нужной сети - такой маршрут и называется статичным.

Но интернет недолго оставался маленьким. Стало появляться все больше и больше сетей, что потребовало динамического метода обмена информацией о маршрутах. Так появился EGP (Exterior Gateway Protocol) - протокол внешнего шлюза.

Это был простой протокол маршрутизации, который работал по древовидной иерархической топологии, то есть как веточки у дерева. Это когда чтобы добраться до точки **E** или **F**, **A** должен пройти через **B**, **C** и **D**.

![[Pasted image 20240122121650.png]]

Другими словами - при EGP, ни о какой интеллектуальной, как видосы на нашем канале, маршрутизации не могло быть и речи. И когда Интернет стал ещё больше, недостатки EGP стали очевидны всем. Так и появился BGP.

---

### Autonomous System

В самом начале мы обещали вернуться к автономным системам: так вот **Autonomous System** или _AS_ это сеть или набор подсетей, которые объединены общей внутренней политикой маршрутизации.

Внутри этих подсетей работает свой протокол маршрутизации, например **OSPF** или **EIGRP**. Это мы и называем внутренней политикой маршрутизации.

Автономными системами управляют отдельные организации, как правило - интернет-провайдеры, различные ВУЗы, коммерческие компании или крупные корпорации типа Google или Facebook.

Даже ты сейчас сидишь в какой-то AS. Вот например AS в которой находится наша база знаний _wiki.merionet.ru_.

![[Pasted image 20240122121703.png]]

Каждая AS имеет свой уникальный номер - **AS Number (ASN)** и диапазон IP адресов, то есть подсеть. А BGP обеспечивает обмен информацией о маршрутах между этими системами.

---

### BGP в деталях

Так как на BGP возложена великая задача – соединение автономных систем во всем Интернете, то он должен быть очень надежным. Так что в самом начале работы, BGP-маршрутизатор инициирует установление **TCP** сессии на **179** порт к своему соседу

Если TCP-сессия установлена успешно, то BGP-маршрутизаторы начинают обмен сообщениями **OPEN** в котором сообщают свои номер автономной системы (ASN), идентификатор маршрутизатора, который называется **RouterID** и **Hold timer**.

**Hold timer** это время, в течение которого будет поддерживаться TCP-сессия. Если одному роутеру что-то не понравится, например не совпадёт информация о номере AS, то сообщением **NOTIFICATION** он уведомит об этом своего соседа и сбросит TCP-сессию.

Соединение по BGP должно быть абсолютно согласовано администраторами автономных систем, желающих организовать стык.

![[Pasted image 20240122121727.png]]

Если, скажем, администратор **AS1** запустил процесс BGP на маршрутизаторе **R1** указав в качестве соседа **R2** и его ASN, а администратор **AS2** ничего не настроил, то TCP-сессия не поднимется и системы так и останутся несвязными. Да, все верно, администраторы настраивают BGP вручную.

Если же все условия соблюдаются, то маршрутизаторы, с определенным интервалом, начинают слать друг другу сообщения **KEEPALIVE**, означающие _“Я ещё жив и со мной можно работать!”_

Наконец, маршрутизаторы могут приступать к обмену маршрутной информацией по средствам сообщения **UPDATE**. Структура данного сообщения делится на две части:

- **Path Attributes (Атрибуты пути)** - здесь указывается из какой AS поступил маршрут, его происхождение и следующий маршрутизатор для данного пути.
- **NRLI (Network Layer Reachability Information)** - здесь указывается информация о сетях, которые нужно добавить в таблицу маршрутизации, т.е IP-адрес сети и ее маска.

Сообщение **UPDATE** будет передаваться каждый раз, когда один из маршрутизаторов получит информацию о новых сетях, а сообщение **KEEPALIVE** на протяжении всей TCP-сессии.

BGP принимает решения о наилучшем пути на основе текущей сложности маршрута, количестве _хопов_ (то есть точек маршрутизации) и других характеристик пути. BGP анализирует все данные и устанавливает одного из своих соседей в качестве следующей остановки для пересылки пакетов в определенную сеть.

Каждый узел управляет таблицей со всеми известными ему маршрутами для каждой сети и передает эту информацию своим соседним автономным системам. Таким образом, BGP позволяет роутерам собирать всю информацию о маршрутизации из соседних автономных систем и далее анонсировать эту информацию соседям.

Именно таким образом и работает маршрутизация во всем Интернете.

Сбои в работе BGP ни раз приводили к недоступности целых частей Интернета. Помнишь как в октябре 2021 во всем мире прилёг Facebook, а с ним и остальные его сервисы - Instagram, WhatsApp?

Это случилось потому, что из-за ошибки инженеров, информация о маршрутах к серверам Facebook, которая рассылается, как ни странно, по протоколу BGP, была удалена, а это вызвало невозможность разрешения доменного имени Facebook по DNS. Дошло до того, что инженерам FB пришлось выпиливать двери в серверную, чтоб всё починить, потому что система пропусков тоже была завязана на их сервисы и не работала!