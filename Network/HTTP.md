
## 1. Жизненный цикл HTTP-запроса (HTTP Lifecycle)

При взаимодействии по протоколу HTTP всегда будет присутствовать клиент, который будет запрашивать услугу у сервера, а сервер будет возвращать ему результат.

![[Pasted image 20231002125402.png]]

Работа по протоколу HTTP производится одноразовыми запросами на которые высылается ответ.

**IP Resolving** - процесс определения IP адреса устройства по доменному имени сайта

![[Pasted image 20231002133637.png]]

> `.` - это корневой сервер, адрес которого должен быть известен всем (на самом деле серверов хранящих информацию обо всех глобальных именах **13**)

DNS сервера могут кешировать запросы, чтобы снизить нагрузку на корневые сервера.

**Подключение к портам**

Чтобы обратиться к процессу(службе) web сервера определенного компьютера, на котором может работать несколько разных процессов осуществляющих взаимодействие с клиентами по сети, используются системы виртуальных портов которыми управляет операционная система. Работающий процесс может попросить ОС забронировать один из портов (от 1 до 65535), при этом на одном порту не может быть несколько процессов.

![[Pasted image 20231002134748.png]]

Теперь при подключении к серверу необходимо использовать связку `ip-адрес:порт`
по умолчанию используются 80 порт для `http` и 443 порт для `https`

Итак нам нужно подключится к 80 порту удаленного сервера, для этого клиент:
1. Запрашивает у ОС свободный порт для сетевого взаимодействия
2. Инициирует соединение с локального порта на 80 порт удаленного сервера, путем отправки запроса, содержащего информацию о получателе(`ip-адрес:порт` удаленного сервера) и отправителе(`ip-адрес:порт` клиента)
3. Сервер отвечает на этот запрос клиенту, что готов к подключению

Такой процесс обмена служебным сообщениями называется "**рукопожатием**", после завершения рукопожатия, соединение считается установленным. Теперь процесс на клиенте может отправить запрос к серверу по протоколу `http`

```http
GET / HTTP/1.0
```

и получить ответ.

![[123.gif]]

Протокол `http` версии 1.0 не предполагает удержание соединения и работает по принципу одноразовых запросов и ответов

В `http` версии 1.1 реализована возможность последовательной отправки нескольких запросов посредством одного подключения.

В `http` версии 2 была реализована возможность передачи запросов и ответов в более оптимальном бинарном формате и дали возможность мультиплексировать запросы (в одном запросе браузер может помещать несколько маленьких запросов, а сервер может также упаковывать ответы)

![[Pasted image 20231003161212.png]]

## 2. Структура HTTP-запроса и ответа

Методы **GET**, **HEAD** и **OPTIONS** служат только для получения информации, поэтому эти методы называются **безопасными** (такие запросы можно отправлять сколько угодно раз и безопасно кешировать). 

Если запрос несколько раз отправляется на сервер и после таких повторных запросов на сервере ничего не изменяется то такие методы являются **идемпотентными** (**GET**, **HEAD**, **OPTIONS**, **PUT**, **DELETE**)

Если запрос несколько раз отправляется на сервер и после таких повторных запросов данные сервера изменяются то такой запрос **не является идемпотентным**. (**POST**, **PATCH**)

- **GET** (Чтение)
- **POST** (Добавление в коллекцию)
- **PUT** (Поместить в коллекцию на позицию, Заменить)
- **PATCH** (Редактировать)
- **DELETE** (Удалить)
- **CONNECT**
- **TRACE**
- **OPTIONS** (Список методов для ресурса)

**Статусы HTTP ответов**:

- **2XX** - Success
- **3XX** - Redirection
- **4XX** - Client Errors
- **5XX** - Server Errors

Адрес по которому мы обращаемся к серверу называется **унифицированным идентификатором ресурса (URI)**

![[Pasted image 20231004105903.png]]

Если мы хотим отправить запрос с дополнительными параметрами их следует перечислять в URI после символа `?` через разделитель `&`

![[Pasted image 20231004110515.png]]

Сервер может отправлять параметр **Connection: close** если не хочет чтобы соединение использовалось много раз (т.о. клиент закроет соединение получив такой ответ), если же сервер позволяет использовать множественное соединение, то в ответе он вышлет набор параметров `Connection: keep-alive` и `Keep-Alive: timeout=<timeout>, max=<max connection>`

![[Pasted image 20231004114002.png]]

где:
- `timeout=<timeout>` - максимальное время жизни соединения, 
- `max=<max connection>` - максимальное число запросов, которое можно через него отправить
## 3. Заголовки для описания контента

HTTP - текстовый протокол, в нем все описывается простым текстом, но если серверу нужно передать ответ не содержащий текст (например: изображение, docx, pdf) он может указать тип передаваемого ответа переда заголовок `Content-Type`

![[Pasted image 20231004163549.png]]

так же заголовком `сharset` сервер может указать кодировку файла

![[Pasted image 20231004163953.png]]

Чтобы клиент или сервер мог удостовериться в том что файл передан полностью существует заголовок `Content-Length`

![[Pasted image 20231005154455.png]]

Чтобы сервер мог автоматически на основе запроса клиента вернуть нужный тип файла  существует заголовок `Accept`

![[Pasted image 20231005155024.png]]

## 4. Состояние: Cookies и сессии

Сервер может попросить клиентский браузер сохранить у себя какое либо значение заголовком `Set-Cookie`

![[Pasted image 20231005165037.png]]

такие значения будут храниться до перезагрузки браузера (исключение Chrome), если же мы хотим хранить куки на протяжении определенного времени необходимо воспользоваться параметром `Expires` c указанием даты истечения

![[Pasted image 20231005165442.png]]

Можно также ограничивать область видимости таких значений, например для JavaScript:

![[Pasted image 20231005165844.png]]

по умолчанию браузер рассылает куки автоматически при отправки http запросов на сайт, но если необходимо отсылать куки, только при посещении определенной страницы можно указывать параметр `Path` c указанием URI страницы:

![[Pasted image 20231005171304.png]]

Вместо того, чтобы хранить данные на стороне клиента можно воспользоваться механизмом сессий - сервер средствами языка программирования может создать сессию(файл с идентификатором) и записать туда нужные данные, а в ответ клиенту послать куки с идентификатором сессии

![[Pasted image 20231005174027.png]]

таким образом у клиента не хранится кокой либо важной информации(и он не сможет подменить его), а только идентификатор сессии который он в каждом запросе отправляет на сервер

![[Pasted image 20231005174257.png]]

![[Pasted image 20231005174638.png]]

Вместо обычных файлов сессий, обычно используются базы данных для хранения сессий, а могут хранится в специальных базах (Redis, MemCache)

![[Pasted image 20231005175009.png]]

![[Pasted image 20231005175253.png]]

## 5. Способы аутентификации

При разграничении доступа сервер может посылать ошибки **401 Unauthorized** с указанием ожидаемого способа аутентификации (параметр `WWW-Authenticate`)

**Basic auth** - поддерживают все браузеры "из коробки"

![[Pasted image 20231016102814.png]]

при вводе данных аутентификации, браузер отправит на сервер следующий запрос:

![[Pasted image 20231016103554.png]]

с http заголовком `Authorization`: где `Basic` - метод аутентификации, а последующий набор символов - строка закодированная методом `base64`, содержащая имя пользователя и пароль разделенные `:` 

Недостатки:
- данные передаются в открытом виде (`base64` легко декодируется)
- каждый запрос браузера к таким ресурсам должен содержать заголовок `Authorization` с именем пользователя и паролем, а сервер должен каждый такой запрос декодировать и сверять, что занимает какое-то время

**Bearer Auth**

После ввода логина и пароля генерируется случайный токен и в следующих запросах он используется для аутентификации

Данный метод не поддерживается браузерами! Реализуется средствами языка программирования!

![[Pasted image 20231016113343.png]]

Пользователь отправляет на сервер логин и пароль, сервер находит пользователя по имени и достаёт его `id`, генерирует случайный токен и дату его истечения, затем эти данные сохраняются на сервере, а браузеру клиента высылается токен для последующих авторизации (браузер или мобильное приложение могут его сохранить для повторного использования). В следующих запросах клиент будет посылать http запросы с заголовком `Authorization: Bearer <token>`

![[Pasted image 20231016113842.png]]

**OAuth** - стандарт аутентификации по токенам, все запросы\ответы проходят по определенной спецификации, описанной в протоколе `OAuth`

![[Pasted image 20231016114741.png]]

Основная проблема заключается в том, что токены быстро истекают и пользователю придется заново вводить данные авторизации, для этого в `OAuth2` предусмотрена генерация дополнительного токена. Для использования этого метода клиенту необходимо передать параметр `mode` со значением `offline`, в ответ на это браузер вышлет дополнительный `refresh_token`, который обычно действует более длительное время

![[Pasted image 20231016140756.png]]

По истечению основного токена авторизации, клиент может отправить запрос с параметром `grant_type: refresh_token` и сам `refresh_token` на сервер, который вернёт новый `access_token` и новый `refresh_token`

![[Pasted image 20231016141210.png]]

**Session Auth**

Используется встроенный механизм сессий: клиент передает в запросе логин и пароль, сервер создает сессию и высылает клиенту `SESSION_ID`

![[Pasted image 20231017111100.png]]
## 6. Управление кэшированием

Cache - временное копирование информации с целью последующего её переиспользования, существует несколько типов кэша:
- публичный (например прокси-сервер)
- приватный (например браузер)

![[Pasted image 20231017113016.png]]

Сервер может указать http заголовок `Cache-Control` с параметром `no-store`, если не требуется кэшировать передаваемую информацию, полный набор параметров для запрета кэширования:

```
Cache-Control: no-cache, no-store, must-revalidate
```

- параметр `no-cache` позволяет браузеру сохранять ответ в кэш в служебных целях, но при этом не показывать данные из кеша
- параметр `no-store`
- параметр `must-revalidate` - указывает клиенту на необходимость проверки на `Last-Modified`

Так же сервер может указать на какое время нужно кешировать ответ с помощью параметра `max-age` указываемого в секундах. Например, для кеширования на 1 час.

```
Cache-Control: max-age=3600
```

Для разных типов кеша предусмотрены разные параметры `Cache-Control`:

- публичный `Cache-Control: public, max-age=3600`
- приватный `Cache-Control: private, max-age=3600`

Помимо заголовка `Cache-Control` для кеша важен заголовок `Last-Modified` который показывает когда в последний раз страница была модифицирована

```
Last-Modified: Mon, 29 Jun 2018 02:02:02 GMT
```

Таким образом клиент может проверить изменилась ли страница или нет посылая запрос с заголовком `If-Modified-Since` и если страница не изменилась сервер отвечает заголовком `304 Not Modified`

![[Pasted image 20231017130433.png]]

Если же страница поменялась то сервер вышлет её с измененным заголовком `Last-Modified`
## 7. Кроссдоменные запросы (CORS)

**Cross-Origin Resource Sharing** - разделение ресурсов разных сайтов друг с другом

Браузеры позволяют выполнять код JavaScript. полученный с html страницей и, если, такой JavaScript код будет обращаться на другой домен, отличный от того домена с которого получен ответ, то браузер заблокирует его:

![[Pasted image 20231017134110.png]]

У любого браузера в целях безопасности существует политика **Same Origin Policy**(политика работы с одного или разных сайтов), в реализации этой политики прописан полный доступ к ресурсам сайта с которого получена html страница(ответ)
**Same Origin Policy** включает:
- XMLHttpRequest & Fetch API 
- Web Fonts 
- WebGL Textures 
- Canvas drawImageQ

По этой политике браузер считает безопасными:
1. Методы:
- GET
- HEAD
- POST
2. Заголовки:
- Connection, User-Agent, Content-Length,... 
- Accept
- Accept-Language
- Content-Language
- Content-Type
	- application/x-www-form-urlencoded 
	- multipart/form-data 
	- text/plain 
- Last-Event-ID

Если же мы работаем по методу **Cross Origin** (т.е. со своего сайта делаем запрос к ресурсам другого) применяется CORS политика, которая блокирует такие запросы.

По политике CORS все нижеперечисленные сайты разные:
- https://example.com
- https://exchangeratesapi.io
- https://api.example.com
- https://example.com:81
- http://example.com

Если же браузер посылает запрос, который выходит за рамки безопасных методов и заголовков, то отсылка запроса происходит по методу подготовительного запроса:
- отправляется `OPTIONS` запрос, который позволяет получить с сервера ответ: принимает ли он подключения с адреса origin или нет, а так же доступные методы для этого ресурса

![[Pasted image 20231017173413.png]]

В заголовках `Access-Control-Request-Method: POST` и  `Access-Control-Request-Headers: Content-Type` браузер запрашивает у сервера методы и заголовки отличающиеся от безопасных. Если ответ сервера (`Access-Control-Allow-Origin`,
`Access-Control-Allow-Methods`, `Access-Control-Allow-Headers`) совпадает, браузер
отсылает следующий запрос, который содержит оригинальный запрос из JavaScript

![[Pasted image 20231017173811.png]]
если же ответы сервера не совпали браузер заблокирует запрос JavaScript

![[Pasted image 20231017174047.png]]

## 8. Заголовки безопасности

**Очистка `cookies` с сервера:**
- `Clear-Site-Data: 'cookies'` - браузер удалит все `cookies` данного сайта
- `Clear-Site-Data: 'storage'` - браузер удалит локальное хранилище данного сайта
- `Clear-Site-Data: 'cache'` - браузер удалит кэш сайта
- `Clear-Site-Data: 'executionContexts'` - браузер удалит информацию обо всех открытых контекстах соединений (открытых JavaScript)
- `Clear-Site-Data: '*'`- браузер удалит всю информацию

**Переход на другие домены(сайты)**

При переходе по ссылкам браузер может передавать информацию о том с какой страницы был осуществлен переход за это отвечает заголовок `Referer`

```
Referer: https://example.com/terms
```

если нужно указать браузеру не передавать заголовок `Referer` - нужно в ссылке указать параметр `rel="noreferrer noopener"`

```
<a rel="noreferrer noopener” href="https://google.com">Google</a>
```

так же можно указать заголовок `Referrer-Policy`

```
Referrer-Policy: same-origin
```

в этом случае `referrer` не будет передаваться на внешние сайты

**Флаг `Secure`**

Если сервер указывает флаг `Secure`, то в данном случае сервер указывает что куки ему нужно передавать только по https и не передавать по http
![[Pasted image 20231018110349.png]]

**Content Security Policy**

Заголовок позволяет переопределить политику браузера по-умолчанию

```
Content-Security-Policy: block-all-mixed-content;
```

Запрещает загружать скрипты, изображения и т.п. по незащищенному протоколу http

Все возможные значения `Content-Security-Policy`:
- default-src
- child-src
- connect-src
- font-src
- form-action
- frame-ancestors
- frame-src
- sandbox
- img-src
- manifest-src
- media-src
- script-src
- style-src
- block-all-mixed-content
- upgrade-insecure-requests
- report-to
## 9. Дополнительные заголовки

**`Server`** - Заголовок сервера

```
Server: nginx/1.14.2 
```

**`X-Powered-By`** - Заголовок ЯП на сервере(небезопасно)

```
X-Powered-By: PHP/7.1.25
```

**`Content-Encoding`** - сжатие контента


```
# Клиент сообщает какие алгоритмы сжатия поддерживает
Accept-Encoding: gzip, deflate, br

# Сервер сжимает контент доступным клиенту алгоритмом и посылает ответ
Content-Encoding: gzip
```

**Do Not Track** - запрет отслеживания(на клиенте)

```
DNT: 1
```
## 10. Собственные HTTP заголовки

