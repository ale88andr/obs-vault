###  TCP IP – уровни сетевой модели

![[Pasted image 20240606092932.png]]

Уровневая архитектура TCP/IP описана в документе RFC 1122

### Канальный уровень

На аппаратном уровне (Link Layer) определены правила взаимодействия сетевого оборудования между собой. Для передачи той или иной информации между хостами она должна быть поделена на пакеты и передана по нужному каналу связи.

На канальном уровне сетевой модели TCP/IP определены физические свойства среды обмена информацией:

- максимальное расстояние, на которое передаются пакеты;
- частота сигнала;
- время задержки ответа.

Наиболее часто на канальном уровне используется протокол Ethernet.

### Межсетевой уровень

Межсетевое взаимодействие — это основной принцип построения интернета. Локальные сети по всему миру объединены в глобальную, а передачу данных между этими сетями осуществляют магистральные и пограничные маршрутизаторы.

Именно на межсетевом уровне функционирует протокол IP, позволивший объединить разные сети в глобальную.
### Транспортный уровень

Transport Layer берет на себя функцию контроля доставки пакетов. На этом уровне работают протоколы TCP и UDP. Первый устанавливает соединение между двумя хостами и гарантирует предоставление информации в полном объеме. Если во время передачи часть информации была утеряна, протокол запрашивает ее повторно, таким образом у адресата есть полный пакет данных, собранный в нужном порядке.

Протокол UDP не устанавливает соединение между хостами, а передает автономные датаграммы. В процессе передачи часть из них может быть утеряна, проверка целостности информации не производится. UDP используется в случаях, когда требуется снизить нагрузку на сеть, а потеря какой-то доли информации не является критичной для адресата, например, при воспроизведении потокового видео.

### Прикладной уровень

Applicatopn Layer объединяет три уровня сетевой модели OSI: сеансовый, уровень представления и прикладной. На прикладном уровне происходит поддержание сеанса связи между хостами, преобразование передаваемых данных, работа с конечным пользователем и сетью.
HTTP для передачи гипертекста по сети, почтовые клиенты — SMTP для передачи почты, FTP-клиенты — протокол FTP для передачи файлов, службы DHCP — протокол назначения IP-адресов DHCP и так далее.

## Уровни модели OSI

Вот уровни модели OSi сверху вниз, с указанием функций и PDU (блоки данных протокола) для уровней 1−4:

7. **Прикладной** (application). Доступ к сетевым службам

6. **Представления** (presentation). Представление и шифрование данных

5. **Сеансовый** (session). Управление сеансом связи. 

4. **Транспортный** (transport). Прямая связь между конечными пунктами и надёжность. Сегменты и датаграммы

3. **Сетевой** (network). Определение маршрута и логическая адресация. Пакеты

2. **Канальный** (data link). Физическая адресация. Кадры (фреймы)

1. **Физический** (physical). Работа со средой передачи, сигналами и двоичными данными. Биты, символы

![[Pasted image 20240604130743.png]]

### Решение проблем в сети

#### 1. Шаг
Необходимо проверить корректно ли настроены сетевые интерфейсы на диагностируемой машине, имеется ли информация о дефолтном маршруте, DNS?. Для Windows систем вам поможет `ipconfig /all`. Пример:

![[Pasted image 20240604131346.png]]

Аналогичную информацию, но для Linux систем можно получить введя команды: **ip a** (информация о сетевых интерфейсах), **ip r** (таблица маршрутизации), **ip n** (arp таблица), **cat /etc/resolv.conf** (информация об используемых DNS).
#### 2 Шаг

На втором шаге проверяем доступен ли стандартный шлюз (default gateway) и правильно ли маршрутизируется трафик (при условии нескольких шлюзов в одном сегменте):

![[Pasted image 20240604131514.png]]

При проверке стандартного шлюза необходимо учитывать, что в таблице маршрутизации конечного хоста могут присутствовать и **статические маршруты**, переопределяющие шлюз по умолчанию для конкретных сетей. Понять есть ли статика можно опять же заглянув в раздел **"Постоянные маршруты"** вывода команды `route print`:

![[Pasted image 20240604131551.png]]

Команды `route print` и `ip r` по сути являются аналогами команд типа `show ip route` (**в синтаксисе cisco)** и выводят все содержимое таблицы маршрутизации. Однако есть более удобный способ выяснить (перепроверить) куда будет направляться трафик в зависимости от адреса назначения:

Для Windows в **PowerShell**:

![[Pasted image 20240604131740.png]]

**Для Linux:**

![[Pasted image 20240604131758.png]]

Команда **ip route get** позволяет получить ответ через какой шлюз будет маршрутизироваться трафик.

Данный способ гораздо проще, особенно в случаях перегруженной логики маршрутизации на хосте когда используется несколько шлюзов в одном сегменте или задействованы метрики, определяющие приоритет в зависимости от некоторых условий.

В целом для проверки первого хопа можно использовать и команду **traceroute -d -h <адрес назначения>** для Windows:

![[Pasted image 20240604131831.png]]

параметр **-d** - Без разрешения в имена узлов.
параметр **-h** - Максимальное число прыжков при поиске узла.Нас не интересует трассировка всей цепочки, а только первый хоп. Для этого мы и передаем параметру **-h** значение - 1

для **Linux:**

![[Pasted image 20240604131956.png]]

параметр **-n** - Без разрешения в имена узлов.
параметр **-p** - Максимальное число прыжков при поиске узла.
#### 3 Шаг

Необходимо проверить есть ли у нас связность между клиентом и сервером. Под связностью я понимаю, что на всем пути от первого хопа по последнего у нас есть маршрутная информация. В данном случае нам поможет `tracert/tracepath`:

![[Pasted image 20240604132109.png]]

На втором скрине мы видим, что узел с IP `10.89.60.220` ничего не знает об адресе `10.0.0.34`.

> Наличие сообщения "Превышен интервал ожидания для запроса" в середине трассировки еще не говорит о том, что маршрута нет. Просто возможно на узле отключена поддержка ICMP.
> ![[Pasted image 20240604132203.png]]
> C 8 по 16 хопы не поддерживают ICMP. Таким образом транзитные провайдеры могут скрывать маршрутную информацию. Однако самый последний хоп (сервер DNS) таки ответил.

Утилиты типа **tracert/tracepath** дают представление о том как в конкретный момент времени будет следовать пакеты от хоста источника к хосту назначения.

> Если вы с столкнулись с ситуацией при которой наблюдается потеря пакетов (packet loss) и у вас есть подозрение, что это происходит где-то на транзитных участках, то тут потребуется применить более изощренную утилиту типа MTR (My Traceroute) . MTR задействует такой параметр как RTT (Round trip time). Встроенные механизмы утилиты и небольшой объем знаний как правильно интерпретировать ее вывод позволят вам локализовать проблемный участок. 

#### **4 Шаг**

- На 1-м шаге мы проверяли все ли верно настроено на нашей стороне (на клиенте);
- На 2-м шаге мы разобрались с тем куда трафик пойдет с нашего хоста (первый хоп);
- На 3-м шаге мы проверили связность между клиентом и сервером на L3 уровне.

Переходим на уровень L4 - транспортный (TCP/UDP). Для проверки TCP сокета обычно используется **telnet** (Да! Та самая не безопасная утилита, если ее использовать для удаленного управления железом. А вот в качестве диагностического инструмента она в самый раз!)

Проверим устанавливается ли у нас соединение по **telnet.**

Команда: `telnet 172.17.74.64 80`

Если соединение не устанавливается. Как понять в чем причина? Причин может быть несколько: закрыт порт на межсетевом экране, не запущенна служба, прослушивающая порт 80.

Подход к диагностики будет отличаться, в зависимости от того куда у вас есть доступ.

Предположим у вас есть доступ к серверу на котором должна быть активна служба `http`, тогда можно проверить активна ли служба командой `netstat -tunlp | grep 80` (Для Linux систем). Если результат выполнения данной команды нулевой, то на 80 порту нет слушающих служб. Если же картина такая, то служба в готовности принять входящий запрос:

![[Pasted image 20240604132633.png]]

Состояние **"LISTEN"** означает, что демон **httpd** с PID (Process ID) №25674 слушает входящие запросы на 80-м порту. Если не отфильтровывать вывод утилитой grep, то можно увидеть все прослушиваемы порты и их службы:

Понять где именно "режется доступ" можно используя **tcpdump** или **wireshark**. Первый для **Linux** систем, второй для **Windows**.

Запустив на нашем хосте, с которого мы инициируем подключение по http wireshark, то мы увидим следующую картину:

![[Pasted image 20240604132756.png]]

С нашей колокольни все выглядит так, как-будто сервер с IP адресом 172.17.74.64 режет нашу попытку подключения (флаг **RST**, в поле info). Но так ли это? Давайте я вам расскажу как это понять. Для этого нам придется препарировать 41-й пакет нашего дампа и заглянуть в заголовок сетевого уровня:

![[Pasted image 20240604132906.png]]

Нас будет интересовать поле **"Time to live (TTL)"**:

![[Pasted image 20240604132931.png]]

В нашем случае значение поля = 64. Это начальное значение TTL.

Данное значение уменьшается на 1 каждый раз когда пакет передается следующему узлу. Т.е. можно смело сказать, что пакет №41 с флагом RST прислал нам наш шлюз (FW), а не удаленный сервер.

Теперь рассмотрим такой вывод:

![[Pasted image 20240604133042.png]]

В данном случае TTL=63 и это говорит о том, что пакет TCP сессии успешно прошел транзитом через FW и режется на втором хопе. Сколько всего хопов мы уже умеем вычислять, но есть и альтернативная команда на Windows серверах - **pathping:**

![[Pasted image 20240604133106.png]]


> Всегда нужно помнить, что фильтрация трафика может происходить не только на специальных устройствах (межсетевых экранах), но и непосредственно на уровне пакетных фильтров, встроенных в ядра операционных систем и управляемых специальными утилитами наподобие **Iptables.**

Пример tcpdump в linux

```
tcpdump -i ens257 host 109.248.140.254 and port 64905 -n -w dump.pcap
```

