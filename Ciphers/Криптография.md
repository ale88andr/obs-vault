                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
**Криптография** -	наука о математических методах обеспечения конфиденциальности, аутентичности и целостности информации.
**Шифр** -	множество обратимых преобразований исходного текста в зашифрованный.
**Ключ** - параметр, определяющий выбор конкретного преобразования. Секретность ключа гарантирует нераскрываемость шифра.

```
Y = Ek (X)
```

`X` - исходный текст
`Y` - шифрованный текст
`Ек (X)` - криптографическое преобразование

### Требования к шифрам (криптосистемам)
- (!) Стойкость криптосистем должна быть основана на секретности ключа (но не секретности алгоритма).
- Длина ключа должна исключать перебор за приемлемей время приемлемыми ресурсами (обычный компьютер - 2<sup>40</sup>-2<sup>60</sup> ключей, суперкомпьютер 2<sup>70</sup>-2<sup>80</sup>)
- Шифр должен обеспечивать защиту, даже при атаке на выбранную пару «ИТ-ШТ»
- Малые изменения ключа или ИТ должны приводить к значительным изменениям зашифрованного текста (или ЭП).
- Алфавит ИТ и ШТ должны совпадать, шифр не должен изменять длину текста

# 1. Блочные шифры

**Блок** - n-разрядная двоичная последовательность

Например - исходный текст:

```
X = 110011011011
```

Будем использовать длину блока равной 3 (Nb=3)

Т.е. исходный текст  разделим на блоки длинной по 3 бита и заменим блоки открытого текста на блоки шифрованного :

```
X = 110_011_011_011
```

Чем больше длинна блока тем больше разнообразие таблицы подстановки: если при длине блока = 3, кол-во вариантов подстановки будет 2<sup>3</sup> = 8, то при длине блока = 64, , кол-во вариантов подстановки будет 2<sup>64</sup> = 18446744073709551

> Шифрование в блочных шифрах реализуется с помощью **итерационных** алгоритмов

## 1.1 SP-сеть

Цепочка преобразований над блоками, состоящая из последовательности примитивных криптографических операций:

1. подстановка (s) [substitution]
2. перестановка (p) [permutation]
3. добавление ключа (a) [add]

![[Pasted image 20250428223316.png]]

1. **подстановка**:
- таблица подстановки 

| Исходный блок | Подстановочный блок |
| ------------- | ------------------- |
| 001           | 010                 |
| 010           | 011                 |
| ...           | ...                 |
| 111           | 000                 |

- инверсия

| Исходный блок | Инверсия блока |
| ------------- | -------------- |
| 0101          | 1010           |
| 0001          | 1110           |

2. **перестановка**:

Циклический сдвиг(куда, на сколько)  - поддерживается аппаратно всеми процессорами, т.к. умножение на 2 - это и есть сдвиг

при Nb=4

Циклический сдвиг на 1 разряд влево

| Исходный блок | Сдвиг блока |
| ------------- | ----------- |
| 0001          | 0010        |
| 0010          | 0100        |

3. **добавление ключа**

Поразрядное сложение по модулю 2 (+):

| Исходный биты | Сложение |
| ------------- | -------- |
| 0 (+) 0       | 0        |
| 0 (+) 1       | 1        |
| 1 (+) 0       | 1        |
| 1 (+) 1       | 0        |

- примитивная и очень быстрая операция (1 такт)
- `X (+) X = 0`

Шифрование

```
X (+) K = Y
```

Расшифрование

```
Y (+) K = X
```

или

```
Y (+) K = X (+) K (+) K = X
```

X = 0011
(+)
K = 0101

Y = 0110

# Задача
Зашифровать данные (`X` = `1001`) блочным шифром (блок по 4 бита Nb=4) используя:
- `s` - инверсия
- `p` - циклический сдвиг влево
- `a` - сложение (`k` = `0101`)
в 2 раунда

### Раунд 1

| Преобразование                | Исходные данные | Преобразованные данные |
| ----------------------------- | --------------- | ---------------------- |
| `s` - инверсия                | `1001`          | `0110`                 |
| `p` - циклический сдвиг влево | `0110`          | `1100`                 |
| `a` - добавление ключа        | `1100` + `0101` | `1001`                 |
X<sub>1 раунд</sub> = `1001`

### Раунд 2

| Преобразование                | Исходные данные | Преобразованные данные |
| ----------------------------- | --------------- | ---------------------- |
| `s` - инверсия                | `1001`          | `0110`                 |
| `p` - циклический сдвиг влево | `0110`          | `1100`                 |
| `a` - добавление ключа        | `1100` + `0101` | `1001`                 |
X<sub>2 раунд</sub> = `1001`

## 1.2 Сеть Фейстела

Суть данного метода заключается в том, что блок данных разбивается на 2 подблока

```
X = (A | B)
```

и помещаются в два регистра(ячейки памяти)

| Регистр 1 | Регистр 2 |
| --------- | --------- |
| `A`       | `B`       |

и преобразуется следующим образом:

> Функция `F` - это однораундовая SP-сеть (3-4 преобразования)

| Регистр 1 | Регистр 2    |
| --------- | ------------ |
| `B`       | `A (+) F(B)` |

Это является одним раундом сети Фейстеля

Второй раунд будет выглядеть следующим образом:

| Регистр 1 | Регистр 2    |
| --------- | ------------ |
| `B`       | `A (+) F(B)` |
преобразование

| Регистр 1    | Регистр 2             |
| ------------ | --------------------- |
| `A (+) F(B)` | `B (+) F(A (+) F(B))` |
### Пример

`X` = `010101` , кол-во блоков (`Nb` = 6), кол-во раундов (`Nr` = 2)

| Регистр 1 | Преобразование     | Регистр 2 |
| --------- | ------------------ | --------- |
| `010`     |                    | `101`     |
| `101`     | `010` (+) `F(101)` | `001`     |

