
В Linux пользователи организованы в группы. Эти группы определяют разрешения и права доступа, которые у пользователя есть.

Команда `id`. Это отличный способ узнать, к каким группам вы принадлежите.

```
id
uid=5000(labex) gid=5000(labex) groups=5000(labex),27(sudo),121(ssl-cert),5002(public)
```

Вот разбор:

- `uid`: Ваш идентификатор пользователя (уникальный числовой идентификатор).
- `gid`: Идентификатор вашей основной группы.
- `groups`: Все группы, членом которых вы являетесь.

Также можно использовать команду `id` для поиска информации о других пользователях. 

```
id root
uid=0(root) gid=0(root) groups=0(root)
```

# Системный монитор htop

Он похож на приборную панель, которая дает вам реальное представление о том, что происходит внутри вашего компьютера.

```
htop
```

![[Pasted image 20250519110233.png]]

`htop` показывает:

1. Верхняя часть: Использование ЦП и памяти, а также время работы компьютера (uptime).
2. Средняя часть: Список всех запущенных программ (процессов).
3. Нижняя часть: Опции для взаимодействия с `htop`.

Используйте стрелки на клавиатуре для навигации.

# Менеджер пакетов apt

`apt` - это широко используемый менеджер пакетов для систем на основе Debian, таких как Ubuntu. Сначала обновим список доступных пакетов. Это гарантирует, что мы устанавливаем последнюю версию пакета.

Далее мы используем `sudo apt install` для установки `htop`:

- `sudo`: сокращение от "*SuperUser DO*". Он позволяет выполнять команды с правами администратора (времено).
- `apt`: инструмент для установки и управления программным обеспечением.
- `install`: сообщает `apt`, что мы хотим установить программу.
- `htop`: конкретная программа, которую мы хотим установить.

# Понимание рабочей среды

В Linux каждый пользователь обычно имеет "домашний каталог", обозначаемый символом `~`. 

Определение текущего местоположения

```
pwd
```

`pwd` расшифровывается как "print working directory" (вывести текущий рабочий каталог). Эта команда отображает ваше текущее местоположение в файловой системе.

```
echo ~
```

Эта команда отобразит путь к вашему домашнему каталогу

Чтобы посмотреть содержимое текущего каталога, используйте:

```
ls
```

Эта команда выведет список файлов и каталогов в текущем рабочем каталоге

**Создадим несколько файлов**:

```
touch file1.txt
```

Команда `touch` используется для создания пустого файла. Если файл уже существует, эта команда обновляет временную метку файла без изменения его содержимого.

```
echo "Hello, Linux" > file2.txt
```

Эта команда выполняет две задачи:

- `echo` - это команда, которая выводит текст.
- Символ `>` перенаправляет вывод команды `echo` в файл с именем `file2.txt`. Если файл не существует, он будет создан. Если файл уже существует, его содержимое будет заменено.

```
echo "Hidden file" > .hiddenfile
```

Эта команда создает скрытый файл. В Linux любой файл или каталог, имя которого начинается с точки (`.`), считается скрытым.

**Теперь создадим каталог**:

```
mkdir testdir
```

Команда `mkdir` (сокращение от "make directory" - создать каталог) создает новый каталог с именем `testdir`.

**Подробный просмотр содержимого**:

```
ls -l
```

Опция `-l` предоставляет вывод в "длинном" формате. Вы увидите дополнительные сведения, такие как права доступа к файлу, владелец, размер и дата изменения.

Показать скрытые файлы:

```
ls -a
```

Эта команда покажет все файлы, включая скрытый файл `.hiddenfile`, который мы создали.

Комбинирование опций

```
ls -la
```

Эта команда комбинирует длинный формат вывода (`-l`) с показом всех файлов (`-a`).

Просмотр содержимого конкретного каталога:

```
ls -l testdir
```

# Копирование файлов и каталогов

Теперь, когда у нас есть файлы, с которыми можно работать, давайте научимся их копировать:

1. Скопировать файл:

```
cp file1.txt file1_copy.txt
```

Эта команда создает копию файла `file1.txt` с именем `file1_copy.txt` в текущем каталоге.

2. Скопировать файл в другой каталог:

```
cp file2.txt testdir/
```

Эта команда копирует файл `file2.txt` в каталог `testdir`.

3. Скопировать каталог

```
cp -r testdir testdir_copy
```

Опция `-r` расшифровывается как "рекурсивно" (recursive). Она обязательна при копировании каталогов, чтобы скопировать все их содержимое.

# Перемещение и переименование файлов и каталогов

В Linux команда `mv` используется как для перемещения, так и для переименования:

```
mv file1.txt newname.txt
```

Эта команда переименовывает файл `file1.txt` в `newname.txt`.

Переместить файл в каталог:

```
mv newname.txt testdir/
```

Эта команда перемещает файл `newname.txt` в каталог `testdir`.

Переименовать каталог:

```
mv testdir_copy new_testdir
```

Эта команда переименовывает каталог `testdir_copy` в `new_testdir`.

Переместить и переименовать за один раз:

```
mv testdir/newname.txt ./original_file1.txt
```

Эта команда перемещает файл `newname.txt` из каталога `testdir` и переименовывает его в `original_file1.txt` в текущем каталоге.

# Удаление файлов и директорий

Удаление файлов и директорий – это мощная операция. В отличие от графических интерфейсов, командная строка часто не имеет "Корзины" (Recycle Bin). Удаления, выполненные с помощью `rm`, обычно необратимы.

Удаление одного файла:

```
rm original_file1.txt
```

Команда `rm` (сокращение от "remove" - удалить) удаляет файлы.

Удаление в интерактивном режиме (безопаснее):

Давайте попробуем удалить `file2.txt`, но на этот раз используя интерактивный флаг `-i`:

```
rm -i file2.txt
```

Опция `-i` запрашивает подтверждение перед удалением каждого файла. Введите `y` (для yes - да) и нажмите Enter, чтобы подтвердить удаление. Если вы введете `n` или что-либо другое, файл не будет удален.

Удаление пустой директории

```
rmdir new_testdir
```

`rmdir` (remove directory - удалить директорию) работает только с **пустыми** директориями.

Удаление непустой директории

```
rm -r testdir
```

Принудительное удаление:

Иногда может потребоваться удалить файлы без запроса, даже если они защищены от записи. Опция `-f` (force - принудительно) делает это.

```
rm -rf temp_dir
```

# Вывод содержимого файла

используем команду `cat` для отображения содержимого файла:

```
cat /tmp/hello
```

Вывод содержимого файла с номерами строк

```
cat -n /tmp/hello
```

**Вывод первых строк файла** - команда `head` используется для просмотра начала (или "головы") файла.

```
head -n1 /tmp/hello
```

Здесь `-n1` - это опция, которая сообщает команде `head` показать только первую строку. Число `1` можно заменить на любое другое, чтобы показать соответствующее количество строк.

По умолчанию, без опции `-n1`, команда `head` показывает первые 10 строк файла.

**Вывод последних строк файла**

```
tail -n1 /tmp/hello
```

# Сравнение файлов

Команда `diff` для сравнения двух файлов и нахождения различий между ними.

```shell
diff file1 file2
```

```shell
1c1
< this is file1
---
> this is file2
```

Этот вывод сообщает нам, что первая строка файла `file1` отличается от первой строки файла `file2`. Символ `<` показывает содержимое из файла `file1`, а символ `>` показывает содержимое из файла `file2`.

**Сравнение директорий**

```shell
diff -r ~/Desktop ~/Code
```

Опция `-r` сообщает команде `diff` рекурсивно сравнивать также поддиректории. `~/Desktop` и `~/Code` - это пути к двум директориям, которые мы сравниваем.

```shell
Only in /home/labex/Desktop: code.desktop 
Only in /home/labex/Desktop: gedit.desktop 
Only in /home/labex/Desktop: gvim.desktop 
Only in /home/labex/Desktop: xfce4-terminal.desktop
```

Этот вывод показывает, что в директории `Desktop` есть четыре файла, которых нет в директории `Code`.

# Создание нового файла

`touch` - универсальная команда может создавать новые пустые файлы и обновлять временные метки существующих.

```shell
touch example.txt
```

# Изменение владельца файла

Команда `chown` позволяет нам изменить как пользователя - владельца файла, так и группу, которой он принадлежит. Владелец определяет, кто имеет контроль над файлом.

Сначала проверим текущего владельца нашего файла `example.txt`:

```shell
ls -l example.txt
```

```shell
-rw-rw-r-- 1 user user 0 Jul 29 15:11 example.txt
```

Разберем этот вывод:

1. `-rw-rw-r--` представляет права доступа к файлу (мы более подробно рассмотрим это на шаге 4). Первый символ указывает на тип файла ( `-` для обычного файла, `d` для директории и т.д.). Остальные символы представляют права на чтение, запись и выполнение для владельца, группы и других пользователей.
2. Первое `user` - это текущий владелец файла. Это имя пользователя, которому принадлежит файл.
3. Второе `user` - это текущая группа файла. Группа - это набор пользователей, которые могут разделять права доступа.
4. `0` - размер файла в байтах. Поскольку файл пуст, его размер равен нулю.
5. `Jul 29 15:11` - дата и время последнего изменения.
6. `example.txt` - имя файла.

Теперь изменим владельца файла на пользователя `root`. `root` - это административный аккаунт в системах Linux, который имеет специальные привилегии.

```shell
sudo chown root:root example.txt
```

Вот что делает эта команда:

- `sudo` запускает команду с привилегиями `root`. Вам, вероятно, будет предложено ввести пароль. Команда `chown` требует повышенных привилегий, так как это мощная команда, которая может повлиять на безопасность системы. Без `sudo` вы получите ошибку "Permission denied" (доступ запрещен).
- `chown` - команда для изменения владельца.
- `root:root` - указывает нового владельца и группу (оба установлены на `root`). Синтаксис: `owner:group` (владелец:группа).
- `example.txt` - целевой файл.

# Изменение владельца директории

Команда `chown` также может изменить владельца целых директорий и их содержимого. Давайте посмотрим, как это работает. Это особенно полезно для управления сложными структурами директорий, когда вы хотите, чтобы все файлы и поддиректории имели одного и того же владельца.

```shell
mkdir -p new-dir/subdir 
echo "Hello, world" > new-dir/file1.txt 
echo "Another file" > new-dir/subdir/file2.txt
```

Разберем эти команды:

- `mkdir -p new-dir/subdir` создает директорию `new-dir` и ее поддиректорию `subdir`. Опция `-p` сообщает команде `mkdir` создавать родительские директории по мере необходимости. Без `-p`, если директория `new-dir` не существовала, создание `new-dir/subdir` завершилось бы с ошибкой.
- `echo "Hello, world" > new-dir/file1.txt` создает файл с именем `file1.txt` внутри директории `new-dir` и записывает в него текст "Hello, world". Символ `>` используется для перенаправления; он берет вывод команды `echo` и перенаправляет его в указанный файл.
- `echo "Another file" > new-dir/subdir/file2.txt` аналогично создает файл с именем `file2.txt` внутри директории `new-dir/subdir` и записывает в него текст "Another file".

