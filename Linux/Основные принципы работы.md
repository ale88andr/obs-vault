
В Linux пользователи организованы в группы. Эти группы определяют разрешения и права доступа, которые у пользователя есть.

Команда `id`. Это отличный способ узнать, к каким группам вы принадлежите.

```
id
uid=5000(labex) gid=5000(labex) groups=5000(labex),27(sudo),121(ssl-cert),5002(public)
```

Вот разбор:

- `uid`: Ваш идентификатор пользователя (уникальный числовой идентификатор).
- `gid`: Идентификатор вашей основной группы.
- `groups`: Все группы, членом которых вы являетесь.

Также можно использовать команду `id` для поиска информации о других пользователях. 

```
id root
uid=0(root) gid=0(root) groups=0(root)
```

# Системный монитор htop

Он похож на приборную панель, которая дает вам реальное представление о том, что происходит внутри вашего компьютера.

```
htop
```

![[Pasted image 20250519110233.png]]

`htop` показывает:

1. Верхняя часть: Использование ЦП и памяти, а также время работы компьютера (uptime).
2. Средняя часть: Список всех запущенных программ (процессов).
3. Нижняя часть: Опции для взаимодействия с `htop`.

Используйте стрелки на клавиатуре для навигации.

# Менеджер пакетов apt

`apt` - это широко используемый менеджер пакетов для систем на основе Debian, таких как Ubuntu. Сначала обновим список доступных пакетов. Это гарантирует, что мы устанавливаем последнюю версию пакета.

Далее мы используем `sudo apt install` для установки `htop`:

- `sudo`: сокращение от "*SuperUser DO*". Он позволяет выполнять команды с правами администратора (времено).
- `apt`: инструмент для установки и управления программным обеспечением.
- `install`: сообщает `apt`, что мы хотим установить программу.
- `htop`: конкретная программа, которую мы хотим установить.

# Понимание рабочей среды

В Linux каждый пользователь обычно имеет "домашний каталог", обозначаемый символом `~`. 

Определение текущего местоположения

```
pwd
```

`pwd` расшифровывается как "print working directory" (вывести текущий рабочий каталог). Эта команда отображает ваше текущее местоположение в файловой системе.

```
echo ~
```

Эта команда отобразит путь к вашему домашнему каталогу

Чтобы посмотреть содержимое текущего каталога, используйте:

```
ls
```

Эта команда выведет список файлов и каталогов в текущем рабочем каталоге

**Создадим несколько файлов**:

```
touch file1.txt
```

Команда `touch` используется для создания пустого файла. Если файл уже существует, эта команда обновляет временную метку файла без изменения его содержимого.

```
echo "Hello, Linux" > file2.txt
```

Эта команда выполняет две задачи:

- `echo` - это команда, которая выводит текст.
- Символ `>` перенаправляет вывод команды `echo` в файл с именем `file2.txt`. Если файл не существует, он будет создан. Если файл уже существует, его содержимое будет заменено.

```
echo "Hidden file" > .hiddenfile
```

Эта команда создает скрытый файл. В Linux любой файл или каталог, имя которого начинается с точки (`.`), считается скрытым.

**Теперь создадим каталог**:

```
mkdir testdir
```

Команда `mkdir` (сокращение от "make directory" - создать каталог) создает новый каталог с именем `testdir`.

**Подробный просмотр содержимого**:

```
ls -l
```

Опция `-l` предоставляет вывод в "длинном" формате. Вы увидите дополнительные сведения, такие как права доступа к файлу, владелец, размер и дата изменения.

Показать скрытые файлы:

```
ls -a
```

Эта команда покажет все файлы, включая скрытый файл `.hiddenfile`, который мы создали.

Комбинирование опций

```
ls -la
```

Эта команда комбинирует длинный формат вывода (`-l`) с показом всех файлов (`-a`).

Просмотр содержимого конкретного каталога:

```
ls -l testdir
```

# Копирование файлов и каталогов

Теперь, когда у нас есть файлы, с которыми можно работать, давайте научимся их копировать:

1. Скопировать файл:

```
cp file1.txt file1_copy.txt
```

Эта команда создает копию файла `file1.txt` с именем `file1_copy.txt` в текущем каталоге.

2. Скопировать файл в другой каталог:

```
cp file2.txt testdir/
```

Эта команда копирует файл `file2.txt` в каталог `testdir`.

3. Скопировать каталог

```
cp -r testdir testdir_copy
```

Опция `-r` расшифровывается как "рекурсивно" (recursive). Она обязательна при копировании каталогов, чтобы скопировать все их содержимое.

# Перемещение и переименование файлов и каталогов

В Linux команда `mv` используется как для перемещения, так и для переименования:

```
mv file1.txt newname.txt
```

Эта команда переименовывает файл `file1.txt` в `newname.txt`.

Переместить файл в каталог:

```
mv newname.txt testdir/
```

Эта команда перемещает файл `newname.txt` в каталог `testdir`.

Переименовать каталог:

```
mv testdir_copy new_testdir
```

Эта команда переименовывает каталог `testdir_copy` в `new_testdir`.

Переместить и переименовать за один раз:

```
mv testdir/newname.txt ./original_file1.txt
```

Эта команда перемещает файл `newname.txt` из каталога `testdir` и переименовывает его в `original_file1.txt` в текущем каталоге.

# Удаление файлов и директорий

Удаление файлов и директорий – это мощная операция. В отличие от графических интерфейсов, командная строка часто не имеет "Корзины" (Recycle Bin). Удаления, выполненные с помощью `rm`, обычно необратимы.

Удаление одного файла:

```
rm original_file1.txt
```

Команда `rm` (сокращение от "remove" - удалить) удаляет файлы.

Удаление в интерактивном режиме (безопаснее):

Давайте попробуем удалить `file2.txt`, но на этот раз используя интерактивный флаг `-i`:

```
rm -i file2.txt
```

Опция `-i` запрашивает подтверждение перед удалением каждого файла. Введите `y` (для yes - да) и нажмите Enter, чтобы подтвердить удаление. Если вы введете `n` или что-либо другое, файл не будет удален.

Удаление пустой директории

```
rmdir new_testdir
```

`rmdir` (remove directory - удалить директорию) работает только с **пустыми** директориями.

Удаление непустой директории

```
rm -r testdir
```

Принудительное удаление:

Иногда может потребоваться удалить файлы без запроса, даже если они защищены от записи. Опция `-f` (force - принудительно) делает это.

```
rm -rf temp_dir
```

# Вывод содержимого файла

используем команду `cat` для отображения содержимого файла:

```
cat /tmp/hello
```

Вывод содержимого файла с номерами строк

```
cat -n /tmp/hello
```

**Вывод первых строк файла** - команда `head` используется для просмотра начала (или "головы") файла.

```
head -n1 /tmp/hello
```

Здесь `-n1` - это опция, которая сообщает команде `head` показать только первую строку. Число `1` можно заменить на любое другое, чтобы показать соответствующее количество строк.

По умолчанию, без опции `-n1`, команда `head` показывает первые 10 строк файла.

**Вывод последних строк файла**

```
tail -n1 /tmp/hello
```

# Сравнение файлов

Команда `diff` для сравнения двух файлов и нахождения различий между ними.

```shell
diff file1 file2
```

```shell
1c1
< this is file1
---
> this is file2
```

Этот вывод сообщает нам, что первая строка файла `file1` отличается от первой строки файла `file2`. Символ `<` показывает содержимое из файла `file1`, а символ `>` показывает содержимое из файла `file2`.

**Сравнение директорий**

```shell
diff -r ~/Desktop ~/Code
```

Опция `-r` сообщает команде `diff` рекурсивно сравнивать также поддиректории. `~/Desktop` и `~/Code` - это пути к двум директориям, которые мы сравниваем.

```shell
Only in /home/labex/Desktop: code.desktop 
Only in /home/labex/Desktop: gedit.desktop 
Only in /home/labex/Desktop: gvim.desktop 
Only in /home/labex/Desktop: xfce4-terminal.desktop
```

Этот вывод показывает, что в директории `Desktop` есть четыре файла, которых нет в директории `Code`.

# Создание нового файла

`touch` - универсальная команда может создавать новые пустые файлы и обновлять временные метки существующих.

```shell
touch example.txt
```

# Изменение владельца файла

Команда `chown` позволяет нам изменить как пользователя - владельца файла, так и группу, которой он принадлежит. Владелец определяет, кто имеет контроль над файлом.

Сначала проверим текущего владельца нашего файла `example.txt`:

```shell
ls -l example.txt
```

```shell
-rw-rw-r-- 1 user user 0 Jul 29 15:11 example.txt
```

Разберем этот вывод:

1. `-rw-rw-r--` представляет права доступа к файлу (мы более подробно рассмотрим это на шаге 4). Первый символ указывает на тип файла ( `-` для обычного файла, `d` для директории и т.д.). Остальные символы представляют права на чтение, запись и выполнение для владельца, группы и других пользователей.
2. Первое `user` - это текущий владелец файла. Это имя пользователя, которому принадлежит файл.
3. Второе `user` - это текущая группа файла. Группа - это набор пользователей, которые могут разделять права доступа.
4. `0` - размер файла в байтах. Поскольку файл пуст, его размер равен нулю.
5. `Jul 29 15:11` - дата и время последнего изменения.
6. `example.txt` - имя файла.

Теперь изменим владельца файла на пользователя `root`. `root` - это административный аккаунт в системах Linux, который имеет специальные привилегии.

```shell
sudo chown root:root example.txt
```

Вот что делает эта команда:

- `sudo` запускает команду с привилегиями `root`. Вам, вероятно, будет предложено ввести пароль. Команда `chown` требует повышенных привилегий, так как это мощная команда, которая может повлиять на безопасность системы. Без `sudo` вы получите ошибку "Permission denied" (доступ запрещен).
- `chown` - команда для изменения владельца.
- `root:root` - указывает нового владельца и группу (оба установлены на `root`). Синтаксис: `owner:group` (владелец:группа).
- `example.txt` - целевой файл.

# Изменение владельца директории

Команда `chown` также может изменить владельца целых директорий и их содержимого. Давайте посмотрим, как это работает. Это особенно полезно для управления сложными структурами директорий, когда вы хотите, чтобы все файлы и поддиректории имели одного и того же владельца.

```shell
mkdir -p new-dir/subdir 
echo "Hello, world" > new-dir/file1.txt 
echo "Another file" > new-dir/subdir/file2.txt
```

Разберем эти команды:

- `mkdir -p new-dir/subdir` создает директорию `new-dir` и ее поддиректорию `subdir`. Опция `-p` сообщает команде `mkdir` создавать родительские директории по мере необходимости. Без `-p`, если директория `new-dir` не существовала, создание `new-dir/subdir` завершилось бы с ошибкой.
- `echo "Hello, world" > new-dir/file1.txt` создает файл с именем `file1.txt` внутри директории `new-dir` и записывает в него текст "Hello, world". Символ `>` используется для перенаправления; он берет вывод команды `echo` и перенаправляет его в указанный файл.
- `echo "Another file" > new-dir/subdir/file2.txt` аналогично создает файл с именем `file2.txt` внутри директории `new-dir/subdir` и записывает в него текст "Another file".

Теперь проверим текущего владельца:

```shell
ls -lR new-dir
```

`ls -lR` выводит содержимое директории `new-dir` рекурсивно. Опция `-R` (рекурсивно) заставляет команду `ls` выводить все файлы и поддиректории внутри `new-dir` и их содержимое.

Теперь изменим владельца директории `new-dir` и всего ее содержимого на пользователя `root`:

```shell
sudo chown -R root:root new-dir
```

# Изменение прав доступа к файлу

В Linux права доступа к файлам представлены последовательностью букв или цифр. Понимание прав доступа является важным аспектом обеспечения безопасности ваших файлов и предотвращения несанкционированного доступа.

Сначала посмотрим на текущие права доступа к нашему файлу `example.txt`:

```shell
ls -l example.txt
```

```shell
-rw-rw-r-- 1 root root 0 Jul 29 15:11 example.txt
```

Часть `-rw-rw-r--` представляет права доступа к файлу. Именно здесь применяются числовые и символьные обозначения. Разберем ее:

- Первый символ (`-`) указывает, что это обычный файл. Другие распространенные обозначения: `d` для директории и `l` для символической ссылки.
- Следующие три символа (`rw-`) представляют права доступа владельца (чтение и запись, но не выполнение).
    - `r` означает право на чтение: Владелец может открыть и прочитать файл.
    - `w` означает право на запись: Владелец может изменить файл.
    - `x` означает право на выполнение: Владелец может запустить файл (если это программа или скрипт). Символ `-` означает, что право доступа запрещено.
- Следующие три символа (`rw-`) относятся к группе. Они имеют то же значение, что и выше, но применяются к членам группы, которой принадлежит файл.
- Последние три символа (`r--`) относятся к другим пользователям (всем остальным). Они также имеют то же значение, но применяются к пользователям, которые не являются владельцем файла и не входят в его группу.

Теперь изменим эти права доступа с помощью команды `chmod`. `chmod` означает "change mode" (изменить режим), и она позволяет вам изменять эти права. Начнем с **числового обозначения**.

```shell
sudo chmod 700 example.txt
```

В этой команде:

- `700` - это числовое представление прав доступа:
    - Первая цифра (`7`) представляет права доступа владельца.
    - Вторая цифра (`0`) представляет права доступа группы.
    - Третья цифра (`0`) представляет права доступа других пользователей.

Каждая цифра - это число от `0` до `7`, вычисляемое путем сложения значений для прав на чтение (`4`), запись (`2`) и выполнение (`1`):

- `4`: Право на чтение
- `2`: Право на запись
- `1`: Право на выполнение
- `0`: Нет прав доступа

Таким образом, `7` (первая цифра) дает владельцу права на чтение (4), запись (2) и выполнение (`1`): `4` + `2` + `1` = `7`.  
`0` (вторая цифра) дает группе никаких прав (0 + 0 + 0 = 0).  
`0` (третья цифра) дает другим пользователям никаких прав (0 + 0 + 0 = 0).

Следовательно, `700` означает: Владелец: чтение, запись, выполнение. Группа: нет прав. Другие: нет прав.

Проверяем изменения

```shell
ls -l example.txt
```

```shell
-rwx------ 1 root root 0 Jul 29 15:11 example.txt
```

# Изменение прав доступа к директории

Изменение прав доступа к директориям происходит аналогично изменению прав доступа к файлам. Права доступа к директориям определяют, кто может просматривать содержимое директории, создавать новые файлы в ней и получать доступ к уже существующим файлам.

Сначала создадим новую директорию и установим некоторые нестандартные права доступа:

```shell
mkdir ~/test-dir 
chmod 700 ~/test-dir
```

```shell
ls -ld ~/test-dir
```

Опция `-d` в команде `ls -l` сообщает `ls` вывести информацию о самой директории, а не о ее содержимом. Без `-d` команда `ls` вывела бы файлы и поддиректории _внутри_ `test-dir`.

```shell
drwx------ 2 user user 4096 Jul 29 15:45 /home/labex/test-dir
```

Символ `d` в начале указывает, что это директория. `rwx------` означает, что владелец имеет права на чтение, запись и выполнение, в то время как группа и другие пользователи не имеют никаких прав. Для директорий:

- Право на чтение (`r`) позволяет вам просматривать содержимое директории с помощью команды `ls`.
- Право на запись (`w`) позволяет вам создавать новые файлы и поддиректории в директории.
- Право на выполнение (`x`) позволяет вам получать доступ к файлам и поддиректориям в директории (например, использовать команду `cd` для перехода в нее).

Теперь изменим права доступа:

```shell
chmod -R 755 ~/test-dir
```

В этой команде:

- `-R` применяет изменения рекурсивно ко всем файлам и поддиректориям (хотя наша директория в данном случае пуста). Это хорошая практика включать эту опцию при работе с директориями, даже если они в настоящее время пусты, на случай, если вы добавите файлы позже.
- `755` дает права на чтение, запись и выполнение владельцу, а права на чтение и выполнение группе и другим пользователям.

Разберем `755`:

- Владелец (`7`): Чтение (`4`) + Запись (`2`) + Выполнение (`1`) = `7`
- Группа (`5`): Чтение (`4`) + Выполнение (`1`) = `5`
- Другие (`5`): Чтение (`4`) + Выполнение (`1`) = `5`

# Использование символьного обозначения для прав доступа

В то время как числовое обозначение прав доступа компактно, символьное обозначение может быть более интуитивно понятным, особенно когда вам нужно изменить только одно право доступа. Символьное обозначение использует буквы для обозначения пользователя, группы и других, а также операторы для добавления или удаления прав доступа.

Сначала создадим новый скрипт с некоторым содержимым:

```shell
cd ~/project 
echo '#!/bin/bash\necho "Hello, World"' > script.sh
```

Эта команда выполняет две задачи:

1. Она создает новый файл с именем `script.sh`. Расширение `.sh` обычно используется для shell - скриптов. Shell - скрипты - это исполняемые файлы, содержащие последовательность команд, которые выполняются по порядку.
2. Она записывает две строки в этот файл:
    - `#!/bin/bash` (называемая шебангом) сообщает системе, что это bash - скрипт. Строка шебанга указывает интерпретатор, который должен быть использован для выполнения скрипта. В данном случае это `/bin/bash`, который является путем к интерпретатору Bash.
    - `echo "Hello, World"` - это команда, которая выведет "Hello, World" при запуске скрипта. Команда `echo` просто выводит текст, который следует за ней.
    - `\n` - это символ новой строки, который обеспечивает размещение команд на отдельных строках в файле.

Теперь проверим начальные права доступа к скрипту:

```shell
ls -l script.sh

-rw-rw-r-- 1 user user 32 Jul 29 16:30 script.sh
```

 Изначально скрипт имеет только права на чтение и запись для владельца и группы, а также право на чтение для других. У него нет права на выполнение, которое необходимо для запуска его как программы.

Попробуем запустить скрипт:

```shell
./script.sh

zsh: permission denied: ./script.sh
```

Часть `./` сообщает оболочке, что нужно выполнить скрипт, расположенный в текущей директории.

Теперь добавим право на выполнение для владельца с использованием **символьного обозначения**:

```shell
chmod u+x script.sh
```

В этой команде:

- `u` обозначает пользователя (владельца). Другие варианты: `g` для группы, `o` для других и `a` для всех (пользователь, группа и другие).
- `+x` добавляет право на выполнение. Символ `+` добавляет право доступа, в то время как символ `-` удаляет право доступа.

Таким образом, `u+x` означает "добавить право на выполнение для владельца".

```shell
ls -l script.sh

-rwxrw-r-- 1 user user 32 Jul 29 16:30 script.sh
```

Владелец теперь имеет права `rwx` (чтение, запись и выполнение).

# Создание нового пользователя

Linux - это мультипользовательская операционная система. Это означает, что несколько пользователей могут одновременно использовать один и тот же компьютер с Linux, каждый с собственной личной областью и файлами, а также совместно использовать некоторые системные ресурсы.

Прежде чем создать нового пользователя, давайте обсудим концепцию основных групп (primary groups). В Linux каждый пользователь принадлежит к основной группе и может принадлежать к нескольким дополнительным группам. Основная группа обычно используется в качестве группы-владельца для файлов, созданных пользователем.

Когда вы создаете нового пользователя с помощью команды `adduser`, автоматически создается основная группа для этого пользователя с тем же именем, что и имя пользователя. Это называется схемой Пользовательской Приватной Группы (User Private Group, UPG).

Начнем с создания новой пользовательской учетной записи с именем `joker`.

```shell
sudo useradd joker
```

Разберем эту команду по частям:

- `sudo` - это команда, которая предоставляет вам временные привилегии суперпользователя (администратора). Мы используем ее, так как создание новой пользовательской учетной записи требует более высоких прав доступа.
- `useradd` - это команда для создания нового пользователя.
- `joker` - это имя пользователя, которое мы создаем.

Эта команда выполнит следующие действия:

1. Создаст нового пользователя с именем `joker`.
2. Создаст новую группу с именем `joker` (основную группу).
3. Добавит пользователя `joker` в группу `joker` в качестве основной группы.
4. Создаст домашний каталог для jack по пути `/home/joker`.

> Примечание: Если вы попытаетесь выполнить эту команду без `sudo`, вы получите ошибку "permission denied" (доступ запрещен). Это связано с тем, что обычные пользователи не имеют права создавать новые пользовательские учетные записи - это задача, зарезервированная для системных администраторов. Это подчеркивает разницу между суперпользователем и обычным пользователем. Как обычный пользователь, вы не можете создавать новые пользовательские учетные записи, но с помощью `sudo` вы можете временно повысить свои привилегии для выполнения этой административной задачи.

Чтобы убедиться, что пользователь был создан, мы проверим файл `/etc/passwd`:

```shell
sudo grep -w 'joker' /etc/passwd
```

```shell
joker:x:5001:5001::/home/joker:/bin/sh
```

Эта строка показывает:

- Имя пользователя: `joker`
- Пароль: `x` (фактический пароль хранится в другом месте в безопасном виде)
- Идентификатор пользователя: `5001`
- Идентификатор группы: `5001`
- Домашний каталог: `/home/joker`, но он еще не создан
- Стандартный оболочка: `/bin/sh`

Файл `/etc/passwd` похож на телефонный справочник для пользовательских учетных записей. Каждая строка представляет одну пользовательскую учетную запись, а различные части информации разделены двоеточиями (`:`).
# Создание пользователя с домашним каталогом

Теперь создадим еще одного пользователя с именем `bob` и предоставим ему домашний каталог.

```shell
sudo useradd -m bob
```

Опция `-m` сообщает системе создать домашний каталог для пользователя. Домашний каталог - это своего рода личная папка, в которой пользователь может хранить свои файлы и настройки.

```shell
sudo ls -ld /home/bob

drwxr-x--- 2 bob bob 57 Jan 19 13:33 /home/bob
```

Этот вывод показывает:

- Символ `d` в начале означает, что это каталог.
- `rwxr-x---` показывает, кто может читать, записывать или выполнять действия в этом каталоге.
- Два вхождения `bob` показывают, что как пользователь, так и группа-владелец этого каталога - это bob.
- `57` - размер каталога в байтах.
- `Jan 19 13:33` - дата и время создания каталога.
- `/home/bob` - расположение каталога.

# Установка пароля для пользователя

Теперь нам нужно установить пароль для наших новых пользователей. Установим пароль для `joker`.

```shell
sudo passwd joker
```

Будет предложено дважды ввести новый пароль.

Под капотом Linux хранит зашифрованные пароли в безопасном файле `/etc/shadow`. Это более безопасно, чем хранение паролей в файле `/etc/passwd`, где их могут видеть все.

# Изменение свойств пользователя

В Linux можно изменять различные настройки пользовательской учетной записи после ее создания. В качестве примера изменим домашний каталог пользователя `joker`.

```shell
sudo usermod -d /home/wayne joker
```

Вот что делает эта команда:

- `usermod` - команда для изменения настроек пользовательской учетной записи.
- `-d /home/wayne` - задает новый домашний каталог.
- `joker` - пользователь, настройки которого мы изменяем.

Проверим изменения:
 
```shell
sudo grep -w 'joker' /etc/passwd
```

`-w` используется для поиска целого слова, а `grep` - для поиска этого слова в файле. В выводе вы должны увидеть, что домашний каталог пользователя joker был обновлен.

# Изменение оболочки (shell) пользователя

Еще одной важной настройкой, которую мы можем изменить, является стандартная оболочка (shell) пользователя. Оболочка - это программа, которая интерпретирует и выполняет команды, которые вы вводите в терминале.

По умолчанию пользователь 'joker' использует `/bin/sh` в качестве своей оболочки. В то время как `sh` (Bourne Shell) - это базовая оболочка, которая присутствует на большинстве Unix-подобных систем, `bash` (Bourne Again Shell) предлагает больше функций и, как правило, более удобна для пользователя.

Изменение оболочки пользователя joker на bash имеет несколько преимуществ:

- Более интуитивный командный интерфейс.
- Улучшенные возможности скриптинга.
- Лучшие параметры настройки окружения пользователя.

```shell
sudo usermod -s /bin/bash joker
```

```shell
sudo grep -w 'joker' /etc/passwd

joker:x:5001:5001::/home/wayne:/bin/bash
```

# Добавление пользователя в группу

В Linux группы используются для организации пользователей и управления правами доступа. Одной из важных групп является группа `sudo`, которая предоставляет пользователям административные привилегии. В качестве примера добавим пользователя joker в группу `sudo`.

Зачем добавлять пользователя в группу `sudo`?

1. Администрирование системы: Пользователи в группе `sudo` могут выполнять системные административные задачи.
2. Установка программного обеспечения: Участники группы `sudo` могут устанавливать и обновлять пакеты программного обеспечения.
3. Изменение конфигурации: Они могут изменять системные конфигурационные файлы.
4. Управление пользователями: Они могут создавать, изменять или удалять другие пользовательские учетные записи.

Возможно, у вас возникнет вопрос: "Зачем добавлять кого - то в группу `sudo`, если мы всегда можем использовать команду '`sudo`'?" Вот почему:

- Удобство: Пользователи в группе sudo могут использовать sudo без необходимости знать пароль root. Они используют свой собственный пароль.
- Точное управление: Системные администраторы могут настроить `sudo` так, чтобы разрешить определенным пользователям выполнять только определенные команды с привилегиями суперпользователя.
- Ответственность: В отличие от общего доступа к паролю `root`, `sudo` записывает, кто выполнил какую команду, что повышает безопасность и возможность отслеживания действий.
- Безопасность: Как правило, более безопасно иметь именованные учетные записи с доступом `sudo`, чем делиться паролем `root` между несколькими администраторами.

В реальной жизни вы обычно добавляете пользователя в группу `sudo`, если:

- Это системный администратор или сотрудник IT - отдела, который должен выполнять регулярные задачи по обслуживанию системы.
- Это разработчик, который должен установить определенное программное обеспечение или внести изменения в систему для своей работы.
- Это продвинутый пользователь, которому нужны повышенные привилегии для определенных задач, но вы не хотите давать ему пароль root.

Помните, что добавление пользователя в группу `sudo` дает ему значительную власть над системой, поэтому это должно быть сделано осторожно и только при необходимости.

добавим пользователя `joker` в группу `sudo`:

```shell
sudo usermod -aG sudo joker
```

Вот что делает эта команда:

- `usermod` - команда для изменения пользовательских учетных записей.
- `-aG` означает "добавить в группу" (добавить в группу без удаления из других групп).
- `sudo` - группа, в которую мы добавляем пользователя.
- `joker` - пользователь, учетную запись которого мы изменяем.

Проверяем изменения:

```shell
groups joker
```

Чтобы увидеть эффект этого изменения, нам нужно переключиться на пользователя `joker` и попробовать команду, которая требует привилегий `sudo`:

```shell
su - joker
```

Эта команда переключает вас от текущего пользователя на пользователя `joker`. Вам будет предложено ввести пароль пользователя `joker`.

После входа в систему как `joker`, попробуем просмотреть файл, который обычно требует привилегий `root`:

```shell
sudo cat /etc/shadow
```

После завершения работы введите `exit`, чтобы вернуться в свою исходную учетную запись

# Блокировка и разблокировка пользовательских учетных записей

Иногда вам может понадобиться временно отключить пользовательскую учетную запись без ее удаления.

Заблокировать учетную запись joker:

```shell
sudo passwd -l joker
```

Опция `-l` блокирует пароль.

Теперь разблокируем учетную запись

```shell
sudo passwd -u joker
```

Опция `-u` разблокирует пароль.

# Удаление пользователя

Удалите пользователя `bob` и его домашний каталог:

```shell
sudo userdel -r bob
```

Команда `userdel` удаляет пользовательские учетные записи. Опция `-r` удаляет домашний каталог пользователя и почтовый ящик.

Проверяем, что пользователь был удален

```shell
sudo grep -w 'bob' /etc/passwd 
sudo ls -ld /home/bob
```

# Группы
## Исследование групп пользователей

В Linux группы пользователей представляют собой способ организации нескольких пользователей для управления разрешениями. Каждый пользователь имеет основную группу и может принадлежать к нескольким дополнительным группам. Давайте исследуем группы, к которым принадлежит наш текущий пользователь:

```shell
id user

uid=5000(user) gid=5000(user) groups=5000(user),27(sudo),121(ssl-cert),5002(public)
```

Это показывает, что:

- Пользователь `user` имеет идентификатор пользователя (User ID, UID) 5000.
- Основная группа для `user` также называется `user` и имеет идентификатор группы (Group ID, GID) 5000.
- `user` принадлежит к нескольким дополнительным группам, включая `sudo`, `ssl-cert` и `public`.

Теперь давайте посмотрим все группы в системе:

```shell
cat /etc/group | sort
```

Команда `cat` отображает содержимое файла, `/etc/group` - это место, где хранится информация о группах, а `| sort` сортирует вывод в алфавитном порядке.

Чтобы увидеть только группы, связанные с `user`, используйте:

```shell
cat /etc/group | grep -E "user"
```

`grep` - это мощный инструмент поиска. Эта команда ищет строки, содержащие "user", в файле с информацией о группах.

## Создание новой группы и добавление пользователя в нее

Сначала создадим новую группу:

```shell
sudo groupadd developers
```

Теперь добавим `user` в группу developers:

```shell
sudo usermod -aG developers user
```

Команда `usermod` изменяет учетные записи пользователей. Опция `-aG` добавляет пользователя в дополнительную группу.

Чтобы убедиться, что `user` теперь является членом группы `developers`, используйте:

```shell
groups user
```

## Добавление пользователя в группу sudo

Теперь, когда мы создали пользователя `jack`, давайте предоставим ему привилегии sudo, добавив его в группу `sudo`. Но сначала разберемся, почему это важно:

Добавление пользователя в группу sudo позволяет ему выполнять команды с привилегиями суперпользователя или корневого пользователя. Это полезно по нескольким причинам:

1. Безопасность: Пользователь может выполнять административные задачи без входа в систему как корневой пользователь, что обычно считается риском для безопасности.
2. Ответственность: Когда пользователи используют sudo, их действия записываются в журналы, что обеспечивает аудит trail административных действий.
3. Удобство: Не нужно переключаться на учетную запись корневого пользователя для выполнения периодических административных задач.
4. Гранулярный контроль: Конфигурация sudo может быть настроена так, чтобы разрешить определенным пользователям запускать только определенные команды с повышенными привилегиями.

```shell
sudo usermod -aG sudo user
```

Эта команда использует `usermod` для изменения учетной записи пользователя. Опция `-aG` означает "добавить в группу", поэтому она добавляет `user` в группу `sudo`, не удаляя его из других групп.

Добавив `user` в группу `sudo`, мы дали ему возможность выполнять административные задачи в системе.

# Операции с файлами и каталогами

некоторые базовые концепции:

- **Файловая система Linux**: Представьте себе ее как древовидную структуру для организации всех файлов на вашем компьютере. В отличие от Windows с его буквами дисков (C:, D: и т.д.), Linux имеет единую корневую директорию (/), от которой все остальное разветвляется.
- **Директория**: Это термин Linux для того, что вы, возможно, знаете как "папка" в других операционных системах. Это контейнер для файлов и других директорий.
- **Файл**: В Linux почти все является файлом! Обычные документы, директории, даже аппаратные устройства рассматриваются как файлы. Этот единый подход упрощает многие операции.
- **Путь**: Это как адрес для файла или директории. Мы узнаем о абсолютных путях (которые начинаются от корневой директории) и относительных путях (которые начинаются от вашего текущего местоположения).
- **Терминал**: Это ваша командный центр для взаимодействия с Linux. Сначала он может показаться пугающим, но вы скоро обнаружите, что это мощный инструмент для управления вашей системой.
- **Поиск файлов**: Linux предоставляет мощные инструменты для поиска файлов по всей системе. Мы рассмотрим команды, такие как `find` и `which`, чтобы помочь вам быстро найти файлы и исполняемые файлы.

1. `pwd` расшифровывается как "print working directory" (вывести текущую рабочую директорию). Эта команда показывает, где вы находитесь в файловой системе.
2. Посмотреть на всю структуру каталогов:

```shell
tree /
```

исследуем некоторые основные директории:

```shell
tree /home
tree /etc
tree /bin
```

- `/home` - это место, где хранятся директории пользователей. Каждый пользователь обычно имеет свою собственную директорию здесь.
- `/etc` содержит системные файлы конфигурации.
- `/bin` хранит важные бинарные файлы команд (программы), которые должны быть доступны для всех пользователей.

```shell
cd ~ # Перейти в домашнюю дирректорию
pwd 
cd - # Перейти в предидущую дирректорию 
pwd 
cd   # Ещё один способ перейти в домашнюю дирректорию
pwd
```

# Поиск файлов в Linux

Быстрый поиск файлов - это важный навык в Linux. Давайте узнаем несколько распространенных команд для поиска файлов.

1. Сначала используем команду `find` для поиска всех файлов с расширением.txt в текущем каталоге и его подкаталогах

```shell
find. -name "*.txt"
```

2. Теперь поищем конкретный файл по всей системе:

```shell
sudo find / -name "passwd"
```

Эта команда будет искать файлы с именем "passwd" по всему файловому системному пространству. Здесь мы используем `sudo`, потому что поиск по всей файловой системе (начиная от корневого каталога `/`) требует повышенных прав доступа. Многие системные каталоги недоступны для чтения обычным пользователям, поэтому `sudo` позволяет нам искать в этих защищенных областях.

