
В Linux пользователи организованы в группы. Эти группы определяют разрешения и права доступа, которые у пользователя есть.

Команда `id`. Это отличный способ узнать, к каким группам вы принадлежите.

```
id
uid=5000(labex) gid=5000(labex) groups=5000(labex),27(sudo),121(ssl-cert),5002(public)
```

Вот разбор:

- `uid`: Ваш идентификатор пользователя (уникальный числовой идентификатор).
- `gid`: Идентификатор вашей основной группы.
- `groups`: Все группы, членом которых вы являетесь.

Также можно использовать команду `id` для поиска информации о других пользователях. 

```
id root
uid=0(root) gid=0(root) groups=0(root)
```

# Системный монитор htop

Он похож на приборную панель, которая дает вам реальное представление о том, что происходит внутри вашего компьютера.

```
htop
```

![[Pasted image 20250519110233.png]]

`htop` показывает:

1. Верхняя часть: Использование ЦП и памяти, а также время работы компьютера (uptime).
2. Средняя часть: Список всех запущенных программ (процессов).
3. Нижняя часть: Опции для взаимодействия с `htop`.

Используйте стрелки на клавиатуре для навигации.

# Менеджер пакетов apt

`apt` - это широко используемый менеджер пакетов для систем на основе Debian, таких как Ubuntu. Сначала обновим список доступных пакетов. Это гарантирует, что мы устанавливаем последнюю версию пакета.

Далее мы используем `sudo apt install` для установки `htop`:

- `sudo`: сокращение от "*SuperUser DO*". Он позволяет выполнять команды с правами администратора (времено).
- `apt`: инструмент для установки и управления программным обеспечением.
- `install`: сообщает `apt`, что мы хотим установить программу.
- `htop`: конкретная программа, которую мы хотим установить.

# Понимание рабочей среды

В Linux каждый пользователь обычно имеет "домашний каталог", обозначаемый символом `~`. 

Определение текущего местоположения

```
pwd
```

`pwd` расшифровывается как "print working directory" (вывести текущий рабочий каталог). Эта команда отображает ваше текущее местоположение в файловой системе.

```
echo ~
```

Эта команда отобразит путь к вашему домашнему каталогу

Чтобы посмотреть содержимое текущего каталога, используйте:

```
ls
```

Эта команда выведет список файлов и каталогов в текущем рабочем каталоге

**Создадим несколько файлов**:

```
touch file1.txt
```

Команда `touch` используется для создания пустого файла. Если файл уже существует, эта команда обновляет временную метку файла без изменения его содержимого.

```
echo "Hello, Linux" > file2.txt
```

Эта команда выполняет две задачи:

- `echo` - это команда, которая выводит текст.
- Символ `>` перенаправляет вывод команды `echo` в файл с именем `file2.txt`. Если файл не существует, он будет создан. Если файл уже существует, его содержимое будет заменено.

```
echo "Hidden file" > .hiddenfile
```

Эта команда создает скрытый файл. В Linux любой файл или каталог, имя которого начинается с точки (`.`), считается скрытым.

**Теперь создадим каталог**:

```
mkdir testdir
```

Команда `mkdir` (сокращение от "make directory" - создать каталог) создает новый каталог с именем `testdir`.

**Подробный просмотр содержимого**:

```
ls -l
```

Опция `-l` предоставляет вывод в "длинном" формате. Вы увидите дополнительные сведения, такие как права доступа к файлу, владелец, размер и дата изменения.

Показать скрытые файлы:

```
ls -a
```

Эта команда покажет все файлы, включая скрытый файл `.hiddenfile`, который мы создали.

Комбинирование опций

```
ls -la
```

Эта команда комбинирует длинный формат вывода (`-l`) с показом всех файлов (`-a`).

Просмотр содержимого конкретного каталога:

```
ls -l testdir
```

# Копирование файлов и каталогов

Теперь, когда у нас есть файлы, с которыми можно работать, давайте научимся их копировать:

1. Скопировать файл:

```
cp file1.txt file1_copy.txt
```

Эта команда создает копию файла `file1.txt` с именем `file1_copy.txt` в текущем каталоге.

2. Скопировать файл в другой каталог:

```
cp file2.txt testdir/
```

Эта команда копирует файл `file2.txt` в каталог `testdir`.

3. Скопировать каталог

```
cp -r testdir testdir_copy
```

Опция `-r` расшифровывается как "рекурсивно" (recursive). Она обязательна при копировании каталогов, чтобы скопировать все их содержимое.

# Перемещение и переименование файлов и каталогов

В Linux команда `mv` используется как для перемещения, так и для переименования:

```
mv file1.txt newname.txt
```

Эта команда переименовывает файл `file1.txt` в `newname.txt`.

Переместить файл в каталог:

```
mv newname.txt testdir/
```

Эта команда перемещает файл `newname.txt` в каталог `testdir`.

Переименовать каталог:

```
mv testdir_copy new_testdir
```

Эта команда переименовывает каталог `testdir_copy` в `new_testdir`.

Переместить и переименовать за один раз:

```
mv testdir/newname.txt ./original_file1.txt
```

Эта команда перемещает файл `newname.txt` из каталога `testdir` и переименовывает его в `original_file1.txt` в текущем каталоге.

# Удаление файлов и директорий

Удаление файлов и директорий – это мощная операция. В отличие от графических интерфейсов, командная строка часто не имеет "Корзины" (Recycle Bin). Удаления, выполненные с помощью `rm`, обычно необратимы.

Удаление одного файла:

```
rm original_file1.txt
```

Команда `rm` (сокращение от "remove" - удалить) удаляет файлы.

Удаление в интерактивном режиме (безопаснее):

Давайте попробуем удалить `file2.txt`, но на этот раз используя интерактивный флаг `-i`:

```
rm -i file2.txt
```

Опция `-i` запрашивает подтверждение перед удалением каждого файла. Введите `y` (для yes - да) и нажмите Enter, чтобы подтвердить удаление. Если вы введете `n` или что-либо другое, файл не будет удален.

Удаление пустой директории

```
rmdir new_testdir
```

`rmdir` (remove directory - удалить директорию) работает только с **пустыми** директориями.

Удаление непустой директории

```
rm -r testdir
```

Принудительное удаление:

Иногда может потребоваться удалить файлы без запроса, даже если они защищены от записи. Опция `-f` (force - принудительно) делает это.

```
rm -rf temp_dir
```

# Вывод содержимого файла

используем команду `cat` для отображения содержимого файла:

```
cat /tmp/hello
```

Вывод содержимого файла с номерами строк

```
cat -n /tmp/hello
```

**Вывод первых строк файла** - команда `head` используется для просмотра начала (или "головы") файла.

```
head -n1 /tmp/hello
```

Здесь `-n1` - это опция, которая сообщает команде `head` показать только первую строку. Число `1` можно заменить на любое другое, чтобы показать соответствующее количество строк.

По умолчанию, без опции `-n1`, команда `head` показывает первые 10 строк файла.

**Вывод последних строк файла**

```
tail -n1 /tmp/hello
```

# Сравнение файлов

Команда `diff` для сравнения двух файлов и нахождения различий между ними.

```shell
diff file1 file2
```

```shell
1c1
< this is file1
---
> this is file2
```

Этот вывод сообщает нам, что первая строка файла `file1` отличается от первой строки файла `file2`. Символ `<` показывает содержимое из файла `file1`, а символ `>` показывает содержимое из файла `file2`.

**Сравнение директорий**

```shell
diff -r ~/Desktop ~/Code
```

Опция `-r` сообщает команде `diff` рекурсивно сравнивать также поддиректории. `~/Desktop` и `~/Code` - это пути к двум директориям, которые мы сравниваем.

```shell
Only in /home/labex/Desktop: code.desktop 
Only in /home/labex/Desktop: gedit.desktop 
Only in /home/labex/Desktop: gvim.desktop 
Only in /home/labex/Desktop: xfce4-terminal.desktop
```

Этот вывод показывает, что в директории `Desktop` есть четыре файла, которых нет в директории `Code`.

# Создание нового файла

`touch` - универсальная команда может создавать новые пустые файлы и обновлять временные метки существующих.

```shell
touch example.txt
```

# Изменение владельца файла

Команда `chown` позволяет нам изменить как пользователя - владельца файла, так и группу, которой он принадлежит. Владелец определяет, кто имеет контроль над файлом.

Сначала проверим текущего владельца нашего файла `example.txt`:

```shell
ls -l example.txt
```

```shell
-rw-rw-r-- 1 user user 0 Jul 29 15:11 example.txt
```

Разберем этот вывод:

1. `-rw-rw-r--` представляет права доступа к файлу (мы более подробно рассмотрим это на шаге 4). Первый символ указывает на тип файла ( `-` для обычного файла, `d` для директории и т.д.). Остальные символы представляют права на чтение, запись и выполнение для владельца, группы и других пользователей.
2. Первое `user` - это текущий владелец файла. Это имя пользователя, которому принадлежит файл.
3. Второе `user` - это текущая группа файла. Группа - это набор пользователей, которые могут разделять права доступа.
4. `0` - размер файла в байтах. Поскольку файл пуст, его размер равен нулю.
5. `Jul 29 15:11` - дата и время последнего изменения.
6. `example.txt` - имя файла.

Теперь изменим владельца файла на пользователя `root`. `root` - это административный аккаунт в системах Linux, который имеет специальные привилегии.

```shell
sudo chown root:root example.txt
```

Вот что делает эта команда:

- `sudo` запускает команду с привилегиями `root`. Вам, вероятно, будет предложено ввести пароль. Команда `chown` требует повышенных привилегий, так как это мощная команда, которая может повлиять на безопасность системы. Без `sudo` вы получите ошибку "Permission denied" (доступ запрещен).
- `chown` - команда для изменения владельца.
- `root:root` - указывает нового владельца и группу (оба установлены на `root`). Синтаксис: `owner:group` (владелец:группа).
- `example.txt` - целевой файл.

# Изменение владельца директории

Команда `chown` также может изменить владельца целых директорий и их содержимого. Давайте посмотрим, как это работает. Это особенно полезно для управления сложными структурами директорий, когда вы хотите, чтобы все файлы и поддиректории имели одного и того же владельца.

```shell
mkdir -p new-dir/subdir 
echo "Hello, world" > new-dir/file1.txt 
echo "Another file" > new-dir/subdir/file2.txt
```

Разберем эти команды:

- `mkdir -p new-dir/subdir` создает директорию `new-dir` и ее поддиректорию `subdir`. Опция `-p` сообщает команде `mkdir` создавать родительские директории по мере необходимости. Без `-p`, если директория `new-dir` не существовала, создание `new-dir/subdir` завершилось бы с ошибкой.
- `echo "Hello, world" > new-dir/file1.txt` создает файл с именем `file1.txt` внутри директории `new-dir` и записывает в него текст "Hello, world". Символ `>` используется для перенаправления; он берет вывод команды `echo` и перенаправляет его в указанный файл.
- `echo "Another file" > new-dir/subdir/file2.txt` аналогично создает файл с именем `file2.txt` внутри директории `new-dir/subdir` и записывает в него текст "Another file".

Теперь проверим текущего владельца:

```shell
ls -lR new-dir
```

`ls -lR` выводит содержимое директории `new-dir` рекурсивно. Опция `-R` (рекурсивно) заставляет команду `ls` выводить все файлы и поддиректории внутри `new-dir` и их содержимое.

Теперь изменим владельца директории `new-dir` и всего ее содержимого на пользователя `root`:

```shell
sudo chown -R root:root new-dir
```

# Изменение прав доступа к файлу

В Linux права доступа к файлам представлены последовательностью букв или цифр. Понимание прав доступа является важным аспектом обеспечения безопасности ваших файлов и предотвращения несанкционированного доступа.

Сначала посмотрим на текущие права доступа к нашему файлу `example.txt`:

```shell
ls -l example.txt
```

```shell
-rw-rw-r-- 1 root root 0 Jul 29 15:11 example.txt
```

Часть `-rw-rw-r--` представляет права доступа к файлу. Именно здесь применяются числовые и символьные обозначения. Разберем ее:

- Первый символ (`-`) указывает, что это обычный файл. Другие распространенные обозначения: `d` для директории и `l` для символической ссылки.
- Следующие три символа (`rw-`) представляют права доступа владельца (чтение и запись, но не выполнение).
    - `r` означает право на чтение: Владелец может открыть и прочитать файл.
    - `w` означает право на запись: Владелец может изменить файл.
    - `x` означает право на выполнение: Владелец может запустить файл (если это программа или скрипт). Символ `-` означает, что право доступа запрещено.
- Следующие три символа (`rw-`) относятся к группе. Они имеют то же значение, что и выше, но применяются к членам группы, которой принадлежит файл.
- Последние три символа (`r--`) относятся к другим пользователям (всем остальным). Они также имеют то же значение, но применяются к пользователям, которые не являются владельцем файла и не входят в его группу.

Теперь изменим эти права доступа с помощью команды `chmod`. `chmod` означает "change mode" (изменить режим), и она позволяет вам изменять эти права. Начнем с **числового обозначения**.

```shell
sudo chmod 700 example.txt
```

В этой команде:

- `700` - это числовое представление прав доступа:
    - Первая цифра (`7`) представляет права доступа владельца.
    - Вторая цифра (`0`) представляет права доступа группы.
    - Третья цифра (`0`) представляет права доступа других пользователей.

Каждая цифра - это число от `0` до `7`, вычисляемое путем сложения значений для прав на чтение (`4`), запись (`2`) и выполнение (`1`):

- `4`: Право на чтение
- `2`: Право на запись
- `1`: Право на выполнение
- `0`: Нет прав доступа

Таким образом, `7` (первая цифра) дает владельцу права на чтение (4), запись (2) и выполнение (`1`): `4` + `2` + `1` = `7`.  
`0` (вторая цифра) дает группе никаких прав (0 + 0 + 0 = 0).  
`0` (третья цифра) дает другим пользователям никаких прав (0 + 0 + 0 = 0).

Следовательно, `700` означает: Владелец: чтение, запись, выполнение. Группа: нет прав. Другие: нет прав.

Проверяем изменения

```shell
ls -l example.txt
```

```shell
-rwx------ 1 root root 0 Jul 29 15:11 example.txt
```

# Изменение прав доступа к директории

Изменение прав доступа к директориям происходит аналогично изменению прав доступа к файлам. Права доступа к директориям определяют, кто может просматривать содержимое директории, создавать новые файлы в ней и получать доступ к уже существующим файлам.

Сначала создадим новую директорию и установим некоторые нестандартные права доступа:

```shell
mkdir ~/test-dir 
chmod 700 ~/test-dir
```

```shell
ls -ld ~/test-dir
```

Опция `-d` в команде `ls -l` сообщает `ls` вывести информацию о самой директории, а не о ее содержимом. Без `-d` команда `ls` вывела бы файлы и поддиректории _внутри_ `test-dir`.

```shell
drwx------ 2 user user 4096 Jul 29 15:45 /home/labex/test-dir
```

Символ `d` в начале указывает, что это директория. `rwx------` означает, что владелец имеет права на чтение, запись и выполнение, в то время как группа и другие пользователи не имеют никаких прав. Для директорий:

- Право на чтение (`r`) позволяет вам просматривать содержимое директории с помощью команды `ls`.
- Право на запись (`w`) позволяет вам создавать новые файлы и поддиректории в директории.
- Право на выполнение (`x`) позволяет вам получать доступ к файлам и поддиректориям в директории (например, использовать команду `cd` для перехода в нее).

Теперь изменим права доступа:

```shell
chmod -R 755 ~/test-dir
```

В этой команде:

- `-R` применяет изменения рекурсивно ко всем файлам и поддиректориям (хотя наша директория в данном случае пуста). Это хорошая практика включать эту опцию при работе с директориями, даже если они в настоящее время пусты, на случай, если вы добавите файлы позже.
- `755` дает права на чтение, запись и выполнение владельцу, а права на чтение и выполнение группе и другим пользователям.

Разберем `755`:

- Владелец (`7`): Чтение (`4`) + Запись (`2`) + Выполнение (`1`) = `7`
- Группа (`5`): Чтение (`4`) + Выполнение (`1`) = `5`
- Другие (`5`): Чтение (`4`) + Выполнение (`1`) = `5`

# Использование символьного обозначения для прав доступа

В то время как числовое обозначение прав доступа компактно, символьное обозначение может быть более интуитивно понятным, особенно когда вам нужно изменить только одно право доступа. Символьное обозначение использует буквы для обозначения пользователя, группы и других, а также операторы для добавления или удаления прав доступа.

Сначала создадим новый скрипт с некоторым содержимым:

```shell
cd ~/project 
echo '#!/bin/bash\necho "Hello, World"' > script.sh
```

Эта команда выполняет две задачи:

1. Она создает новый файл с именем `script.sh`. Расширение `.sh` обычно используется для shell - скриптов. Shell - скрипты - это исполняемые файлы, содержащие последовательность команд, которые выполняются по порядку.
2. Она записывает две строки в этот файл:
    - `#!/bin/bash` (называемая шебангом) сообщает системе, что это bash - скрипт. Строка шебанга указывает интерпретатор, который должен быть использован для выполнения скрипта. В данном случае это `/bin/bash`, который является путем к интерпретатору Bash.
    - `echo "Hello, World"` - это команда, которая выведет "Hello, World" при запуске скрипта. Команда `echo` просто выводит текст, который следует за ней.
    - `\n` - это символ новой строки, который обеспечивает размещение команд на отдельных строках в файле.

Теперь проверим начальные права доступа к скрипту:

```shell
ls -l script.sh

-rw-rw-r-- 1 user user 32 Jul 29 16:30 script.sh
```

 Изначально скрипт имеет только права на чтение и запись для владельца и группы, а также право на чтение для других. У него нет права на выполнение, которое необходимо для запуска его как программы.

Попробуем запустить скрипт:

```shell
./script.sh

zsh: permission denied: ./script.sh
```

Часть `./` сообщает оболочке, что нужно выполнить скрипт, расположенный в текущей директории.

Теперь добавим право на выполнение для владельца с использованием **символьного обозначения**:

```shell
chmod u+x script.sh
```

В этой команде:

- `u` обозначает пользователя (владельца). Другие варианты: `g` для группы, `o` для других и `a` для всех (пользователь, группа и другие).
- `+x` добавляет право на выполнение. Символ `+` добавляет право доступа, в то время как символ `-` удаляет право доступа.

Таким образом, `u+x` означает "добавить право на выполнение для владельца".

```shell
ls -l script.sh

-rwxrw-r-- 1 user user 32 Jul 29 16:30 script.sh
```

Владелец теперь имеет права `rwx` (чтение, запись и выполнение).

# Создание нового пользователя

Начнем с создания новой пользовательской учетной записи с именем `joker`.

```shell
sudo useradd joker
```

Разберем эту команду по частям:

- `sudo` - это команда, которая предоставляет вам временные привилегии суперпользователя (администратора). Мы используем ее, так как создание новой пользовательской учетной записи требует более высоких прав доступа.
- `useradd` - это команда для создания нового пользователя.
- `joker` - это имя пользователя, которое мы создаем.

> Примечание: Если вы попытаетесь выполнить эту команду без `sudo`, вы получите ошибку "permission denied" (доступ запрещен). Это связано с тем, что обычные пользователи не имеют права создавать новые пользовательские учетные записи - это задача, зарезервированная для системных администраторов. Это подчеркивает разницу между суперпользователем и обычным пользователем. Как обычный пользователь, вы не можете создавать новые пользовательские учетные записи, но с помощью `sudo` вы можете временно повысить свои привилегии для выполнения этой административной задачи.

Чтобы убедиться, что пользователь был создан, мы проверим файл `/etc/passwd`:

```shell
sudo grep -w 'joker' /etc/passwd
```

```shell
joker:x:5001:5001::/home/joker:/bin/sh
```

Эта строка показывает:

- Имя пользователя: `joker`
- Пароль: `x` (фактический пароль хранится в другом месте в безопасном виде)
- Идентификатор пользователя: `5001`
- Идентификатор группы: `5001`
- Домашний каталог: `/home/joker`, но он еще не создан
- Стандартный оболочка: `/bin/sh`

Файл `/etc/passwd` похож на телефонный справочник для пользовательских учетных записей. Каждая строка представляет одну пользовательскую учетную запись, а различные части информации разделены двоеточиями (`:`).

# Создание пользователя с домашним каталогом

Теперь создадим еще одного пользователя с именем `bob` и предоставим ему домашний каталог.

```shell
sudo useradd -m bob
```

Опция `-m` сообщает системе создать домашний каталог для пользователя. Домашний каталог - это своего рода личная папка, в которой пользователь может хранить свои файлы и настройки.

```shell
sudo ls -ld /home/bob

drwxr-x--- 2 bob bob 57 Jan 19 13:33 /home/bob
```

Этот вывод показывает:

- Символ `d` в начале означает, что это каталог.
- `rwxr-x---` показывает, кто может читать, записывать или выполнять действия в этом каталоге.
- Два вхождения `bob` показывают, что как пользователь, так и группа-владелец этого каталога - это bob.
- `57` - размер каталога в байтах.
- `Jan 19 13:33` - дата и время создания каталога.
- `/home/bob` - расположение каталога.

# Установка пароля для пользователя

Теперь нам нужно установить пароль для наших новых пользователей. Установим пароль для `joker`.

```shell
sudo passwd joker
```

Будет предложено дважды ввести новый пароль.

Под капотом Linux хранит зашифрованные пароли в безопасном файле `/etc/shadow`. Это более безопасно, чем хранение паролей в файле `/etc/passwd`, где их могут видеть все.

# Изменение свойств пользователя

В Linux можно изменять различные настройки пользовательской учетной записи после ее создания. В качестве примера изменим домашний каталог пользователя `joker`.

```shell
sudo usermod -d /home/wayne joker
```

Вот что делает эта команда:

- `usermod` - команда для изменения настроек пользовательской учетной записи.
- `-d /home/wayne` - задает новый домашний каталог.
- `joker` - пользователь, настройки которого мы изменяем.

Проверим изменения:
 
```shell
sudo grep -w 'joker' /etc/passwd
```

`-w` используется для поиска целого слова, а `grep` - для поиска этого слова в файле. В выводе вы должны увидеть, что домашний каталог пользователя joker был обновлен.

# Изменение оболочки (shell) пользователя

Еще одной важной настройкой, которую мы можем изменить, является стандартная оболочка (shell) пользователя. Оболочка - это программа, которая интерпретирует и выполняет команды, которые вы вводите в терминале.

По умолчанию пользователь 'joker' использует `/bin/sh` в качестве своей оболочки. В то время как `sh` (Bourne Shell) - это базовая оболочка, которая присутствует на большинстве Unix-подобных систем, `bash` (Bourne Again Shell) предлагает больше функций и, как правило, более удобна для пользователя.

Изменение оболочки пользователя joker на bash имеет несколько преимуществ:

- Более интуитивный командный интерфейс.
- Улучшенные возможности скриптинга.
- Лучшие параметры настройки окружения пользователя.

```shell
sudo usermod -s /bin/bash joker
```

```shell
sudo grep -w 'joker' /etc/passwd

joker:x:5001:5001::/home/wayne:/bin/bash
```


