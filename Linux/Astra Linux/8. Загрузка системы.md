#### 1.1 Особенности MBR и UEFI

На материнской плате компьютера имеется чип памяти, в котором находится «прошивка» (firmware) - специальная программа, которая выполняет тестирование аппаратных компонентов компьютера и запуск загрузчика операционной системы. На старых компьютерах эта прошивка называлась `BIOS` (Basic lnput Output System, базовая система ввода/вывода), а на новых называется `UEFI` (Unified Extensible Firmware Interface, унифицированный расширяемый интерфейс микропрограммного
обеспечения).

Прошивка выполняет процедуру `POST` (Power-On Selft Test) - это процедура
самотестирования, определяющая «здоровье» аппаратных компонентов. Если все здоровы, прошивка берет первое устройство из списка `Boot Order` и пытается на нем найти загрузчик операционной системы.

Если на вашем компьютере до сих пор используется старая схема разметки `MBR` (Master Boot Record, главной загрузочной записи), которая была характерна на компьютерах с `BIOS`, то первые 512 байтов на жестком диске как раз и занимает `MBR`. То есть `MBR` - это область на жестком диске, содержащая загрузчик операционной системы и таблицу разделов.

```shell
fdisk -l
```

![[Pasted image 20250822121520.png]]

Начиная с 2010 года на новых компьютерах вместо `BIOS` стали прошивать `UEFI`. Прошивка `UEFI` принесла другую схему разметки диска - `GPT`
(GUID Partition Таblе). В начале накопителя, использующего схему разметки `GPT`, создается загрузочный раздел небольшого размера, в который и помещается код загрузчика.

```shell
fdisk -l
```

![[Pasted image 20250822121536.png]]

#### 1.2 Настройка загрузчика GRUB2

Главное назначение загрузчика - запуск выбранной пользователем операционной системы.

##### 1.2.1. Конфигурационный файл GRUB2

Основным конфигурационным файлом загрузчика `GRUB2` является файл `/boot/grub/grub.cfg`.

Конфигурационный файл `/boot/gruЬ/grub.cfg`, как правило, не редактируют вручную - для его создания используется утилита `/usr/sbin/grub-mkconfig`, которая генерирует этот файл на основе шаблонов, хранящихся в каталоге `/etc/grub.d`, и настроек из файла `/etc/default/grub`.

В конфигурационном файле содержится описание поведения `GRUB2`, а также элементов загрузочного меню. Собственно, ради элементов загрузочного меню часто и возникает необходимость отредактировать этот файл.

После изменения файла `/etc/default/grub` не забудьте выполнить команду `update-grub` для обновления вашего файла `/boot/gruЬ/grub.cfg`. Команда `update-grub` - это просто сценарий, вызывающий утилиту `grub-mkconfig/grub2-mkconfig` и передающий ей параметр - имя выходного файла (по умолчанию `/boot/grub/grub.cfg`).

##### 1.2.2. Установка пароля загрузчика

По умолчанию любой желающий может изменить параметры ядра. 

1. Сгенерировать хеш пароля командой `grub-mkpasswd-pbkdf2`.

```shell

```

2. Полученный хеш скопировать в буфер обмена
3. Создать файл `/etc/grub.d/07_password` или открыть его, если он существует.
4. Вставить в файл инструкции:
```shell
set superusers="username"
password_pbkdf2 username gruЬ.pbkdf2.sha512.10000.9C319610666 ..........
```
2. Установить права 700 для этого файла:
sudo chmod 700 /etc/grub.d/07_password
3. Обновить загрузчик командой update-grub.

#### 2.1 Система инициализации system d

Загрузчик `GRUB2` загружает ядро `Linux` и передает ему управление. Ядро, в свою очередь, должно запустить систему инициализации. Раньше в качестве системы инициализации использовалась `SysVinit`, но на сегодняшний день она безнадежно устарела и больше не соответствует требованиям современных дистрибутивов. Во всех современных дистрибутивах сейчас используется система инициализации `systemd`.

##### 2.1.1 Сервисы, службы, демоны

Служба (англ. service - сервис) - это программа, выполняющаяся в фоновом режиме и предоставляющая определенный сервис. Например, служба `apache2` предоставляет сервис веб-сервера. Она в фоновом режиме прослушивает заданный в настройках порт (чаще всего `80` или `443`) и обслуживает поступающие на него запросы, отправляя в ответ на запрос НТМL-код веб-страницы.

> Ранее сервисы также назывались демонами (`daemon`). Именно поэтому в названии некоторых служб присутствует буква `d` - например, демон, обслуживающий снапы, называется `snapd`.

Для управления сервисами (автоматический запуск, перезапуск, остановка) как раз и служит система инициализации. Как уже отмечено ранее, в древних дистрибутивах Linux использовалась система инициализации `init`.

Программа `init` - это процесс с `UID 1`, он первым запускается ядром и выступает родителем для всех процессов, у которых нет собственного родителя. Основная задача такого процесса (помимо всех остальных задач)- инициализация системы. А значит, он должен это сделать быстро. Чтобы запустить систему быстро необходимо:
- запускать не все, что можно, а только самое необходимое; 
- запускать сервисы параллельно;

##### 2.1.2 Терминология `systemd`

Система инициализации `systemd` контролирует всю систему. Система `systemd` построена на концепции модулей (`units`). У каждого модуля есть
свое имя и тип. Например, модуль типа `nscd.service` управляет сервисом (демоном) `nscd`.

Основными типами модулей являются:
- `service` (сервис) - демоны, которые можно запустить, перезапустить, остановить;
- `socket` (сокет)- реализует сокет, расположенный в файловой системе или в Интернете. Поддерживаются сокеты `AF_INET`, `AF_INET6`, `AF_UNIX`. У каждого сокета есть связанный с ним сервис. Например, при попытке установки соединения с сокетом `nscd.socket` будет запущен сервис `nscd.service`.
- `device` (устройство) - реализует устройство в дереве устройств. Если устройство описано через правила `udev` ( системы управления устройствами для новых версий ядра Linux), то его можно представить в `systemd` как модуль типа `device`;
- `mount` (точка монтирования) - реализует точку монтирования в файловой системе. Демон `systemd` контролирует все точки монтирования, . их подключение и отключение. Теперь файл `/etc/fstab` не главный, а служит дополнительным источником информации о точках монтирования, хотя вы по-прежнему можете описывать в нем свои точки монтирования;
- `automount` (автоматическая точка монтирования)- реализует автоматическое монтирование файловой системы. Такой модуль имеет соответствующий ему модуль типа `mount`, который будет запущен, как только файловая система станет доступной;
- `target` (цель)- служит для логической группировки модулей других типов. Этот тип модуля очень важен, но в то же время он ничего не делает, а просто группирует другие модули. В `systemd` больше нет уровней запуска (которые были в `init`), вместо них используются цели. Например, цель `multi-user.target` описывает, какие сервисы (точнее модули, а не только сервисы) должны быть запущены в многопользовательском режиме.
- `snapshot` ( снимок) - также ничего не делает, а только ссылается на другие модули. Снимки используются в двух случаях: первый случай - временный перевод системы в какое-то состояние (например, в однопользовательский режим) и последующий возврат из этого состояния, второй - поддержка режима `suspend`.

**Основные особенности `systemd`:**

- позволяет контролировать для каждого процесса: среду исполнения, ограничение ресурсов, рабочий каталог, корневой каталог, `umask`, параметр `nice`, `ID` пользователя и группы и многое другое;

##### 2.1.3 Управление службами

Для управления сервисами из консоли используется утилита `systemctl`. Например, вот как можно запустить, остановить и перезапустить сервис:

- `systemctl start <название>`
- `systemctl stop <название>`
- `systemctl restart <название>`
- `systemctl enable <название>`
- `systemctl disable <название>`

Команда `еnаblе` включает автоматическую загрузку сервиса, а `disable` - отключает ее.

**Astra Linux** содержит очень удобный графический конфигуратор, позволяющий управлять сервисами более просто:
1. Откройте панель управления.
2. Перейдите в раздел Система.
3. Откройте конфигуратор Инициализация системы.
4. Для управления службой щелкните правой кнопкой мыши - в появившемся меню вы увидите следующие команды:
	• Запустить юнит - запускает службу;
	• Остановить юнит - останавливает службу.
	• Перезапустить юнит - перезапускает службу;
	• Перечитать конфигурацию юнита - заставляет службу перечитать свой
	файл конфигурации. Полезно, если вы внесли незначительные изменения 	в файл конфигурации и теперь хотите, чтобы они вступили в силу, но при 	этом перезагружать весь сервис нежелательно, чтобы не прерывать обслуживание пользователей;
	• Включить юнит - включает автоматическую загрузку службы;

![[Pasted image 20250825114652.png]]

![[Pasted image 20250825114719.png]]

#### 2.2 Журналирование системы

В любой UNIХ-подобной системе, имеются так называемые *демоны протоколирования* (далее просто демоны). Демоны записывают в протоколы (журналы, логи) сообщения, генерируемые ядром, сервисами, пользовательскими программами.

Во многих современных дистрибутивах протоколированием системы занимается сама система инициализации `systemd`, а точнее - ее сервис `systemd-joumald.service`. При этом запрос системного лога (журнала) организуется через утилиту `joumalctl`.

Вот что нужно знать о протоколировании в современных дистрибутивах:
- все журналы по-прежнему хранятся в каталоге `/var/log`;
- серверы (`WWW`, `FTP` и пр.) могут создавать собственные каталоги/файлы журналов в каталоге `/var/log`;
- для просмотра системных журналов используется утилита `joumalctl` - привычные файлы вроде `/var/log/messages` более недоступны. Конечно, вы можете параллельно установить демон `rsyslogd`, и он будет прекрасно работать в паре с `journalcrl`. Однако у `joumalctl` гораздо больше возможностей - например, с помощью опции `-b` можно просмотреть логи текущей или предыдущей загрузки.

##### 2.2.1 Установка времени

Первое, что нужно сделать, - это установить правильный часовой пояс.

Для выбора часового пояса служит команда:

```shell
$ timedatectl set-timezone <часовой пояс>
```

Просмотреть список часовых поясов можно командой:

```shell
$ timedatectl list-timezones
```

Просмотреть информацию о текущем часовом поясе можно командой:

```shell
$ timedatectl status
```

##### 2.2.2 Просмотр и фильтрация логов

Для просмотра логов введите команду `sudo journalctl` - будет выведен огромный список различных записей. Обратите внимание на самую первую строку - она говорит, с какого момента начинается ведение логов. Как правило, это дата установки системы.

**Фильтр по дате**

Фильтрацию журналов можно выполнить и по дате - для этого используются
опции `--since` и `--until`. Например, для просмотра логов начиная с `11.10.24 7:00` введите команду:

```shell
journalctl --since "2024-10-11 07:00:00"
```

Если вы указали опцию `--since`, но не указали дату, будет взята текущая дата. Если указана дата, но не указано время, будет взято время `00:00:00`.

Еще несколько примеров:

```shell
journalctl --since yesterday
journalctl --since 09:00 --until now
journalctl --since 10:00 --until "1 hour ago"
```

Первая команда показывает логи, начиная со вчерашнего дня и по текущий момент. Вторая - отображает журналы, начиная с `9 утра` и по текущий момент. Третья - начиная с `10 утра` и до прошлого часа

**Фильтр по сервису**

Выполнить фильтрацию можно и по определенному сервису (когда нужно просмотреть не все журналы, а только опрtделенной службы):

```shell
journalctl -u nginx.service
```

Тип фильтрации можно комбинировать - например, следующая команда выводит журналы nginx начиная со вчерашнего дня:

```Shell
journalctl -u nginx.service --since today
```

**Фильтр по пути**

Просмотреть журналы какого-то процесса можно путем указания пути к нему:

```shell
journalctl /usr/bin/docker
```

**Фильтр по процессу или пользователю**

Можно отфильтровать журнал по `PID` процесса:

```Shell
journalctl PID=<PID процесса>
```

А также и по `UID` пользователя:

```Shell
journalctl UID=ЗЗ
```

Узнать `UID` пользователя можно так:

```Shell
id -u <имя пользователя>
```

**Просмотр сообщений ядра**

Для просмотра сообщений ядра используйте опции `-k` или `--dmesg`:

```shell
sudo journalctl -k
```

Эта команда покажет все сообщения ядра для текущей загрузки.

**Фильтр по уровню ошибки**

В `journalctl`, как и в `syslogd`, используется та же класификация уровней ошибок:

- 0 - EМERG (система неработоспособна);
- 1 - ALERT (требуется немедленное вмешательство);
- 2 - CRIT (критическое состояние);
- 3 - ERR ( ошибка);
- 4 - WARNING (предупреждение);
- 5 -NOТICE (просто обратите внимание);
- 6 - INFO (информационное сообщение);
- 7- DEBUG (отложенная печать).
Например:

```shell
sudo journalctl -p err -b
```

Эта команда выводит все ошибки при текущей загрузке.

**Журналы в реальном времени**

Журналы системы можно просматривать в реальном времени. Для этого используется опция `-f` :

```shell
sudo journalctl - f
```

