### 5.1 Планировщик операционной системы

##### Процессы

Когда приложения загружаются в оперативную память они становятся **процессами**. У каждого процесса есть в оперативной памяти своё адресное пространство в которых располагаются ресурсы процесса, которые изолированы от других процессов в памяти(т.е. процесс не может напрямую обратиться к ресурсам другого процесса).

![[Pasted image 20251119103325.png]]

Процессор выполняет инструкции находящиеся в разделе `code`(`text`) последовательно

![[Pasted image 20251119103921.png]]

`PC` - регистр следующей инструкции
`IR` - instruction registry (сюда загружаются инструкции для исполнения)
`R1`, `R2`, `R3` - регистры данных

Но в реальности при работе ОС в памяти находятся множество процессов, для того чтобы они не простаивали, процессор может с помощью **планировщика задач** переключаться на исполнение инструкций других процессов, имитируя таким образом многозадачность.

При вытесняющей многозадачности, планировщик может переключить процессор на другую задачу в любой момент времени.

![[Pasted image 20251119104945.png]]

При этом в инструкциях другого процесса могут использоваться те же регистры, что и в предыдущем процессе. Для этого планировщик, перед переключением процессов, сохраняет значения регистров в специальную структуру данных `task`, затем очищает все значения регистров и лишь затем начинает выполнять инструкции другого процесса

![[Pasted image 20251119105519.png]]

При дальнейшем переключении между процессами, данные регистров восстанавливаются из стуктуры `task` для корректного продолжения работы процесса.

##### Поток

Каждый процесс имеет, как минимум один **поток**. Потоки запущенные процессом имеют общую память(т.е. напрямую могут общаться между собой) 

Потоки, так же как и процессы имеют собственные регистры, но они, в общем легче процессов, но имеют такую же структуру и по сути **планировщик задач работает именно с потоками**.

У каждого потока свой стек

![[Pasted image 20251119111417.png]]

##### Горутины

**Горутина** - это легковесный поток

- Начальный размер стека - `2кб`, и стек может расти до `1гб` (`256мб` в `32`-битной системе) - Для сравнения, поток ОС имеет фиксированный размер `1-8 мб`, для примера `1000` горутин - `2МБ`
- Переключение горутин происходит в определенные моменты, когда горутина не выполняет CPU-intensive задачи, не нужно сохранять всё состояние процессора - В ОС конкурентность вытесняющая, в `Go` конкурентность кооперативная(горутины в определенные моменты сигнализируют, когда их можно вытеснить), например горутины не переключаются в момент интенсивной нагрузки процессора в отличии от потоков ОС
- Для создания и переключения горутин не нужно выполнять Syscall (поход в `Kernel Space`) и обращаться к планировщику OS для переключения потока. Всё это делается в `User Space` - Горутина это сущность Go и выполняется она с помощью планировщика Go, потоки ОС при этом не переключаются

Чем плох `Syscall`?
- выполняется дольше (2х mode switch + context switch = 1.2 - 12ms) для сравнения переключение горутин занимает 100-500ns.
- когда поток уходит в Kernel Space, мы теряем над ним контроль (не можем предсказать, когда он выполнится, можем только ждать)

### Планировщик в Go

##### Зачем нам свой планировщик в Go?

- Не давать разработчику потоки, сделать вид что есть только горутины (зачем это нужно - см. что такое горутина)
- Эффективное использование ресурсов процессора и кэшей
	- пул потоков - не тратится время на создание потоков
	- добавление новых горутин в очередь текущего процессора
	- кэши логических процессоров
	- work stealing - логические процессоры не простаивают, а проактивно ищут себе работу
	- и т.д
- Эффективная работа с сетевыми вызовами (network I/O)

##### Особенности планировщика Go

Это **NxM** планировщик.

Планировщик Go управляет выполнением горутин, эффективно распределяя их между потоками ОС с помощью модели M:N.  
  
что делает планировщик Go  
  
Планировщик Go отвечает за:  
- Создание, выполнение и завершение горутин (легковесных потоков)  
- Распределение горутин между потоками ОС  
- Переключение контекста между задачами без участия ядра ОС (в большинстве случаев)  

Архитектура: модель `M:N ` 
  
Go использует модель `M:N`, где:  
- `G (goroutine)` — задача, которую нужно выполнить  
- `M (machine)` — поток ОС, исполняющий код  
- `P (processor)` — логический процессор, управляющий очередью горутин  
  
Связь:  
- Каждому `P` соответствует очередь горутин  
- M может выполнять только те горутины, которые привязаны к `P`  
- Количество `P` задаётся через `GOMAXPROCS` (по умолчанию = числу ядер)  

Как работает планирование  
  
1. Создание горутины — добавляется в очередь `P`  
2. `M` получает `P` и начинает выполнять горутины из его очереди  
3. Если горутина блокируется (например, ждёт `I/O`), `M` может взять другую из очереди  
4. Если очередь пуста, `P` может "украсть" горутину у другого `P` (`work stealing`)  
5. Переключение контекста происходит быстро, без системных вызовов  

Особенности и преимущества  
  
- Лёгкие горутины: тысячи горутин могут работать одновременно  
- Быстрое переключение: не требует вмешательства ОС  
- Эффективное использование ядер: благодаря `GOMAXPROCS` и `P/M/G` модели  
- Механизмы синхронизации: каналы, мьютексы и др. встроены