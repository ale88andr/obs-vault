**МАССИВ** - Структура данных фиксированного размера, хранящая последовательно элементы одного типа (каждый элемент имеет индекс от `0` до `n-1`)

![[Pasted image 20250831222055.png]]

## Создание Maccива

```go
var datal [5]int           // [0 0 0 0 0]
var data2 [2][5]int        //[[0 0 0 0 0] [0 0 0 0 0]]
data3 := [...]int{1, 2, 3} // [1 2 3]
data4 := [5]int{1, 2, 3}   //[1 2 3 0 0]
data5 := [5]tnt{3:4}       // [0 0 0 4 0]
data6 := [5]int{2: 5, 6, 1: 7} // [0 7 5 6 0]
```

## API

```go
value := data[5] // чтение из массива
data[5] = 10000  // запись в массив
len(data)        // получение длины массива
cap(data)        // получение емкости массива
p := &data       // получение указателя на массив
s := data[1:4]   // получение среза из массива
```

**МАССИВ != УКАЗАТЕЛЬ и ВНУТРИ НЕГО НЕТ НИКАКОГО УКАЗАТЕЛЯ**
Это структура данных у которой есть только адрес начала, длина и размер элементов

Как вычисляется доступ к элементу:
```go
array[idx] = *(array + idx * elem_size):
array[0] = *(array + 0 * 2) // *(0xA02 + 0 * 2) = 0xA2
array[1] = *(array + 1 * 2) // *(0xA02 + 1 * 2) = 0xA4
array[2] = *(array + 2 * 2) // *(0xA02 + 2 * 2) = 0xA6
array[3] = *(array + 3 * 2) // *(0xA02 + 3 * 2) = 0xA8
```

МАССИВ В GO - Его длина, как и размер элементов является частью типа (не хранятся рядом с данными)

```go
package main

func mainO {
    data1 := [3]int{1, 2, 3} // data1 - один тип данных
    data2 := [2]int{1, 2} // data2 - другой тип данных
    datal = data2 // compilation error
}
```

ВЫЗОВ ФУНКЦИИ `LEN()` ДЛЯ МАССИВА ВЫЧИСЛЯЕТСЯ НА ЭТАПЕ КОМПИЛЯЦИИ - А не в рантайме

Т.е. в данном коде компилятор просто подставит константу из типа, а не будет вызываться какая либо функция

```go
data := [5]tnt{ 1, 2, 3, 4, 5 } 
length := len(data)	// => 5
```

МАССИВ В GO - Не имеет постоянного расположения в памяти на все время жизни программы (может переезжать, когда растет стек горутины)

**КАК ИТЕРИРОВАТЬСЯ ПО МАССИВУ?**

**OFF BY ONE ERROR** - Ошибка на единицу или ошибка неучтённой единицы - логическая ошибка в алгоритме, включающая в частности дискретный вариант нарушения граничных условий

```go
for i := 0; i < len(data); i++ {
	...
}
```

Чтобы обойти эту ошибку, в go есть следующие конструкции

```go
for _, value := range data {
	...
}

for idx, _ := range data {
	...
}

for idx := range data {
	...
}

for _, _ = range data {
	...
}

for range data {
	...
}
```

**GO АЛЛОЦИРУЕТ МАССИВ В СТЕКЕ, ЕСЛИ ЕГО РАЗМЕР МЕНЬШЕ <= `10` МБ**

22:03