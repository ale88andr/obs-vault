## 1.1.1 Стек и куча
Память делится на 2 части: *стек* и *кучу*

![[Pasted image 20251029214404.png]]

Куча растет последовательно, стек заполняется от конца к началу, когда стэк заполняется(доходит до защищенной области) происходит переполнение (`stackoverflow`)

![[Pasted image 20251029214818.png]]

Cтек и куча - это разные способы работы с памятью:
- стек как правило быстрее, и ненужная память освобождается автоматически
	- стек лучше подходит для хранения **недолго живущих локальных переменных**
- работа с кучей как правило медленнее, и ненужная память не освобождается автоматически (нужно освобождать ее вручную или использовать `GC`)
	- в куче хранятся объекты, ссылки на которые **живут за пределами функции**

### Стек в Go

В `Go` стеков много! (каждой горутине выделяется свой стек). Стеки выделяются операционной системой.
- начальный размер стека при запуске горутины от `2KB` до `8KB`. 
- если стек переполняется, Go автоматически увеличивает его размер путем копирования текущего стека в новое место с большим объемом памяти

`Go` использует *анализ выхода* (`escape analysis`), чтобы определить можно ли хранить переменную в стеке или в куче:
- Если переменная не покидает область видимости функции - **стек**
- Если переменная возвращается из функции или передается по ссылке - **куча**
- Если объект слишком большой (`> 10mb`), он аллоцируется в **куче**
- Если неизвестно, насколько большим вырастет объект в рантайме, он аллоцируется в **куче**
- Так же часто аллоцируются в **куче** литералы функций и структуры данных, принадлежащие мапам, слайсам, строкам и каналам

стеки условно "бесконечные", растут до `1Gb` (до `256Мb` в 32 битной системе)

Код в `Go` в основном состоит из вызова различных функций, которые попадают в стек как специальная область - `function frame`, при этом `stack pointer` перемещается на функцию которая вызовется первой:

![[Pasted image 20251029220916.png]]

Пример динамического стека:

```go
package main

//go:noinline
func foo() {
    bar()
}

//go:noinline
func bar() {
    arr := [10000]byte{}
    println(&arr)
}

func main() {
    a := 1
    println("before", &a)
    foo()
    println("after", &a)
}
```

Адрес переменной `a` изменился:

```
before 0xc000059f38
0xc00002f7f8
after 0xc000031f38
```

Когда функция исполняется  `stack pointer` двигается назад, а место в стеке помечается как `invalid memory`:

![[Pasted image 20251029224515.png]]

А какая разница, на стеке или в куче аллоцировать?

- При аллокации в куче мы нагружаем `GC` + немного замедляется выполнение функции

> Аллокатор пытается аллоцировать все переменные на стеке, кроме переменных, которые будут использоваться за пределами функции, либо переменные больших размеров (`> 10Mb`), а так же переменные, размер которых неопределен, но может вырасти до этого предела.

### Nil значения

```go
package main

import "fmt"

func main() { 
	var m map([string]int) // исправляем на m := make(map([string]int))
	m["A"] = 1
	m["B"] = 2
	m["C"] = 3
	fmt.Println(m) // panic
```

|           | value  | read                | write          | execute |
| --------- | ------ | ------------------- | -------------- | ------- |
| **slice** | `nil`  | read by index fails | append works   | -       |
| **map**   | `nil`  | zero value          | `panic`        | -       |
| **func**  | `nil`  | -                   | -              | `panic` |
| **chan**  | `chan` | blocks forever      | blocks forever | -       |

### Сборщик мусора

##### Зачем нужен сборщик мусора и как он работает?

- Нужен для того, чтобы освобождать память в **куче** от объектов, которые больше не нужны приложению

##### Что такое мусор? Откуда берется мусор в приложении?

- Мусор - это объекты, на которые нет валидных ссылок

Объект появляется в куче(например в функции `foo()` создается массив, ссылка на него остается в стеке, как и объект функции, сам массив помещается в куче, т.к. размер массива превышает порог хранения в стеке)

![[Pasted image 20251102205955.png]]

Функция отработала, `stack pointer` помечает область памяти с функцикй и её переменными как *невалидный участок памяти*, таким образом переменная массива становится недостижимой:

![[Pasted image 20251102210537.png]]

В какой-то момент вызывается следующая функция `bar()`

![[Pasted image 20251102210855.png]]

Таким образом получается, что ссылки на массив нет, но сам массив остался в куче - такой объект становится мусором, который нужно чистить.

##### Какой алгоритм сборщика мусора?

- **Concurrent mark & sweep** (на основе трёхцветной маркировки с инкрементальной очисткой и минимальными паузами *Stop-The-World*)

Алгоритм в двух словах:
1. **Трёхцветная маркировка (Three-color marking):**
	- Все объекты делятся на _белые_ (непроверенные), _серые_ (проверяемые) и _чёрные_ (проверенные).
	- Цель — найти все достижимые объекты, начиная с корневых, и пометить их как чёрные.
	- Белые объекты, не достигнутые в процессе, считаются мусором и удаляются.
2. **Инкрементальность и конкурентность:**
	- Сборщик мусора работает _параллельно_ с основным приложением, минимизируя паузы.
	- Большая часть работы GC выполняется в фоне, а короткие Stop-The-World (STW) паузы происходят только в ключевых моментах — например, при завершении цикла маркировки.
3. **Темп работы (Pacing):**
	- GC регулирует свою активность в зависимости от скорости выделения памяти.
	- Чем больше аллокаций — тем активнее работает GC, чтобы избежать переполнения кучи.

**Этапы работы GC в Go**
1. **Start GC Cycle:** начинается новый цикл, запускается фоновая маркировка.
2. **Mark Phase:** объекты маркируются как достижимые.
3. **STW Pause:** короткая пауза для завершения маркировки. (**Низкие паузы STW:** обычно менее 1 мс, что делает GC подходящим для real-time приложений.)
4. **Sweep Phase:** удаление недостижимых объектов.
5. **Allocation:** освобождённая память становится доступной для новых объектов.

**Профилирование GC:** Go предоставляет инструменты (`runtime/pprof`, `GODEBUG=gctrace=1`) для анализа поведения GC.

**Настройки GC:** можно управлять чувствительностью GC через переменную `GOGC` (по умолчанию 100 — означает, что GC запускается при увеличении кучи на 100%).

##### Маркировка объектов

Фаза маркировки нужна для того, чтобы понять какие объекты являются мусором.

Изначально все объекты в куче считаются **белыми**:

![[Pasted image 20251102220149.png]]

В первую очередь собираются все ссылки на объекты в куче из стеков горутин и глобальных переменных. Такие объекты в куче помечаются как проверяемые(*серые*), т.е. те, по которым необходимо проитерироваться и поискать в них ссылки на другие объекты:

![[Pasted image 20251102220836.png]]

Допустим, мы взяли первый объект(`obj1`) из очереди и в ходе проверки выясняем, что он содержит ссылку на существующий *белый* объект в куче. Тогда новый найденный объект помечается как *серый* при этом ссылка на него помещается в очередь проверки, а объект `obj1` после окончательной проверки помечается как *черный*.

![[Pasted image 20251102221355.png]]

Далее получаем следующий объект(`obj5`), проверяем его и допустим находим в нем две новые ссылки на объекты `obj24` и `obj12`:

![[Pasted image 20251102222332.png]]

и по аналогии помечаем `obj5`, как *черный*, а объекты `obj24` и `obj12` как *серые* и добавляем их в конец очереди проверки

![[Pasted image 20251102222525.png]]

и так далее до тех пор, пока очередь проверки не окажется пустой:

![[Pasted image 20251102223145.png]]

В тот момент, когда очередь окажется пустой, фаза разметки считается завершенной, а по результатам маркировки объекты в куче стали либо *белыми*, либо *черными*. Далее GS выключается(т.е. все горутины начинают работать на полную мощность), а помеченная на очистку память освобождается по мере необходимости(по мере аллокации новых объектов) при этом вновь добавленные объекты маркируются *белыми*.

![[Pasted image 20251102223703.png]]

Потом цикл GC запускает следующую итерацию с новыми объектами.

Но есть один нюанс! **Сборщик мусора работает _параллельно_ с основным приложением**, т.е. приложение во время фазы маркировки может аллоцировать новые объекты в куче:

![[Pasted image 20251102224816.png]]

Чтобы решить эту проблему вводится глобальная переменная(`write barrier`) которая при каждой аллокации проверяет установлен ли барьер на запись(`write barrier`) или нет. И если барьер установлен, то вновь аллоцируемая переменная маркируется не *белой*, а сразу *черной*  (`obj29` на рисунке)

![[Pasted image 20251102225356.png]]

##### Когда запускается GC?

- Когда память в куче заполняется до определенного значения (частота запуска GC регулируется `GOGC` и `MEMLIMIT`)
- Раз в 2 минуты
- Можно запустить вручную

**GC работает конкурентно с приложением** (При этом он забирает 25% ресурсов CPU себе)

> Работающие горутины могут быть привлечены к разметке, если они аллоцируют слишком много объектов

GC можно отключить. `GOGC=off` (при этом `MEMLIMIT` не должен быть задан)


