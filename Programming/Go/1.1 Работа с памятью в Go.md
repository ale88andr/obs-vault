## 1.1.1 Стек и куча
Память делится на 2 части: *стек* и *кучу*

![[Pasted image 20251029214404.png]]

Куча растет последовательно, стек заполняется от конца к началу, когда стэк заполняется(доходит до защищенной области) происходит переполнение (`stackoverflow`)

![[Pasted image 20251029214818.png]]

Cтек и куча - это разные способы работы с памятью:
- стек как правило быстрее, и ненужная память освобождается автоматически
	- стек лучше подходит для хранения **недолго живущих локальных переменных**
- работа с кучей как правило медленнее, и ненужная память не освобождается автоматически (нужно освобождать ее вручную или использовать `GC`)
	- в куче хранятся объекты, ссылки на которые **живут за пределами функции**

### Стек в Go

В `Go` стеков много! (каждой горутине выделяется свой стек). Стеки выделяются операционной системой.
- начальный размер стека при запуске горутины от `2KB` до `8KB`. 
- если стек переполняется, Go автоматически увеличивает его размер путем копирования текущего стека в новое место с большим объемом памяти

`Go` использует *анализ выхода* (`escape analysis`), чтобы определить можно ли хранить переменную в стеке или в куче:
- Если переменная не покидает область видимости функции - **стек**
- Если переменная возвращается из функции или передается по ссылке - **куча**
- Если объект слишком большой (`> 10mb`), он аллоцируется в **куче**
- Если неизвестно, насколько большим вырастет объект в рантайме, он аллоцируется в **куче**
- Так же часто аллоцируются в **куче** литералы функций и структуры данных, принадлежащие мапам, слайсам, строкам и каналам

стеки условно "бесконечные", растут до `1Gb` (до `256Мb` в 32 битной системе)

Код в `Go` в основном состоит из вызова различных функций, которые попадают в стек как специальная область - `function frame`, при этом `stack pointer` перемещается на функцию которая вызовется первой:

![[Pasted image 20251029220916.png]]

Пример динамического стека:

```go
package main

//go:noinline
func foo() {
    bar()
}

//go:noinline
func bar() {
    arr := [10000]byte{}
    println(&arr)
}

func main() {
    a := 1
    println("before", &a)
    foo()
    println("after", &a)
}
```

Адрес переменной `a` изменился:

```
before 0xc000059f38
0xc00002f7f8
after 0xc000031f38
```

Когда функция исполняется  `stack pointer` двигается назад, а место в стеке помечается как `invalid memory`:

![[Pasted image 20251029224515.png]]

А какая разница, на стеке или в куче аллоцировать?

- При аллокации в куче мы нагружаем `GC` + немного замедляется выполнение функции
- 