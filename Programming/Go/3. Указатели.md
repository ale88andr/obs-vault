**УКАЗАТЕЛЬ** - Переменная, диапазон значений которой состоит из адресов ячеек памяти или специального значения - нулевого адреса (`nil`)

**Указатели** - это переменные, которые хранят **адрес** в памяти, а не значения.

> **Ссылка** и **указатель** в Go - **синонимы** 

```go
func main() {
    a := 5
    println("Адрес:", &a)
    println("Значение:", *&a)
}
```

![[Pasted image 20251029071052.png]]

```go
// 1 way 
pointer := new(int)
// 2 way 
var value int pointer := &value
// 3 way - only for structs 
pointer := &int{}
```

```go
package main

import "fmt"

func main() {
	var value int32 = 100
	var pointer *int32 = &value
	
	fmt.Println("address:", pointer) 
	fmt.Println("value:", *pointer)
	
	*pointer = 500

	fmt.Println("address:", pointer)
	fmt.Println("value:", *pointer)
```

![[Pasted image 20251029071227.png]]

![[Pasted image 20250831134944.png]]

**ЗАЧЕМ НУЖНЫ УКАЗАТЕЛИ?**: 
1. чтобы убрать лишнее копирование, например при передаче значения в функцию

```go
package main

import "fmt"

func double(number *int) {
	fmt.Printin("address:", &number)
	*number *= 2
}

func main() { 
	number := 100 
	double(&number)
	fmt.PrintIn("number:", number)
	fmt.PrintIn("address:", &number)
}
```

2. Чтобы вместо больших объектов передавать только адреса на них и чтобы строить структуры данных, основанные на указателях (такие как связные списки, деревья и так далее)
3. Мутировать значение, например в структурах

> В Go не поддерживается арифметика указателей, но зато можно использовать пакет `unsafe`

Пример #1:

```go
package main

import "fmt"

func main() {
    a := [4]int{1, 2, 3, 4}
    reverse(&a)
    fmt.Println(a)
}

func reverse(n *[4]int) {
    for index, value := range *n {
        (*n)[len(*n)-1-index] = value
    }
}
```

##### Ключевой момент: 

`range` создает копию массива

В Go, когда вы используете  `range` с массивом, он создает **копию** массива на момент начала итерации. Поэтому переменная `value` всегда содержит исходные значения, даже если массив изменяется в процессе.

Код работает правильно именно потому, что `range` использует снимок исходного массива, а не текущее состояние изменяющегося массива. Это особенность Go, которая делает такой алгоритм разворота массива корректным. Но! Этот код **не будет работать для слайсов**.  для слайсов `range` **НЕ** создает копию.

Пример #2:

```go
package main

import "fmt"

func main() {
    a := false
    b := true
    c := &a
    d := &b

    fmt.Printf("value = %v, address = %p\n", a, &a)
    fmt.Printf("value = %v, address = %p\n", b, &b)
    fmt.Printf("value = %v, address = %p\n", c, &c)
    fmt.Printf("value = %v, address = %p\n", d, &d)
}
```

```plaintext
value = false, address = 0xc00000a0f8
value = true, address = 0xc00000a0f9
value = 0xc00000a0f8, address = 0xc000058060
value = 0xc00000a0f9, address = 0xc000058068
```

### Передача аргументов

В Go всё передаётся **по значению**, и это значение копируется

```go
func changeName(name string) { } // передаётся и копируется строка

func changeName(name *string) { } // передаётся и копируется ссылка на строку
```

Может показаться, что во втором случае переменная передастся по ссылке, но на самом деле это **НЕ** так!

Пример №1:

```go
package main

import "fmt"

func changeName(name string) {
    fmt.Printf("changeName value = %v, address = %p\n", name, &name)
}

func main() {
    name := "Alexandr"
    fmt.Printf("main value = %v, address = %p\n", name, &name)
    changeName(name)
}
```

```
main value = Alexandr, address = 0xc00009c060
changeName value = Alexandr, address = 0xc00009c080
```

Внутри функции `changeName` создалась новая переменная `name`

Пример №2:

```go
package main

import "fmt"

func changeName(name *string) {
    fmt.Printf("changeName value = %v, address = %p\n", name, &name)
} 

func main() {
    name := "Alexandr"
    fmt.Printf("main value = %v, address = %p\n", name, &name)
    changeName(&name)
}
```

```
main value = Alexandr, address = 0xc00009c060
changeName value = 0xc00009c060, address = 0xc00008e060
```

Внутри функции `changeName` создалась новая переменная ссылочного типа `name`

Важный момент касающийся слайсов:

```go
package main

import "fmt"  

func changeSlice(s []int) {
    s[1] = 10
}

func main() {
    s := []int{1, 2, 3}
    changeSlice(s)
    fmt.Println(s) // [1 10 3]
}
```

Такой код сработает, т.к. слайс - это ссылочный тип, т.е. в `changeSlice(s)`, `s` - это ссылка на слайс, хоть и не помечена как `&s`

!но такой код уже не будет работать:

```go
package main

import "fmt" 

func changeSlice(s []int) {
    s = append(s, 4)
}

func main() {
    s := []int{1, 2, 3}
    changeSlice(s)
    fmt.Println(s) // [1 2 3]
}
```

т.к. `s` - это ссылка на слайс (адрес), её значение копируется в функцию `changeSlice`, а затем переприсваивается ссылка на новый слайс и после окончания работы функции исчезает, т.к. результат работы функции не возвращается. Т.е. в первом случае мы обращаемся к значению слайса через адрес, а во втором случае мы присваеваем переменной новый адрес, который никуда не передается.
