**ТИП ДАННЫХ** - Множество значений и операций, которые могут быть применимы над этими значениями

![[Pasted image 20251029070109.png]]

**ПРИМИТИВНЫЕ ТИПЫ ДАННЫХ**
*Логические*
- bool
*Строковые*
- string
*Числовые*
- int8, uint8 (byte), int16, uint16, int32(rune), uint32, int64, uint64, int, uint, uintptr
- float32, float64
- complex

**СОСТАВНЫЕ ТИПЫ ДАННЫХ**
1.	Указатели
2.	Структуры
3.	Функции
4.	Контейнеры
	- массивы
	- срезы
	- словари
5.	Каналы
6. Интерфейсы

КАЖДЫЙ ТИП ИМЕЕТ НУЛЕВОЕ ЗНАЧЕНИЕ (**ZERO VALUE**) - которое можно рассматривать как значение типа по умолчанию

### ТИПЫ ДАННЫХ

| ТИП          | ЭКЗЕМПЛЯРЫ                                  | ОПИСАНИЕ                                                  |
| ------------ | ------------------------------------------- | --------------------------------------------------------- |
| Базовые      | `numbers`<br>`strings`<br>`boolean`         | Простые типы данных                                       |
| Агрегирующие | `array`<br>`structs`                        | Составные типы днных, которые содержат другие типы данных |
| Ссылочные    | `slice`<br>`map`<br>`function`<br>`channel` | Тыпы данных представленные в виде некоторой связи         |

#### КАКОЙ РАЗМЕР У ОСНОВНЫХ ТИПОВ ДАННЫХ?

**Бит** - минимальная единица измерения информации, которая принимает значение «ноль» или «один»
**Байт (октет)** - единица измерения информации, которая состоит из восьми бит или двух тетрад
**Машинное слово** - основная единица информации, которой оперирует процессор (размер машинного слова равен архитектуре процессора, например 32 или 64 битная архитектура)

| ТИП                          | РАЗМЕР В БАЙТАХ                                                                                  |
| ---------------------------- | ------------------------------------------------------------------------------------------------ |
| `uint8`, `int8`              | `1`                                                                                              |
| `uint16`, `int16`            | `2`                                                                                              |
| `uint32`, `int32`, `float32` | `4`                                                                                              |
| `uint64`, `int64`            | `8`                                                                                              |
| `float64`, `complex64`       | `8`                                                                                              |
| `complex128`                 | `16`                                                                                             |
| `uint`, `int`                | implementation-specific, generally `4` on 32-bit architectures, and `8` on 64 bit architectures. |
| `uintptr`                    | implementation-specific, large enough to store the uninterpreted bits of a pointer value.        |
### ЦЕЛОЧИСЛЕННЫЕ ТИПЫ ДАННЫХ

МОЖНО ЗАКОДИРОВАТЬ `2nN - 1` ЗНАЧЕНИЙ, где `N` - количество бит
**8 бит**
- `00000000` = `0`
- `11111111` = `255`
**16 бит**
- `00000000 00000000` = `0`
- `11111111 11111111` = `65535`

### РАЗРЯДЫ БИТОВ

Седьмой разряд (крайний левый) называется старшим, а нулевой разряд (крайний правый) - младшим. Наименьшему значению соответствует комбинация нулей, а наибольшему значению соответствует комбинация единиц

![[Pasted image 20250830203337.png]]

### ЦЕЛОЧИСЛЕННЫЕ ЛИТЕРАЛЫ
- Двоичные - используется префикс `0b` или `0B` (например `0b100`)
- Восьмеричные - используется префикс `0` или `0о` (например `010`)
- Шестнадцатеричные - используется префикс `0х` или `0Х` (например `0xF`)
- Мнимые - используется суффикс `i` (например `3i`)

Еще можно использовать `_` в качестве разделителя для удобства чтения, например `1_000_000`

## УКАЗАТЕЛИ

**УКАЗАТЕЛЬ** - Переменная, диапазон значений которой состоит из адресов ячеек памяти или специального значения - нулевого адреса (`nil`)

![[Pasted image 20251029071052.png]]

```go
// 1 way 
pointer := new(int)
// 2 way 
var value int pointer := &value
// 3 way - only for structs 
pointer := &int{}
```

```go
package main

import "fmt"

func main() {
	var value int32 = 100
	var pointer *int32 = &value
	
	fmt.Println("address:", pointer) 
	fmt.Println("value:", *pointer)
	
	*pointer = 500

	fmt.Println("address:", pointer)
	fmt.Println("value:", *pointer)
```

![[Pasted image 20250831134944.png]]

**ЗАЧЕМ НУЖНЫ УКАЗАТЕЛИ?**: 
1. чтобы отменить копирование, например при передаче значения в функцию

```go
package main

import "fmt"

func double(number *int) {
	fmt.Printin("address:", &number)
	*number *= 2
}

func main() { 
	number := 100 
	double(&number)
	fmt.PrintIn("number:", number)
	fmt.PrintIn("address:", &number)
}
```

2. Чтобы вместо больших объектов передавать только адреса на них и чтобы строить структуры данных, основанные на указателях (такие как связные списки, деревья и так далее)

> В Go не поддерживается арифметика указателей, но зато можно использовать пакет `unsafe`














