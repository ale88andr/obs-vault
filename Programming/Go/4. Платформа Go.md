## Слайсы

Слайс -  реализация в Go динамического массива

Структура слайса:

```go
type slice struct { 
	array unsafe.Pointer 
	len int 
	cap int
}
```

```go
a := []int8{1, 2, 3}
```

![[Pasted image 20251103130616.png]]

### `append`

Допустим мы хотим добавить элемент в слайс

```go
a = append(a, 4)
```

При этом происходит следующее:

1. Вычисляется новая длинна массива `new len = 4`
2. Новая длинна массива сравнивается с `cap`(вместимостью) текущего массива
3. Если новая длинна больше текущей `cap`, то в памяти выделяется место под новый массив (при этом у нового массива `cap` будет вычисляться по формуле: `new cap = cap * 2`)
4. В новый массив копируются значения старого и добавляется новое значение
5. Обновляется ссылка `array` в структуре на новую ячейку памяти
6. Обновляются значения `len` и `cap` в структуре

![[Pasted image 20251103132554.png]]

### Механика работы ссылочного типа

Слайс - **ссылочный** тип.

При передачи слайса в функцию - передается копия слайса, но сама ссылка на массив в копии остается **прежней**:

Если мы хотим поменять значения в копии - обновится исходный массив:

![[Pasted image 20251103135000.png]]

Если мы хотим добавить элемент в слайс - создастся новый слайс не имеющий отношение к старому

![[Pasted image 20251103133928.png]]

допустим, мы хотим к копии слайса добавить элемент:

![[Pasted image 20251103134300.png]]

при этом выделится новая область памяти, значения из старого массива скопируются в новый, а так же добавится новый элемент. Затем в копии слайса обновится ссылка на `array`

![[Pasted image 20251103134656.png]]

### Задача №1

```go
package main

import "fmt"

func main() {
	a := []int{1, 2, 3} // len=3, cap=3, a = [1,2,3]

	println("cap(a) =", cap(a))

	b := append(a, 4) // len=4, cap=6, new arr, b =(1,2,3,4],0,0
	c := append(a, 5) // len=4, cap=6, new arr, c =(1,2,3,5],0,0

	c[1] = 0 // c = [1,0,3,5],0,0

	fmt.Println("a =", a) // a = [1 2 3]
	fmt.Println("b =", b) // b = [1 2 3 4]
	fmt.Println("c =", c) // c = [1 0 3 5]
}
```

### Задача №2

```go
package main

import "fmt"

func main() {
    a := []int{1, 2, 3, 4, 5}   // len=5, cap=5, a = [1,2,3,4,5]
    b := a[2:4]                 // b = [3,4],5; len=2, cap=3, based on a
    c := append(b, 10)          // len=3, cap=3, based on b, c = [3,4,10], b = [3,4],10, a = [1,2,3,4,10]
    c[1] =50                    // c = [3,55,10], b = [3,55],10, a = [1,2,3,55,10]

    fmt.Println(a)              // [1 2 3 50 10]
    fmt.Println(b)              // [3 50]
    fmt.Println(c)              // [3 50 10]

    d := b[:3]
    fmt.Println(d)              // [3 50 10]
}
```


```go

```

