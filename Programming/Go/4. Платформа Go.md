## Слайсы

Слайс -  реализация в Go динамического массива

Структура слайса:

```go
type slice struct { 
	array unsafe.Pointer 
	len int 
	cap int
}
```

```go
a := []int8{1, 2, 3}
```

![[Pasted image 20251103130616.png]]

### `append`

Допустим мы хотим добавить элемент в слайс

```go
a = append(a, 4)
```

При этом происходит следующее:

1. Вычисляется новая длинна массива `new len = 4`
2. Новая длинна массива сравнивается с `cap`(вместимостью) текущего массива
3. Если новая длинна больше текущей `cap`, то в памяти выделяется место под новый массив (при этом у нового массива `cap` будет вычисляться по формуле: `new cap = cap * 2`)
4. В новый массив копируются значения старого и добавляется новое значение
5. Обновляется ссылка `array` в структуре на новую ячейку памяти
6. Обновляются значения `len` и `cap` в структуре

![[Pasted image 20251103132554.png]]

### Механика работы ссылочного типа

Слайс - **ссылочный** тип.

При передачи слайса в функцию - передается копия слайса, но сама ссылка на массив в копии остается **прежней**:

Если мы хотим поменять значения в копии - обновится исходный массив:

![[Pasted image 20251103135000.png]]

Если мы хотим добавить элемент в слайс - создастся новый слайс не имеющий отношение к старому

![[Pasted image 20251103133928.png]]

допустим, мы хотим к копии слайса добавить элемент:

![[Pasted image 20251103134300.png]]

при этом выделится новая область памяти, значения из старого массива скопируются в новый, а так же добавится новый элемент. Затем в копии слайса обновится ссылка на `array`

![[Pasted image 20251103134656.png]]

### Задача №1

```go
package main

import "fmt"

func main() {
	a := []int{1, 2, 3} // len=3, cap=3, a = [1,2,3]

	println("cap(a) =", cap(a))

	b := append(a, 4) // len=4, cap=6, new arr, b =(1,2,3,4],0,0
	c := append(a, 5) // len=4, cap=6, new arr, c =(1,2,3,5],0,0

	c[1] = 0 // c = [1,0,3,5],0,0

	fmt.Println("a =", a) // a = [1 2 3]
	fmt.Println("b =", b) // b = [1 2 3 4]
	fmt.Println("c =", c) // c = [1 0 3 5]
}
```

### Задача №2

```go
package main

import "fmt"

func main() {
    a := []int{1, 2, 3, 4, 5}   // len=5, cap=5, a = [1,2,3,4,5]
    b := a[2:4]                 // b = [3,4],5; len=2, cap=3, based on a
    c := append(b, 10)          // len=3, cap=3, based on b, c = [3,4,10], b = [3,4],10, a = [1,2,3,4,10]
    c[1] =50                    // c = [3,55,10], b = [3,55],10, a = [1,2,3,55,10]

    fmt.Println(a)              // [1 2 3 50 10]
    fmt.Println(b)              // [3 50]
    fmt.Println(c)              // [3 50 10]

    d := b[:3]
    fmt.Println(d)              // [3 50 10]
}
```

### Задача №3

```go
package main

import "fmt"

const MAX = 5

func main() {
    s := generate() // s = [1,2,3,4],0 ; len=4, cap=5
    mutation(s)     // s = [1,2,3,4],-1, len=4, cap=5

    fmt.Println("s=", s) // s= [1 2 3 4]
    fmt.Println(s[0:MAX]) // [1 2 3 4 -1]
} 

func generate() []int {
    out := make([]int, 0, MAX) // out = [],0,0,0,0,0, ten=0, cap=5
    for i := 1; i < MAX; i++ { // 1,2,3,4 out = append(out, i)
        out = append(out, i)
    }
    return out
}

func mutation(s []int) {
    s = append(s, -1) // len=5, cap=5, s = [1,2,3,4,-1]
}
```

## Мапы

Операции удаления, добавления и поиска выполняются **за константное время**

- **Ключи должны быть сравнимыми** (`comparable`): числа, строки, массивы, указатели, интерфейсы и т.д. Несравнимые типы (например, срезы) использовать нельзя

#### Внутреннее устройство `map`

- **Хеш-таблица** — основа `map`. Ключи хешируются, и результат используется для определения, в какой _бакет_ поместить пару ключ-значение.
- **Бакеты** — это фиксированные структуры, содержащие до 8 пар ключ-значение. Если в бакете возникает переполнение, создаются _overflow-бакеты_.

при создании `map`

```go
m := make(map[int]int)
```

в этот момент создаются бакеты `buckets` - это структура данных, содержащая другие структуры данных(по сути массивы ограниченной длинны): `tophash`, `key`, `value`

![[Pasted image 20251106144801.png]]

Допустим, мы хотим добавить элемент в мапу:

```go
m[1] = 10
```

При этом происходит следующее:

1. Вычисляется хеш ключа (в данном случае - `1`)

```
hash(1) = 11000110 10010010 10101010 00010001
```

2. На следующем шаге нам нужно узнать в какой бакет нужно положить ключ и значение, для этого берется `Low Order Bits` (определенное количество бит с хвоста хеша, которое зависит от количества бакетов) 

	11000110 10010010 10101010 000100**01**
	`01` - Будет означать что запись будет производиться в **бакет № 1**

3. Далее выбираем первый байт хеша, ключ и значение и добавляем в нужный бакет

	`tophash` - **11000110** 10010010 10101010 00010001
	`key` - **1**
	`value` - **10**

![[Pasted image 20251106152003.png]]

##### Общее представление

![[Pasted image 20251106165307.png]]

### Сложность вставки в `map`

1. Вычисление хеша: `hash(1) = 11000110 10010010 10101010 00010001` - **O(1)**
2. Поиск Low Order Bit (номера бакета): `LOB(hash(1)) = 01` - **O(1)**
3. Взятие первого байта от хэша - **O(1)**
4. Добавление первого байта в массив `tophash` - **O(1)**
5. Добавление ключа и значения в массивы - **O(1)** и **O(1)**

> Итого - **O(1)**

###### Всегда ли сложность **O(1)**?
- не всегда, т.к. существуют **коллизии**
- В худшем случае все элементы попадут в один бакет. Тогда нам придется последовательно перебирать весь связанный список бакетов(т.е. N), следовательно сложность будет **O(N)**

### Поиск по ключу

![[Pasted image 20251106173536.png]]

1. Go применяет хеш-функцию к ключу. Вычисляем `hash` ключа
2. Ищем `LOB` (Last Order Bite). Это значение используется для определения, в каком бакете будет осуществляться поиск.
3. Берем `tophash` от вычисленного хеша
4. Проверяем есть ли `tophash` в бакете. Go сначала сравнивает _top hash_ (часть хеша) для быстрого отсеивания неподходящих ключей. Затем выполняется точное сравнение ключей (через оператор сравнения)
5. Если нужный ключ не найден в основном бакете, но есть overflow-бакеты (из-за коллизий), поиск продолжается в них.
6. Если ключ найден — возвращается соответствующее значение. Если нет — возвращается _нулевое значение_ типа `V` и `false` как второй результат (если используется форма `val, ok := m[key]`).

### Сложность поиска в `map`

1. Вычисление хеша: `hash(31)` = 10010011 01101000 11110101 001110**01** - `O(1)`
2. Нахождение номера бакета: `L0B(hash(31))` = **01** - `O(1)`
3. Вычисление первого байта от хэша - `O(1)`
4. Cравнение первого байта с каждым элементом массива `tophash` - `O(8)` = `0(1)`
5.	Cравнение ключа с каждым элементом массива ключей - `O(8)` = `O(1)`
6.	Получение значения по тому же индексу, что и найденный ключ - `O(1)`

> Итого - `O(1)`

### Эвакуация данных

- процесс перераспределения элементов `map` при её расширении, чтобы сохранить производительности.

Когда `map` заполняется, увеличивается количество коллизий. Это снижает производительность операции, чтобы этого избежать `Go` автоматически расширяет `map` и эвакуирует(перемещает) данные из старых бакетов в новые.

Как происходит эвакуация:
1. Инициация расширения
	- Когда коэффициент заполнения(`load factor`) превышает порог (около `6.5`) запускается процесс расширения (количество бакетов увеличивается вдвое). 
2. `Go` выделяет память под новые бакеты
3. Перенос данных - элементы из старых бакетов перемещаются в новые
4. Постепенная эвакуация: эвакуация не происходит мгновенно, она выполняется поэтапно, при обращении к элементам `map`, чтобы избежать падения производительности

![[Pasted image 20251107144437.png]]

По достижении коэффициента заполненности в `6,5` создаются новые бакеты, а старые бакеты становятся `old backets`

![[Pasted image 20251107145038.png]]

Далее происходит постепенный перенос значений из `old backets` в `buckets`

![[Pasted image 20251107145316.png]]

при этом параметр `evacuated` увеличивается на `1`

- В процессе эвакуации итерация идет по старым бакетам.
- Проверяем новые бакеты, если текущий бакет уже был эвакуирован

> Так как данные (ключ-значение, tophash) могут быть в любой момент эвакуированы в новый бакет (новое место в памяти), то мы не можем взять ссылку на значение в `map`

> По той же причине невозможна конкурентная запись в мапу

Каждая эвакуация - это дополнительная аллокация памяти и дополнительные накладные расходы, поэтому если размер мапы известен заранее, всегда создаём мапу нужного размера сразу

```go
m := make(map[int]int, mapSize)
```

### Итерация по мапе

Итерация по мапе всегда начинается со случайного бакета.




