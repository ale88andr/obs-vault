При работе с данными можно рассматривать три основных компонента:
1. Хранение данных
2. Передача данных
3. Оптимизации

## 1. Хранение данных

Если в приложении обрабатываются критические данные, то :
- данные должны быть в безопасности
- данные должны быть легкодоступны
- данные должны быть в сохранности

Для хранения информации необходимо применять устойчивые и отказоустойчивые механизмы. Одним из зрелых и надежных механизмов является **реляционная СУБД** 

#### SQL реляционные СУБД

Основные характеристики реляционной СУБД:
- **Табличная структура**: данные хранятся в таблицах, где каждая строка — это запись, а каждый столбец — атрибут.
- **SQL**: используется язык структурированных запросов (Structured Query Language) для работы с данными.
- **Ключи**: первичные ключи идентифицируют записи, внешние — связывают таблицы.
- **ACID-свойства**: обеспечивают надёжность транзакций — атомарность, согласованность, изолированность и долговечность.
- **Нормализация**: уменьшает избыточность данных и повышает целостность.

|Коммерческие|Open Source|
|---|---|
|Oracle DB|PostgreSQL|
|IBM DB2|MySQL|
|MS SQL Server|SQLite|

Основные **преимущества** реляционных СУБД:

1. Согласованность и целостность данных
	- Использование **ограничений** (уникальность, NOT NULL, внешние ключи) обеспечивает точность и непротиворечивость данных.
	- **Ссылочная целостность** между таблицами предотвращает "висячие" записи и ошибки связей.
2. Простота получения и обработки данных
	- Стандартизированный язык **SQL** позволяет легко извлекать, фильтровать и агрегировать данные.
	- Поддержка сложных запросов, объединений (`JOIN`), подзапросов и транзакций.
3. Масштабируемость и производительность
	- Современные реляционные СУБД поддерживают **горизонтальное и вертикальное масштабирование**, кэширование, индексы и оптимизацию запросов. 
4. Гибкость и адаптируемость
	- Таблицы можно легко модифицировать, добавлять новые поля, связи и ограничения без полной перестройки базы. 
5. Безопасность и соответствие требованиям
	- Поддержка **ролевой модели доступа**, шифрования, аудита и соответствия стандартам (например, GDPR, HIPAA). 
6. Совместимость и экосистема
	- Широкая поддержка инструментов: ORM, BI-систем, ETL-платформ, облачных решений. 
	- Лёгкая интеграция с языками программирования и фреймворками.
7. Теоретическая устойчивость
	- Основаны на математической **реляционной модели**, что обеспечивает предсказуемость и формальную корректность операций.

**Транзакция** — это единица работы с базой данных, которая должна быть выполнена полностью или не выполнена вовсе. Она гарантирует, что операции над данными будут выполнены **надежно, последовательно и безопасно**, даже в случае сбоев.

Реляционные СУБД (например, PostgreSQL, MySQL, Oracle) поддерживают транзакции как один из ключевых механизмов обеспечения надежности и целостности данных.

| Свойство               | Описание                                                                           |
| ---------------------- | ---------------------------------------------------------------------------------- |
| **A** (Атомарность)    | Все операции внутри транзакции выполняются как единое целое: либо все, либо ничего |
| **C**(Согласованность) | После завершения транзакции база данных остаётся в согласованном состоянии         |
| **I**(Изолированность) | Параллельные транзакции не мешают друг другу и не влияют на промежуточные данные   |
| **D** (Долговечность)  | После фиксации (commit) данные сохраняются даже при сбоях системы                  |

Пример транзакции в SQL

```sql
BEGIN;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT;
```

Если что-то пойдёт не так — можно сделать `ROLLBACK`, и изменения не будут сохранены.

Основные **недостатки** реляционных СУБД

1. Неудобство представления сложных объектов
	- Реляционная модель плохо справляется с **иерархическими** или **глубоко вложенными структурами**, например, графами, деревьями, JSON-объектами.
	- Всё приходится раскладывать по множеству таблиц, что усложняет запросы и архитектуру.
2. Высокая стоимость операций соединения (`JOIN`)
	- При работе с фрагментированными данными часто требуются множественные `JOIN`-операции, которые могут быть ресурсоёмкими и замедлять выполнение запросов.
3. Семантическая перегрузка
	- Реляционная модель использует **одну конструкцию — таблицу — для всего**: сущностей, связей, метаданных. Это затрудняет выражение сложных смыслов и типов связей (например, "владеет", "управляет", "имеет").
4. Ограниченная поддержка бизнес-ограничений
	- Многие корпоративные правила (например, "сумма всех транзакций не должна превышать лимит") приходится реализовывать на уровне приложения, а не базы данных.
5. Жёсткая схема
	- Реляционные СУБД требуют **строгой схемы**: заранее определённых таблиц, типов данных и связей. Это затрудняет работу с динамически изменяющимися структурами или слабо структурированными данными.
6. Сложности при изменении схемы
	- Изменение структуры таблиц (например, добавление новых полей) может быть трудоёмким и рискованным в больших системах.
7. Слабая масштабируемость по горизонтали
	- Реляционные СУБД хуже масштабируются на множество узлов по сравнению с NoSQL-решениями, особенно в распределённых системах.

#### NoSQL

**NoSQL СУБД** — это класс систем управления базами данных, которые **не используют реляционную модель** и **не требуют SQL** как основного языка запросов.

Основные особенности NoSQL СУБД
- **Гибкая структура данных**: можно хранить документы, ключ-значения, графы, столбцы — без строгой схемы.
- **Высокая масштабируемость**: легко распределяются по множеству серверов (горизонтальное масштабирование).
- **Оптимизация под Big Data**: эффективны при работе с большими объёмами неструктурированных или слабо структурированных данных.
- **Отказ от ACID**: часто используют модель **BASE** (Basically Available, Soft state, Eventually consistent) для повышения доступности и скорости.

Типы NoSQL СУБД

| Тип                           | Примеры              | Описание                                   |
| ----------------------------- | -------------------- | ------------------------------------------ |
| **Ключ-значение**             | `Redis`, `Riak`      | Простое хранилище пар ключ-значение        |
| **Документо-ориентированные** | `MongoDB`, `CouchDB` | Хранение JSON-подобных документов          |
| **Графовые**                  | `Neo4j`, `OrientDB`  | Работа с узлами и связями (графы)          |
| **Колонковые**                | `Cassandra`, `HBase` | Хранение данных по столбцам, не по строкам |

#### Шардирование

**Шардинг** — это метод горизонтального масштабирования баз данных, при котором данные разбиваются на части (шарды) и распределяются по нескольким серверам или узлам. Каждая часть хранит только часть общего набора данных, и вместе они образуют единую логическую базу.

Как работает шардинг
- Данные делятся по какому-либо критерию: например, по ID пользователя, региону или алфавиту.
- Каждый **шард** — это отдельная база или сервер, обслуживающий свою часть данных.
- Приложение знает, куда направить запрос: в нужный `шард`.

Пример:

Допустим, в приложении 10 миллионов пользователей. Вместо хранения всех в одной базе:

| Шард      | Пользователи           |
| --------- | ---------------------- |
| `Shard 1` | ID 1–1,000,000         |
| `Shard 2` | ID 1,000,001–2,000,000 |
| …         | …                      |

Преимущества шардинга:
- **Масштабируемость**: можно добавлять новые шарды по мере роста данных.
- **Производительность**: каждый шард обслуживает меньше данных → быстрее запросы.
- **Изоляция**: сбой одного шарда не влияет на другие.

Недостатки шардинга:
- Сложность реализации: нужно управлять маршрутизацией запросов.
- Трудности с глобальными операциями: например, `SELECT COUNT(*)` по всем шардам.
- Балансировка нагрузки: шарды могут быть неравномерно загружены.

#### Репликация

**Репликация** — это процесс копирования и синхронизации данных между несколькими серверами или базами данных. Цель — обеспечить **отказоустойчивость**, **высокую доступность** и **распределённую нагрузку** при работе с данными.

Зачем нужна репликация
- **Резервирование**: если основной сервер выйдет из строя, можно переключиться на реплику.
- **Ускорение чтения**: запросы на чтение можно распределить между несколькими репликами.
- **Геораспределение**: данные доступны в разных регионах, ближе к пользователю.
- **Защита от потерь**: реплики помогают восстановить данные при сбоях.

Виды репликации

|Тип|Описание|
|---|---|
|**Синхронная**|Основной и реплика обновляются одновременно. Гарантирует согласованность.|
|**Асинхронная**|Реплика обновляется с задержкой. Быстрее, но возможны расхождения.|
|**Мастер-слейв**|Один сервер — источник (мастер), остальные — копии (слейвы).|
|**Мульти-мастер**|Несколько серверов могут одновременно принимать изменения.|

## 2. Передача данных

#### TCP/IP

**TCP/IP (Transmission Control Protocol / Internet Protocol)** — это набор сетевых протоколов, лежащий в основе интернета и большинства локальных сетей. Он определяет, **как данные передаются между компьютерами**, обеспечивая надёжную и стандартизированную связь.

Основные уровни модели TCP/IP

| Уровень                  | Назначение                                    | Протоколы                    |
| ------------------------ | --------------------------------------------- | ---------------------------- |
| **Прикладной**           | Взаимодействие с пользователем и приложениями | `HTTP`, `FTP`, `SMTP`, `DNS` |
| **Транспортный**         | Надёжная доставка данных между узлами         | `TCP`, `UDP`                 |
| **Сетевой**              | Маршрутизация и адресация пакетов             | `IP`, `ICMP`                 |
| **Канальный/Физический** | Передача битов по физической среде            | `Ethernet`, `Wi-Fi`, `PPP`   |

#### DNS

**DNS** — это система, которая переводит понятные человеку доменные имена (например, `example.com`) в IP-адреса (например, `192.0.2.1`), необходимые для связи между устройствами в интернете.

Основные компоненты

|Компонент|Назначение|
|---|---|
|**DNS-клиент**|Отправляет запросы (обычно встроен в ОС)|
|**Рекурсивный сервер**|Ищет ответ, обращаясь к другим серверам|
|**Корневой сервер**|Начальная точка поиска домена|
|**Авторитетный сервер**|Хранит точные записи о домене|

Как происходит `DNS` запрос:
1. Пользователь вводит адрес сайта
	Например: `www.example.com`
2. Проверка локального кеша
	Операционная система сначала проверяет, есть ли IP-адрес этого домена в **локальном DNS-кеше**:
	- Если есть — используется кешированный IP, запрос в интернет не отправляется.
	- Если нет — переходим к следующему шагу.
3. Запрос к рекурсивному DNS-серверу
	ОС отправляет запрос на **рекурсивный DNS-сервер** (обычно от провайдера или Google DNS `8.8.8.8`).
4. Рекурсивный сервер ищет ответ
	Если у него **нет кеша**, он делает цепочку запросов:
	- К корневому серверу → "Где `.com`?"
	- К серверу зоны `.com` → "Где `example.com`?"
	- К авторитетному серверу `example.com` → "Какой IP у `www.example.com`?"
5. Ответ и кеширование
	- Рекурсивный сервер получает IP-адрес и:
	    - Отправляет его клиенту
	    - Сохраняет в **свой кеш** на время, указанное в `TTL` (Time To Live)
	- ОС тоже может сохранить IP в **локальный кеш**
6. Повторный запрос — быстрее!
	Если пользователь снова откроет `www.example.com`:
	- ОС или DNS-сервер найдёт IP в кеше
	- Ответ будет мгновенным, без обращения к корневым серверам

#### HTTP

**HTTP** — это протокол прикладного уровня, который используется для передачи данных между клиентом (например, браузером) и сервером в интернете. Он лежит в основе работы веб-сайтов.

Основные особенности
- **Клиент-серверная модель**: клиент отправляет запрос, сервер отвечает.
- **Текстовый протокол**: легко читается и отлаживается.
- **Без состояния**: каждый запрос независим, сервер не хранит информацию о предыдущих.

**Структура HTTP-запроса**

```http
GET /index.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
```

- `GET` — метод запроса  
- `/index.html` — путь к ресурсу
- `Host` — домен
- `User-Agent` — информация о клиенте

1. Стартовая строка (Request Line)

```http
GET /index.html HTTP/1.1
```

- `GET` — метод запроса (действие: получить, отправить, удалить и т.д.)
- `/index.html` — путь к ресурсу на сервере
- `HTTP/1.1` — версия протокола

2. Заголовки (Headers)

```http
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

- **Host** — домен, к которому обращается клиент
- **User-Agent** — информация о клиенте (браузер, ОС)
- **Accept** — какие типы данных клиент готов принять

3. Тело запроса (Body) — _не всегда есть_

Используется в методах `POST`, `PUT`, `PATCH`:

```http
name=Alice&email=alice@example.com
```

- Содержит данные формы, JSON, XML и т.д.

**Структура HTTP-ответа**

```http
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234
```

- `200 OK` — статус ответа
- `Content-Type` — тип содержимого
- `Content-Length` — размер тела

Ответ приходит от сервера и состоит из:

1. Стартовая строка (Status Line)

```http
HTTP/1.1 200 OK
```

- `HTTP/1.1` — версия протокола
- `200` — код состояния (успешно)
- `OK` — текстовое описание статуса

2. Заголовки (Headers)

```http
Content-Type: text/html; charset=UTF-8
Content-Length: 1024
Set-Cookie: sessionid=abc123
```

- **Content-Type** — тип возвращаемого содержимого
- **Content-Length** — размер тела ответа
- **Set-Cookie** — установка cookie для клиента

3. Тело ответа (Body)

```html
<!DOCTYPE html>
<html>
  <head><title>Пример</title></head>
  <body><h1>Привет, мир!</h1></body>
</html>
```

- Содержит HTML, JSON, изображение, файл — в зависимости от запроса

#### REST

**REST** — это архитектурный стиль для создания веб-сервисов, основанный на принципах HTTP. Он определяет, **как клиент и сервер должны взаимодействовать** через стандартизованные запросы и ответы.

Основные принципы `REST`

1. **Клиент-сервер** — чёткое разделение между клиентом (UI) и сервером (данные).
2. **Без состояния (Stateless)** — каждый запрос содержит всю необходимую информацию, сервер не хранит сессии.
3. **Кешируемость** — ответы могут быть закешированы для повышения производительности.
4. **Единообразие интерфейса** — стандартные методы HTTP (`GET`, `POST`, `PUT`, `DELETE`) для работы с ресурсами.
5. **Иерархия ресурсов** — данные представлены как ресурсы с уникальными URL.
6. **Код по требованию (опционально)** — сервер может отправлять исполняемый код клиенту.

#### WebSocket

WebSocket — это сетевой протокол, обеспечивающий **двустороннюю связь** между клиентом и сервером **в реальном времени** через одно постоянное соединение.

**Основные особенности:**

- **Постоянное соединение**: в отличие от HTTP, WebSocket не закрывается после каждого запроса.
- **Двусторонняя передача**: клиент и сервер могут отправлять данные друг другу **в любое время**.
- **Меньше накладных расходов**: нет необходимости повторно устанавливать соединение, как в HTTP.

## 3. Оптимизации

#### Вертикальное масштабирование

**Вертикальное масштабирование** — это увеличение ресурсов **одного сервера** или узла системы для повышения его производительности.

Что включает:
- Увеличение **процессора (CPU)**
- Добавление **оперативной памяти (RAM)**
- Расширение **дискового пространства**
- Улучшение **сетевых интерфейсов**

Преимущества:
- Простота реализации — не требует изменения архитектуры
- Быстрое повышение производительности
- Подходит для монолитных приложений

Недостатки:
- Имеет **физический предел** (нельзя масштабировать бесконечно)
- Может быть **дороже** по сравнению с горизонтальным масштабированием
- Уязвимость: сбой одного узла — сбой всей системы

#### Горизонтальное масштабирование

**Горизонтальное масштабирование** — это увеличение производительности системы за счёт **добавления новых узлов** (серверов, контейнеров, машин) в инфраструктуру.

Основные особенности:

- Вместо усиления одного сервера (как при вертикальном масштабировании), добавляются **несколько одинаковых экземпляров**.
- Все узлы работают **параллельно**, распределяя нагрузку.
- Часто используется в **облачных и микросервисных архитектурах**.

Преимущества:
- **Гибкость и масштабируемость**: можно добавлять ресурсы по мере роста нагрузки.
- **Отказоустойчивость**: сбой одного узла не приводит к остановке всей системы.
- **Экономичность**: можно использовать недорогие машины вместо одного мощного сервера.

Недостатки:
- Требует **балансировки нагрузки** (например, через Nginx, HAProxy)
- Сложнее в **настройке и мониторинге**
- Не все приложения легко масштабируются горизонтально (например, монолиты)

сравнение **вертикального** и **горизонтального масштабирования**:

| Характеристика      | Вертикальное масштабирование                | Горизонтальное масштабирование                 |
| ------------------- | ------------------------------------------- | ---------------------------------------------- |
| Подход              | Увеличение ресурсов одного сервера          | Добавление новых серверов/узлов                |
| Масштабируемость    | Ограничена физическими пределами            | Почти неограниченная                           |
| Стоимость           | Может быть дорого (мощное оборудование)     | Гибкая: можно использовать дешёвые узлы        |
| Отказоустойчивость  | Низкая: сбой узла = сбой системы            | Высокая: сбой одного узла не критичен          |
| Сложность внедрения | Простая                                     | Требует балансировки и распределения нагрузки  |
| Применение          | Монолитные приложения, базы данных          | Микросервисы, облачные системы, веб-приложения |
| Ограничения         | Аппаратные пределы, узкое место — один узел | Сложность синхронизации и управления           |

#### Балансировка нагрузки

**Балансировка нагрузки** — это процесс распределения входящего трафика или задач между несколькими серверами, узлами или ресурсами, чтобы обеспечить **эффективную работу системы**, избежать перегрузок и повысить отказоустойчивость.

Зачем нужна:
- Повышает производительность
- Обеспечивает стабильность при высоких нагрузках
- Защищает от отказов одного узла
- Ускоряет отклик системы для пользователей

Как работает:

Балансировщик нагрузки (например, `Nginx`, `HAProxy`, `AWS ELB`):
- Принимает запросы от клиентов
- Выбирает оптимальный сервер по заданному алгоритму
- Перенаправляет запрос на выбранный узел

Алгоритмы распределения:
- **Round Robin** — по очереди на каждый сервер
- **Least Connections** — на сервер с наименьшим числом активных соединений
- **IP Hash** — по хэшу IP клиента
- **Weighted** — с учётом веса (мощности) сервера

#### Кэширование

Кэширование — это процесс **временного хранения данных** в быстром доступе, чтобы ускорить повторное использование и снизить нагрузку на систему.

Зачем нужно:
- Ускоряет доступ к часто используемой информации
- Снижает количество повторных вычислений или запросов
- Повышает производительность и масштабируемость

> когда данные запрашиваются в первый раз, они кэшируются, при последующих запросах данные берутся из кэша, а не из первоначального источника, что позволяет уменьшить время отклика и снизить нагрузку на источник данных

Виды кэша:
- **Память (RAM)** — самый быстрый, но ограниченный
- **Дисковый кэш** — используется при нехватке оперативной памяти
- **Кэш браузера** — хранит ресурсы сайтов
- **Кэш CDN** — ускоряет доставку контента по всему миру
- **Кэш базы данных** — хранит результаты запросов

Примеры инструментов:
- **Redis**, **Memcached** — in-memory кэш
- **Varnish**, **Cloudflare** — HTTP-кэш
- **Go**: `sync.Map`, сторонние библиотеки
- **Python**: `functools.lru_cache`, `cachetools`

#### CDN (Content Delivery Network)

CDN — это распределённая сеть серверов, которая хранит и доставляет **статический контент** (изображения, видео, стили, скрипты и т.д.) пользователям **из ближайшего к ним узла**.

Как работает:
- Контент копируется на множество серверов по всему миру.
- Когда пользователь запрашивает ресурс, CDN перенаправляет его к **ближайшему серверу**.
- Это снижает **время отклика**, **нагрузку на основной сервер** и повышает **надёжность**.

Преимущества:
- Быстрая загрузка сайта
- Защита от перегрузок и DDoS-атак
- Масштабируемость при высоком трафике
- Глобальное покрытие

#### CAP-теорема

**CAP-теорема утверждает, что в распределённой системе невозможно одновременно обеспечить согласованность, доступность и устойчивость к разделению сети. Можно выбрать только два из трёх.**

CAP-теорема (Consistency, Availability, Partition Tolerance) — фундаментальный принцип проектирования распределённых систем. Она описывает **ограничения**, с которыми сталкиваются разработчики при сбоях сети или высокой нагрузке.

**Три свойства CAP**:
- **Согласованность (Consistency)** Все узлы системы видят одинаковые данные в один момент времени. Любой запрос возвращает актуальное значение или ошибку.
- **Доступность (Availability)** Каждый запрос получает ответ, даже если некоторые узлы недоступны. Ответ может быть не самым свежим, но система остаётся работоспособной.
- **Устойчивость к разделению (Partition Tolerance)** Система продолжает работать, даже если сеть разделена и узлы не могут обмениваться данными.

**Компромиссы**:

При сетевых сбоях **невозможно обеспечить все три свойства одновременно**. Системы выбирают два из трёх:

|Тип системы|Свойства|Пример|
|---|---|---|
|**CP**|Согласованность + Устойчивость|СУБД, банковские системы|
|**AP**|Доступность + Устойчивость|DNS, кеши, NoSQL (Cassandra)|
|**CA**|Согласованность + Доступность|Возможна только при отсутствии сетевых разделений|

CAP-теорема помогает архитекторам систем **осознанно выбирать компромиссы** в зависимости от бизнес-задач. Например:
- В финансовых системах важна **точность** → выбирают **CP**
- В социальных сетях важна **доступность** → выбирают **AP**

Расширение CAP-теоремы — это **PACELC-теорема**, которая уточняет поведение распределённых систем **не только при сетевых разделениях**, но и **в нормальных условиях**.

CAP-теорема говорит только о поведении **при сбоях**, а PACELC добавляет **вторую ось выбора** — что делать, когда всё работает нормально.

PACELC показывает, что **даже без сбоев** системы делают компромиссы между **быстротой ответа** и **точностью данных**. Это помогает архитекторам выбирать подходящие технологии в зависимости от требований:
- Нужна скорость → выбираем **Latency**
- Нужна точность → выбираем **Consistency**

