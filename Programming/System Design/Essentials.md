При работе с данными можно рассматривать три основных компонента:
1. Хранение данных
2. Передача данных
3. Оптимизации

## 1. Хранение данных

Если в приложении обрабатываются критические данные, то :
- данные должны быть в безопасности
- данные должны быть легкодоступны
- данные должны быть в сохранности

Для хранения информации необходимо применять устойчивые и отказоустойчивые механизмы. Одним из зрелых и надежных механизмов является **реляционная СУБД** 

Основные характеристики реляционной СУБД:
- **Табличная структура**: данные хранятся в таблицах, где каждая строка — это запись, а каждый столбец — атрибут.
- **SQL**: используется язык структурированных запросов (Structured Query Language) для работы с данными.
- **Ключи**: первичные ключи идентифицируют записи, внешние — связывают таблицы.
- **ACID-свойства**: обеспечивают надёжность транзакций — атомарность, согласованность, изолированность и долговечность.
- **Нормализация**: уменьшает избыточность данных и повышает целостность.

|Коммерческие|Open Source|
|---|---|
|Oracle DB|PostgreSQL|
|IBM DB2|MySQL|
|MS SQL Server|SQLite|

Основные **преимущества** реляционных СУБД:

1. Согласованность и целостность данных
	- Использование **ограничений** (уникальность, NOT NULL, внешние ключи) обеспечивает точность и непротиворечивость данных.
	- **Ссылочная целостность** между таблицами предотвращает "висячие" записи и ошибки связей.
2. Простота получения и обработки данных
	- Стандартизированный язык **SQL** позволяет легко извлекать, фильтровать и агрегировать данные.
	- Поддержка сложных запросов, объединений (`JOIN`), подзапросов и транзакций.
3. Масштабируемость и производительность
	- Современные реляционные СУБД поддерживают **горизонтальное и вертикальное масштабирование**, кэширование, индексы и оптимизацию запросов. 
4. Гибкость и адаптируемость
	- Таблицы можно легко модифицировать, добавлять новые поля, связи и ограничения без полной перестройки базы. 
5. Безопасность и соответствие требованиям
	- Поддержка **ролевой модели доступа**, шифрования, аудита и соответствия стандартам (например, GDPR, HIPAA). 
6. Совместимость и экосистема
	- Широкая поддержка инструментов: ORM, BI-систем, ETL-платформ, облачных решений. 
	- Лёгкая интеграция с языками программирования и фреймворками.
7. Теоретическая устойчивость
	- Основаны на математической **реляционной модели**, что обеспечивает предсказуемость и формальную корректность операций.

**Транзакция** — это единица работы с базой данных, которая должна быть выполнена полностью или не выполнена вовсе. Она гарантирует, что операции над данными будут выполнены **надежно, последовательно и безопасно**, даже в случае сбоев.

Реляционные СУБД (например, PostgreSQL, MySQL, Oracle) поддерживают транзакции как один из ключевых механизмов обеспечения надежности и целостности данных.

| Свойство               | Описание                                                                           |
| ---------------------- | ---------------------------------------------------------------------------------- |
| **A** (Атомарность)    | Все операции внутри транзакции выполняются как единое целое: либо все, либо ничего |
| **C**(Согласованность) | После завершения транзакции база данных остаётся в согласованном состоянии         |
| **I**(Изолированность) | Параллельные транзакции не мешают друг другу и не влияют на промежуточные данные   |
| **D** (Долговечность)  | После фиксации (commit) данные сохраняются даже при сбоях системы                  |

Пример транзакции в SQL

```sql
BEGIN;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT;
```

Если что-то пойдёт не так — можно сделать `ROLLBACK`, и изменения не будут сохранены.

Основные **недостатки** реляционных СУБД

1. Неудобство представления сложных объектов
	- Реляционная модель плохо справляется с **иерархическими** или **глубоко вложенными структурами**, например, графами, деревьями, JSON-объектами.
	- Всё приходится раскладывать по множеству таблиц, что усложняет запросы и архитектуру.
2. Высокая стоимость операций соединения (`JOIN`)
	- При работе с фрагментированными данными часто требуются множественные `JOIN`-операции, которые могут быть ресурсоёмкими и замедлять выполнение запросов.
3. Семантическая перегрузка
	- Реляционная модель использует **одну конструкцию — таблицу — для всего**: сущностей, связей, метаданных. Это затрудняет выражение сложных смыслов и типов связей (например, "владеет", "управляет", "имеет").
4. Ограниченная поддержка бизнес-ограничений
	- Многие корпоративные правила (например, "сумма всех транзакций не должна превышать лимит") приходится реализовывать на уровне приложения, а не базы данных.
5. Жёсткая схема
	- Реляционные СУБД требуют **строгой схемы**: заранее определённых таблиц, типов данных и связей. Это затрудняет работу с динамически изменяющимися структурами или слабо структурированными данными.
6. Сложности при изменении схемы
	- Изменение структуры таблиц (например, добавление новых полей) может быть трудоёмким и рискованным в больших системах.
7. Слабая масштабируемость по горизонтали
	- Реляционные СУБД хуже масштабируются на множество узлов по сравнению с NoSQL-решениями, особенно в распределённых системах.

**NoSQL СУБД** — это класс систем управления базами данных, которые **не используют реляционную модель** и **не требуют SQL** как основного языка запросов.

Основные особенности NoSQL СУБД
- **Гибкая структура данных**: можно хранить документы, ключ-значения, графы, столбцы — без строгой схемы.
- **Высокая масштабируемость**: легко распределяются по множеству серверов (горизонтальное масштабирование).
- **Оптимизация под Big Data**: эффективны при работе с большими объёмами неструктурированных или слабо структурированных данных.
- **Отказ от ACID**: часто используют модель **BASE** (Basically Available, Soft state, Eventually consistent) для повышения доступности и скорости.

Типы NoSQL СУБД

| Тип                           | Примеры              | Описание                                   |
| ----------------------------- | -------------------- | ------------------------------------------ |
| **Ключ-значение**             | `Redis`, `Riak`      | Простое хранилище пар ключ-значение        |
| **Документо-ориентированные** | `MongoDB`, `CouchDB` | Хранение JSON-подобных документов          |
| **Графовые**                  | `Neo4j`, `OrientDB`  | Работа с узлами и связями (графы)          |
| **Колонковые**                | `Cassandra`, `HBase` | Хранение данных по столбцам, не по строкам |

**Шардинг** — это метод горизонтального масштабирования баз данных, при котором данные разбиваются на части (шарды) и распределяются по нескольким серверам или узлам. Каждая часть хранит только часть общего набора данных, и вместе они образуют единую логическую базу.

Как работает шардинг
- Данные делятся по какому-либо критерию: например, по ID пользователя, региону или алфавиту.
- Каждый **шард** — это отдельная база или сервер, обслуживающий свою часть данных.
- Приложение знает, куда направить запрос: в нужный `шард`.

Пример:

Допустим, в приложении 10 миллионов пользователей. Вместо хранения всех в одной базе:

| Шард      | Пользователи           |
| --------- | ---------------------- |
| `Shard 1` | ID 1–1,000,000         |
| `Shard 2` | ID 1,000,001–2,000,000 |
| …         | …                      |

Преимущества шардинга:
- **Масштабируемость**: можно добавлять новые шарды по мере роста данных.
- **Производительность**: каждый шард обслуживает меньше данных → быстрее запросы.
- **Изоляция**: сбой одного шарда не влияет на другие.

Недостатки шардинга:
- Сложность реализации: нужно управлять маршрутизацией запросов.
- Трудности с глобальными операциями: например, `SELECT COUNT(*)` по всем шардам.
- Балансировка нагрузки: шарды могут быть неравномерно загружены.

