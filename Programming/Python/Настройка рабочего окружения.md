Писать код в текстовом редакторе — не самый удобный вариант. Есть решения получше:
- **интегрированная среда разработки** (англ. _Integrated development environment_) — это комплекс программных средств, который программисты используют для разработки программного обеспечения;
- **редактор кода** — это текстовый редактор с дополнительными инструментами для разработки и тестирования программ; такой редактор — часть IDE.

# Установка VSCode

**Для Windows:**

Перейдите [на официальный сайт Visual Studio Code](https://code.visualstudio.com/), выберите установочный файл для используемой вами системы, скачайте его и запустите. Все настройки при установке можно оставить по умолчанию.

**Для Linux:**

`Visual Studio Code` доступен в официальных репозиториях `Microsoft` apt. Чтобы установить его, выполните следующие действия:

- команды для обновления индексов пакетов менеджера:

```bash
sudo apt update
sudo apt install software-properties-common apt-transport-https wget 
```

- подключите репозиторий `Visual Studio Code`:

```bash
sudo add-apt-repository "deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main" 
```

- запустите установку пакета `Visual Studio Code`:

```bash
sudo apt install code 
```

## Настраиваем `VSCode` под `Python`

У `VSCode` много бесплатных дополнений. Скачать и установить их можно, перейдя к пункту `Extensions` в боковом меню

Найдите и установите следующие дополнения:

- **Python** — дополнение от `Microsoft`. Оно добавляет в редактор подсветку ошибок, возможность автодополнения кода, описание функций при наведении на них, то есть расширенную поддержку языка `Python` для всех версий >=3.7 и инструменты работы с кодом.
- **Pylance** — автодополнение кода и подсказки.

# Установка виртуального окружения (venv)

Как правило, на компьютере программиста находятся сразу несколько проектов. Одним проектам нужны одни версии библиотек, другим — другие.

Чтобы весь этот зоопарк разнообразных программ мирно уживался на одном компьютере — были придуманы **«виртуальные окружения»**. Это своего рода «изолированные территории», отдельные виртуальные среды для проектов.

В каждой среде находится один проект, и для него можно установить собственные настройки: указать нужную версию Python, установить необходимые библиотеки. Так можно одновременно работать со множеством проектов на одном компьютере, не переживая, что они будут мешать друг другу.

Через терминал перейдите в папку _<project_name>_ и разверните в ней виртуальное окружение:

```bash
# Папка, в которой должна быть выполнена команда .../<project_name>.

# Команда для Windows:
python -m venv venv
# Первый 'venv' — это часть команды (имя модуля), которая указывает, что нужно создать виртуальное окружение.
# Второй 'venv' — это имя для этого окружения.

# Команда для Linux и macOS:
python3 -m venv venv
```

После выполнения этой команды в директории проекта появится папка venv (от _**v**irtual **env**ironment_, «виртуальное окружение»), в ней хранятся служебные файлы. В этой же директории будут сохраняться все зависимости проекта, например библиотеки и модули.

Структура проекта будет такой:

```bash
<dir>/
 └── <project_name>/
     ├── .vscode/         <-- Папка с настройками vscode (необязательно).
     ├── main.py     <-- Файл с вашей программой.
     └── venv/            <-- Папка виртуального окружения. 
```

Виртуальное окружение создано, теперь его нужно активировать.

Активировать виртуальное окружение нужно каждый раз перед началом работы с проектом. Для каждого проекта нужно создавать и активировать собственное виртуальное окружение. При активированном окружении проект будет работать внутри собственной «области», где ему будут доступны его зависимости и интерпретатор Python.

Для активации виртуального окружения введите в терминал команду:

```bash
# Директория, в которой вы должны находиться ...<project_name>.

# Команда для Windows:
source venv/Scripts/activate

# Для Linux и macOS:
source venv/bin/activate 
```

Виртуальное окружение для проекта _project_name_ запущено! Теперь все команды, которые вы введёте в терминал, будут выполняться в этом окружении.

Деактивировать виртуальное окружение можно командой:

```bash
(venv)...$ deactivate 
```

## Выгрузка и загрузка виртуального окружения

Количество устанавливаемых библиотек и пакетов за время разработки может сильно разрастись. Просто передать директорию _venv/_ проекта — не самый хороший вариант. Директория может быть достаточно «тяжёлой». И что самое неприятное — на разных операционных системах библиотеки могут работать некорректно или не работать вообще.

Чтобы таких проблем не было, нужно передавать проект вместе с конкретными версиями библиотек.

В виртуальном окружении проекта _project_name выполните команду

```bash
(venv)...$ pip freeze > requirements.txt
```

По этой команде пакетный менеджер в директории проекта создаст файл _requirements.txt_, его ещё называют «файл зависимостей». В этот файл будут построчно записаны имена пакетов и библиотек с указанием их версий: всё, что вы устанавливали в виртуальное окружение проекта.

Чтобы смоделировать установку пакетов из файла _requrements.txt_, удалите текущее виртуальное окружение — введите в терминал две команды:

```bash
# Деактивировать текущее окружение.
deactivate
# Удалить директорию окружения.
rm -r venv 
```

Теперь создадим новое виртуальное окружение и активируем его.

```bash
python -m venv venv

source venv/Scripts/activate 

sudo pip install -r requirements.txt 
```

Пакетный менеджер построчно считает файл зависимостей и установит указанные в нём библиотеки

# Git и GitHub

Git — это просто программа, консольная утилита, которая управляется командами через терминал.

Когда вы начинаете работать со своим проектом через Git, папка с проектом становится **репозито́рием**. В широком смысле репозиторий — это хранилище с данными. Если же говорить о нём в ключе системы контроля версий, того же Git, — это не просто хранилище данных, это хранилище версий файлов проекта.

Репозитории бывают **локальными**(хранятся на вашем компьютере) и **удалёнными**(хранятся удалённо, например в облачном сервисе).

С локальным репозиторием удобно работать, если вы пишете проект самостоятельно, без помощи других разработчиков. Но как правило современная разработка — это групповая разработка, где вы с коллегами трудитесь над одним и тем же проектом совместно, в одно и то же время. Для организации подобной работы обычно используется не локальный, а удалённый репозиторий, доступ к которому разработчики получают через специальные веб-сервисы. Есть несколько таких сервисов; среди них — `GitHub`, `GitLab` и `BitBucket`.
## Веб-сервис GitHub

Доступ к репозиториям, которые хранятся на `GitHub` обеспечивается интерфейсом командной строки `Git` и `Git-команд`.

### Аутентификация на GitHub

Работать с `GitHub` вы будете через терминал. Первым делом сервис должен определить, есть ли у вашего аккаунта права на подключение к `GitHub`, и если есть — то с каким уровнем доступа. Такой процесс называется **аутентификация**.

Аутентифицироваться можно через сетевые протоколы [HTTPS](https://ru.wikipedia.org/wiki/HTTPS) или [SSH](https://ru.wikipedia.org/wiki/SSH). По этим протоколам передаются данные и происходит безопасное соединение между клиентом и сервером. Каждый из протоколов достигает безопасности за счёт шифрования данных, а вот сами способы шифрования различаются:

- при подключении через **HTTPS** необходимо указать свой логин и токен; токен можно получить в личном кабинете на GitHub, используя [инструкцию](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token);
- при подключении по **SSH** нужно сгенерировать специальные ключи и записать их в настройках аккаунта на GitHub.

### Настройка SSH для GitHub

**SSH** (англ. _**S**ecure **SH**ell_ — безопасная оболочка) — это сетевой протокол для зашифрованного соединения между клиентом и сервером; по этому протоколу можно безопасно передавать данные.

При подключении по SSH применяют пары криптографических ключей: открытый (_public,_ публичный) и закрытый (_private_, приватный). Пользователь создаёт ключи специальной командой в терминале и сохраняет закрытый ключ на своём компьютере. Открытый ключ сохраняется на сервере, например, в настройках аккаунта на GitHub.

При соединении с сервером проверяется соответствие этих ключей друг другу, и если проверка пройдена успешно — пользователю разрешается доступ на сервер.

При аутентификации по ключу закрытая часть (_private key_) всегда передаётся в зашифрованном виде. Закрытый ключ можно защитить паролем. При соединении клиент запросит этот пароль перед тем, как сравнить ключи.

#### Создание SSH-ключей

Запустите Git Bash (если у вас Windows) или Терминал (на Linux/MacOS). Выполните команду `ssh-keygen`:

```bash
ssh-keygen
```

Консоль попросит ввести путь к файлу, в который будут сохранены сгенерированные ключи, и одновременно предложит сохранить их в файл по умолчанию:

```bash
Enter file in which to save the key (/home/имя_пользователя/.ssh/id_rsa): 
```

При создании ключей система попросит придумать пароль для доступа к ключам.

```bash
Enter passphrase (empty for no passphrase): 
```

Теперь необходимо сохранить открытый ключ в вашем аккаунте на `GitHub`.

Выведите ключ в терминал командой:

```bash
cat .ssh/id_rsa.pub  
```

Скопируйте ключ от символов `ssh-rsa` , включительно, и до конца:

Зайдите в свой аккаунт на GitHub, перейдите в раздел настроек:

![[Pasted image 20240212110423.png]]

Выберите пункт **SSH and GPG keys**; для создания нового ключа нажмите на кнопку **New SSH key** в правом верхнему углу:

![[Pasted image 20240212110453.png]]

Откроется страница с двумя полями ввода:

- **Title** (заголовок ключа). Когда будете задавать заголовок, учитывайте, что в дальнейшем вы, возможно, добавите и другие ключи. Например, с другого своего компьютера, чтобы получить с него доступ к репозиториям на GitHub. Поэтому выбирайте для каждого ключа уникальные заголовки, например ключ с домашнего компьютера можно назвать **HomePC**, а с рабочего — _WorkPC_.
- **Key** (ключ). Сюда необходимо вставить скопированный из терминала ключ.

![[Pasted image 20240212110520.png]]

Нажмите кнопку **Add SSH key** — ключ добавится к вашему аккаунту. Если вы захотите получить SSH-доступ к своему аккаунту на GitHub с нескольких компьютеров, для каждого из них должен быть создан и добавлен свой SSH-ключ.

### Клонирование репозитория

Аккаунт на `GitHub` создан, удалённый репозиторий форкнут. Теперь, чтобы управлять содержимым репозитория на своём устройстве, вам нужно сохранить его в локальный репозиторий — «склонировать» с `GitHub`.

#### Подготовка Git на вашем компьютере, локально

С локальным репозиторием вы будете работать через `Git`, поэтому первым делом нужно указать для него базовые настройки: имя и адрес электронной почты.

Каждое изменение, которое вносится в репозиторий, подписывается именем того, кто его проводит. Поэтому в настройках укажите своё настоящее имя (пусть ваш аккаунт выглядит прилично, ведь вам его работодателям показывать) и действующий адрес электронной почты.

Запустите Git Bash (если у вас Windows) или Терминал (на Linux/macOS) и выполните команды:

```bash
git config --global user.name "Имя Фамилия"
git config --global user.email "email@mail.com"
```

#### Клонирование репозитория

«Клонировать репозиторий» — значит создать на компьютере его копию. При клонировании вы получаете не только рабочие файлы, но и историю их изменения.

Через терминал перейдите в папку со своими проектами, например, _Dev/_. Используйте команду `cd`.

В интерфейсе `GitHub` зайдите в репозиторий c проектом и скопируйте ссылку на него; эта ссылка потребуется для клонирования репозитория на локальный компьютер.

![[Pasted image 20240212110927.png]]

Напечатайте в терминале команду `git clone`, после неё поставьте пробел, вставьте скопированный адрес и выполните команду:

```
git clone git@github.com:ваш-аккаунт-на-гитхабе/имя_репозитория.git 
```

`Git` запросит пароль перед тем, как сравнить публичный и приватный ключи, введите его. После того как вы введёте пароль, репозиторий загрузится с удалённого сервера на ваш компьютер, в директорию, из которой была выполнена команда клонирования.

Теперь у вас есть локальная копия нужного вам репозитория, и вы можете управлять его содержимым.

## Status/Add. Отображение изменений, добавление файлов

При работе над проектом нужно сохранять его состояния на разных этапах разработки. У программистов есть отличный инструмент для контроля версий своего проекта — это `Git`. В `Git` все версии проекта связаны между собой и разработчик может посмотреть полную историю изменений.

Контроль версий (или версионный контроль) в `Git` предполагает, что любой файл локального репозитория находится в одном из четырёх состояний:

1. **Неотслеживаемый** (англ. _untracked_).
2. **Отслеживаемый,** _staged_, добавленный в _Staging Area_ (англ. «плацдарм», «временное хранилище»). Иначе в Git это называют «добавить в индекс».
3. **Изменённый** (англ. _modified_).
4. **Боевой**, на жаргоне разработчиков «закоммиченный» (англ. _committed_, «брошенный в бой»). [В документации](https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository) такие файлы называются **неизменёнными** (от англ. _unmodified_). Иными словами, это файлы, в которых не было никаких изменений с момента последнего коммита (с момента, как разработчик «бросил их в бой»).

`Git` всегда следит за изменениями, которые происходят в локальном репозитории, будь то создание нового файла или внесение изменений в уже существующий файл. Новый файл в репозитории получает статус «**Неотслеживаемый**», а файл, содержимое которого разработчик изменил, получает статус «**Изменённый**».

Чтобы указать `Git`, что изменения должны быть «сохранены», нужно проиндексировать файлы, то есть перевести их в статус «**Отслеживаемый**». Далее изменения можно зафиксировать: файлы перейдут в состояние «**Неизменённый**», а `Git` начнёт отслеживать уже новые изменения.

![[Pasted image 20240212111401.png]]

#### Добавление изменений в локальном репозитории в индекс

`git add` (англ. _add_, «добавить») — команда для добавления `изменений` в _Staging Area,_ в индекс. После команды укажите имя файла, изменения которого нужно поместить в индекс: `git add название_файла`.

В индекс можно добавить изменения во всех файлах репозитория сразу, для этого есть опция **--all** (англ. _all_, «все»): `git add --all`. Опцию **--all** можно заменить точкой: `git add .` При выполнении этих команд изменения файлов из вложенных каталогов также добавятся в индекс.

#### Commit/Push. Сохранение изменений и отправка изменений на сервер

Чтобы зафиксировать изменения в файле, сначала нужно эти изменения внести и отправить их в индекс.

Каждый коммит сохраняет актуальное состояние файлов, и вы можете сравнивать разные состояния от коммита к коммиту. Пока что коммиты будут сохранены локально, на вашем компьютере, и доступны только вам. Для этого есть команда `git commit`. Ключ `-m` (от англ. _message_, «послание») даёт возможность добавить к коммиту комментарий, который пишется в кавычках после ключа, В комментариях описывайте, какие изменения были сделаны в коммите

```bash
git commit -m "add first commit"
```

вывод:

```bash
[main (root-commit) ab98382] Add first commit
 1 files changed, 1 insertions(+), 0 deletions(-) 
```

В первой строке вы видите свой комментарий (_Add first commit_), а перед ним, в квадратных скобках, информацию о коммите:

- **main (master)** — название ветки, в которой сделан коммит. Ветки, или, как их ещё называют, «бранчи» — один из инструментов Git. Их используют, например, когда нужно добавить и протестировать работу нового функционала, но при этом не повлиять на работу программы в целом.
- **root-commit** (англ. «корневой коммит») — означает, что этот коммит самый первый. Продолжая работу в том же репозитории, вы больше не увидите этого сообщения.
- **контрольная сумма или «хеш»** — уникальный идентификатор, присвоенный коммиту. Для удобства коммиты идентифицируются по первым семи символам контрольной суммы. В нашем примере это `ab98382`.

Второй строкой идёт информация о файлах коммита:

- изменён один файл (1 _files changed_);
- в изменённых файлах добавлена одна строка и ни одна не удалена (1 _insertions(+), 0 deletions(-)_ ).

#### Изменение сделанного коммита

Если вдруг вы забыли добавить новый файл в репозиторий и сделали это уже после коммита, можно не делать новый коммит. Достаточно добавить изменения к последнему коммиту. Для этого есть ключ `--amend` (англ. _amend_, «исправить»):

```bash
git commit --amend -m "Текст вашего комментария"
```

Эта команда добавит изменённые файлы в последний сделанный коммит, а с дополнительным флагом `-m` ещё и обновит комментарий

#### Отправка на сервер

Все сделанные коммиты сохранены локально, на вашем компьютере. Чтобы ваша работа стала доступна коллегам, нужно отправить изменения на сервер.

Для отправки локальных изменений на сервер GitHub, выполните команду из любой директории проекта:

```bash
git push 
```

Git запомнил, откуда вы клонировали репозиторий, поэтому не нужно указывать, куда именно отправлять изменения. На сленге эту операцию называют «запушить» (от англ. _push_, «протолкнуть»).

#### Что делать, если в удалённый репозиторий попали лишние файлы или папки

Избавиться от лишнего поможет команда `git rm`. 

Допустим _new.py_ — лишний файл в удалённом репозитории. Чтобы не отслеживать его, выполните команды:

```bash
# Удаляем файл из отслеживания, но не удаляем из папки на компьютере.
git rm --cached new.py
# Фиксируем изменения в локальном репозитории.
git commit -m "Delete new file"
# Отправляем изменения в удалённый репозиторий.
git push 
```

#### История изменений. Откат

Когда программист работает над кодом, он вносит в него немало изменений и фиксирует их в `Git`. Может случиться такое, что после определённых изменений в работе программы что-то пойдёт не так, например одна из функций начнёт возвращать неверный результат, хотя до изменений всё было в порядке. В таком случае можно, используя возможности `Git`, вернуться к той версии проекта, которая работала корректно. Для этого вам нужно:

1. Получить информацию обо всех коммитах и найти тот коммит, после которого в работе кода возникли проблемы.
2. Просмотреть изменения, которые были сделаны в этом коммите.
3. Вернуться к коммиту, при котором в работе кода было всё в порядке.

Для того чтобы получить информацию о коммитах проекта выполните команду `git log` (англ. _log_, «журнал»):

```bash
commit 0cde0f40afe27c9092c36b9f8f7d88a27fd918cc (HEAD -> master, origin/master, origin/HEAD)
# Автор коммита.
Author: User <user@yandex.ru>
# Дата проведения коммита.
Date:   Fri Jul 15 16:34:58 2022 +0300
# Сообщение к коммиту.
    delete new file

commit abeccbd51e48503feac5fc7d9954c6e6180e6629
Author: User <user@yandex.ru>>
Date:   Fri Jul 15 16:33:07 2022 +0300

    new file

commit 6bcb4d7020edb0e840dbdbc83c1f8c66fc8db71f
Author: User <user@yandex.ru>
Date:   Fri Jul 15 16:30:23 2022 +0300

    Added .gitignore file

commit 96c739551bab7281f34caf2f4e7512f5cb893bce
Author: User <user@yandex.ru>
Date:   Fri Jul 15 16:07:41 2022 +0300

    fix error
```

#### Show: что изменилось в файлах

Просмотреть изменения, внесённые в определённом коммите, можно командой `git show` (англ. _show_, «показать»). Она продемонстрирует не просто лог, а конкретные изменения в коде. Введите эту команду, а после неё укажите семь первых символов идентификатора коммита, который вас интересует:

```bash
$ git show id_коммита
```

#### Reset: отказ от изменений

`Git` — это машина времени. `Git` может вернуть ваш код в любое предыдущее состояние, если оно сохранено в коммите. Для этого есть команда `git reset` (англ. _reset_, «сброс в исходное состояние»).

Чтобы вернуться к определённому коммиту, нужно выполнить команду `git reset` и через пробел указать первые семь символов идентификатора нужного коммита, точно так же, как с командой `git show`:

```bash
# Смотрим список коммитов.
git log 

# Вывод в терминал.
commit 0cde0f40afe27c9092c36b9f8f7d88a27fd918cc (HEAD -> master, origin/master, origin/HEAD)
# Автор коммита.
Author: User <user@yandex.ru>
# Дата проведения коммита.
Date:   Fri Jul 15 16:34:58 2022 +0300
# Сообщение к коммиту.
    delete new file

commit abeccbd51e48503feac5fc7d9954c6e6180e6629
Author: User <user@yandex.ru>>
Date:   Fri Jul 15 16:33:07 2022 +0300

    new file

# Откатываемся до коммита, в котором все файлы ещё на месте.
git reset abeccbd 
```

Можно откатиться на один коммит назад в определённом файле, указав его имя через `HEAD`:

```bash
# Откатываем изменения во всех файлах до предыдущего коммита.
git reset HEAD 
```

# Как писать сообщения для коммитов

Общие правила написания сообщений для коммитов:
- лаконично,
- однородно,
- осознанно.

Пишите сообщения с заглавной буквы:

```bash
# Хорошо.
"Add 'get' method to post model"

# Плохо.
"add 'get' method to post model"
```

Не используйте прошедшее время:

```bash
# Хорошо.
"Fix the bug in the function 'set'"

# Плохо.
"Fixed bug in the function 'set'"
```

Чтобы составлять сообщения в нужном формате было проще, воспользуйтесь одним из лайфхаков:
1. Представьте, что вы обращаетесь к `Git`: «Git, добавь», «Git, удали».
2. Подставьте строку сообщения во фразу `If applied, this commit will …` :
`If applied, this commit will <сообщение для коммита>`.

По возможности указывайте на исходный код в сообщении:

```bash
# Хорошо.
"If applied, this commit will fix the bug in the function 'set'"

# Плохо.
"If applied, this commit will fix the bug"
```

Пишите осмысленные сообщения

При написании сообщений для коммитов можно пользоваться формулой:
«`Что сделать + для какой сущности + подробности (необязательно)`».

```bash
# Хорошо.
"Fix a crashed function 'read file'"
"Add function 'get_positive'"
"Add classes, group new fields"

# Плохо.
"Fix this"
"Add func"
"Change classes"
```
# Установка Pytest и запуск тестов

**Pytest** — инструмент для написания и запуска автоматических тестов, написанных на Python.
#### Установка Pytest

Следуйте плану:
- через терминал перейдите в папку проекта,
- создайте и активируйте виртуальное окружение,
- выполните команду `pip install pytest==7.1.3`.

Чтобы убедиться, что пакет `pytest` установился в виртуальное окружение проекта, воспользуйтесь командой:

```bash
pytest --version 
```

По этой команде в терминал должна вывестись версия установленного пакета

#### Запуск тестов

Файлы с тестами и настройками для запуска этих тестов уже есть в репозитории:
- `test_***.py` — файл с кодом тестов;
- `pytest.ini` — файл с настройками для запуска тестов.

Чтобы запустить тесты:

```bash
pytest
```

# Правила оформления кода и линтеры

> > «Соотношение времени чтения и написания кода превышает 10:1. … Из-за столь высокого соотношения наш код должен легко читаться, даже если это затрудняет его написание».
> 
> Роберт Мартин, «Чистый код: создание, анализ и рефакторинг»

Чтобы код легко было читать каждому участнику команды, в группе разработки обычно принимаются правила оформления кода. Но для некоторых языков программирования правила оформления выносятся как стандарты на всё сообщество. В Python принято оформлять код [по стандарту оформления кода PEP8](https://peps.python.org/pep-0008/)

## Основные правила PEP8

- Длина строки — не более 79 символов.
- Отступы — 4 пробела.
- Стили имён соответствуют [PEP8: Naming Conventions](https://peps.python.org/pep-0008/#prescriptive-naming-conventions).
- Переносы строк делаются [с правильными отступами](https://peps.python.org/pep-0008/#indentation).
- Бэкслеши `\` для переносов не применяются.
- В коде нет неиспользуемых импортов.
- Импорты отсортированы в таком порядке:
    - импорты стандартной библиотеки,
    - импорты сторонних библиотек,
    - импорты модулей текущего проекта.
- Функции верхнего уровня (не вложенные) и определения классов отделены друг от друга двумя пустыми строчками.
- Определения методов внутри класса отделены одной пустой строкой.
- В проекте использован одинаковый стиль кавычек: или везде одинарные, в которые вложены двойные (выбран как основной для проектов на курсе), или везде двойные, в которые вложены одинарные

Для отслеживания правил оформления кода есть специальные программы: **линтеры**.

Рекомендуется линтер [flake8](https://flake8.pycqa.org/en/latest/). Он объединяет в себе несколько анализаторов кода (`pycodestyle`, `pyflakes` и `mccabe`). Сейчас это один из самых популярных линтеров для Python.

В нижней части интерфейса может появиться окошко с предложением установить линтер. Соглашайтесь. После этого линтер должен заработать.

Линтер немедленно сообщит вам о проблемах в файле: даст описание ошибок во вкладке _Problems…_

![[Pasted image 20240212145717.png]]

**Линтер не включился: что делать?**

Бывает, что не получается включить линтер через графический интерфейс. Чаще всего это связано с правами доступа к системным файлам на компьютере. В таком случае можно работать с линтером через терминал по вот такому плану:

1. Запускаете виртуальное окружение проекта.
2. Устанавливаете flake8 через пакетный менеджер pip:
```
$ pip install flake8
```
3. Проверяете, выполнена ли установка: запрашиваете через терминал версию утилиты `flake8`:
```bash
$ flake8 --version
```
4. Начинаете проверку кода через `flake8`. Для этого при запущенном виртуальном окружении вводите в терминал команду:
```bash
 # Для текущего проекта
 flake8 имя_файла.py
```

В терминал выведется список несоответствий кода стандарту `PEP8`; он будет выглядеть приблизительно так:

```bash
main.py:6:80: E501 line too long (80 > 79 characters)
main.py:8:80: E501 line too long (81 > 79 characters)
main.py:10:80: E501 line too long (82 > 79 characters)
main.py:11:1: E302 expected 2 blank lines, found 0
main.py:18:1: E302 expected 2 blank lines, found 0
main.py:20:80: E501 line too long (85 > 79 characters)
main.py:29:1: E303 too many blank lines (4)
main.py:37:80: E501 line too long (157 > 79 characters)
main.py:50:1: E302 expected 2 blank lines, found 1
main.py:54:80: E501 line too long (104 > 79 characters)
```

В каждой строчке указано место, где совершена ошибка, код ошибки и её краткое описание:

```bash
 # Имя_файла:номер_строки:номер_символа:код_ошибки краткое описание.
 main.py:6:80: E501 line too long (80 > 79 characters)

 # В файле main.py, в 6-й строке, у 80-го символа обнаружено 
 # несоответствие стандарту, код ошибки E501, длина строки
 # больше 79 символов (80 > 79).
```

## Дополнения для flake8

Для `flake8` можно установить дополнения. Задача этих дополнений — проверять на соответствие стандарту конкретные части кода.

Дополнения устанавливаются из консоли через pip.

Мы рекомендуем установить следующие дополнения:

- [pep8-naming](https://github.com/PyCQA/pep8-naming) — проверяет имена классов, функций и переменных на соответствие PEP8;
- [flake8-broken-line](https://github.com/wemake-services/flake8-broken-line) — отслеживает применение устаревших переносов (через обратный слеш `\`);
- [flake8-return](https://github.com/afonasev/flake8-return) — проверяет значения, возвращаемые функциями;
- [flake8-isort](https://github.com/gforcada/flake8-isort) — проверяет правильность порядка импортов.

### Аннотация типов. Простые типы

Python поддерживает **динамическую типизацию**. Это значит, что переменная получает свой тип не в момент её объявления, а когда ей присваивается значение. Таким образом, в разных участках кода одна и та же переменная может иметь разный тип.

```Python
# Создана переменная, ей присвоено значение типа string.
var = "string here"

# Переменной присваивается новое значение, и вот уже тип данных — integer.
var = 1234
```

#### Type Hints: аннотация типов данных

Чтобы держать типизацию под контролем — применяют **аннотации типов данных** (_Type Hints_, дословный перевод с английского — «подсказки типов»). Это явное указание типа ожидаемых данных при объявлении переменных, классов и функций.

```Python
# Без аннотации: объявили переменную, 
# а Python сам догадался, какой в ней тип данных.
birth_year = 1971

# С аннотацией: объявили переменную и указали, 
# что это переменная только для целых чисел.
birth_year: int = 1971
```

При выполнении кода интерпретатор Python игнорирует аннотации типов и не выдаёт ошибок, если типизация нарушена:

```Python
# Переменная var_for_bool аннотирована как булева, но в неё передана строка.
var_for_bool: bool = 'Чистая правда, клянусь'

# Python не обратит внимания на это несоответствие 
# и продолжит выполнять код как ни в чём не бывало.
# Аннотация будет проигнорированна, переменная будет воспринята
# Python как строка. 
```

Python не обратит внимания на это несоответствие и продолжит выполнять код как ни в чём не бывало. Аннотация будет проигнорирована, переменная будет воспринята Python как строка.

Однако Python не оставляет аннотации совсем без внимания: он считывает _Type Hints_ и сохраняет их в словарь `__annotations__`. Содержимое этого словаря можно вывести на экран:

```Python
# Аннотация переменной name: "это строка".
name: str = 'Наташа'

# Аннотация переменной var_for_bool: "это булева переменная".
var_for_bool: bool = True

# Можно напечатать аннотации переменных из глобальной области видимости.
print(__annotations__)
>>> {'name': <class 'str'>, 'var_for_bool': <class 'bool'>} 
```

## Ну и кому нужны эти Type Hints?

Если Python игнорирует аннотации типов, а разработчик и без аннотаций старается отслеживать корректность кода — какой прок в этих _Type Hints_?

Аннотации типов могут считываться сторонними программами, предназначенными для проверки типизации. В случае обнаружения ошибок эти программы сообщат разработчику о проблемах.

Есть четыре популярных пакета для проверки типов: 

- [Mypy](http://mypy-lang.org/) активно разрабатывается, в частности, Гвидо ван Россумом, создателем Python. Один из самых популярных пакетов для работы с аннотациями в Python.
- [Pyre](https://pyre-check.org/) — альтернатива mypy.
- [Pytype](http://github.com/google/pytype) — анализатор от Google.
- [Pylance](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance) — разработан корпорацией Майкрософт.

Эти пакеты могут работать и в терминале, и в редакторе кода (например, как Pylance в VSCode). Такие пакеты подсвечивают некорректный код и выдают подсказки в процессе набора текста.

## Проверка аннотации типов через консоль

Теперь можно посмотреть, как работает проверка типизации.

```Python
def we_crash_all(name: str) -> str:    
    return 'Привет, ' + name + ', мы всё сломали!'

print(we_crash_all(100)) 
```

Для проверки файлов на соответствие указанным аннотациям установите пакет `mypy` в ваше виртуальное окружение:

```bash
pip install mypy 
```

Перейдите в директорию с файлом _temp.py_ и запустите этот файл утилитой `mypy`:

```bash
mypy temp.py
temp.py:5: error: Argument 1 to "we_crash_all" 
has incompatible type "int"; expected "str"
Found 1 error in 1 file (checked 1 source file) 
```

Утилита `mypy` сделала своё дело:

- обнаружила, что в функцию передали число, хотя ожидалась строка;
- указала на суть ошибки и на строку, в которой допущена ошибка.

## Проверка типизации через редактор кода

Вызовите командную строку VSCode (**Ctrl+Shift+P**), введите в поисковую строку текст _Python: Select Linter,_ нажмите **Enter**, в выпадающем списке выберите линтер `mypy`:

# Пакеты и модули

Модуль в Python — это отдельный файл с расширением _.py_, который содержит код программы.

Модули можно разделить на три типа:

- [модули стандартной библиотеки Python](https://docs.python.org/3/library/index.html),
- сторонние модули,
- пользовательские модули.

В стандартной библиотеке содержатся модули, написанные на `Cи`, которые отвечают за доступ к системным функциям, например функциям ввода-вывода. Без подобных модулей программисты на Python не смогли бы пользоваться этими функциями. Также в стандартной библиотеке есть модули, написанные на Python. Они помогают решать многие задачи, с которыми ежедневно сталкиваются разработчики на Python. Например, модуль `datetime` предоставляет инструменты управления значениями даты и времени.

**Сторонние модули** — это модули, которые написали другие разработчики. Такие модули можно установить через пакетный менеджер или скачать с GitHub.

Сторонние модули чаще всего пишут для того, чтобы расширить возможности стандартной библиотеки, например, для работы с искусственным интеллектом, графикой, интерфейсами устройств.

Такие модули помогают писать код быстрее, ведь нет необходимости «придумывать велосипед». Достаточно заглянуть на GitHub и поискать то, что нужно в данный момент. Также сторонние модули можно изменять под свои нужды и предлагать включать эти изменения в исходный код.

**Пользовательские модули** — это файлы с кодом, которые разработчик создаёт самостоятельно для конкретного проекта.

Например, у вас есть два модуля, которые находятся в одной директории:

- первый содержит две функции: одна функция складывает два числа, а вторая — вычитает одно число из другого:

```Python
# Эта функция складывает два числа.
def add_two_numbers(a, b):
    return a + b

# Эта функция вычитает одно число из другого.
def subtraction (a, b):
    return a - b 
```

- второй модуль обрабатывает и преобразует в число значения, которые пользователь вводит в терминал:

```Python
# В переменные записываются значения, которые пользователь вводит в терминал.
# Далее эти значения преобразовываются в число.
first_num = int(input())
second_num = int(input()) 
```

Задача — использовать функции сложения и вычитания из первого модуля во втором модуле, чтобы обработать те данные, которые введёт пользователь. Конечно, можно просто дописать код во втором модуле, и дело сделано. Но зачем писать код, который уже кто-то написал за вас? Импортируем функции из первого модуля во второй:

```Python
# Из файла ... импортируем функции ...
from имя_файла_первого_модуля_без_.py import add_two_numbers, subtraction

first_num = int(input())
second_num = int(input())

# Выводим результат на печать.
print(add_two_numbers( first_num, second_num))
print(subtraction( first_num, second_num)) 
```

## Папка с модулями — это пакет

Когда проект начинает разрастаться, разработчики для удобства собирают общие по тематике модули в одну папку внутри проекта. Такая папка называется **пакетом** (англ. _package_). В стандартной библиотеке тоже есть пакеты модулей, например, пакет `email` объединяет несколько модулей для управления сообщениями электронной почты.

В каждый пакет рекомендуется добавлять файл `__init__.py`. [В официальной документации](https://docs.python.org/3.9/tutorial/modules.html#packages) нет чёткого указания использовать этот файл, но он может быть полезен.

Например, в этот файл можно добавить описание пакета. У пакета `email` из стандартной библиотеки Python описание в `__init__.py` выглядит так

```Python
# Copyright (C) 2001-2007 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""A package for parsing, handling, and generating email messages.""" 
```

Описание поможет вам или другим разработчикам быстро понять, для чего используются модули из пакета. Также описанные в пакете модули отображаются в подсказке в редакторе кода при импорте. Всё на виду — не нужно заглядывать внутрь пакета, чтобы понять, какие у него есть возможности.

## Библиотека

Библиотека — это совокупность модулей и пакетов, которые решают задачу в одной предметной области. Например, [стандартная библиотека](https://docs.python.org/3.9/library/index.html) Python — это набор модулей и пакетов для решения популярных задач, с которыми ежедневно встречаются разработчики на Python. Не нужно писать код с нуля — достаточно подключить в проект готовый модуль или пакет. Удобно.

> Модуль — это python-файл, который содержит переменные, функции, классы и исполняемый код. Модули могут быть объединены в пакеты, а пакеты и модули, которые решают задачу в одной предметной области, — в библиотеки.

# Docstring: документирование кода

Комментировать каждую строчку кода считается плохим тоном. Используйте комментарии, когда нужно:

- указать на участок кода, на который стоит обратить внимание;
- пояснить сложные алгоритмы или логику;
- указать на код, который нужно доработать;
- указать на код, который хочется позже разобрать.

**docstring**, «строка документации», в ней автор кода описывает содержимое пакета, модуля или функции; такое описание позволяет другим разработчикам понять, что делает тот или иной код, не исследуя его.

```Python
"""
Asciimatics is a package to help people create full-screen text UIs (from interactive forms to ASCII animations) on any platform. It is licensed under the Apache Software Foundation License 2.0.
"""
```

## Что и как можно документировать

Строки документации принято писать для публичных функций, методов и классов. Иногда в докстринге описывают весь модуль целиком.

Вот как может выглядеть документированный код:

```Python
"""Документация модуля. Описывает работу классов и функций. 
Размещается в верхней части файла (начиная с первой строки).
"""

def tricky_func(self):
    """Описывает работу функции tricky_func."""
    ...

class Test:
    """Класс Test используется для демонстрации docstring.
```

> Строки документации пишутся по определённым правилам. Соблюдение этих правил упростит чтение вашей документации и, дополнительно, создаст вам хорошую репутацию в команде. Правила оформления докстрингов описаны в [стандарте PEP257](https://www.python.org/dev/peps/pep-0257/).

## Основные правила оформления докстрингов

- После открывающих тройных кавычек `"""` не должно быть пробела.
- Докстринг начинается с заглавной буквы и заканчивается точкой:

```Python
"""Возвращает число 1."""
```

Если докстринг не умещается в одну строку — можно разбить его на несколько строк. Отступы на новой строке должны выровнять текст по кавычкам:

```Python
  def tricky_func():
      """Можно перенести
      так.
      """
  
  def muddy_func():
      """
      А можно - 
      так.
      """
```

- Если документируется класс — после строки документации оставляется пустая строка. В остальных случаях код должен начинаться сразу после докстринга.
- Пакеты документируются в файле `__init__.py`. Докстринг должен находиться в самом начале файла. В докстринге пакета содержится:
    - описание пакета;
    - список модулей и пакетов, которые экспортирует описываемый модуль;
    - имя автора кода;
    - контактные данные;
    - лицензия.

Существуют разные стили оформления строк документации. Вот самые популярные:
- [Google styleguide](https://github.com/google/styleguide/blob/gh-pages/pyguide.md#38-comments-and-docstrings),
- [numpydoc](https://numpydoc.readthedocs.io/en/latest/format.html#class-docstring),
- [epydoc](http://epydoc.sourceforge.net/epytext.html).

Документировать код необязательно, программа будет работать и без этого. Однако докстринги применяют во всех крупных проектах.

Код читают намного чаще, чем пишут, и докстринги помогают в чтении.

Докстринг — это и признак уважения, и реальная помощь коллегам, работающим с вашим кодом; это признак хорошего тона и профессионализма.

# Виды ошибок в коде

Принято выделять три вида ошибок:

- синтаксические,
- логические,
- исключения.

**Синтаксические ошибки** программисту искать не нужно. Такие ошибки интерпретатор находит и обрабатывает сам, так как синтаксические ошибки — это нарушение синтаксиса языка. Если в программе есть подобные ошибки, программа не запустится, и Python выведет в терминал соответствующее сообщение.

**Логические ошибки** интерпретатор не умеет отслеживать. Программисту придётся отыскивать их самостоятельно. Логические ошибки появляются, когда разработчик неправильно описывает алгоритм работы программы.

**Исключения** (от англ. _Exceptions_) — это вид ошибок, какой появляется в тех случаях, когда в ходе работы программы возникает ситуация, которую разработчик не описал в коде. То есть программа запускается, но не выполняется целиком.

#### Начинаем дебажить

Откройте в редакторе кода проект и активируйте виртуальное окружение, если ещё не сделали этого.

Запустите файл _main.py_. Для этого в терминале выполните команду:

```bash
# На Windows:
python -m pdb main.py

# На Linux/MacOS:
python3 -m pdb main.py 
```

Отладчик запустит файл и остановит выполнение кода на первой строке; в терминале появится приглашение для ввода команд отладчика — это строка, которая начинается с идентификатора `(pdb)`:

В режиме отладки (или дебага) используются специальные команды для управления ходом выполнения программы. Вот описание основных команд:

- `h (help)` — вывести все доступные команды pdb.
- `l (list)` — вывести в терминал по пять строк до и после строки, на которую интерпретатор указывает в данный момент.
- `s (step)` — выполнить строку, на которую указывает интерпретатор в данный момент, и остановить выполнение программы на следующей строке, если это возможно.
- `n (next)` — эта команда очень похожа на команду `step`, но она будет выполнять программу не строго по шагам. Команда `next` не станет заходить внутрь функций, а выполнит их целиком, в один шаг.
- `b (break) имя_файла:номер_строки` — указать место обязательной остановки выполнения программы. Место обязательной остановки программы разработчики называют **«точка останова**» или **«брейкпоинт»**.
- `c (continue)` — выполнять программу до тех пор, пока она не отработает полностью или пока её выполнение не будет прервано ошибкой. Также выполнение этой команды будет прервано достижением точки останова — брейкпоинта.
- `p имя_переменной` — вывести текущее значение переменной в терминал.
- `q (quit)` — остановить работу отладчика.

#### Дебаггинг через интерфейс VSCode

С отладчиком pdb можно работать не только в терминале, но и через интерфейс редактора кода, в том числе и VSCode — в левой боковой панели VSCode выберите пункт _Run and Debug_:

![[Pasted image 20240212174157.png]]

Окно VSCode в режиме отладки делится на четыре части:

1. Боковая Debug-панель с информационным меню.
2. _Debug Toolbar_ — панель с кнопками управления процессом отладки:
    - _continue_ (F5) — `c (continue)`;
    - _step over_ (F10) — `n (next)`;
    - _step into_ (F11) — `s (step)`;
    - _step out (Shift+F11) — `r (return)`;
    - _restart_ (Shift+Ctrl+F5) — перезапуск отладчика;
    - _stop_ (Shift+F5) — остановка отладки.
3. Рабочая область с кодом. Здесь появился указатель, который останавливается на строке кода, на которой Python находится в данный момент.
4. Терминал, запущенный в режиме отладки.


