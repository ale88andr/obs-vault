![[Pasted image 20230609223157.png]]

# 1. Логгирование

**Логгирование** - это протокол(журнал) в который записывается каждое действие.

## 1.1 Модуль logging

Пример простейшего логгера:

```Python
import logging


log = logging.getLogger()
print(log)  # <RootLogger root (WARNING)>


def main(name):
    log.warning(f'Call {main.__name__}() with param name = {name}')


if __name__ == '__main__':
    main('Test')
```

Когда мы вызываем методы логгеров, например, `warning()` создаётся специальный объект `Logger`, который предоставляет API для записи сообщений в лог.  `Logger` является экземпляром класса `LogRecord`, который содержит всю информацию о произошедшем событии(имена функций, модулей, номер строки, время и т.д.) и далее направляются в обработчик `Handler` который занимается тем, что фильтрует объекты `LogRecord` и принимает решение, что с ним делать дальше(вывести в консоль, записать в файл, отправить по почте и т.д.), затем при необходимости  `LogRecord` передается в закрепленный за ним `Formatter`, который создаст строку лога нужного вида

![[Pasted image 20230726135037.png]]

Уровни сообщений:
1. `NOTSET` - 0
2. `DEBUG` - 10
3. `INFO` - 20
4. `WARNING` - 30
5. `ERROR` - 40
6. `CRITICAL` - 50

По умолчанию уровень логгирования - **30**. Чтобы проверить текущий уровень можно воспользоваться свойством `level` объекта `LogRecord`

```Python
print(log.level)  # 30
```

установить свой уровень:

```Python
log.setLevel('DEBUG')
```

Чтобы посмотреть список обработчиков логгера можно воспользоваться свойством `handlers` объекта `LogRecord`, если обработчики не были заданы выведется пустой список

```Python
log.handlers  # []
```

Для несконфигурированного объекта логгера по умолчанию создается обработчик `StreamHandler()` c уровнем `WARNING`, который будет выводить все сообщения в `stderr` ( консоль)

> Обработчики имеют свои, отдельные уровни сообщений!

Для настройки логгера предназначен метод `basicConfig()`

```Python
import logging


logging.basicConfig(level='DEBUG')
log = logging.getLogger()
log.handlers  # [<StreamHandler <stderr> (NOTSET)>]
```

если в параметр функции передать параметр `filename`, то вместо стандартного обработчика логгеру присвоиться обработчик `FileHandler`

```Python
logging.basicConfig(level='DEBUG', filename='main.log')
log = logging.getLogger()
log.handlers  # [<FileHandler main.log (NOTSET)>]
```

Модуль `logging` использует паттерн Singleton, поэтому настройки будут распространяться на все созданные логгеры. Чтобы изменить настройки определенного логгера нужно получить объект нужного логгера через функцию `getLogger('<logger_name>')`, а затем уже менять его настройки:

```Python
logging.getLogger('<name>').setLevel('CRITICAL')
```

Создание именованного логгера:

```Python
import logging
app_logger = logging.getLogger('app_logger')
print(app_loger.parent)  # <RootLogger root (WARNING)>
print(app_logger)        # <Logger app_logger (WARNING)>
```

Форматирование сообщений логгера осуществляется с помощью форматировщиков

```Python
f = logging.Formatter(fmt='%(levelName)s - %(name)s - %(message)s')
```

теперь объект форматтера необходимо связать с обработчиком:

```Python
import logging


# Создаем именованный логгер
app_logger = logging.getLogger('app_logger')
# Получаем обработчик консольного вывода логов
console_handler = logging.StreamHandler()
# Задаем формат отображения сообщений лога
f = logging.Formatter(fmt='%(levelname)s - %(name)s - %(message)s')
# Привязываем объект форматтера к обработчику
console_handler.setFormatter(f)
# Привязываем именнованный логгер к измененному консольному обработчику
app_logger.addHandler(console_handler)


def main():
    app_logger.warning('A very important log message')


if __name__ == '__main__':
    main()
```

# 2. Профилирование

### 2.1 Измерение времени выполнения программы

Очень часто нам бывает необходимо измерить время выполнения всей программы, либо отдельных ее частей. Чтобы найти данную величину, достаточно посчитать разницу в секундах между точкой старта и местом, где она завершает свою работу.

В следующем примере демонстрируется применение функции `time()` для получения текущего времени, чтобы в итоге выявить, как долго работал блок кода.

```Python
import time

start_time = time.time()

for i in range(5): 
    print(i)
    time.sleep(1)

end_time = time.time()

elapsed_time = end_time - start_time
print(f'Время работы программы = {elapsed_time}')  # Время работы программы = 5.0228848457
```

Несмотря на простоту вышеописанного подхода, использовать его в серьезных целях, где требуется точный и независимый от операционной системы (ОС) результат, не рекомендуется. Все дело в том, что числовое значение времени, получаемое таким образом, может иметь погрешности за счет внутренних особенностей работы компьютера, в среде которого выполняется программа. Более того, системные часы могут быть подкорректированы вручную пользователем во время выполнения программы.

### 2.2  Функция monotonic()

Для измерения времени выполнения программы идеально подходит функция `monotonic()`, доступная на всех ОС (начиная с Python 3.5), так как ее результат не зависит от корректировки системных часов.

> Функция `monotonic_ns()` похожа на `monotonic()`, но возвращает время в наносекундах. Работает не на всех операционных системах.

Используемый таймер в функции `monotonic()` никогда не вернет при повторном вызове значение, которое будет меньше значения, полученного при предыдущем вызове. Это позволяет избежать многих ошибок, а также неожиданного поведения.

```Python
import time

start_time = time.monotonic()

for i in range(5): 
    print(i)
    time.sleep(0.5)

end_time = time.monotonic()

elapsed_time = end_time - start_time
print(f'Время работы программы = {elapsed_time}')  # Время работы программы = 2.54700000001
```

> Принцип работы и применения функции `monotonic()` такой же, как и у функции `time()`. Однако функция `monotonic()` дает результат, который обладает гарантированной точностью и не зависит от внешних условий.

### 2.3 Функция perf_counter()

Для самого точного измерения времени выполнения программы следует использовать функцию `perf_counter()`. Данная функция использует таймер с наибольшим доступным разрешением, что делает эту функцию отличным инструментом для измерения времени выполнения кода на коротких интервалах.

```Python
import time

start_time = time.perf_counter()

for i in range(5): 
    print(i)
    time.sleep(1)

end_time = time.perf_counter()

elapsed_time = end_time - start_time
print(f'Время работы программы = {elapsed_time}')  # Время работы программы = 5.04214090004
```

> В Python версии 3.7 добавлена функция `perf_counter_ns()` – работает так же, но длительность выводится в наносекундах, что удобнее для совсем малых интервалов времени и быстро исполняемых команд.

### 2.4 Модуль timeit

Модуль timeit предоставляет простой способ измерения времени выполнения (производительности) маленьких объемов кода Python.

```Python
>>> import timeit
>>> timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
0.3018611848820001
>>> timeit.timeit('"-".join([str(n) for n in range(100)])', number=10000)
0.2727368790656328
>>> timeit.timeit('"-".join(map(str, range(100)))', number=10000)
0.23702679807320237
```

В момент запуска программы в фоновом режиме также запускается множество сторонних процессов. Модуль `timeit` за счет многократного запуска фрагмента нивелирует неоднородность длительности его выполнения.

Кроме куска кода, функции `timeit()` можно передать строку `setup`, однократно выполняемую перед началом повторения кода `stmt`. В `setup`, например, можно вынести импорт библиотек:

```Python
mysetup = 'from math import sqrt'

mycode = '''
mylist = []
for i in range(100):
    mylist.append(sqrt(i))
'''
        
timeit.timeit(stmt = mycode,
              setup = mysetup,
              number = 10000)
```

### 2.5 Random

### 2.5.0 Случайные и псевдослучайные числа

**Случайные числа** – последовательность чисел, в которой невозможно предсказать следующее число, зная все предыдущие.

Случайные числа широко используются в различных задачах программирования:
-        в играх (имитация подбрасывания игрального кубика и другие подобные ситуации);
-        в программах имитационного моделирования;
-        в статистических программах, случайным образом отбирающих данные для анализа;
-        в компьютерной безопасности для шифрования уязвимых данных.

**Псевдослучайные числа** - для обычного человека псевдослучайные числа практически не отличаются от случайных, однако они вычисляются по математической формуле, и зная первое число и формулу, можно определить любое следующее.

Python предлагает встроенные функции для работы с псевдослучайными числами. Эти функции хранятся в модуле `random` в стандартной библиотеке.

В Python для генерации псевдослучайных чисел используется один из самых совершенных алгоритмов генерации псевдослучайных чисел – "**вихрь Мерсенна**", разработанный в 1997 году. Реализация выполнена на языке `C`, является быстрой и потокобезопасной.

### 2.5.1 Модуль `random`

Модуль **random** предоставляет функции для генерации псевдослучайных чисел, букв и случайного выбора элементов последовательности (списка, строки и т.д.).

Функция **randint()** - принимает два обязательных аргумента `a` и `b` и возвращает псевдослучайное целое число из отрезка [a;b].

```Python
import random

num1 = random.randint(0, 17)  # 9
num2 = random.randint(-5, 5)  # 1
```

Левая и правая граница `a` и `b` включаются в диапазон генерируемых псевдослучайных чисел. Результатом вызова функции `random.randint(2, 9)` может быть любое число от `2` до `9`, включая `2` и `9`.

Функция `randrange()` - принимает такие же аргументы, что и функция `range()`. Различие состоит в том, что функция `randrange()` не возвращает саму последовательность чисел. Вместо этого она возвращает случайно выбранное число из последовательности чисел.

```Python
import random

num = random.randrange(5, 10)  # 9
```

Функция `random()` - функция `random()` возвращает псевдослучайное число с плавающей точкой (вещественное число). В функцию `random()` никаких аргументов не передается. Функция `random()` возвращает случайное число с плавающей точкой в диапазоне от `0.0` до `1.0` (исключая `1.0`).

```Python
import random

num = random.random()  # 0.11779223807836836
```

Функция `uniform()` -  возвращает случайное число с плавающей точкой, но при этом она позволяет задавать диапазон для отбора значений.

```Python
import random

num = random.uniform(1.5, 17.3)  # 6.374012820810563
```

Функция `seed()` - псевдослучайные числа вычисляются на основе **некой формулы**. Генерация случайных чисел инициируется **начальным значением**. Оно используется в вычислении, возвращающем следующее случайное число в ряду. Когда модуль `random` импортируется, он получает системное время из внутреннего генератора тактовых импульсов компьютера и использует его как начальное значение. Системное время – целое число, представляющее собой текущую дату и время вплоть до сотой секунды. Поскольку системное время меняется каждую сотую долю секунды, можно утверждать, что всякий раз, когда импортируется модуль `random`, будет создана отличающаяся от предыдущих последовательность случайных чисел.

Вместе с тем, некоторые программы требуют генерации одной и той же последовательности случайных чисел. Для этого можно вызвать функцию `seed()`, задав начальное значение.

```Python
import random

random.seed(17)   # явно устанавливаем начальное значение для генератора случайных чисел

for _ in range(10):
    print(random.randint(1, 100))
```

Если выполнить код еще раз, получим ту же самую последовательность псевдослучайных чисел.

Метод `shuffle()` - принимает список в качестве обязательного аргумента и перемешивает его случайным образом.

```Python
import random

numbers = [1, 2, 3, 4, 5, 6, 7, 8]
random.shuffle(numbers)  # [6, 8, 3, 4, 2, 7, 1, 5]
```

Метод `choice()` - принимает список (строку, кортеж) в качестве обязательного аргумента и возвращает один случайный элемент.

```Python
import random

print(random.choice('BEEGEEK'))            # E
print(random.choice([1, 2, 3, 4]))         # 3
print(random.choice(('a', 'b', 'c', 'd'))) # d
```

Метод `sample()` - принимает два обязательных аргумента: первый – список (строка, кортеж, множество), второй – количество случайных элементов. Возвращает список из указанного количества уникальных (имеющих разные индексы) случайных элементов.

```Python
import random
 
numbers = [2, 5, 8, 9, 12]

print(random.sample(numbers, 1))  # [5]
print(random.sample(numbers, 2))  # [12, 2]
print(random.sample(numbers, 3))  # [5, 12, 2]
print(random.sample(numbers, 5))  # [12, 5, 9, 2, 8]
```

Модуль `string` - встроенный модуль `string` раньше использовался для расширения стандартных возможностей (функционала) строкового типа данных `str`. На текущий момент все функции из модуля `string` переехали в методы строкового типа данных `str`, однако в модуле `string` остались удобные константные строки, которые можно использовать при решении задач.

```Python
import string

print(string.ascii_letters)    # abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
print(string.ascii_uppercase)  # ABCDEFGHIJKLMNOPQRSTUVWXYZ
print(string.ascii_lowercase)  # abcdefghijklmnopqrstuvwxyz
print(string.digits)           # 0123456789
print(string.hexdigits)        # 0123456789abcdefABCDEF
print(string.octdigits)        # 01234567
print(string.punctuation)      # !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
print(string.printable)        # 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
```

### 2.6 Input

#TODO 

### 2.7 Print

#TODO 

## 2.8 Криптография (Cryptography)

### 2.8.1 Основные принципы безопасности

- **целостность данных** (изменены ли данные) - служит для проверки, не было ли содержимое искажено. Таким образом мы можем быть уверенны, что прочитали те же данные, которые были записаны(отправлены)
- **проверка подлинности** (кто это?) - это может быть как проверка личности, так и проверка подлинности чего бы то ни было. Подлинность устанавливается в момент ввода верной пары логина и пароля.
- **проверка подлинности данных** (кем созданы данные) - обеспечивает возможность проверить личность того, кто данные записал.
- **неопровержимость действия** (авторство) - кто бы то ни был - ни личность, ни организация не сможет отрицать содеянного.
- **предоставление прав** (что можно и что нельзя) - действия которые могут быть позволены либо не позволены пользователю.
- **неразглашение** (у кого есть доступ к данным) - гарантия того, что две или более стороны обмениваются данными исключительно частно.

| **Фундаментальный принцип** | **Архитектурное решение** | 
|--|--|
| Целостность данных | Защищенные сетевые протоколы; Система контроля версий; Диспетчер пакетов |
| Проверка подлинности | Проверка личности; Проверка подлинности системы |
| Проверка подлинности данных | Регистрация пользователей; Ввод пользователем учётных данных; Механизм сброса и восстановления пароля; Пользовательские сеансы | 
| Неопровержимость действия | Посылка данных об операции на сервер; Цифровые подписи; Доверенные третьей стороны |
| Предоставление прав | Выдача прав пользователям; Выдача прав системам; Выдача прав на доступ к файлам и папкам |
| Неразглашение | Алгоритмы шифрования; Защищенные сетевые протоколы |

### 2.8.2 Модули Python для безопасности

- `hashlib` - модуль для криптографического хеширования;
- `secrets` - модуль для генерации непредсказуемых чисел;
- `hmac` - модуль для проверки подлинности сообщение по хешам;
- `os`, `subprocess` - модули для доступа к возможностям операционной системы;
- `argon2-cffi` - функция для защиты паролей;
- `cryptography` - пакет с распространенными криптографическими функциями;
- `defusedxml` - безопасный способ разбора XML;
- `gunicorn` - веб-сервер, написанный на Python;
- `pipenv` - пакетный менеджер с акцентом на безопасности;
- `requests`, `requests-oauthlib` - библиотека для отправки http-запросов, реализация клиента протокола OAuth 2

### 2.8.3 Хеширование

Любой хеш-функции можно подать на вход данные(*сообщение*) и получить на выходе результат - очень большое **число**(*хэш, хеш-сумма, отпечаток*). Хеш-функция принимает на вход содержимое неопределенного размера, но результата предопределены. Хеш уникален для каждого набора данных(*сообщения*)

```Python
message = 'message'
hash(message)  # -5427477157861188105
```

Хеш-функциям присущи три основных свойства:
- **детерминированное поведение** - для одного и того же сообщения на входе функция всегда выдает одинаковый результат;
- **хеши неизменной длины** - у сообщений произвольная длина, у хешей же для каждой хеш-функции длина строго определена, т.е. длина сообщения не должна влиять на длину хеша
- **лавинный эффект** - когда незначительное изменение сообщения разительно сказывается на получаемом хеше

Все криптографические хеш-функции обязаны быть *вычислительно необратимыми* (one way functions)

#### Выбор криптографической функции

В Python уже встроена поддержка криптографического хеширования. Встроенный модуль `hashlib` содержит всё для криптографического хеширования:

```Python
import hashlib
sorted(hashlib.algorithms_guaranteed)
# ['blake2b', 'blake2s', 'md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha3_224', 'sha3_256', 'sha3_384', 'sha3_512', 'sha512', 'shake_128', 'shake_256']
```
#### Безопасные хеш-функции

Безопасные хеш-функции принадлежат семействам:
- SHA-2;
- SHA-3;
- BLAKE2;

#### Небезопасные хеш-функции

Небезопасные хеш-функции оставлены в Python для обеспечения  обратной совместимости:
- MD5;
- SHA-1;
#### Как стоит выбирать криптографическую хеш-функцию

- Для большинства задач подходит SHA-256;
- Для обеспечения высокой безопасности подходит SHA3-256, но она не обладает настолько широкой поддержкой как SHA-256;
- Для объемных сообщений подходит BLAKE2;
- Не следует использовать MD5 либо SHA1
#### Модуль `hashlib`

Модуль `hashlib` содержит в себе все именованные конструкторы для каждой хеш-функции, так же все хеш-функции доступны через универсальный конструктор `new`

```Python
import hashlib


named = hashlib.sha256()
generic = hashlib.new('sha256')
```

Независимо от способа создания, любой экземпляр функции имеет идентичный внешний интерфейс (API). Открытые методы экземпляра SHA-256 не отличаются от открытых методов экземпляра MD5. Методы `digest` и `hexdigest` возвращают хеш как байтовую строку и шестнадцатеричный текст во втором:

```Python
from hashlib import sha256

message = b'message'
hash_function = sha256(message)
# 'ab530a13e45914982b79f9b7e3fba994cfd1f3fb22f71cea1afbf02b460c6d1d'
hash_function.hexdigest()
# b'\xabS\n\x13\xe4Y\x14\x98+y\xf9\xb7\xe3\xfb\xa9\x94\xcf\xd1\xf3\xfb"\xf7\x1c\xea\x1a\xfb\xf0+F\x0cm\x1d'
hash_function.digest()
```

Также сообщение может передаваться по частям:

```Python
from hashlib import sha256


message = b'message'
once = sha256(message)

many = sha256()
many.update(b'm')
many.update(b'e')
many.update(b's')
many.update(b's')
many.update(b'a')
many.update(b'g')
many.update(b'e')

once.digest() == many.digest()
```
### 2.8.4 Функции контрольного суммирования

Между хеш-функциями и функциями контрольного суммирования есть что-то общее. Хеш-функции принимают данные и выдают хеш, функции контрольного суммирования принимают данные и выдают контрольную сумму. Что хеш, что контрольная сумма - числа.

Python имеет встроенную поддержку функций контрольного суммирования CRC и Adler-32. Они находятся в модуле `zlib`

```Python
import zlib

message = b'this is repetitious' * 42

compressed = zlib.compress(message)
decompressed = zlib.decompress(compressed)

zlib.crc32(decompressed) == zlib.crc32(message)  # True
```

Криптографические хеш-функции и функции контрольного суммирования похожи между собой но путать их не стоит. Контрольное суммирование происходит быстрее, но в ущерб криптографической стойкости(легко найти коллизию), а для хеш-функции сложно найти коллизию, но подсчет занимает больше ресурсов.

### 2.8.5 Хеш-функции с ключом

Проверка подлинности данных, иногда проверка подлинности сообщения, служит для того, чтобы при чтении файла можно было проверить личность того, кто этот файл записал. Для этого потребуются две вещи: ключ и хеш-функция, которой, кроме сообщения, можно передать и собственно ключ. Следующие разделы говорят о генерации ключа и вычислении хеша с участием ключа
#### Генерация ключа

Любой секретный ключ должно быть сложно угадать, существуют две его разновидности: случайное число и кодовая фраза.

**Случайные числа** - Разработчики, как правило, используют функцию `os.urandom` в качестве криптобезопасного источника случайных чисел. В качестве аргумента она принимает целое число `size` и возвращает соответствующее количество случайных байтов. Источник этих байтов – сама операционная система. На UNIX-подобных системах это `/dev/urandom`, в Windows это `CryptGenRandom`.
```Python
import os

os.urandom(16)  # b':=\xff\xa7u\x9eV\xcf\x84.W/\x8f\xebdd'
```

В Python 3.6 специально для генерации криптобезопасных случайных чисел был добавлен модуль secrets.

```Python
from secrets import token_bytes, token_hex, token_urlsafe


# Генерация 16 случайных байт
token_bytes(16)  # b'\xb5PWN\xcb\x8f]!2\xb8H\xc5~\x98+\xa2'

# Генерация 16 случайных байт в виде шестнадцатеричного текста
token_hex(16)  # '5d6ad328a781b735a0807b6a040ab82d'

# Генерация 16 случайных байт для вставки в URL
token_urlsafe(16)  # 'TmgH5n-Ag0jtaI908OR3Jw'
```

Модуль `random` – это третий способ получения случайных чисел. Большинство функций из этого модуля возвращают небезопасные значения.

**Кодовые фразы** - является набор случайных слов вместо чисел. В листинге показано, как составить кодовую фразу из четырех слов с помощью модуля secrets. Слова берутся из файла, он служит словарем.

```Python
from pathlib import Path
import secrets

# Загружаем словарь в память
words = Path('/usr/share/dict/words').read_text().splitlines()
# Выбираем четыре случайных слова
passphrase = ' '.join(secrets.choice(words) for i in range(4))
print(passphrase)
```

Соль кроется в длине кодовой фразы. Например, фраза `whereat isostatic custom insupportableness` весит 42 байта. По данным www.useapassphrase.com, на взлом этой фразы уйдет *163 274 072 817 384* столетия. Успешная атака «грубой силой» на такой длинный ключ недостижима. Длина решает.
#### Хеширование с ключом

Некоторым хеш-функциям можно передать необязательный аргумент – ключ. Он, подается на вход функции вместе с сообщением.

![[Pasted image 20230811115801.png]]
Хеш зависит от переданного ключа. Хеш одного и того же сообщения будет разным, если передан разный секрет. Хеши будут идентичны, если пары ключ–сообщение будут совпадать. Вот пример хеширования с ключом функцией `BLAKE2`, которой при необходимости можно передать ключ:

```Python
from hashlib import blake2b


m = b'same message'
x = b'key x'
y = b'key y'

# Тот же ключ, тот же хеш
blake2b(m, key=x).digest() == blake2b(m, key=x).digest()  # True
# Разные ключи, разные хеши
blake2b(m, key=x).digest() == blake2b(m, key=y).digest()  #False
```

Таким образом, например, можно сохранять документы на пару с хешем, который технически может подсчитать только владелец с ключом. У злоумышленника больше не получится изменить документ и просто пересчитать его хеш. Использование хеша с ключом защищает от случайного повреждения данных и злонамеренных изменений.

```Python
import hashlib
from pathlib import Path


def store_with_hash(path, data, key):
    data_path = Path(path)
    hash_path = data_path.with_suffix('.hash')
    # Подсчет хеша содержимого с ключом
    hash_value = hashlib.blake2b(data, key=key).hexdigest()
    # Запись документа и хеша по разным файлам
    with data_path.open(mode='x'), hash_path.open(mode='x'):
        data_path.write_bytes(data)
        hash_path.write_text(hash_value)


def is_modified(path, key):
    data_path = Path(path)
    hash_path = data_path.with_suffix('.hash')
    # Чтение документа и хеша из хранилища
    data = data_path.read_bytes()
    original_hash_value = hash_path.read_text()
    # Пересчет хеша с ключом
    hash_value = hashlib.blake2b(data, key=key).hexdigest()
    # Сравнение хеша текущего содержимого документа со значением с диска
    return original_hash_value != hash_value


if __name__ == '__main__':
    store_with_hash('test.txt', b'test\ntest\ntest', b'nhfcjj,ek')
    if is_modified('test.txt', b'Pa$$w0rd'):
        print('File is modified!')
    else:
        print('It\'s ok')
```

Рядовые хеш-функции вроде SHA-256 не позволяют указать ключ – и таких функций большинство, поэтому был разработан механизм проверки подлинности сообщений 
использующий хеш-функции без ключа - HMAC-функции.
#### HMAC-функции

HMAC-функции (hash-based message authentication code; код проверки подлинности сообщений, использующий хеш-функции) – распространенный способ применить любую хеш-функцию для проверки подлинности данных, как если бы ей можно было передать ключ. HMAC-функция принимает три параметра: сообщение, ключ
и рядовую криптографическую хеш-функцию.
![[Pasted image 20230811122212.png]]

В Python для HMAC существует одноименный модуль `hmac`. В примере ниже функции этого модуля передается сообщение, ключ и ссылка на конструктор хеш-функции `SHA-256`. Ссылку на хеш-функцию ожидает именованный аргумент `digestmod`. В него допустимо передать любой конструктор хеш-функции из модуля `hashlib`.

```Python
import hashlib
import hmac


hmac_sha256 = hmac.new(b'key', b'message', hashlib.sha256)
hmac_sha256.hexdigest()  # '6e9ef29b75fffc5b7abae527d58fdadb2fe42e7219011976917343065f58ed4a'
```

Проверка подлинности данных между системами:

Допустим, система Алисы теперь должна принимать документы от Боба. Алиса хочет знать наверняка, что по пути ни одно сообщение не было изменено злоумышленниками. Алиса и Боб договорились о взаимодействии:
- Алиса и Боб согласовали общий секретный ключ;
- Боб высчитывает хеш документа через HMAC-функцию;
- Боб отправляет документ и его хеш Алисе;
- Алиса высчитывает хеш документа через HMAC-функцию;
- Алиса сравнивает свой хеш с хешем Боба.
![[Pasted image 20230811123335.png]]
```Python
import hashlib
import hmac
import json


s_key = b'secret_key'

#----------------------------------------------------
# Отправитель
#----------------------------------------------------
hmac_sha256 = hmac.new(s_key, digestmod=hashlib.sha256)
message = b'from Bob to Alice'
hmac_sha256.update(message)
hash_value = hmac_sha256.hexdigest()

authenticated_msg = {
    'message': message.decode('utf-8'),
    'hash_value': hash_value, }

outbound_msg_to_alice = json.dumps(authenticated_msg)
```

В результате сформируется сообщение вида:

```json
{
	"message": "from Bob to Alice", 
	"hash_value": "774f8f9047dc149ff615f99d930e7b5c125309932db9cb4032d1feb2072aaa77"
}
```

А вот реализация со стороны Алисы. Она тоже использует `HMAC-SHA256`
для подсчета хеша полученного сообщения. Если оба MAC совпадают, считается, что сообщение подлинное.

```Python
#----------------------------------------------------
# Получатель
#----------------------------------------------------
authenticated_msg = json.loads(outbound_msg_to_alice)

message = bytes(authenticated_msg['message'].encode())
hmac_sha256 = hmac.new(s_key, digestmod=hashlib.sha256)
hmac_sha256.update(message)
hash_value = hmac_sha256.hexdigest()

if hash_value == authenticated_msg['hash_value']:
    print('доверенное сообщение')
```

Даже если это сообщение будет идти через злоумышленника, то у него никак не получится заставить Алису поверить измененному сообщению. Так как у злоумышленницы нет ключа, который есть у Алисы и Боба, она не может высчитать подходящий сообщению хеш. Если злоумышленник изменит сообщение либо хеш на пути к получателю, то пришедший хеш не будет совпадать с хешем, который посчитает Алиса.
#### Атака по времени

В основе проверки как целостности данных, так и подлинности сообщения лежит сравнение хешей. Казалось бы, что может быть проще, чем сравнить две строки, но эта простота обманчива. Оператор `==` выдает False, как только повстречает первое несоответствие между его операндами. Как минимум ему придется сравнить первый символ, а как максимум – в случае полного либо почти полного совпадения – придется сравнить все символы. Самое важное здесь заключается в том, что оператор `==` будет сравнивать строки дольше, если они начинаются одинаково. 

Итак, злоумышленник атакует. Сперва она создает документ, который хочет подсунуть Алисе как файл от Боба. Злоумышленник не знает, какой хеш от этого документа получится у Алисы, ведь у него нет ключа. Но из передаваемого сообщения она знает, что хеш длиной 64 символа и это шестнадцатеричный текст – у каждого символа 16 возможных значений. Следующим шагом злоумышленник хочет знать, какой у правильного хеша первый символ. Возможных вариантов всего шестнадцать – и злоумышленник создает шестнадцать хешей, которые начинаются с разных символов. Она берет первый хеш, прикрепляет его к файлу и отправляет Алисе. Затем повторяет это еще пятнадцать раз с оставшимися хешами. После каждой отправки она измеряет и записывает время, за которое система документооборота ответила ей. Взломщик повторяет одни и те же отправки много-много раз, чтобы накопить статистику времени ответа. В какой-то момент ей
становится понятно, что система отвечает чуточку медленнее на один из шестнадцати вариантов. Таким образом становится известен первый из 64 символов верного хеша.
![[Pasted image 20230811131423.png]]

Затем злоумышленник повторяет процедуру для 63 оставшихся символов
64-значного хеша, и таким образом узнаёт хеш целиком. Это пример атаки по времени. Ее принцип заключается в том, что взломщик узнаёт информацию, о которой знать не должен, опосредованно – по времени отклика системы. Злоумышленник измеряет время, которое тратит сервис на операцию, и по замерам строит догадки о недоступном ему содержимом. Здесь этой операцией является сравнение строк.

> **Безопасные системы сравнивают хеши за постоянное время!**

Модуль `hmac` содержит функцию `compare_digest`, которая сравнивает хеши за одинаковое время. Она работает как оператор `==`, но отличается от него временно́й сложностью алгоритма.
### 2.8.6 Симметричное шифрование

**Шифрование** – это умышленное обратимое искажение открытого текста с целью скрыть информацию. Результатом этого процесса является шифрованный текст (ciphertext). Обратный процесс, то есть преобразование шифротекста в откры-
тый с применением ключа, называется **расшифровкой**.
![[Pasted image 20230811152245.png]]
Шифрование отвечает за **неразглашение данных**.
#### Пакет `cryptography`

Чтобы установить пакет `cryptography`

```Shell
pip install cryptography
```

По умолчанию за кулисами пакета трудится библиотека `OpenSSL`, имеющая открытый код. В ней реализованы сетевые протоколы, отвечающие за безопасность, и криптографические функции для широкого круга задач. В основном библиотека написана на `C`.

Высокоуровневый и простой в использовании API называется «*готовые рецепты*».

Один из готовых рецептов реализует метод симметричного шифрования под названием **fernet**. Его нормативная документация описывает протокол для шифрованного взаимодействия, стойкий к постороннему вмешательству. Его воплощает класс `Fernet`, который находится в `cryptography.fernet`.

Метод `Fernet.generate_key` создает ключ длиной 32 случайных байта, который требуется конструктору класса в качестве аргумента:

```Python
from cryptography.fernet import Fernet

key = Fernet.generate_key()
fernet = Fernet(key)
```

Под капотом `Fernet` делит переданный ключ на два 128-битных. Один используется для шифрования, а второй – для проверки подлинности. Метод `Fernet.encrypt` не только зашифровывает открытый текст, он также высчитывает хеш от шифротекста функцией `HMAC-SHA256`. То есть шифротекст для хеш-функции является сообщением. Шифрованный текст и хеш возвращаются внутри объекта под названием fernet token:

```Python
# Зашифровывает открытый текст, хеширует шифротекст
token = fernet.encrypt(b'plaintext')
```

![[Pasted image 20230811153432.png]]
Методу `Fernet.encrypt` противопоставлен метод `Fernet.decrypt`. Он извлекает шифротекст из токена и проверяет его подлинность с помощью HMAC-SHA256. Если заново посчитанный хеш не совпадает с хешем внутри токена, то будет брошено исключение `InvalidToken`. Если хеши совпадают, метод расшифровывает сообщение
и возвращает его:

```Python
# Проверяет подлинность и расшифровывает шифротекст
fernet.decrypt(token)
```

![[Pasted image 20230811154917.png]]

> Если алгоритму шифрования требуется один и тот же ключ как для зашифровки открытого текста, так и для его расшифровки такое шифрование называется **симметричным**. Алгоритмы симметричного шифрования делятся на две подкатегории: **блочные** шифры и **потоковые**.
#### Блочные шифры

Блочные шифры зашифровывают открытый текст в последовательность блоков шифротекста одинаковой длины. Открытый текст делится на блоки, над которыми и проводится зашифровка. Размер блока зависит от алгоритма. Популярными блочными шифрами являются:
- **Triple DES** - создан на основе Data Encryption Standard (DES), под капотом блок шифруется алгоритмом DES в три прогона, считается медленным, устаревший;
- **Blowfish** - Размер блока – 64 бита, ключ любой длины от 32 до 448 бит., оказался уязвим к атаке SWEET32, применять не следует;
- **Twofish** - разработан в конце 90-х на замену **Blowfish**, Размер блока – 128 бит, длина ключа – 128, 192 либо 256 бит.;
- **Advanced Encryption Standard** - *Rijndael* (произносится «рейндал»), единственный алгоритм симметричного шифрования, о котором нужно знать рядовому программисту, Размер блока – 128 бит, длина ключа – 128, 192 либо 256 бит. У него широкий и внушающий послужной список. AES применяется в сетевых протоколах, например HTTPS, а также в алгоритмах сжатия, внутри файловых систем, при вычислении хешей и для установления виртуальных частных сетей (VPN) и есть поддержка на уровне команд центрального процессора. Для рядовых задач этот шифр – *самый оптимальный выбор*. Под капотом у `Fernet` трудится **AES**.
#### Потоковые шифры

Потоковые шифры не делят открытый текст на блоки. Вместо этого они обрабатывают его как поток несвязанных байтов: один вошел, один вышел. Эти шифры подходят для обработки непрерывного потока данных, либо когда размер открытого текста просто неизвестен. Поэтому они часто применяются в сетевых протоколах. Когда открытый текст очень мал, потоковые шифры показывают
себя лучше блочных.

**RC4** и **ChaCha** – примеры потоковых шифров. **ChaCha** же считается защищенным и весьма быстрым. **RC4** - уязвим!

> Потоковые шифры, несмотря на скорость и эффективность, не востребованы настолько, насколько блочные.
#### Режимы шифрования

Алгоритмы симметричного шифрования могут работать в разных режимах.

- **Режим электронной кодовой книги**(по ГОСТ – режим простой замены.) - Этот режим небезопасен потому, что одинаковые блоки открытого текста он превращает в одинаковые блоки шифрованного. Благодаря этому с ним легко разобраться новичку, но и злоумышленнику тоже становится просто угадать структуру открытого текста по шифротексту.
![[Pasted image 20230811160802.png]]
> Никогда не шифруйте данные в режиме ECB на боевых системах.

- **Режим сцепления блоков шифротекста** (cipher block chaining – CBC) не страдает болезнью предыдущего режима. Достигается это тем, что любое изменение в блоке влияет на шифротекст блоков последующих. Кроме того, зашифровка в этом режиме одинаковых открытых текстов дает разные шифротексты. Это достигается с помощью вектора инициализации. Он подается шифру на вход вместе с текстом и ключом. Вектор для режима сцепления блоков шифротекста должен быть случайным 128-битным числом, он должен быть использован только однократно.
![[Pasted image 20230811160944.png]]

Этот пример кода зашифровывает два одинаковых текста из двух одинаковых блоков алгоритмом **AES** в режиме **CBC**. Для каждого текста вектор инициализации генерируется заново. Обратите внимание: шифротексты уникальны, блоки внутри шифротекста тоже не равны:

```Python
import secrets
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import (Cipher, algorithms, modes)

key = b'key must be 128, 196 or 256 bits'

def encrypt(data):
    # Вектор инициализации, 16 случайных байт
    iv = secrets.token_bytes(16)
    # Будет применен AES в режиме CBC
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    
    encryptor = cipher.encryptor()
    return encryptor.update(data) + encryptor.finalize()

plaintext = b'the same message' * 2

# Зашифровка одинаковых текстовъ
x = encrypt(plaintext)
y = encrypt(plaintext)

# Два одинаковых блока открытого текста стали двумя разными блоками шифротекста
x[:16] == x[16:]    # False

# Два одинаковых открытых текста стали двумя разными шифротекстами
x == y              # False


print(x.hex())  # b681c71b8d628e1f094954fe5285b50650075f49cf3232a2aaa0b9264f61ad7a

print(y.hex())  # fc50d7672f9edf0150b30256b399bdb250b7209d13cc68bf73e5842f0526d7ad
```

Использованный вектор требуется и при последующей расшифровке, наравне с шифротекстом и ключом. Следовательно, `IV` требуется сохранить. Без него открытый текст будет безвозвратно потерян.

> - Шифрование обеспечивает неразглашение.
> - `Fernet` – безопасный и простой способ симметричного шифрования и проверки подлинности данных.
> - В алгоритмах симметричного шифрования применяется один и тот же ключ для зашифровки и расшифровки.
> - Если симметричное шифрование, то AES

### 2.8.7 Ассиметричное шифрование

Как передать ключи – классическая задача криптографии, и у симметричного шифрования нет на нее ответа. На помощь приходит шифрование **асимметричное**.

Если алгоритму шифрования – например, AES – требуется один и тот же ключ для зашифровки и расшифровки, то это симметричное шифрование. Если для зашифровки применяется один ключ, а для расшифровки – другой, то это **асимметричное** шифрование. Эти два ключа называют *парой ключей*. Пара состоит из **закрытого** ключа и **открытого**. **Закрытый** ключ владелец **держит в секрете**. **Открытый** ключ держать в секрете **не нужно**, им можно делиться с кем угодно. Закрытым ключом можно расшифровать то, что зашифровано открытым, и наоборот. Асимметричное шифрование еще называют *криптосистемой с открытым ключом*.

Асимметричное шифрование – типичный ответ на задачу с передачей ключей. Его механизм показан на рисунке ниже. Допустим, Алиса хочет отправить Бобу секретные сведения с помощью криптосистемы с открытым ключом. Боб генерирует пару ключей. Закрытый ключ он оставляет себе, открытый отправляет Алисе по незащищенному каналу связи. Ева может обозревать этот канал связи – это не имеет
значения, открытый ключ на то и открытый. Алиса зашифровывает сообщение открытым ключом Боба и отправляет ему шифрованный текст по незащищенному каналу. Боб получает шифротекст и расшифровывает его закрытым ключом. Никаким другим ключом расшифровать текст не получится.
![[Pasted image 20230814131029.png]]
#### RSA

RSA – классический пример криптосистемы с открытым ключом, которая выдержала проверку временем. Она была создана в конце 70-х, ее создатели – Рон Ривест (Ron Rivest), Ади Шамир (Adi Shamir) и Леонард Адлеман (Leonard Adleman). Название алгоритму дано по первым буквам их фамилий.

Ниже показан вызов openssl, который генерирует закрытый ключ RSA длиной 3072 бита. Для этого использована команда genpkey(ключи RSA должны быть размером минимум 2048 бит).

```Shell
openssl genpkey -algorithm RSA \  # Ключ для RSA
	-out private_key.pem \        # Файл с ключом положить по этому пути
	-pkeyopt rsa_keygen_bits:3072 # Длина ключа 3072 бита
```

Обратите внимание, насколько разнятся размеры ключа для RSA и AES. Первому для обеспечения сравнимой стойкости надлежит быть куда длиннее своего симметричного собрата. Ключ AES может быть 256 бит длиной максимум, ключ RSA же такой длины просто никуда не годится. Такая разница обусловлена математическими моделями, на которых строится шифрование. RSA применяет факторизацию целых чисел, AES использует подстановочно-перестановочную сеть. В общих чертах: ключ для асимметричного шифрования всегда будет длиннее ключа для симметричного.

С помощью команды rsa утилиты openssl можно извлечь открытый ключ из файла с закрытым:

```Shell
openssl rsa -pubout -in private_key.pem -out public_key.pem
```

Пара ключей иногда хранится в файловой системе. Важно отрегулировать права доступа к этим файлам. Права на чтение и запись файла с закрытым ключом должны быть только у владельца. Открытый ключ же можно читать кому угодно. Вот как ограничить доступ к файлам ключей на UNIX-подобных системах:

```Shell
chmod 600 private_key.pem
chmod 644 public_key.pem
```

OpenSSL сохраняет ключи на диск в формате Privacy-Enhanced Mail (PEM, почта повышенной секретности). Это стандарт де-факто для представления пар ключей. Если вам уже приходилось сталкиваться с PEM-файлами раньше, вам может быть знаком заголовок, начинающийся
с -----BEGIN:

```
-----BEGIN PRIVATE KEY-----
MIIG/QIBADANBgkqhkiG9w0BAQEFAASCBucwggbjAgEAAoIBgQDJ2Psz+Ub+VKg0
vnlZmm671s5qiZigu8SsqcERPlSk4KsnnjwbibMhcRlGJgSo5Vv13SMekaj+oCTl
...
-----BEGIN PUBLIC KEY-----
MIIBojANBgkqhkiG9w0BAQEFAAOCAY8AMIIBigKCAYEAydj7M/lG/lSoNL55WZpu
u9bOaomYoLvErKnBET5UpOCrJ548G4mzIXEZRiYEqOVb9d0jHpGo/qAk5VCwfNPG
...
```

Следующий пример показывает, как зашифровать данные открытым ключом и как расшифровать закрытым. Как и симметричные блочные шифры, RSA перед зашифровкой дополняет открытый текст ничего не значащими данными.

> Рекомендуемой схемой дополнения открытого текста для шифрования алгоритмом RSA является оптимальное асимметричное шифрование с дополнением (optimal asymmetric encryption padding – OAEP).

```Python
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding

# Схема дополнения OAEP
padding_config = padding.OAEP(
	mgf=padding.MGF1(algorithm=hashes.SHA256()),
	algorithm=hashes.SHA256(),
	label=None, 
)

plaintext = b'message from Alice to Bob'

# Зашифровка открытым ключом
ciphertext = loaded_public_key.encrypt(
	plaintext=plaintext,
	padding=padding_config, 
)

# Расшифровка закрытым ключом
decrypted_by_private_key = loaded_private_key.decrypt(
	ciphertext=ciphertext,
	padding=padding_config
)

assert decrypted_by_private_key == plaintext
```

> Асимметричное шифрование работает в обе стороны. Можно зашифровать послание открытым ключом, а расшифровать закрытым. Или наоборот, можно зашифровать закрытым, а расшифровать открытым. Таким образом, мы можем быть уверены только в чем-то одном: либо в неразглашении, либо в подлинности данных. То, что зашифровано открытым ключом, может расшифровать только владелец закрытого ключа, и, следовательно, не может быть разглашено. При этом создателем содержимого может быть кто угодно. То, что зашифровано закрытым ключом, является подлинным и принадлежит руке владельца закрытого ключа, но расшифровать эти данные может кто угодно. Следовательно, данные разглашаются, но их авторство несомненно.

### 2.8.8 Цифровые подписи

Если требуется не просто проверка подлинности и целостности данных, а неопровержимость, то понадобится электронная цифровая подпись (ЭЦП). Ее применение позволяет кому угодно, а не только получателю, ответить на два вопроса: кто отправил сообщение и дошло ли оно в первозданном виде.

ЭЦП обычно производится с помощью **хеш-функции** и **зашифровки закрытым ключом**. Чтобы подписать сообщение, сначала требуется **вычислить его хеш**. Затем полученное **значение и закрытый ключ подаются на вход алгоритму асимметричного шифрования**, и на выходе получается цифровая подпись. Таким образом владелец закрытого ключа подписывает созданное им сообщение. Если
взглянуть со стороны алгоритма шифрования, то хеш – это открытый текст, а цифровая подпись – шифрованный. Сообщение и ЭЦП затем передаются вместе по сети связи.

![[Pasted image 20230814172838.png]]

Цифровая подпись не хранится в секрете, а передается в открытом виде вместе с сообщением. На этом моменте некоторые разработчики ловят когнитивный диссонанс, ведь подпись – это шифротекст, который злоумышленник без труда может расшифровать открытым ключом. В этом нет ничего страшного. **ЭЦП нужна для неопровержимости**, ведь для ее генерации был задействован закрытый ключ владельца. Она *не предназначена для неразглашения ее содержимого*. Если взломщик расшифрует подпись, то все, что он получит, – хеш содержимого и никакой личной информации.

```Python
import json
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes

message = b'from Bob to Alice'

# Схема дополнения PSS
padding_config = padding.PSS(
	mgf=padding.MGF1(hashes.SHA256()),
	salt_length=padding.PSS.MAX_LENGTH
)

# Загрузка закрытого ключа
private_key = load_rsa_private_key()

# Непосредственно подписание хеша SHA-256, высчитанного из сообщения
signature = private_key.sign(
	message,
	padding_config,
	hashes.SHA256()
)

# Сообщение для Алисы содержит изначальное послание и его ЭЦП
signed_msg = {
	'message': list(message),
	'signature': list(signature),
}

outbound_msg_to_alice = json.dumps(signed_msg)
```

> Схемы дополнения незначащими данными для подписания алгоритмом RSA и для зашифровки данных с помощью того же RSA не одинаковы. Стоит выбирать OAEP для шифрования и PSS для генерации ЭЦП. Они не взаимозаменяемы.

#### Проверка подписи, созданной криптосистемой RSA

Как только Алиса получила сообщение и ЭЦП от Боба, она:
1. вычисляет хеш сообщения;
2. расшифровывает подпись открытым ключом Боба;
3. сравнивает хеш из открытого текста подписи с вычисленным
ею ранее. Если хеши равны, то она может доверять этому посланию.
![[Pasted image 20230814174327.png]]
Все три шага заключены внутри метода verify класса RSAPublicKey. Если высчитанный хеш не совпадает с хешем из ЭЦП Боба, то метод бросит исключение InvalidSignature. Если же они совпадают, то Алиса может быть уверена в двух вещах. Первое – что никто не исказил сообщение по пути. Второе – что отправил его некто, в чьем распоряжении есть закрытый ключ Боба, и высока вероятность, что он сам.

```Python
import json
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.exceptions import InvalidSignature

def receive(inbound_msg_from_bob):
	# Получение сообщения и ЭЦП
	signed_msg = json.loads(inbound_msg_from_bob)
	message = bytes(signed_msg['message'])
	signature = bytes(signed_msg['signature'])
	# Схема дополнения PSS
	padding_config = padding.PSS(
		mgf=padding.MGF1(hashes.SHA256()),
		salt_length=padding.PSS.MAX_LENGTH)

	# Загрузка закрытого ключа
	private_key = load_rsa_private_key()
	
	try:
		# Метод verify проверяет все необходимое
		private_key.public_key().verify(
			signature,
			message,
			padding_config,
			hashes.SHA256()
		)
		print('Сообщению можно доверять')
	except InvalidSignature:
		print('Сообщению нельзя доверять')
```

> Алгоритм RSA - затратный метод подписывать данные
#### Подписание данных на базе эллиптических кривых

Как и в случае с RSA, в эллиптической криптографии тоже фигурируют пары ключей. Как и RSA, криптосистемами на основе эллиптических кривых можно подписывать данные и проверять созданную ЭЦП. Однако эллиптическая криптография не находит популярности в прикладных целях. Ее основная задача – генерация подписей, в то время как RSA используется для шифрования широкого спектра
открытых текстов. Дело в том, что эллиптические криптосистемы затрачивают меньше вычислительной мощности на создание ЭЦП, подлинность которой потом можно проверить особого вида открытым ключом даже без получения открытого текста из шифротекста. Поэтому они теперь и стали использоваться для подписания
сообщений вместо RSA.

>Эллиптическая криптография прибегает к эллиптическим кривым над конечными полями, RSA применяет факторизацию целых чисел.

Генерация подписи

```Python
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec

message = b'from Bob to Alice'

private_key = ec.generate_private_key(ec.SECP384R1(), default_backend())

signature = private_key.sign(message, ec.ECDSA(hashes.SHA256()))
```

Проверка подписи

```Python
from cryptography.exceptions import InvalidSignature

public_key = private_key.public_key()

try:
	public_key.verify(signature, message, ec.ECDSA(hashes.SHA256()))
except InvalidSignature:
	pass
```

> - хеширование позволяет убедиться в целостности данных и их подлинности;
> - шифрование обеспечивает неразглашение;
> - цифровые подписи гарантируют неопровержимость.

### 2.8.9 Transport Layer Security TLS

**Transport Layer Security (TLS)** - отвечает за целостность, подлинность и неразглашение данных, а также обеспечивает неопровержимость действий.

Разница между SSL, TLS и HTTPS - это разные вещи.

- SSL (Secure Sockets Layer, слой защищенных сокетов) – предшественник TLS, пользоваться им небезопасно.
- HTTPS ( Hypertext Transfer Protocol Secure, безопасный протокол передачи гипертекста) – просто-напросто HTTP, обернутый в SSL либо TLS.

#### Атака «человек посередине»

Человек посередине (Man-in-the-middle – MITM) – классический пример атаки. Для начала злоумышленник так или иначе вклинивается между уязвимыми точками соединения. Это может быть сегмент сети либо промежуточный узел. В зависимости от этого взломщик может избрать как пассивную(прослушивание или чтение), так и активную стратегию(изменение).

**TLS** сможет обеспечить неразглашение и проверку подлинности, и для злоумышленника разговор между двумя узлами сети будет лишь набором бессмысленных байтов. Все потому, что соединение через **TLS** будет зашифровано.

#### Процедура подтверждения связи

**`TLS`** – это клиент-серверный протокол, другими словами, точка-точка. Каждое соединение начинается с процедуры подтверждения связи(handshake). Первым «протягивает руку» всегда клиент. Суть рукопожатия сводится к трем вещам:
1. переговоры о наборе шифров;
2. обмен ключами;
3. проверка подлинности сервера.

**Переговоры о наборе шифров**

В `TLS` на практике применяются шифрование и хеширование. Чтобы установить связь, клиент и сервер для начала обязаны договориться о **взаимном использовании набора алгоритмов**. Он называется набор шифров (шифронабор, cipher suite). В каждом из них определен конкретный алгоритм хеширования и шифрования данных. В документации `TLS 1.3` указано пять наборов:
- `TLS_AES_128_CCM_8_SHA256`;
- `TLS_AES_128_CCM_SHA256`;
- `TLS_AES_128_GCM_SHA256`;
- `TLS_AES_256_GCM_SHA384`;
- `TLS_CHACHA20_POLY1305_SHA256`.

Допустим, клиент и сервер договорились использовать набор шифров `TLS_AES_128_GCM_SHA256`. Это значит, что будет использован алгоритм шифрования `AES` в режиме `GCM`, с ключом длиной `128` бит, а для вычисления хеша – `SHA-256`. `GCM` – режим для блочного шифра, славящийся скоростью.

![[Pasted image 20230815153235.png]]
`TLS` опирается на симметричное шифрование для обеспечения неразглашения потому, что оно в разы эффективнее асимметричного.

На данный момент клиент и сервер выбрали общий набор шифров. Теперь им нужно как-то поделиться друг с другом ключом от симметричного шифрования.

**Обмен ключами** 

Протокол Диффи–Хеллмана (Diffie–Hellman key exchange – DH) позволяет двум сторонам договориться об общем ключе через незащищенный канал связи, что красиво решает незадачу с передачей ключа.

В объяснении работы протокола будут участвовать клиент, сервер и злоумышленник. Клиенту и серверу потребуется сгенерировать одноразовые пары ключей, на основе которых и будет создан **общий секретный ключ**. Созданные ключевые пары будут выброшены после создания секретного ключа, это разные ключи. По мере чтения важно не запутаться, где какой. Вот упрощенный план протокола:
1. Клиент и сервер по незащищенному каналу договариваются о двух простых числах.
2. Каждый из них генерирует свой собственный закрытый ключ.
3. Каждый из них выводит индивидуальный открытый ключ из своего закрытого и двух простых чисел из шага 1.
4. Они обмениваются открытыми ключами по незащищенному каналу.
5. Теперь каждый из них на основе этих данных может вычислить одинаковый ключ, который и будет использоваться

Итак, первым делом клиент и сервер договариваются о двух числах `p` и `q`. Они передаются в открытом виде. Злоумышленник видит их, и в этом нет ничего страшного. Затем клиент генерирует закрытый ключ `a`, сервер – закрытый ключ `b`. Эти числа хранятся в секрете. Клиент прячет свое число от злоумышленника и сервера. Сервер тоже – от злоумышленника и клиента.

Клиент вычисляет открытый ключ `A` из чисел `p, q` и ее закрытого ключа `a`. Сервер тоже получает открытый ключ `B` из `p, q` и `b`. Следом они обмениваются открытыми ключами по незащищенному каналу связи. Эти числа не составляют секрета. Злоумышленник видит их, и пускай видит.

Наконец, клиент и сервер вычисляют число `K` с помощью открытого ключа, который они получили ранее друг от друга. Оно выходит одинаковым у них обоих, и оно будет использоваться в качестве общего ключа для симметричного шифрования. Про обе пары ключей и числа `p, q` можно забыть, они больше не нужны. На рис. показано, как клиент и сервер, следуя протоколу Диффи–Хеллмана, успешно вычисляют общий ключ, число 14.

![[Pasted image 20230815162756.png]]

В жизни числа, составляющие закрытые ключи, `p, K,` значительно длиннее. Именно благодаря большим числам злоумышленнику становится недостижимо вычисление закрытых ключей либо общего ключа `K`, даже с учетом того, что беседа клиента и сервера происходила у него на обозрении. Пускай ему известны `p, g` и открытые ключи, ей все равно остается только полный перебор.

> Протокол Диффи–Хеллмана решает задачу с передачей ключей эффективнее, чем асимметричное шифрование. Он использует арифметические операции с остатками чисел по фиксированному модулю и не тратит излишних вычислительных ресурсов как криптосистемы вроде RSA. Ключ на самом деле даже не передается между сторонами соединения, они оба приходят к нему путем взаимных вычислений. Но и для асимметричного шифрования осталось местечко. Оно нужно, чтобы проверить подлинность сервера.

**Проверка подлинности сервера**

Переговоры о наборе шифров и обмен ключами нужны для обеспечения неразглашения. Но кому нужна беседа с глазу на глаз непонятно с кем? Так что TLS не только хранит секреты, но и проверяет подлинность собеседника. Клиент может проверить подлинность сервера, а сервер – подлинность клиента, однако оба этих шага необязательны. Во время обыкновенного рукопожатия веб-браузера с веб-сервером обычно проверяется только подлинность сервера клиентом.

Сервер удостоверяет свою личность отправкой сертификата открытого ключа клиенту. Сертификат содержит открытый ключ сервера и доказывает, что этот ключ действительно принадлежит веб-сервису. Сертификат должен быть издан удостоверяющим центром (certificate authority – CA), специальной уполномоченной организацией.

Владелец открытого ключа отправляет запрос на подпись сертификата удостоверяющему центру. Запрос содержит данные о владельце ключа и сам открытый ключ.

![[Pasted image 20230815163347.png]]
#### Сертификат открытого ключа

Сертификат открытого ключа во многом напоминает паспорт. Для вас удостоверение личности – это паспорт, для сервера – подобный сертификат. Паспорт выдан вам государственным органом, сертификат выдан владельцу ключа удостоверяющим центром. Полицейский с пристрастием проверяет паспорт, чтобы понять, внушаете ли вы доверие. Браузер либо любой другой TLS-клиент с пристрастием проверяет сертификат, чтобы понять, внушает ли сервер доверие. Как и у паспорта, у сертификата есть срок, после которого он станет недействительным.

Структура сертификата открытого ключа определена в стандарте безопасности X.509.

Стандарт X.509 служит для обеспечения совместимости: чтобы любой сервер мог
представиться любому клиенту во время рукопожатия TLS, а любой клиент умел проверять личность любого сервера.

Сертификат стандарта X.509 состоит из определенного набора полей. Давайте поставим себя на место веб-браузера, чтобы досконально понять, как он проверяет подлинность сервера. Выведем с помощью утилиты openssl поля сертификата в удобочитаемом виде:

```Shell
openssl x509 -inform der -noout -text -in 'test.cer' | less
```

Браузер сначала преобразует сертификат в набор полей, пристально проверит каждое, и только если все в порядке – будет доверять серверу. Рассмотрим некоторые важные поля:
- субъект;
- издатель;
- открытый ключ субъекта;
- срок действия сертификата;
- подпись удостоверяющего центра.

Сертификат, как паспорт, подтверждает личность владельца. Хозяин ключа упоминается в поле субъект. Самое важное с точки зрения браузера свойство, которое хранится в этом поле, – это CN (common name). В нем перечислены доменные имена, которые может удостоверять этот сертификат. Браузер отвергнет сертификат, если домена из адресной строки нет среди имен, перечисленных в CN. Таким образом, сервер не пройдет проверку, и рукопожатие закончится неудачей.

```
Subject: CN=*.wikipedia.org
```

Как и в паспорте, в сертификате указывается, кем он выдан. Удостоверяющий центр, который выдал сертификат Википедии, – Let’s Encrypt. Это некоммерческая организация, выдающая сертификаты автоматически и бесплатно. Взглянем на поле «издатель» сертификата Википедии.

```
Issuer: C=US, O=Let's Encrypt, CN=Let's Encrypt Authority X3
```

Разумеется, любой сертификат открытого ключа содержит открытый ключ владельца. Вот ключ Википедии. Он основан на эллиптической криптографии, его длина 256 бит.

```
Subject Public Key Info:
	Public Key Algorithm: id-ecPublicKey  # Ключ на основе эллиптических кривых
		Public-Key: (256 bit)  # Длина 256 бит
			pub:
				# Сам ключ в шестнадцатеричной форме
				04:6a:e9:9d:aa:68:8e:18:06:f4:b3:cf:21:89:f2:
				b3:82:7c:3d:f5:2e:22:e6:86:01:e2:f3:1a:1f:9a:
				ba:22:91:fd:94:42:82:04:53:33:cc:28:75:b4:33:
				84:a9:83:ed:81:35:11:77:33:06:b0:ec:c8:cb:fa:
				a3:51:9c:ad:dc
```

Как и у паспорта, у сертификата есть срок действия. Сертификат недействителен, если период действия истек или еще не наступил. Браузер не станет подключаться к такому серверу.

```
Validity
	Not Before: Jan 29 22:01:08 2020 GMT
	Not After : Apr 22 22:01:08 2020 GMT
```

Внизу каждого сертификата под полем «алгоритм подписи» можно обнаружить ЭЦП
Давайте разберемся, кто и что подписал. В данном случае удостоверяющий центр, Let’s Encrypt, подписал открытый ключ владельца сертификата – тот самый ключ, который указан в сертификате. Взглянем на листинг ниже. Сначала был вычислен хеш SHA-256 открытого ключа Википедии. Затем организация Let’s Encrypt своим закрытым ключом зашифровала хеш криптосистемой RSA – в результате получилась цифровая подпись удостоверяющего центра.

```
# Центр Let’s Encrypt для подписи применил SHA-256 и RSA
Signature Algorithm: sha256WithRSAEncryption
	# Цифровая подпись в шестнадцатеричном виде
	4c:a4:5c:e7:9d:fa:a0:6a:ee:8f:47:3e:e2:d7:94:86:9e:46:
	95:21:8a:28:77:3c:19:c6:7a:25:81:ae:03:0c:54:6f:ea:52:
	61:7d:94:c8:03:15:48:62:07:bd:e5:99:72:b1:13:2c:02:5e:
```

На рис. изображены первостепенные данные сертификата открытого ключа Википедии.

![[Pasted image 20230815165906.png]]

Браузер проверит подпись Let’s Encrypt и отвергнет сертификат, если она неверна. Таким образом, процедура подтверждения связи оборвется. Если же подпись корректна, то браузер призна́ет сертификат, и рукопожатие успешно завершится. Затем обмен данными будет уже происходить через симметричное шифрование по алгоритмам выбранного набора шифров. Содержимое будет зашифровано общим ключом.

## 2.9 Тестирование (Testing)

### 2.9.0 Уровни тестирования

Тестирование выполняется на различных уровнях в зависимости от типа приложения,
уровня его сложности и роли команды, работающей над приложением. К разным
уровням тестирования относятся:
- модульное тестирование;
- интеграционное тестирование;
- системное тестирование;
- приемочное тестирование.

Эти уровни применяются в следующем порядке:
![[Pasted image 20231212172433.png]]

**Модульное тестирование**

Это тип тестирования, ориентированный на наименьший возможный блок кода
(модуль). Им может быть функция в модуле, метод в классе или модуль в приложении. Такой тест изолированно выполняет один блок кода и проверяет, что тот работает должным образом. Это помогает обнаруживать ошибки на ранней стадии разработки и исправлять их. В Python модульные тесты обычно нацелены на отдельные классы или модули без использования зависимостей.

Тесты пишутся непосредственно разработчиками и могут выполняться в любое
время. Это своего рода тестирование методом белого ящика (**White-box Testing**).
Для этого в Python есть несколько библиотек и инструментов: `pyunit` (`unittest`),
`pytest`, `doctest`, `nose` и некоторые другие.

**Интеграционное тестирование**

Это совместное тестирование отдельных модулей программы в группе на взаимодействие между собой и корректный обмен данными. 

Интеграционное тестирование обычно проводится тестировщиками, а не разработчиками и выполняется после модульного тестирования. Основное внимание уделяется выявлению проблем интеграции, когда различные модули и функции используются вместе. Иногда для тестирования требуются внешние ресурсы или данные, которые недоступны в среде разработки. Тогда на помощь приходит фиктивное тестирование (**Mock Testing**), которое обеспечивает замену внешним и внутренним зависимостям. Фиктивные объекты (или `mосk-объекты`) имитируют поведение реальных зависимостей. Примерами служат отправка электронного письма или оплата кредитной картой. 

Это своего рода тестирование методом черного ящика (**Black-box Testing**). Используемые библиотеки и инструменты почти такие же, как в модульном тестировании, с той лишь разницей, что границы тестов расширяются и включают несколько модулей в один тест.

**Системное тестирование**

Границы системного тестирования расширяются до уровня системы. Это может
быть полноценный модуль или приложение. Здесь проверяется функциональность с
точки зрения сквозного тестирования (`End-to-End`, `Е2Е`), то есть от начала и до
конца.

Системные тесты также разрабатываются тестировщиками, но уже после завершения
процесса интеграционного тестирования. Можно сказать, что интеграционное
тестирование является необходимым условием системного тестирования, иначе
придется делать много лишних действий. На данном этапе можно выявить потенциальные проблемы, но не наверняка определить их местоположение.

Системное тестирование также относится к типу тестирования методом черного
ящика и может использовать те же библиотеки, что и интеграционное

**Приемочное тестирование**

Приемочное тестирование выполняется реальным пользователем перед приемкой
программы для повседневного использования .. Оно также известно, как `UAT-тестирование` (User Acceptance Testing). Обычно для таких тестов не применяют
автоматизацию, но ее стоит использовать в ситуациях, когда пользователям приходится взаимодействовать с продуктом через API

Вы также могли слышать про **альфа-** и **бета-тестирование**, которые выполняются
на уровне пользователей и не автоматизируются. Альфа-тестирование выполняется
разработчиками и другим персоналом для имитации реального поведения пользователей. Бета-тестирование выполняется клиентами или настоящими пользователями для получения обратной связи о продукте, прежде чем он будет выпущен в общий доступ.
Кроме того, существует **регрессионное** тестирование. Оно выполняется всякий раз,
когда вносятся изменения в исходный код или любые внешние и внутренние зависимости. Эта практика гарантирует, что продукт работает так же, как и до внесения изменений. Поскольку регрессионное тестирование повторяется многократно, его автоматизация необходима.

**Работа с тестовыми фреймворками Python**

Прежде чем начать писать тесты, сначала важно понять, что это такое. В контексте
мы будем определять тест-кейс, как **способ проверки результатов определенного поведения кода в соответствии с ожидаемыми результатами**.

Разработку тестов можно разделить на четыре этапа:

1. **Подготовка**: на этом этапе мы подготавливаем среду для тестов. Здесь не выполняется никаких действий или проверок. В сообществе этот этап известен как подготовка тестовых фикстур (Test Fixture) - приспособлений для проверки.
2. **Действие**: здесь мы запускаем тестируемую систему. Этап действия приводит к изменениям системы. А измененное состояние - это именно то, что мы хотим оценить в рамках тестирования. Обратите внимание, здесь мы по-прежнему ничего не проверяем.
3. **Проверка**: здесь мы оцениваем результаты предыдущего этапа и сравниваем их с ожидаемыми результатами. На основе этого тест-кейс помечается как успешный или неудачный. В большинстве инструментов проверка достигается с помощью встроенных функций или операторов `assert`.
4. Очистка: на этом этапе среда очищается. Нужно убедиться, что внесенные изменения на этапе действия не влияют на другие тесты.

Ключевые этапы - **действие** и **проверка**. Подготовка и очистка являются необязательными, но настоятельно рекомендуются.

### 2.9.1 Разработка через тестирование

Разработка через тестирование (`Test-driven development`, `TDD`) - хорошо известная
практика в разработке ПО, при которой мы сначала пишем тесты, а затем код для необходимой функции в приложении. Подход имеет три простых правила:
- Не стоит писать какой-либо функциональный код, пока модульные тесты для него завершаются неудачей.
- Не стоит в том же тесте писать кода больше, чем необходимо для неудачного результата.
- Не стоит писать функционального кода больше, чем необходимо для прохождения неудачного теста.

Эти правила заставляют нас следовать известному трёхэтапному подходу к разработке ПО, который носит название «Красный, Зеленый, Рефакторинг» (Red, Green, Refactor). Эти этапы повторяются непрерывно.

**Красный**

На этом этапе мы пишем тест без какого-либо кода, который нужно проверить.
Очевидно, что в этом случае тест завершится неудачей. Мы не будем пытаться писать
полный тестовый сценарий, а только достаточное количество кода для провала теста.

**Зеленый**

На этом этапе мы пишем код, пока не сможем пройти тест. Опять же, количество
кода не должно превышать необходимый минимум для прохождения теста. После
мы запускаем все тесты с целью убедиться, что ранее написанные кейсы тоже завершаются успехом.

**Рефакторинг**

На этом этапе мы повышаем качество кода, а именно, облегчаем его чтение и оптимизируем использование, например, весь жесткий код (Hardcode) должен быть
удален. Также рекомендуется запускать тесты после каждого цикла рефакторинга,
результатом которого является чистый код. Можно повторять этот цикл, добавляя
все больше тестовых сценариев и нового кода, пока не будет разработан весь функционал.

Важно понимать, что `TDD` не является ни подходом к тестированию, ни подходом к
проектированию. Это **подход к разработке ПО в соответствии со спецификациями**,
которые определены написанием тестов в первую очередь.

![[Pasted image 20231213125834.png]]

### 2.9.2 Автоматизированная непрерывная интеграция

Непрерывная интеграция (`continuous integration`, `CI`) - это процесс, который сочетает преимущества автоматизированного тестирования и систем контроля версий для обеспечения полностью автоматизированной среды интеграции. Этот подход подразумевает внедрение кода в общий репозиторий. При каждом добавлении кода в репозиторий ожидается, что будут запущены следующие два процесса:
- Автоматизированный процесс сборки для подтверждения, что новый код ничего не нарушает с точки зрения компиляции или синтаксиса.
- Автоматизированное выполнение тестов для проверки, что действующий и новый функционал соответствуют определенным тестам.

Различные шаги и этапы CI показаны на схеме ниже. Несмотря на наличие на схеме
фазы сборки, для проектов Python она необязательна, поскольку можно выполнять
интеграционные тесты без скомпилированного кода

![[Pasted image 20231213130059.png]]

Для создания `СI`-системы требуется стабильный распределенный контроль версий и инструмент, с помощью которого можно реализовать рабочий поток для тестирования целого приложения через серию наборов тестов. Существует несколько коммерческих и свободных решений для непрерывной интеграции и непрерывной доставки(`CD`). Эти инструменты предназначены для простой интеграции с системой контроля версий и фреймворком автоматизации тестирования. Популярные инструменты для `CI`: `Jenkins`, `Bamboo`, `Buildbot`, `GitLab CI`, `CircleCI` и `Buddy`.

Очевидные преимущества автоматизированного `CI` заключаются в быстром обнаружении ошибок и в их удобном и максимально быстром исправлении. Важно понимать, что `CI` предназначена не для исправления ошибок, но определенно помогает их легко выявлять и оперативно исправлять.
### 2.9.1 Основы работы с `Pytest`

Это тест:

```Python
import pytest


def test_passing():
    assert (1, 2, 3) == (1, 2, 3)
```

Вот как это выглядит при запуске:

```Shell
pytest ch1\test_one.py
=========================== test session starts =============================
platform win32 -- Python 3.8.6, pytest-7.1.2, pluggy-1.0.0
rootdir: C:\Users\092NekrasovAB\Documents\python\testing
plugins: cov-3.0.0
collected 1 item                                                                        
ch1\test_one.py .                                                                                                                                               [100%]
============================ 1 passed in 0.49s ==============================
```

Точка после `test_one.py` означает, что один тест был запущен, и он прошел. Если вам нужна дополнительная информация, вы можете использовать `-v` или же `--verbose`:

```Shell
pytest -v ch1\test_one.py
============================ test session starts =============================
platform win32 -- Python 3.8.6, pytest-7.1.2, pluggy-1.0.0 -- c:\users\092nekrasovab\appdata\local\programs\python\python38\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\092NekrasovAB\Documents\python\testing
plugins: cov-3.0.0
collected 1 item                                                                        
ch1/test_one.py::test_passing PASSED                                                                                                                            [100%]
============================= 1 passed in 0.04s ==============================
```

Это неудачный тест:

```Python
import pytest


def test_failing():
    assert (1, 2, 3) == (3, 2, 1)
```

То, как `pytest` показывает сбои при тестирование, является одной из многих причин, почему разработчики любят `pytest`.

```Shell
pytest ch1\test_one.py
```

```Shell
============================ test session starts =============================
platform win32 -- Python 3.8.6, pytest-7.1.2, pluggy-1.0.0
rootdir: C:\Users\092NekrasovAB\Documents\python\testing
plugins: cov-3.0.0
collected 2 items                                                                       
ch1\test_one.py .F                                                                                                                                              [100%]
================================== FAILURES ==================================
________________________________ test_failing ________________________________

    def test_failing():
>       assert (1, 2, 3) == (3, 2, 1)
E       assert (1, 2, 3) == (3, 2, 1)
E         At index 0 diff: 1 != 3
E         Use -v to get more diff

ch1\test_one.py:9: AssertionError
========================== short test summary info ===========================
FAILED ch1/test_one.py::test_failing - assert (1, 2, 3) == (3, 2, 1)
======================== 1 failed, 1 passed in 0.88s =========================
```

И `pytest` точно сообщает, что первый сбой в кортеже по индексу `0` — не совпадает. Но мы можем посмотреть более подробно:

```Shell
pytest -v ch1\test_one.py
```

```Shell
============================ test session starts =============================
platform win32 -- Python 3.8.6, pytest-7.1.2, pluggy-1.0.0 -- c:\users\092nekrasovab\appdata\local\programs\python\python38\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\092NekrasovAB\Documents\python\testing
plugins: cov-3.0.0
collected 2 items                                                                       
ch1/test_one.py::test_passing PASSED                                                        [ 50%]
ch1/test_one.py::test_failing FAILED                                                        [100%]

================================== FAILURES ==================================
________________________________ test_failing ________________________________

    def test_failing():
>       assert (1, 2, 3) == (3, 2, 1)
E       assert (1, 2, 3) == (3, 2, 1)
E         At index 0 diff: 1 != 3
E         Full diff:
E         - (3, 2, 1)
E         ?  ^     ^
E         + (1, 2, 3)
E         ?  ^     ^

ch1\test_one.py:9: AssertionError
========================== short test summary info ===========================
FAILED ch1/test_one.py::test_failing - assert (1, 2, 3) == (3, 2, 1)
======================== 1 failed, 1 passed in 0.54s =========================
```

`pytest` добавляет символ `"карет" (^)`, чтобы показать нам в чем именно отличие.

Одно из полезных применений тестов программного обеспечения-это проверка ваших предположений о том, как работает тестируемое программное обеспечение, что может включать в себя тестирование вашего понимания сторонних модулей и пакетов и даже построение структур данных Python.

##### Установка `Pytest`

Как и другие пакеты Python, распространяемые через `PyPI`, используйте `pip` для установки `pytest` в виртуальную среду, используемую для тестирования:

```Shell
pip install pytest
```

##### Запускаем `pytest`

Для примера, создадим подкаталог, называемый `tasks`, и начнем тестировать код:

```Python
"""Проверим тип данных Task."""

from collections import namedtuple


Task = namedtuple('Task', ['summary', 'owner', 'done', 'id'])
Task.__new__.__defaults__ = (None, None, False, None)


def test_defaults():
    """Без использования параметров, следует ссылаться на значения по умолчанию."""
    t1 = Task()
    t2 = Task(None, None, False, None)
    assert t1 == t2


def test_member_access():
    """Проверка свойства .field (поля) namedtuple."""
    t = Task('buy milk', 'brian')
    assert t.summary == 'buy milk'
    assert t.owner == 'brian'
    assert (t.done, t.id) == (False, None)
```

Вы можете использовать `__new __.__ defaults__` для создания объектов `Task` без указания всех полей. 

Тест `test_defaults()` предназначен для демонстрации и проверки того, как вызов `Task` работает по умолчанию.

Тест `test_member_access()` должен продемонстрировать, как обращаться к членам по имени, а не по индексу, что является одной из основных причин использования `namedtuples`.  
Давайте добавим еще пару тестов во второй файл, чтобы продемонстрировать функции `_asdict()` и `_replace()`

```Python
def test_asdict():
    """_asdict() должен возвращать словарь."""
    t_task = Task('do something', 'okken', True, 21)
    t_dict = t_task._asdict()
    expected = {'summary': 'do something',
                'owner': 'okken',
                'done': True,
                'id': 21}
    assert t_dict == expected

def test_replace():
    """должно изменить переданное в fields."""
    t_before = Task('finish book', 'brian', False)
    t_after = t_before._replace(id=10, done=True)
    t_expected = Task('finish book', 'brian', True, 10)
    assert t_after == t_expected
```

Для запуска `pytest` у вас есть возможность указать файлы и каталоги. Если вы не укажете какие-либо файлы или каталоги, `pytest` будет искать тесты в текущем рабочем каталоге и подкаталогах. Он ищет файлы, начинающиеся с `test_` или заканчивающиеся на `_test`. Eсли вы запустите `pytest` из каталога, без команд, вы проведете тесты для всех файлов. Чтобы выполнить только новые тесты, вы можете предоставить `pytest` все имена файлов, которые вы хотите запустить, или каталог, или вызвать `pytest` из каталога, где находятся тесты

```Shell
pytest tasks/test_two.py
```

Ниже приведен краткий обзор соглашений об именах, чтобы ваш тестовый код можно было обнаружить с помощью `pytest`:
- Тестовые файлы должны быть названы `test_<something>.py` или `<something>_test.py`.
- Методы и функции тестирования должны быть названы `test_<something>`.
- Тестовые классы должны быть названы `Test<Something>`.

Давайте более подробно рассмотрим результат запуска только одного файла:

```Shell
============================ test session starts =============================
platform win32 -- Python 3.8.6, pytest-7.1.2, pluggy-1.0.0
rootdir: C:\Users\092NekrasovAB\Documents\python\testing
plugins: cov-3.0.0
collected 4 items                                                                       
ch1\test_two.py ....                                                                                                                                            [100%]
============================= 4 passed in 0.04s ==============================
```

Результат говорит нам совсем немного.

```Shell
============================ test session starts =============================
```

`pytest` предоставляет изящный разделитель для начала тестового сеанса. Сеанс-это один вызов `pytest`, включая все тесты, выполняемые в нескольких каталогах.

Далее идет информация об окружении(версии ОС, Python и `pytest`, а также зависимости пакетов `pytest`.):

```Shell
platform win32 -- Python 3.8.6, pytest-7.1.2, pluggy-1.0.0
```

```
rootdir: C:\Users\092NekrasovAB\Documents\python\testing
```

`rootdir` — это самый верхний общий каталог для всех каталогов в которых ищется тестовый код. В `inifile` (здесь отсутствует) перечислены используемые файлы конфигурации. Конфигурационными файлами могут быть `pytest.ini`, `tox.ini` или `setup.cfg`.

```Shell
collected 4 items
```

Это четыре тестовые функции в файле.

```Shell
ch1\test_two.py ....
```

`test_two.py` показывает тестируемый файл. Для каждого тестового файла есть одна строка. Четыре точки означают, что тесты пройдены — по одной точке для каждой тестовой функции или метода. Точки предназначены только для прохождения тестов. **Failures (сбои), errors (ошибки), skips (пропуски), xfails, и xpasses** обозначаются: **F, E, s, x, и Х**, соответственно. Если вы хотите видеть больше информации о прохождения тестов, используйте опцию `-v` или `--verbose`.

```Shell
============================= 4 passed in 0.04s ==============================
```

Эта строка относится к числу пройденных тестов и времени, затраченному на весь сеанс тестирования. При наличии не пройденных тестов здесь также будет указана информация.

Результат теста-это основной способ, благодаря которому пользователь, выполняющий тест или просматривающий результаты, может понять, что произошло в ходе выполнения теста. В `pytest` тестовые функции могут иметь несколько различных результатов, а не просто пройти или не пройти. Вот возможные результаты тестовой функции:
- **PASSED** (`.`): Тест выполнен успешно.
- **FAILED** (`F`): Тест не выполнен успешно (или XPASS + strict).
- **SKIPPED** (`s`): Тест был пропущен. Вы можете заставить `pytest` пропустить тест, используя декораторы `@pytest.mark.skip()` или `pytest.mark.skipif()`
- **xfail** (`x`): Тест не должен был пройти, был запущен и провалился. Вы можете принудительно указать `pytest`, что тест должен завершиться неудачей, используя декоратор `@pytest.mark.xfail()`.
- **XPASS** (`X`): Тест не должен был пройти, был запущен и прошел!
- **ERROR** (`E`): Исключение произошло за пределами функции тестирования, либо в фикстуре,  или в hook function

##### Выполнение Только Одного Теста

Чтобы запустить только один тест, укажите файл напрямую и добавьте имя тестовой функции `::test_name`:

```Shell
pytest tasks\test_two.py::test_member_access
```

##### Использование Опций 

Мы уже пару раз использовали опцию verbose, `-v` или `--verbose`, но есть еще много опций, о которых стоит знать. Ознакомиться с полным списком вы можете с помощью опции `pytest` `--help`.

- `--collect-only` - Параметр показывает, какие тесты будут выполняться с заданными параметрами и конфигурацией. 

```Shell
pytest --collect-only
```

```Shell
<Module ch1/test_one.py>
  <Function test_passing>
  <Function test_failing>
<Module ch1/test_two.py>
  <Function test_defaults>
  <Function test_member_access>
  <Function test_asdict>
  <Function test_replace>
```

- `-k EXPRESSION` - Параметр `-k` позволяет использовать выражение для определения функций тестирования. Её можно использовать как ярлык для запуска отдельного теста, если имя уникально, или запустить для набора тестов, которые имеют общий префикс или суффикс в их именах. Предположим, вы хотите запустить тесты `test_asdict()` и `test_defaults()`. Вы можете проверить фильтр с помощью: `--collect-only`:

```Shell
pytest -k "asdict or defaults" --collect-only
```

```Shell
<Module ch1/test_two.py>
  <Function test_defaults>
  <Function test_asdict>
```

Это похоже на то, что нам надо. Теперь вы можете запустить их, удалив `--collect-only`:

```Shell
pytest -v -k "asdict or defaults"
```

```Shell
=========================== test session starts =============================
platform win32 -- Python 3.8.6, pytest-7.1.2, pluggy-1.0.0 -- c:\users\092nekrasovab\appdata\local\programs\python\python38\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\092NekrasovAB\Documents\python\testing
plugins: cov-3.0.0
collected 6 items / 4 deselected / 2 selected                                                     
ch1/test_two.py::test_defaults PASSED                                  [ 50%]
ch1/test_two.py::test_asdict PASSED                                    [100%]

===================== 2 passed, 4 deselected in 0.04s =======================
```

- `-m MARKEXPR` - Маркеры-один из лучших способов пометить подмножество тестовых функций для совместного запуска. В качестве примера, один из способов запустить `test_replace()` и `test_member_access()`, даже если они находятся в отдельных файлах, это пометить их. Можно использовать любое имя маркера. Допустим, вы хотите использовать `run_these_please`. Отметим тесты, используя декоратор `@pytest.mark.run_these_please`, вот так:

```Python
import pytest
...
@pytest.mark.run_these_please
def test_member_access():
...
@pytest.mark.run_these_please
def test_replace():
...
```

Теперь вы можете запустить все тесты с тем же маркером с помощью `pytest -m run_these_please`:

```Shell
pytest -v -m run_these_please
```

```Shell
collected 6 items / 4 deselected / 2 selected                                           
ch1/test_two.py::test_member_access PASSED                                 [ 50%]
ch1/test_two.py::test_replace PASSED                                       [100%]
```

- `-x, --exitfirst` - прерывает тестовую сессию после первого сбойного теста

```Shell
pytest -x
```

без этого параметра `pytest` при ошибочном тесте продолжит выполнение тестовой сесии

- `--maxfail=num` - Параметр `-x` приводит к остановке после первого отказа теста. Если вы хотите, чтобы некоторые число сбоев было допущено, но не целая тонна, используйте параметр `--maxfail`, чтобы указать, сколько ошибок допускается получить. 

```Shell
pytest --maxfail=2
```

- `-lf, --last-failed` - запустится последний проваленный тест

```Shell
pytest --lf
```

- `-v, --verbose` - предоставляет более развернутую информацию по итогам. Наиболее очевидным отличием является то, что каждый тест получает свою собственную строку, а имя теста и результат прописываются вместо точки.

- `-q, --quiet` - противоположна `-v/--verbose`; она сокращает объем информации в отчете.

- `-l, --showlocals` - При использовании параметра локальные переменные и их значения отображаются вместе с tracebacks для неудачных тестов.

- `--tb=style` - Параметр изменяет способ вывода пакетов трассировки для сбоев. При сбое теста `pytest` отображает список сбоев и так называемую обратную трассировку, которая показывает точную строку, в которой произошел сбой. Хотя tracebacks полезны большую часть времени, бывают случаи, когда они раздражают. Вот где опция `--tb=style` пригодится. Стили, которые я считаю полезными, это `short`, `line` и `no`. `short` печатает только строку assert и символ `E` без контекста; `line` сохраняет ошибку в одной строке; `no` полностью удаляет трассировку.

- `--durations=N` - Опция полезна, когда вы пытаетесь ускорить свой набор тестов. Она  сообщает самый медленный `N` номер по окончании тестов. Если вы передадите `--durations=0`, он сообщит обо всем в порядке от самого медленного к самому быстрому.

**Создание тестов с маркерами `pytest`**

Фреймворк `pytest` оснащен маркерами, которые позволяют прикреплять метаданные или определять категории для наших тестов. Метаданные могут использоваться для многих целей, например, для включения или исключения определенных тестовых сценариев. Маркеры реализуются с помощью декоратора `@pytest.mark`.

В `pytest` есть несколько встроенных маркеров, самые популярные из них представлены ниже:

- `skip`: при использовании этого маркера исполнитель тестов пропустит сценарий при любых условиях;
- `skipif`: тест может быть пропущен в зависимости от условного выражения, которое передается этому маркеру как аргумент;
- `xfail`: ожидаемое неудачное завершение тестового случая будет проигнорировано; используется с определенным условием;
- `parametrize`: используется для выполнения нескольких вызовов тестового сценария с разными значениями аргументов.

```Python
@pytest.mark.skip
def test_ addl( ):
	"""тест для проверки двух положительных чисел"""
	assert add(lO, 5) == 15
	
@pytest.mark .skipif(sys.version_info > (3,6), \
reason=" skipped for release > than Python 3.6")
def test_add2 ():
	"""тест для проверки двух положительных чисел"""
	assert add(lO, -5) == 5, "should Ье 5"
	
@pytest.mark.xfail(sys.platform == "win32", \
reason= "ignore exception for windows")
def test_add3 ():
	"""тест для проверки двух положительных чисел"""
	assert add(-10, 5) == -5
	raise Exception()
```

Первый тест будет проигнорирован, так как мы использовали для него маркер `skip`
без указания дополнительных условий. Для второго теста мы использовали маркер
`skipif` с условием, что версия Python должна быть выше `3.6`. Для последнего теста
мы намеренно вызвали исключение и использовали маркер `xfail`. Этот тип исключения будет проигнорирован, если операционной системой является Windows.

**Создание тестов с параметризацией**

Часто возникает необходимость запустить один и тот же тест, изменив входные данные. В классическом подходе мы выполняем несколько сценариев, которые отличаются только входными данными.

Рекомендуемым подходом в таких ситуациях является тестирование
на основе данных (`Data-driven Testing`, `DDT`), при котором тестовые данные
предоставляются через словари или таблицы (`tаblе` или `spreadsheet`). Такой подход
также носит название *табличное тестирование* или *параметризированное тестирование*. Данные, предоставленные через таблицу или словарь, используются для выполнения тестов с помощью стандартной реализации исходного кода теста. Такой подход удобен в сценариях, когда нужно протестировать функционал, используя перестановку входных параметров. Вместо создания тестов для каждой перестановки мы можем предоставить их в формате таблицы или словаря и использовать в качестве входных данных для нашего единственного тестового примера. Фреймворки, вроде `pytest`, будут выполнять тест столько раз, сколько перестановок содержится в таблице или словаре. Примером может служить поведение функции авторизации, в которую подставляется множество допустимых и недопустимых учетных данных пользователей.

В `pytest` тестирование на основе данных можно реализовать, используя параметризацию с помощью маркера. Маркером `parametrize` можно определить, какой входной аргумент надо передать, а также набор тестовых данных, который нужно использовать. Фреймворк `pytest` автоматически выполнит тест множество раз в соответствии с количеством записей в тестовых данных, предоставленных маркером `parametrize`.

```Python
import sys

import pytest
from mypytest.src.myaddЗ import add

@pytest.mark.parametrize ("х,у,ans", [(10, 5, 15), (10,-5, 5), (-10,5,-5), (-10,-5,-15)], ids=["pos-pos","pos-neg", "neg-pos", "neg-neg"])
def test_add(x, у, ans}:
	"""тест для проверки двух положительных чисел"""
	assert add(x, у} == ans
```

Для маркера `parametrize` мы указали три параметра, которые можно описать следующим образом:
- Аргументы для тест-кейса: мы предоставили список аргументов, которые должны быть переданы в тестовую функцию в порядке, определенном в ней; тестовые данные, которые необходимо указать в следующем аргументе, также должны следовать в этом порядке.
- Данные: тестовые данные представлены в виде списка различных наборов входных аргументов; количество записей в данных будет определять, сколько раз выполнится тест.
- `ids`: это необязательный параметр, прикрепляющий дружественный тег к тестовым наборам, которые мы указали в предыдущем аргументе; эти теги-идентификаторы (ID) будут использоваться в выходном отчете для идентификации различных исполнений тестового сценария.

Консольный вывод будет следующим:
```Python
test_myadd5.py::test_add[pos-pos] PASSED [ 25%]
test_myadd5.ру::test_add[pos-neq] PASSED [ 50%]
test_myadd5.py::test_add[neq-pos] PASSED [ 75%]
test_myadd5.py::test_add[neq-neq] PASSED [100%]
====== 4 passed in О. 04s =======
```
### 2.9.2 Написание тестовых функций

##### Использование операторов assert

Когда вы пишете тестовые функции, обычный оператор Python-а `assert` является вашим основным инструментом для сообщения о сбое теста. Простота этого в `pytest` блестящая. Это то, что заставляет многих разработчиков использовать `pytest` поверх других фреймворков.

|**pytest**|**unittest**|
|---|---|
|assert something|assertTrue(something)|
|assert a == b|assertEqual(a, b)|
|assert a <= b|assertLessEqual(a, b)|

`pytest` включает функцию, называемую **assert rewriting**, которая перехватывает `assert` calls и заменяет их тем, что может рассказать вам больше о том, почему ваши утверждения не удались.

```Python
def test_task_equality():
    """Разные задачи не должны быть равными."""
    t1 = Task('sit there', 'brian')
    t2 = Task('do something', 'okken')
    assert t1 == t2

def test_dict_equality():
    """Различные задачи, сравниваемые как dicts, не должны быть равны."""
    t1_dict = Task('make sandwich', 'okken')._asdict()
    t2_dict = Task('make sandwich', 'okkem')._asdict()
    assert t1_dict == t2_dict
```

Все эти тесты терпят неудачу, но интересна информация в трассировке

```Shell
================================== FAILURES ==================================
_____________________________ test_task_equality _____________________________

    def test_task_equality():
        """Разные задачи не должны быть равными."""
        t1 = Task('sit there', 'brian')
        t2 = Task('do something', 'okken')
>       assert t1 == t2
E       AssertionError: assert Task(summary=...alse, id=None) == Task(summary=...alse, id=None)
E         
E         Omitting 2 identical items, use -vv to show
E         Differing attributes:
E         ['summary', 'owner']
E         
E         Drill down into differing attribute summary:
E           summary: 'sit there' != 'do something'...
E         
E         ...Full output truncated (9 lines hidden), use '-vv' to show

ch1\test_two.py:51: AssertionError
```

 Для каждого неудачного теста точная строка ошибки отображается с помощью `>` указателя. Строки c указателем `E` показывают дополнительную информацию о сбое `assert`, чтобы помочь вам понять, что пошло не так.

Если использовать параметр `-vv` как указанно в выводе, то получим ещё более полную трассировку:

```Shell
================================== FAILURES ==================================
_____________________________ test_task_equality _____________________________

    def test_task_equality():
        """Разные задачи не должны быть равными."""
        t1 = Task('sit there', 'brian')
        t2 = Task('do something', 'okken')
>       assert t1 == t2
E       AssertionError: assert Task(summary='sit there', owner='brian', done=False, id=None) == Task(summary='do something', owner='okken', done=False, id=None)
E         
E         Matching attributes:
E         ['done', 'id']
E         Differing attributes:
E         ['summary', 'owner']
E         
E         Drill down into differing attribute summary:
E           summary: 'sit there' != 'do something'
E           - do something
E           + sit there
E         
E         Drill down into differing attribute owner:
E           owner: 'brian' != 'okken'
E           - okken
E           + brian
E         Full diff:
E         - Task(summary='do something', owner='okken', done=False, id=None)
E         ?               --- ^^^  ^^^          ^^^^
E         + Task(summary='sit there', owner='brian', done=False, id=None)
E         ?                ^^^  ^^^          ^^^^

ch1\test_two.py:51: AssertionError
```

`pytest` не только смог найти оба различия, но и показал нам, где именно эти различия.

##### Ожидание Исключений (expected exception)

```Python
def test_start_tasks_db_raises():
    with pytest.raises(ValueError) as excinfo:
        tasks.start_tasks_db('some/great/path', 'mysql')
    exception_msg = excinfo.value.args[0]
    assert exception_msg == "db_type must be a 'tiny' or 'mongo'"
```

##### Параметризованное тестирование

Передача отдельных значений через функцию и проверка выходных данных, чтобы убедиться в их правильности, является распространенным явлением в тестировании программного обеспечения. Однако единичного вызова функции с одним набором значений и одной проверкой правильности недостаточно для полной проверки большинства функций. Параметризованное тестирование-это способ отправить несколько наборов данных через один и тот же тест и иметь отчет `pytest`, если какой-либо из наборов не удался.

Чтобы помочь понять проблему, которую пытается решить параметризованное тестирование, давайте возьмем простой тест для `add()`

```Python
def test_add_1():
    """tasks.get () использует id, возвращаемый из add() works."""
    task = Task('breathe', 'BRIAN', True)
    task_id = tasks.add(task)
    t_from_db = tasks.get(task_id)
    # все, кроме идентификатора, должно быть одинаковым
    assert equivalent(t_from_db, task)

def equivalent(t1, t2):
    """Проверяет эквивалентность двух задач."""
    # Сравнить все, кроме поля id
    return ((t1.summary == t2.summary) and
            (t1.owner == t2.owner) and
            (t1.done == t2.done))
```

Тест кажется допустимым. Тем не менее, это просто проверка одной примерной задачи. Что делать, если мы хотим проверить множество вариантов задачи? Нет проблем. Мы можем использовать `@pytest.mark.parametrize(argnames, argvalues)` для передачи множества данных через один и тот же тест, например:

```Python
@pytest.mark.parametrize('task',
                         [Task('sleep', done=True),
                          Task('wake', 'brian'),
                          Task('breathe', 'BRIAN', True),
                          Task('exercise', 'BrIaN', False)])
def test_add_2(task):
    """Демонстрирует параметризацию с одним параметром."""
    task_id = tasks.add(task)
    t_from_db = tasks.get(task_id)
    assert equivalent(t_from_db, task)
```

Первый аргумент `parametrize()` — это строка с разделенным запятыми списком имен — 'task', в нашем случае. Второй аргумент — это список значений, который в нашем случае представляет собой список объектов `Task`. `pytest` будет запускать этот тест один раз для каждой задачи и сообщать о каждом отдельном тесте:

```Shell
collected 4 items

test_add_variety.py::test_add_2[task0] PASSED
test_add_variety.py::test_add_2[task1] PASSED
test_add_variety.py::test_add_2[task2] PASSED
test_add_variety.py::test_add_2[task3] PASSED
```

Ещё примеры:

```Python
@pytest.mark.parametrize('summary, owner, done',
                         [('sleep', None, False),
                          ('wake', 'brian', False),
                          ('breathe', 'BRIAN', True),
                          ('eat eggs', 'BrIaN', False),
                          ])
def test_add_3(summary, owner, done):
    """Демонстрирует параметризацию с несколькими параметрами."""
    task = Task(summary, owner, done)
    task_id = tasks.add(task)
    t_from_db = tasks.get(task_id)
    assert equivalent(t_from_db, task)
```

```Python
tasks_to_try = (Task('sleep', done=True),
                Task('wake', 'brian'),
                Task('wake', 'brian'),
                Task('breathe', 'BRIAN', True),
                Task('exercise', 'BrIaN', False))

@pytest.mark.parametrize('task', tasks_to_try)
def test_add_4(task):
    """Немного разные."""
    task_id = tasks.add(task)
    t_from_db = tasks.get(task_id)
    assert equivalent(t_from_db, task)
```

### 2.9.3 `pytest` Fixtures

**Fixtures** — это функции, выполняемые `pytest` до (а иногда и после) фактических тестовых функций. Код в фикстуре может делать все, что вам необходимо. Вы можете использовать **Fixtures**, чтобы получить набор данных для тестирования. Вы можете использовать **Fixtures**, чтобы получить систему в известном состоянии перед запуском теста. **Fixtures** также используются для получения данных для нескольких тестов.

Вот простой пример фикстуры, который возвращает число:

```Python
import pytest

@pytest.fixture()
def some_data():
    """Return answer to ultimate question."""
    return 42

def test_some_data(some_data):
    """Use fixture return value in a test."""
    assert some_data == 42
```

Декоратор `@pytest.fixture()` используется, чтобы сообщить `pytest`, что функция является фикстурой. Когда вы включаете имя фикстуры в список параметров тестовой функции, `pytest` знает, как запустить её перед запуском теста. Фикстуры могут выполнять работу, а могут возвращать данные в тестовую функцию.

Тест `test_some_data()` имеет в качестве параметра имя фикстуры `some_data`. `pytest` определит это и найдет фикстуру с таким названием. Наименование значимо в `pytest`, он будет искать в модуле теста фикстуру с таким именем.

Мы можем создавать фикстуры с заданной областью действия; по умолчанию - это `function`, что означает, фикстура будет выполняться перед каждой тестовой
функцией (сценарием); можно определить следующие области:
- `Function`: фикстура уничтожается после выполнения теста.
- `Module`: фикстура уничтожается после выполнения последнего теста в модуле.
- `Class`: фикстура уничтожается после выполнения последнего теста в· классе.
- `Package`: фикстура уничтожается после выполнения последнего теста в пакете.
- `Session`: фикстура уничтожается после выполнения последнего теста в сеансе.
##### Обмен Fixtures через conftest.py

Можно поместить фикстуры в отдельные тестовые файлы, но для совместного использования фикстур в нескольких тестовых файлах лучше использовать файл `conftest.py` где-то в общем месте, централизованно для всех тестов. Для проекта задач все фикстуры будут находиться в `tasks_proj/tests/conftest.py`.

Хотя `conftest.py` является модулем Python, он не должен импортироваться тестовыми файлами. Не импортируйте `conftest` никогда! Файл `conftest.py` считывается `pytest` и считается локальным плагином.

###### Использование Fixtures для Setup и Teardown

`pytest` включает в себя отличную фикстуру под названием `tmpdir`. Мы можем использовать её для тестирования и не должны беспокоиться о очистке.

```Python
@pytest.fixture()
def tasks_db(tmpdir):
    """Подключение к БД перед тестами, отключение после."""
    # Setup : start db
    tasks.start_tasks_db(str(tmpdir), 'tiny')

    yield  # здесь происходит тестирование

    # Teardown : stop db
    tasks.stop_tasks_db()
```

Функция `fixture` запускается перед тестами, которые ее используют. Однако, если в функции есть `yield`, то там произойдёт остановка, контроль передастся тестам и выполняется следующая за `yield` строка после завершения тестов. Поэтому можно думать о коде над `yield` как о «**setup**», а о коде после `yield` как о «**teardown**». Код после `yield` будет выполняться независимо от того, что происходит во время тестов.

##### Использование Fixtures для тестовых данных

`Fixtures` являются отличным местом хранения данных для тестирования. Вы можете вернуть всё что угодно. Вот фикстура, возвращающая кортеж смешанного типа:

```Python
@pytest.fixture()
def a_tuple():
    """Вернуть что-нибудь более интересное"""
    return (1, 'foo', None, {'bar': 23})

def test_a_tuple(a_tuple):
    """Demo the a_tuple fixture."""
    assert a_tuple[3]['bar'] == 32
```

Вместе с разделом трассировки стека `pytest` отображает параметры значения функции, вызвавшей исключение или не прошедшей assert.

```Shell
================================== FAILURES ==================================
________________________________ test_a_tuple ________________________________
a_tuple = (1, 'foo', None, {'bar': 23})

    def test_a_tuple(a_tuple):
        """Demo the a_tuple fixture."""
>       assert a_tuple[3]['bar'] == 32
E       assert 23 == 32

ch1\test_tree.py:11: AssertionError
========================== short test summary info ===========================
FAILED ch1/test_tree.py::test_a_tuple - assert 23 == 32
============================= 1 failed in 0.52s ==============================
```
##### Спецификация областей(Scope) Fixture

Фикстуры включают в себя необязательный параметр под названием **scope**, который определяет, как часто фикстура получает setup и teardown. Параметр _scope_ для `@ pytest.fixture()` может иметь значения функции, класса, модуля или сессии. _Scope_ по умолчанию — это функция.

Ниже приведено краткое описание каждого значения _Scope_:

- `scope='function'` -  Выполняется один раз для каждой функции теста. Часть setup запускается перед каждым тестом с помощью fixture. Часть teardown запускается после каждого теста с использованием fixture. Это область используемая по умолчанию, если параметр scope не указан.

- `scope='class'` - Выполняется один раз для каждого тестового класса, независимо от количества тестовых методов в классе.

- `scope='module'` - Выполняется один раз для каждого модуля, независимо от того, сколько тестовых функций или методов или других фикстур при использовании модуля.

- `scope='session'` - Выполняется один раз за сеанс. Все методы и функции тестирования, использующие фикстуру области сеанса, используют один вызов setup и teardown.

```Python
"""Demo fixture scope."""
import pytest


@pytest.fixture(scope='function')
def func_scope():
    """A function scope fixture."""

@pytest.fixture(scope='module')
def mod_scope():
    """A module scope fixture."""

@pytest.fixture(scope='session')
def sess_scope():
    """A session scope fixture."""

@pytest.fixture(scope='class')
def class_scope():
    """A class scope fixture."""

def test_1(sess_scope, mod_scope, func_scope):
    """Тест с использованием сессий, модулей и функций."""

def test_2(sess_scope, mod_scope, func_scope):
    """Демонстрация более увлекательна со множеством тестов."""

@pytest.mark.usefixtures('class_scope')
class TestSomething():
    """Demo class scope fixtures."""

    def test_3(self):
        """Test using a class scope fixture."""

    def test_4(self):
        """Again, multiple tests are more fun."""
```

##### Использование tmpdir и tmpdir_factory

Если вы тестируете что-то, что считывает, записывает или изменяет файлы, вы можете использовать tmpdir для создания файлов или каталогов, используемых одним тестом, и вы можете использовать `tmpdir_factory`, когда хотите настроить каталог для нескольких тестов.

```Python
def test_tmpdir(tmpdir):
    # tmpdir уже имеет имя пути, связанное с ним 
    # join() расширяет путь, чтобы включить имя файла, 
    # создаваемого при записи в
    a_file = tmpdir.join('something.txt')

    # можете создавать каталоги
    a_sub_dir = tmpdir.mkdir('anything')

    # можете создавать файлы в директориях (создаются при записи)
    another_file = a_sub_dir.join('something_else.txt')

    # эта запись создает 'something.txt'
    a_file.write('contents may settle during shipping')

    # эта запись создает 'anything/something_else.txt'
    another_file.write('something different')

    # вы также можете прочитать файлы
    assert a_file.read() == 'contents may settle during shipping'
    assert another_file.read() == 'something different'
```

### 2.9.4 Конфигурация

Следует знать следующее:

- `pytest.ini`: Это основной файл конфигурации `Pytest`, который позволяет вам изменить поведение по умолчанию.
- `conftest.py`: Это локальный плагин, позволяющий подключать хук-функции и фикстуры для каталога, в котором существует файл `conftest.py`, и всех его подкаталогов.
- _`__init__.py`_: При помещении в каждый test-подкаталог этот файл позволяет вам иметь идентичные имена test-файлов в нескольких каталогах test.

##### Изменение параметров командной строки по умолчанию

```ini
[pytest]
addopts = -rsxX -l --tb=short --strict
```

Ключ `-rsxX` дает установку pytest сообщать о причинах всех `skipped`, `xfailed` или `xpassed` тестов. Ключ `-l` позволит pytest вывести трассировку стека для локальных переменных в случае каждого сбоя. `--tb=short` удалит большую часть трассировки стека. Однако, оставит файл и номер строки. Параметр `--strict` запрещает использование маркеров, если они не зарегистрированы в файле конфигурации. Вы увидите, как это сделать в следующем разделе.

##### Требование минимальной версии Pytest

Параметр `minversion` позволяет указать минимальную версию pytest, ожидаемую для тестов.

```ini
[pytest]
minversion = 3.0
```

##### Исключения для поиска тестов в неправильных местах

```ini
[pytest]
norecursedirs = .* venv src *.egg dist build
```

##### Cпецификация дерева тестового каталога

В то время как `norecursedirs` указывает pytest куда не надо заглядыывать, `testpaths` говорит pytest, где искать. `testspaths` — это список каталогов относительно корневого каталога для поиска тестов. Он используется только в том случае, если в качестве аргумента не указан каталог, файл или `nodeid`.

```ini
[pytest]
testpaths = tests
```

##### Изменение правил обнаружения тестов

**python_classes**

Обычное правило обнаружения тестов для pytest и классов — считать класс потенциальным тестовым классом, если он начинается с `Test*`. Класс также не может иметь метод `__init__()`. Но что, если мы захотим назвать наши тестовые классы как `<something>Test` или `<something>Suite`?

```ini
[pytest]
python_classes = *Test Test* *Suite
```

Это позволяет нам называть классы так:

```Python
class DeleteSuite():

    def test_delete_1():
        ...

    def test_delete_2():
        ...
```

**python_files**

Как и `pytest_classes`, `python_files` изменяет правило обнаружения тестов по умолчанию, которое заключается в поиске файлов, начинающихся с `test_*` или имеющих в конце `*_test`.  
Допустим, у вас есть пользовательский тестовый фреймворк, в котором вы назвали все свои тестовые файлы `check_<something>.py`. Кажется разумным. Вместо того, чтобы переименовывать все ваши файлы, просто добавьте строку в `pytest.ini` следующим образом:

```ini
[pytest]
python_files = test_* *_test check_*
```

**python_functions**

`python_functions` действует как две предыдущие настройки, но для тестовых функций и имен методов. Значение по умолчанию — `test_*`. А чтобы добавить `check_*`

```ini
[pytest]
python_functions = test_*  check_*
```

##### `Coverage.py`: Определение объема тестируемого кода

Покрытие кода является показателем того, какой процент тестируемого кода тестируется набором тестов.

Инструменты покрытия кода отлично подходят для того, чтобы сообщить вам, какие части системы полностью пропущены тестами.

`Coverage.py` является предпочтительным инструментом покрытия Python, который измеряет покрытие кода.

```Shell
pip install pytest-cov
```

```Shell
pytest --cov=src
```

Если вы снова запустите `coverage.py` с параметром `--cov-report=html`, будет создан отчет в формате HTML:

```Shell
pytest --cov=src --cov-report=html
```
# 3. Иное

### 3.1 Строка документирования (docstring)

Строка документирования (docstring) — это строковый литерал, который расположен сразу за объявлением функции.

Основное назначение **комментариев** – **пояснить что делает код**, как он работает.

Основное назначение **строк документации** – описать в целом **для чего предназначен объект, какие аргументы принимает, и что возвращает**.

Для описания строки документации обычно используют тройные кавычки, в которых размещается соответствующая информация.

```Python
def square(n):
    '''Принимает число и возвращает его квадрат.'''
    return n**2

def average(*args):
    '''Принимает несколько чисел и возвращает их среднее арифметическое значение.'''
    return sum(args)/len(args)

print(square.__doc__)
print(average.__doc__)
```

Мы можем использовать как тройные двойные кавычки **"""**, так и тройные одинарные кавычки **'''** для создания строк документации. Тройные кавычки используются для многострочных строк.

При описании строки документации обычно описывают типы принимаемых аргументов и возвращаемое значение функции. Рассмотрим функцию multiplier(), которая принимает два числа (int, float) и возвращает их произведение.

```Python
def multiplier(num1, num2):
    """Перемножает два числа и возвращает их произведение.
    :параметр num1: int, float, первое число в произведении;
    :параметр num2: int, float, второе число в произведении;
    :возвращаемое значение: int, float, произведение двух чисел.
    """
    return num1 * num2
```

https://pythonworld.ru/osnovy/dokumentirovanie-koda-v-python-pep-257.html

### 3.2 Пространства имен и области видимости в Python

В Python понятие объекта является ключевым. Фактически все, что программа Python создает или с чем работает, — это **объект.**

Выражение присваивания создает **символическое** имя, которое можно использовать для ссылки на объект. Так выражение x = 'foo' создает символическое имя x, которое ссылается на строковый объект 'foo'.

**Пространство имен** — это совокупность **определенных в настоящий момент символических имен** и информации об объектах, на которые они ссылаются. Можно рассматривать такое пространство как словарь, в котором ключи являются именами объектов, а значения — самими объектами. Каждая пара ключ-значение соотносит имя с соответствующим ему объектом.

Существует 4 типа пространств имен:
1.      Встроенное.
2.      Глобальное.
3.      Нелокальное (объемлющее).
4.      Локальное.

Они обладают разными жизненными циклами. По мере выполнения программы Python создает необходимые пространства имен и удаляет их, когда потребность в них пропадает. Как правило, в любой момент времени существует множество пространств имен.

**Встроенное пространство имен** содержит имена всех встроенных объектов, которые всегда доступны при работе в Python. Вы можете перечислить объекты во встроенном пространстве с помощью следующей команды:

```Python
dir(__builtins__)  # ['ArithmeticError', … 'super', 'tuple', 'type', 'vars', 'zip']
```

Перечень включает, например, исключение StopIteration, такие встроенные функции, как max() и len(), а также типы объектов — int и str. **При запуске** интерпретатор Python создает **встроенное пространство имен**. Оно сохраняется до тех пор, пока интерпретатор **не завершит работу**.

**Глобальное пространство имен** содержит имена, определенные на уровне основной программы, и создаётся **сразу при запуске тела этой программы**. Сохраняется же оно **до момента завершения работы интерпретатора**. Строго говоря, могут существовать и другие глобальные пространства имен. Интерпретатор также создает пространство данного типа для любого модуля, загружаемого программой при помощи выражения import. Теперь, встречая понятие “**глобальное пространство имен**”, вы будете знать, что оно принадлежит **основной программе**.

Локальное и Нелокальное (объемлющее) пространства имен

Интерпретатор создает новое пространство имен **при каждом выполнении функции**. Это пространство является **локальным** для функции и сохраняется до момента завершения ее действия. Функции не существуют независимо друг от друга только на уровне основной программы. Вы также можете определять одну функцию внутри другой.

```Python
def f():
    print('Start f()')

    def g():
        print('Start g()')
        print('End g()')
        return

    g()
    print('End f()')
    return

f()

# Start f()
# Start g()
# End g()
# End f()
```

В этом примере функция **g()** определена внутри тела **f().** Вот что происходит в данном коде:
-        Строки с 1 по 10 определяют **f(), объемлющую функцию**.
-        Строки с 3 по 6 определяют **g(), вложенную функцию**.
-        В строке 12 основная программа вызывает f().
-        В строке 8 **f() вызывает g(**).

Когда основная программа вызывает f(), Python **создает для нее новое пространство имен**. Аналогичным образом, когда f() вызывает g(), последняя **получает свое собственное отдельное пространство**. Пространство, созданное для g(), является **локальным**, а пространство, созданное для f(), — **нелокальным (объемлющим).**

Все эти пространства существуют до тех пор, пока выполняются соответствующие им функции. По завершении же этих функций Python может не сразу отозвать их из памяти, но при этом все ссылки на содержащиеся в них объекты сразу становятся недоступными.

Если ваш код ссылается на имя **x**, то Python будет искать его следующих областях видимости в таком порядке:
-        **Локальная**. Если вы ссылаетесь на x внутри функции, то интерпретатор сначала ищет его в самой внутренней области, локальной для этой функции.
-        **Объемлющая**. Если x не находится в локальной области, но появляется в функции, располагающейся внутри другой функции, то интерпретатор ищет его в области видимости объемлющей функции.
-        **Глобальная**. Если ни один из вышеуказанных вариантов не принес результатов, то интерпретатор продолжит поиск в глобальной области видимости.
-        **Встроенная**. Если интерпретатор не может найти x где-либо еще, то он направляет поиски во встроенную область видимости.

### 3.3 Оператор assert

Оператор **assert** позволяет нам писать **проверки работоспособности** нашего кода. Эти проверки обычно называют **утверждениями**. Мы используем такие утверждения для того чтобы убедиться, остаются ли верными определенные условия во время разработки программы. Если какое-либо из утверждений оказывается ложным, то это означает, что в программе есть ошибка. Если все утверждения истинны, то в программе ошибок нет. Таким образом, **утверждения — это удобный инструмент для документирования, отладки и тестирования кода во время разработки**. После того как мы отладили и протестировали наш код с помощью утверждений, мы можем их отключить.

Оператор **assert** – это встроенный оператор используемый для **проверки** того, является ли заданное утверждение истинным или ложным. Если утверждение **истинно**, то **ничего не происходит** и выполняется следующая строка кода. Если же утверждение **ложно**, оператор **assert останавливает выполнение программы** и подобно оператору raise **возбуждает исключение AssertionError**.

```
assert <утверждение>, <сообщение>
```

```Python
age = 29  # возраст человека
assert age > 0, 'Возраст должен быть положительным числом'

num1 = 20
num2 = 0
assert num2 != 0, 'Делитель равен нулю.'  # AssertionError

print('Частное равно:', num1 / num2)
```

использует оператор **assert** для проверки того, не равен ли нулю делитель. В данном случае утверждение num2 != 0 ложно, поэтому оператором assert будет возбуждено исключение **AssertionError** вместе с добавленным нами сообщением.

Запись

```
assert <утверждение>, <сообщение>
```

примерно эквивалентна записи:

```Python
if not <утверждение>:
    raise AssertionError(<сообщение>)
```

**assert** – это **именно оператор**, а не функция. При использовании **assert** мы не указываем круглые скобки.

Оператор **assert** — это средство отладки, а не механизм обработки ошибок времени выполнения программы (исключений). Цель использования оператора **assert** состоит в том, чтобы позволить разработчикам как можно скорее найти вероятную первопричину ошибки. Если в программе ошибки нет, то исключение **AssertionError** никогда не должно возникнуть. В связи с этим не следует писать код, который явно обрабатывает исключения **AssertionError** с помощью конструкции **try-except**.

основные тезисы относительно оператора assert:

-        оператор **assert** — это средство отладки, которое проверяет утверждение, выступающее в качестве внутренней самопроверки вашей программы

-        оператор **assert** должен применяться только для того чтобы по­могать разработчикам идентифицировать ошибки. Они не являются механизмом обработки ошибок времени выполнения программы (исключений)

оператор **assert** может быть глобально отключен в настройках интерпретатора

### 3.4 Оператор pass

В ходе исполнения оператора **pass** ничего не происходит, поэтому он может использоваться в качестве заглушки в тех местах, где это синтаксически необходимо, например, в инструкциях, где тело является обязательным, таких как `def`.

### 3.5 Виртуальное окружение

`virtualenv` - это утилита для создания изолированных окружений в Python.

`virtualenv` позволяет создавать изолированные окружения для ваших приложений и позволит устанавливать пакеты именно в эти окружения, а не глобально.

Установка средствами `pip`:

```Shell
pip install virtualenv
```

Две основные команды:
- `virtualenv myproject`
- `source myproject/bin/activate`

Первая создаст новое изолированное окружение в папке `myproject`, а вторая активирует это окружение.

При создании виртуального окружения вам нужно принять решение. Хотите ли вы, чтобы виртуальное окружение использовало пакеты, установленные глобально, но по умолчанию у `virtualenv` нет к ним доступа.

Если вы хотите открыть `virtualenv` доступ к глобально установленным пакетам, то используйте флаг `--system-site-packages` во время создания окружения:

```
virtualenv --system-site-packages mycoolproject
```

Вы можете деактивировать виртуальное окружение, набрав:

```
deactivate
```

Команда `python` вновь будет использовать глобально установленный в системе интерпретатор Python после деактивации виртуального окружения.

### 3.6 Отладка

Основной отладчик в Python - `pdb`

**Запуск из командной строки**

Вы можете запустить скрипт из командной строки вместе с отладчиком. Пример:

```
python -m pdb my_script.py
```

Отладчик приостановит выполнение программы на первой найденной им инструкции. Это удобно для коротких скриптов. Вы можете проверить значения переменных и продолжить выполнение программы построчно.

**Запуск из скрипта**

Вы можете задать контрольные точки в коде, что позволит изучить значения переменных и другие параметры в конкретный момент выполнения программы. Это возможно при помощи метода `pdb.set_trace()`.

```Python
import pdb


def make_bread():
	pdb.set_trace()
	return "У меня нет времени"


print(make_bread())
```

**Команды**

- `c`: продолжить выполнения программы
- `w`: отобразить окружение текущей исполняемой инструкции
- `a`: отобразить список аргументов текущей функции
- `s`: исполнить текущую строчку кода и остановиться по возможности
- `n`: продолжить исполнение программы пока не будет достигнута следующая строка текущей функции или пока функция не завершит свою работу

Разница между `n` и `s` в том, что вторая команда приостановит исполнение после вызова функции, а первая только после достижения следующей строки текущей функции.

Это лишь несколько базовых команд. `pdb` также поддерживает проведение анализа после завершения работы программы.

### 3.7 Анализ объекта

В программировании, под анализом объекта понимается возможность определения его типа во время исполнения программы. Это одна из сильных сторон Python. Все в Python является объектами и мы можем их исследовать. В языке есть несколько встроенных функций и модулей для этой цели.

#### `dir`

Это одна из важнейших функций для анализаобъектов. Она возвращает список атрибутов и методов объекта. Вот пример:

```Python
my_list = [1, 2, 3]

dir(my_list)

# Вывод: ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',
# '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',
# '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__',
# '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__',
# '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__',
# '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__',
# '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop',
# 'remove', 'reverse', 'sort']
```

Мы получили все методы списка. Это может быть полезно, если вы не можете вспомнить имя конкретного метода. Если мы запустим `dir()` без аргументов, то она вернет нам имена всех объектов в текущей области видимости.

#### `type` и `id`

Функция `type` возвращает тип объекта. Пример:

```Python
print(type(''))
# Вывод: <type 'str'>

print(type([]))
# Вывод: <type 'list'>

print(type({}))
# Вывод: <type 'dict'>

print(type(dict))
# Вывод: <type 'type'>

print(type(3))
# Вывод: <type 'int'>
```

`id` возвращает уникальный идентификатор объекта. К примеру:

```Python
name = "Yasoob"

print(id(name))
# Вывод: 139972439030304
```

#### Модуль `inspect`

Модуль `inspect` также предоставляет несколько полезных функций для получения информации об объектах. Например, вы можете проверить члены объекта, запустив:

```Python
import inspect

print(inspect.getmembers(str))
# Вывод: [('__add__', <slot wrapper '__add__' of ... ...
```

