![](obs-vault/Programming/Python/attachments/dataset/20230320163205.png)

Структура данных (data structure) — программная единица, позволяющая **хранить и обрабатывать** множество однотипных и/или логически связанных данных.

# 1. Списки (list)

### 1.1 Что такое список?

Список представляет собой **упорядоченную изменяемую коллекцию объектов произвольных типов**. Внутреннее строение списка - **массив (точнее, vector) указателей**, т. е. список является динамическим массивом.

### 1.2 Основные методы списка?

```Python
# Создаем пустой список
a = []
a: list[int] = [10, 20]
b: list[int] = [30, 40]
c: list[int] = [50, 60]

# Добавляем значение в конец списка
a.append(50)

# Вставляем значение по определенному индексу
b.insert(2, 60)

# расширить список другим списком
c.extend(a)  # [50, 60, 10, 20]

# Метод index() возвращает индекс первого элемента, значение которого равняется переданному в метод значению
c.index(60)  # 1

# Метод remove() удаляет первый элемент, значение которого равняется переданному в метод значению.
c.remove(60)  # [50, 10, 20]

# Метод pop() удаляет элемент по указанному индексу и возвращает его. Если индекс не указан, то метод удаляет и возвращает последний элемент списка.
c.pop(0)      # [10, 20]

# Метод count() возвращает количество элементов в списке, значения которых равны переданному в метод значению.
c.count(10)   # 1

# Метод copy() создает поверхностную копию списка.
names = ['A', 'B', 'C']
names_copy1 = list(names)  # создаем поверхностную копию с помощью функции list()
names_copy2 = names[:]     # создаем поверхностную копию с помощью среза от начала до конца

a += b
print(f"Add: {a}")  # Add: [10, 20, 50, 30, 40, 60]

# reversed() возвращает итератор, а не список
a.reversed()
b = list(reversed(a))
print(f"Reverse: {a}, {b}") # Reverse: [60, 40, 30, 50, 20, 10], [10, 20, 50, 30, 40, 60]

# Возвращает новый отсортированный список
b = sorted(a)

# Модифицирует исходный список и не возвращает ничего
a.sort()  # Метод sort() использует алгоритм Timsort.
print(f"Sort: {a}, {b}") # Sort: [10, 20, 30, 40, 50, 60], [10, 20, 30, 40, 50, 60]

s: str = "A whole string"
list_of_chars: list = list(s)
print(list_of_chars) # ['A', ' ', 'w', 'h', 'o', 'l', 'e', ' ', 's', 't', 'r', 'i', 'n', 'g']
list_of_words: list = s.split()
print(list_of_words) # ['A', 'whole', 'string']

# Возвращает индекс первого вхождения искомого элемента или вызывает исключение ValueError
i: int = list_of_chars.index("w")  
print(i) # 2

# Удаляет первое вхождение искомого элемента или вызывает исключение ValueError
list_of_chars.remove("w")

# Удаляет и возвращает значение, расположенное по индексу .pop() удалит и вернет последний элемент списка
e = list_of_chars.pop(9)
print(list_of_chars, e) # ['A', ' ', 'h', 'o', 'l', 'e', ' ', 's', 't', 'i', 'n', 'g'] r

# Очистка списка
a.clear()
```

### 1.3 Существует ли разница между методами списка и методами строк?

Существует большая разница в работе строковых и списочных методов. Строковые методы **не изменяют** содержимого объекта к которому они применяются, **а возвращают новое значение**. Списочные методы, напротив, **меняют** содержимое объекта к которому применяются.

### 1.4 Что такое списочное включение?

Списочные выражения часто используются для инициализации списков. В Python не принято создавать пустые списки, а затем заполнять их значениями, если можно этого избежать.
```Python
evens = [i for i in range(21) if i % 2 == 0]  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
```

Общий принцип:
```
[выражение for переменная in последовательность if условие]
```

Пусть `word = 'Hello', numbers = [1, 14, 5, 9, 12], words = ['one', 'two', 'three', 'four', 'five', 'six']`.

|Списочное выражение|Результирующий список|
|---|---|
|`[0 for i in range(10)]`|`[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`|
|`[i ** 2 for i in range(1, 8)]`|`[1, 4, 9, 16, 25, 36, 49]`|
|`[i * 10 for i in numbers]`|`[10, 140, 50, 90, 120]`|
|`[c * 2 for c in word]`|`['HH', 'ee', 'll', 'll', 'oo']`|
|`[m[0] for m in words]`|`['o', 't', 't', 'f', 'f', 's']`|
|`[i for i in numbers if i < 10]`|`[1, 5, 9]`|
|`[m[0] for m in words if len(m) == 3]`|`['o', 't', 's']`|

#### Вложенные циклы

В списочном выражении можно использовать вложенные циклы.

```python
numbers = [i * j for i in range(1, 5) for j in range(2)]
print(numbers)  # [0, 1, 0, 2, 0, 3, 0, 4]
```

### 1.5 Детали реализации списков в Python

Детали реализации - В *CPython* списки реализованы в виде **массивов переменной длины**:
-       Вставка элемента в произвольном месте с использованием метода `list.insert` имеет сложность **O(n)**;
-       Удаление элемента с помощью list.delete имеет сложность **O(n)**;
-       Извлечение или установка элемента по индексу — это операция, сложность которой не зависит от размера списка и всегда равна **O(1)**

|Операция|Ср. сложность|Пример|Примечание|
|---|---|---|---|
|Обращение по индексу|O(1)|`l[i]`||
|Присвоение|O(1)|`l[i] = 0`||
|len|O(1)|`len(l)`||
|.append|O(1)|`l.append(5)`||
|.pop|O(1)|`l.pop()`|То же что и `l.pop(-1)` — выброс с конца.|
|.clear|O(1)|`l.clear()`||
|Срез|O(b-a)|`l[a:b]`||
|.extend|O(k)|`l.extend(a)`||
|Создание|O(k)|`list(a)`||
|Проверки \=\=, != | O(n) | `l1 == l2`| |
|.insert|O(n)|`l.insert(0, 5)`||
|del|O(n)|`del l[i]`|То же и с удалением среза.|
|.remove|O(n)|`l.remove(...)`||
|Проверка на входимость|O(n)|`x in l`|Проход по списку.|
|.copy|O(n)|`l.copy()`|То же что и l[:].|
|.pop|O(n)|`l.pop(i)`||
|min, max|O(n)|`min(l)`||
|.reverse|O(n)|`l.reverse()`||
|Проход|O(n)|`for v in l:`||
|Присвоение среза|O(k+n)|`l[... : ...] = ...`||
|.sort|O(n log n)|`l.sort()`||
|Умножение|O(k×n)|`i l`||

### 1.6 Срезы

С помощью среза мы можем получить несколько элементов списка, создав диапазон индексов разделенных двоеточием `numbers[x:y]`. При построении среза `numbers[x:y]` первое число – это то место, где начинается срез (**включительно**), а второе – это место, где заканчивается срез (**невключительно**).

Срез `numbers[:]` возвращает копию исходного списка.

### 1.7 Операция конкатенации + и умножения на число *

Мы можем применять операторы `+` и `*` для списков

```Python
print([1, 2, 3, 4] + [5, 6, 7, 8])  # [1, 2, 3, 4, 5, 6, 7, 8]
print([7, 8] * 3)                   # [7, 8, 7, 8, 7, 8]
print([0] * 10)                     # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

# 2. Кортеж (tuple)

### 2.1 Что такое кортеж?

Кортеж — тот же список, только **неизменяемый (immutable)** и **хэшируемый (hashable)**. Кортежи по своей природе (задумке) – **неизменяемые аналоги списков.**

Кортеж - **упорядоченная последовательность** (означает что кортеж (1, 2) **не равен** кортежу (2, 1) – порядок добавления элементов **важен**)

### 2.2 Зачем использовать кортеж вместо списка?

Списки могут делать то же, что кортежи, и даже больше. Но **неизменяемость** кортежей обеспечивает им особые свойства:

-        **скорость** – кортежи быстрее работают, так как из-за неизменяемости хранятся в памяти иначе, и операции с их элементами выполняются заведомо быстрее, чем с компонентами списка. Одна из причин существования кортежей  – **производительность**. Обработка кортежа выполняется быстрее, чем обработка списка, поэтому кортежи удобны для обработки большого объема неизменных данных.

-        **безопасность** – неизменяемость превращает их в идеальные константы. Заданные кортежами константы делают код более читаемым и безопасным. Кроме того, в кортеже можно безопасно хранить данные, не опасаясь, что они будут случайно или преднамеренно изменены в программе.

Если **нужна распаковка** и **не требуется** *изменять\\добавлять\\удалять* данные – то **кортеж**, во всех остальных случаях – **списки**.

### 2.3 Чем кортеж отличается от списка?

**Кортеж** – неизменяемый, хэшируемый тип данных. Кортеж, содержащий те же данные, что и список, занимает меньше места

```Python
a = [2, 3, "Boson", "Higgs", 1.56e-22]
b = (2, 3, "Boson", "Higgs", 1.56e-22)

print(f"List: {a.__sizeof__()} bytes")  # List: 104 bytes
print(f"Tuple: {b.__sizeof__()} bytes") # Tuple: 64 bytes
```

### 2.4 Как произвести смену значений двух переменных без использования временных переменных.

```Python
a = 7
b = 17

a, b = b, a
print(a, b)  # 17 7
```

Сначала вычисляются **все значения справа**, и лишь затем они кладутся в левую часть оператора присваивания. Поэтому можно менять местами значения переменных a и b, написав: a, b = b, a.

### 2.5 Распаковка кортежа

При распаковке кортежа, если число элементов слева и справа не совпадает, то возникает ошибка времени исполнения. Есть способ собрать сразу несколько значений в одну переменную. Это делается при помощи *звездочки (\*)* **перед именем переменной**.

```Python
a, b, *tail = 1, 2, 3, 4, 5, 6
print(tail)  # [3, 4, 5, 6]
```

В этом случае в переменной `a` будет записана единица, в переменной `b` — двойка, а в переменной `tail` — список, состоящий из **всех аргументов, которые не попали в предыдущие переменные**.

Следует учесть, что переменная `tail` всегда будет **списком**, даже когда в него попадает лишь один элемент или даже ноль.

### 2.6 Детали реализации

**Кортежи** (tuples) поддерживают все операции, которые не изменяют структуру данных – и они имеют такие же классы сложности, как у [[#1.5 Детали реализации списков в Python|списков]].

# 3. Именованный кортеж (named tuple)

### 3.1 Что такое именованный кортеж?

Именованные кортежи (тип namedtuple) — это **подтип** обычных кортежей в Python. У них те же функции, что и у обычных кортежей, но их **значения можно получать** как с помощью индекса (например, `[0]`), так и с помощью **имени через точку** (например, `.name` ).

Основное предназначение именованных кортежей — **это улучшение читаемости программного кода**.

> Хотя кортежи и именованные кортежи **неизменяемы**, сохраняемые в них значения не обязательно должны быть неизменяемыми. Совершенно нормально создать кортеж или именованный кортеж, содержащий изменяемые значения при этом кортеж продолжит содержать **те же ссылки на память**.

### 3.2 В каких случаях следует использовать named tuple?

Класс `namedtuple` используется для построения классов, содержащих **только атрибуты** и никаких методов, например, для хранения координат:

```Python
import collections


# объявляем тип Coordinate именованного кортежа
Coordinate = collections.namedtuple('Coordinate', ['latitude', 'longitude'])

# создаем именованный кортеж Coordinate с помощью позиционных аргументов
c1 = Coordinate('33.005896', '15.568878')

# создаем именованный кортеж Coordinate с помощью именованных аргументов
c2 = Coordinate(latitude='33.005896', longitude='15.568878')

print(c1)           # Coordinate(latitude='33.005896', longitude='15.568878')
print(c1.latitude)  # '33.005896'
print(c1.longitude) # '15.568878'
```

Мы можем **распаковывать** именованный кортеж, также, как и обычный.

### 3.3 Дополнительные атрибуты named tuple

Именованные кортежи имеют два дополнительных атрибута: `_fields` и `_field_defaults`. 
-  `_fields` содержит **кортеж строк**, в котором перечислены имена полей. 
-  `_field_defaults` содержит **словарь**, который сопоставляет имена полей с соответствующими значениями по умолчанию, если таковые имеются.

Именованные кортежи (тип `namedtuple`) являются производными от обычных кортежей (тип `tuple`), поэтому **наследует их методы**, а также добавляют три новых: `_make()`, `_replace()`, `_asdict()`.

Метод `_make()` используется для создания именованных кортежей из итерируемых объектов (список, кортеж, строка, словарь и т.д.).

Метод `_asdict()` возвращает словарь, в котором имена полей используются в качестве ключей. Ключи результирующего словаря находятся в том же порядке, что и поля в исходном именованном кортеже.

Метод `_replace()` позволяет создавать новые именованные кортежи на основании уже существующих с заменой некоторых значений. Потребность в данном методе вызвана тем, что именованные кортежи являются неизменяемыми. Метод `_replace()` **не изменяет текущий именованный кортеж, а возвращает новый**.

```Python
from collections import namedtuple


Person = namedtuple('Person', ['name', 'age', 'height', 'country'])

p = Person._make(['Alex', 29, 170]) # Person(name='Alex', age=29, height=170)
p._asdict()                         # {'name': 'Alex', 'age': 29, 'height': 170}

p1 = Person('Alex', 29, 170, 'Russia')
p2 = p1._replace(age=30, country='Germany')

print(p1)  # Person(name='Alex', age=29, height=170, country='Russia')
print(p2)  # Person(name='Alex', age=30, height=170, country='Germany')
```

### 3.4 Функция namedtuple()

Функция `namedtuple()` выступает в роли **фабричной функции**, порождающей новые типы данных.

```Python
namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)
```

Т.о. функция принимает **два обязательных** параметра `typename` и `field_names` и **три необязательных** `rename`, `defaults`, `module`, имеющих значения по умолчанию `False`, `None`, `None` соответственно.

1. Параметр `typename` отвечает за имя создаваемого типа (*это строка с типом, который нужно сделать именованным кортежем*).

2. Параметр `field_names` отвечает за названия полей. В качестве параметра `field_names` можно передавать любой итерируемый объект, например, результат вызова функций `map()` и `filter()`, а также список, словарь, кортеж, строка, множество. В качестве названия полей для именованных кортежей мы можем использовать любое корректное название имени переменной, за исключением:
	-        имен, начинающихся с подчеркивания ( `_` )
	-        ключевых слов языка Python ( `if`, `with`, `else`, `class`, ... )

3. Параметр `defaults` используется для того, чтобы установить значения по умолчанию для полей именованного кортежа.

### 3.5. Сравнение именованных кортежей и словарей

Словарь (`dict`) — это фундаментальная структура данных в Python. Сам язык построен на словарях, они используются повсюду. Несложно заметить, что функционал именованных кортежей можно полностью заменить функционалом словарей. 

Давайте проведем небольшое сравнение именованных кортежей и словарей по следующим параметрам:

1.      *читабельность* (readability)
2.      *изменяемость* (mutability)
3.      *потребление памяти* (memory usage)
4.      *производительность* (performance)

**Читабельность**

С точки зрения удобочитаемости словари так же читабельны, как и именованные кортежи. Но у именованных кортежей доступ к атрибутам через точечную нотацию выглядит немного аккуратнее чем через квадратные скобки. Также нужно заметить, что при использовании квадратных скобок нам нужно использовать символ кавычки. Однако для определения именованного кортежа требуются две дополнительные строки кода: одна строка для импорта фабричной функции namedtuple(), а другая — для определения самого именованного кортежа.

**Изменяемость**

Большая разница между обеими структурами данных заключается в том, что словари **изменяемы**, а именованные кортежи **неизменны**. Это означает, что вы можете изменять словари на месте (подобно спискам), но не можете изменять именованные кортежи (подобно обычным кортежам).

**Потребление памяти**

Для сравнения потребления памяти именованным кортежем и словарем мы будем использовать функцию asizeof() модуля pympler.

```Python
from collections import namedtuple
from pympler import asizeof


Person = namedtuple('Person', ['name', 'age', 'height'])
a = Person('Alex', 29, 170)
a_dct = {'name': 'Alex', 'age': 29, 'height': 170}

print(f'Им. кортеж: {asizeof.asizeof(a)} байт')   # Им. кортеж: 216 байт
print(f'Словарь: {asizeof.asizeof(a_dct)} байт')  # Словарь: 552 байт
```

Именованный кортеж потребляет **меньше памяти** (примерно на *60%*), чем эквивалентный словарь. Поэтому, если потребление памяти является ограничением, следует подумать об использовании именованного кортежа вместо словаря.

**Производительность**

Нужно иметь представление о том, насколько сильно различаются именованные кортежи и словари с точки зрения производительности операций. Для этого мы будем тестировать операции принадлежности и операции доступа к атрибутам.

```Python
from collections import namedtuple
from time import perf_counter


def average_time(structure, test_func):
    time_measurements = []
    for _ in range(1_000_000):
        start = perf_counter()
        test_func(structure)
        end = perf_counter()
        time_measurements.append(end - start)
    return sum(time_measurements) / len(time_measurements) * int(10**9)


def time_dict(dictionary):
    'name' in dictionary
    'missing_key' in dictionary
    28 in dictionary.values()
    'missing_value' in dictionary.values()
    dictionary['age']


def time_namedtuple(named_tuple):
    'name' in named_tuple._fields
    'missing_field' in named_tuple._fields
    28 in named_tuple
    'missing_value' in named_tuple
    named_tuple.age


Person = namedtuple('Person', ['name', 'age', 'height'])
p = Person('Alex', 29, 170)
p_dct = {'name': 'Alex', 'age': 29, 'height': 170}

# Именованный кортеж: 506.3109208458627 наносекунд
print(f'Именованный кортеж: {average_time(p, time_namedtuple)} наносекунд')

# Словарь: 731.6840510538896 наносекунд
print(f'Словарь: {average_time(p_dct , time_dict)} наносекунд')
```

Итоговая таблица сравнения:

| **Характеристика / тип** | **Именованный кортеж** | **Словарь** |
|--|--|--|
| Читабельность **(readability)** | ✔ | ✔ |
| Изменяемость **(mutability)** | ❌ | ✔ |
| Потребление памяти **(memory usage)** | ✔ | ❌ |
| Производительность **(performance)** | ✔ | ❌ |

# 4. Словарь (dict)

### 4.1. Что такое словарь?

Словарь (`dict`) - реализация *хеш-таблицы* (ключ: значение), поэтому в качестве ключа нельзя брать нехешируемый объект. **Ключом** словаря может быть **любой неизменяемый объект**: число, строка, datetime и даже функция. Такие объекты имеют метод `__hash__()`, который однозначно сопоставляет объект с некоторым числом. По этому числу словарь ищет значение для ключа.

Cловари – **изменяемые** коллекции элементов с **произвольными индексами – ключами.** Словарь — реализация структуры данных "ассоциативный массив" или "хеш таблица". В других языках аналогичная структура называется map, HashMap, Dictionary.

Особенности словарей:
1.      **Ключи** должны быть **уникальными**;
2.      **Ключи** должны быть **неизменяемым** типом данных (число, строка, булево значение, кортеж, frozenset, …);
3.      Значения могут относиться к любому типу данных, их тип данных произволен;
4.      Оператор принадлежности `in` на словарях работает **очень быстро**, намного быстрее, чем на списках, поэтому если нужен многократный поиск в коллекции данных, словарь – подходящий выбор.
5.      Словари не содержат метода `sort()`

### 4.1.1. Когда следует использовать словари

Словари нужно использовать в следующих случаях:
1.       Подсчет числа каких-то объектов. В этом случае нужно завести словарь, в котором ключи — названия объектов, а значения — их количество.
2.        Хранение каких-либо данных, связанных с объектом. **Ключи** — наименования объектов, **значения** — связанные с ними данные. Например, если нужно по названию месяца определить его порядковый номер, то это можно сделать при помощи словаря `num = {'January': 1, 'February': 2, 'March': 3, ...}`.
3.        Установка соответствия между объектами (например, “родитель—потомок”). Ключ — объект, значение — соответствующий ему объект.
4.        Если нужен обычный список, где максимальное значение индекса элемента очень велико, но при этом используются не все возможные индексы (так называемый “*разреженный список*”), то для экономии памяти можно использовать словарь.

### 4.2. Основные методы словаря?

```Python
# Создаем пустой словарь
d = {}

# Непосредственное создание словаря
d: dict[str, str] = {"Italy": "Pizza", "US": "Hot-Dog", "China": "Dim Sum"}

k = ["Italy", "US", "China"]
v = ["Pizza", "Hot-Dog", "Dim Sum"]

# Создание словаря из двух коллекций при помощи zip
d = dict(zip(k, v))

# Коллекция ключей. Отражает изменения в основном словаре
k = d.keys()

# Коллекция значений. Тоже отражает изменения в основном словаре
v = d.values()

# Кортежи ключ-значение, которые тоже отражают изменения в основном словаре
k_v = d.items()
print(d)   # {'Italy': 'Pizza', 'US': 'Hot-Dog', 'China': 'Dim Sum'}
print(k)   # dict_keys(['Italy', 'US', 'China'])
print(v)   # dict_values(['Pizza', 'Hot-Dog', 'Dim Sum'])
print(k_v) # dict_items([('Italy', 'Pizza'), ('US', 'Hot-Dog'), ('China', 'Dim Sum')])
print(f"Mapping: {k.mapping['Italy']}") # Mapping: Pizza

# Добавление значение. При совпадении ключа старое значение будет перезаписано
d.update({"China": "Dumplings"})
print(f"Replace item: {d}") # Replace item: {'Italy': 'Pizza', 'US': 'Hot-Dog', 'China': 'Dumplings'}

# Читаем значение
c = d["China"]
print(f"Read item: {c}") # Read item: Dumplings

try:
    # Удаляет значение или вызывает исключение KeyError
    v = d.pop("Spain")
except KeyError:
    print("Dictionary key doesn't exist")

# Примеры dict comprehension
b = {k: v for k, v in d.items() if "a" in k}  # Вернет новый словарь, отфильтрованный по значению ключа

print(b) # {'Italy': 'Pizza', 'China': 'Dumplings'}

c = {k: v for k, v in d.items() if len(v) >= 7}  # Вернет новый словарь, отфильтрованный по длине значений

print(c) # {'US': 'Hot-Dog', 'China': 'Dumplings'}

# Очистка словаря
d.clear()
```

### 4.3. Как решается проблема вычисления хеша при работе со словарем?

Любая хеш-таблица, должна уметь решать проблему **вычисления хеша**. Для этого используются техники **open addressing** или **chaining**. **Python использует open addressing**.

Новый словарь инициализируется **с 8 пустыми слотами**.

Интерпретатор сначала пытается добавить новую запись по адресу, зависящему от хеша ключа. Если этот адрес занят, то интерпретатор проверяет (при помощи  `==` ) хеш и ключ. Если оба совпадают, то, значит, *запись уже существует*. Тогда начинается зондирование свободных слотов, которое идет в псевдослучайном порядке (порядок зависит от значения ключа). Новая запись будет добавлена по первому свободному адресу.

Чтение из словаря происходит аналогично, интерпретатор начинает поиск с позиции `addr` и идет по тому же псевдослучайному пути, пока не прочитает нужную запись.

### 4.4. Что такое hash-таблица?

**Хеш-таблицы** – это особые структуры данных, подобные *ассоциативным массивам*. Ключами в них могут выступать не только числа, но и другие объекты. Однако есть одно важное условие - **для каждого ключа требуется вычислить особый уникальный код**. Этим занимаются специальные функции (**хэш-функции**).

Хеш-таблицы чрезвычайно полезны, потому что они обеспечивают высокую скорость операций и позволяют по-разному моделировать дынные:
-        Хеш-таблица **создается объединением хеш-функции с массивом**
-        Коллизии нежелательны. Хеш-функция должна свести кол-во коллизий к минимуму
-        Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки и удаления
-        Хеш-таблицы хорошо подходят для моделирования отношений между объектами
-        Как только коэффициент заполнения превышает `0,7` - пора менять размер хэш-таблицы
-        В хеш-таблице, обычно, элементы **неупорядоченны**

![[obs-vault/Programming/Python/attachments/dataset/20230519101937.png]]

### 4.5. Что такое хеширование (Хеш-функция)?

**Хеш-функции** получают на входе данные разного объема, а **возвращают хеш-код фиксированной длины**. Набор данных может пройти через такую функцию много раз, но результат для него будет **одинаковым**. И наоборот, для наборов, отличающихся хотя бы одним символом, коды всегда разные.

![[obs-vault/Programming/Python/attachments/dataset/20230519102055.png]]

### 4.6. Что такое хэшируемые объекты в Python?

Объект называется **хешируемым**, если имеет **хеш-код, который не изменяется на протяжении всего времени его жизни** (у него должен быть метод **__hash__()**), **и допускает сравнение с другими объектами** (у него дол жен быть метод **__eq__()**). Если в результате сравнения хешируемых объектов оказывается, что они равны, то и их хеш-коды должны быть равны

Таблица хешируемости встроенных в Python типов данных:

| **Тип данных** | **Хешируемость** |
|--|--|
| bool | ✔ |
| int | ✔ |
| float | ✔ |
| complex | ✔ |
| str | ✔ |
| list | ❌ |
| tuple | ✔* |
| set | ❌ |
| frozenset | ✔ |
| dict | ❌ |

В настоящий момент в Python встроенная функция `hash()` использует алгоритм **SipHash**. **SipHash** – это семейство псевдослучайных функций на основе **add-rotate-xor (ARX)**. Алгоритм создан Дэниелом Дж. Бернстайном в 2012 году. Cуществуют общепринятые и криптостойкие алгоритмы хеширования, такие как MD5 или SHA. Для их использования в Python есть специальный модуль `hashlib`

### 4.7. Как реализовать словарное включение (dictcomp)?

```Python
dial_codes = [
    (880, 'Bangladesh'),
    (55, 'Brazil'),
    (86, 'China'),
    (92, 'Pakistan'),
    (7, 'Russia'),
    (1, 'United States'),
]

country_dial = {country: code for code, country in dial_codes}
```

Общий принцип:

`{ключ: значение **for** переменная **in** последовательность}`

### 4.8. Как распаковать словарь?

```Python
{'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}} # {'a': 0, 'x': 4, 'y': 2, 'z': 3}
```

### 4.9. Перебор элементов словаря

Для вывода **ключей** словаря можно использовать следующий код:

```Python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

for key in capitals:
    print(key)
```

Для вывода **значений** словаря можно использовать следующий код:

```Python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

for key in capitals:
    print(capitals[key])
```

Для вывода элементов словаря каждого на отдельной строке можно использовать следующий код:

```Python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

for key in capitals:
    print('Столица', key, '- это', capitals[key])
```

Методы `keys()`, `values()`, `items()`
-        Словарный метод **keys()** возвращает **список ключей** всех элементов словаря.
-        Словарный метод **values()** возвращает **список значений** всех элементов словаря.
-        Словарный метод **items()** возвращает **список всех элементов словаря**, состоящий из **кортежей пар** (ключ, значение).

Используя магию распаковки кортежей, можно писать такой код:

```Python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

for key, value in capitals.items():
    print(key, '-', value)
```

### 4.10 Детали реализации

|Операция|Ср. сложность|Пример|Примечание|
|---|---|---|---|
|Обращение по индексу|O(1)|`d[k]`||
|Присвоение|O(1)|`d[k] = v`||
|len|O(1)|`len(d)`||
|del|O(1)|`del d[k]`||
|.setdefault|O(1)|`d.setdefault(1)`||
|.pop|O(1)|`d.pop(k)`||
|.popitem|O(1)|`d.popitem()`||
|.clear|O(1)|`d.clear()`|То же: `d = {}` и `d = dict()`.|
|Представление|O(1)|`d.keys()`||
|Создание|O(k)|`dict(obj)`|Зависит от числа кортежей (ключ, значение).|
|Проход|O(n)|`for k in d:`|То же для keys(), values(), items().|
|.copy|O(n)|`d1 = d.copy()`||

# 5. Defaultdict, OrderedDict

### 5.1. Для чего нужен defaultdict?

Если попытаться прочитать из обычного словаря значение ключа, которого там нет, то будет выброшено исключение `KeyError`. `Defaultdict` позволяет не писать обработчик исключений, а просто воспринимает чтение несуществующего ключа как команду записать в этот ключ и вернуть значение по умолчанию;

Если попытаться получить доступ (или изменить значение) по несуществующему ключу, то `defaultdict` автоматически создаст ключ и сформируют для него значение по умолчанию.

Альтернативные способы избежать возникновения такой ошибки:
1.      метод `setdefault()`
2.      метод `get()`
3.      проверка наличия ключа с помощью оператора принадлежности (`key` **in** `dict`)

Функция `defaultdict()` принимает в качестве аргумента тип элемента по умолчанию. Таким образом, для ключей, к которым происходит обращение, словарь `defaultdict` поставит в соответствие дефолтный элемент данного типа:
-        для `int` – число `0`
-        для `float` – число `0.0`
-        для `bool` – значение `False`
-        для `str` – пустая строка `''`
-        для `list` – пустой список `[]`
-        для `tuple` – пустой кортеж `()`
-        для `set` – пустое множество `set()`
-        для `dict` – пустой словарь `{}`

```Python
from collections import defaultdict


info = defaultdict(int, {'name': 'Tim', 'age': 35, 'job': 'Ingeneer'})
info1 = defaultdict(int, name='Tim', age=35, job='Ingeneer')
info2 = defaultdict(int, [('name', 'Tim'), ('age', 35), ('job', 'Ingeneer')])

print(info['salary']) # 0
print(info) # defaultdict(<class 'int'>, {'name': 'Tim', 'age': 35, 'job': 'Ingeneer', 'salary': 0})
```

Тип `defaultdict` наследуется от типа `dict`. Таким образом, все методы доступные для обычных словарей (тип `dict`), также доступны и для `defaultdict` словарей.

При создании `defaultdict` словаря можно указывать не только тип данных для значений по умолчанию, но и любую функцию, **не принимающую аргументов и возвращающую некоторое дефолтное значение**.

```Python
from collections import defaultdict


def get_default():
    return 69

info = defaultdict(get_default, {'name': 'Tim', 'age': 35, 'job': 'Engeneer'})
print(info['salary'])  # 69
```

Тип `defaultdict` работает **быстрее** чем использование методов `setdefault()` и `get()` обычного словаря (тип `dict`).

### 5.2. Когда использовать defaultdict?

Приведем несколько рекомендаций, когда удобно использовать `defaultdict`, вместо `dict`:
-        Если ваш код в значительной степени основан на словарях, и вы все время имеете дело с отсутствующими ключами, вам следует подумать об использовании `defaultdict`, а не обычного `dict`
-        Если элементы вашего словаря необходимо инициализировать некоторым значением по умолчанию, вам следует подумать об использовании `defaultdict`, вместо `dict`
-        Если ваш код использует словари для агрегирования, накопления, подсчета или группировки значений, вам следует подумать об использовании `defaultdict`, вместо `dict`

### 5.3. Тип данных OrderedDict

В Python 3.6 словари (тип `dict`) были переработаны так, чтобы повысилась их производительность. Следствием такой переработки явился один очень интересный побочный эффект — **словари стали упорядоченными**, то есть стали сохранять порядок вставки. Начиная с Python 3.7, в спецификации языка гарантируется сохранение порядка вставки элементов в словарь.

Тип `OrderedDict` является **подтипом** типа `dict`, сохраняющий порядок, в котором пары "ключ-значение" вставляются в словарь. Когда мы перебираем объект типа `OrderedDict`, его элементы перебираются в исходном порядке. Если мы обновим значение существующего ключа, то порядок останется неизменным. Если мы удалим элемент и вставим его снова, то этот элемент будет добавлен в конец словаря.

Тип `OrderedDict` является изменяемым. Мы можем вставлять новые элементы, обновлять и удалять существующие элементы.

Методы `popitem()` и `move_to_end()`

`OrderedDict` словари имеют два полезных метода:
-        метод `move_to_end()` позволяет переместить существующий элемент либо в конец, либо в начало словаря
-        метод `popitem()` позволяет удалить и вернуть элемент либо из конца, либо из начала словаря

**Сравнение словарей**

При сравнении на равенство **обычных словарей** (тип `dict`) порядок расположения их элементов **неважен**.

При сравнение на равенство `OrderedDict` словарей порядок расположения их элементов **важен**.

Тип данных `OrderedDict` написан на языке C и **реализован в виде двусвязного списка** для сохранения порядка элементов.

Тип данных `OrderedDict` проигрывает типу `dict` по производительности:
-        примерно на `40%` медленнее
-        примерно на `50%` занимает больше памяти

Различия и особенности типов `dict` и `OrderedDict` отражены в таблице:

| **Функционал** | **Тип OrderedDict** | **Тип dict** |
|--|--|--|
| сохранность порядка вставки ключей | да (начиная с Python 3.1) | да (начиная с Python 3.6) |
| удобочитаемость и сигнализация о намерениях | высокая | низкая |
| возможность менять порядок элементов | да (методы  move_to_end(), popitem()) | нет |
| производительность операций | низкая | высокая |
| потребление памяти | высокая | низкая |
| учет порядка элементов при сравнении на равенство | да | нет |
| перебор ключей в обратном порядке | да (начиная с Python 3.5) | да (начиная с Python 3.8) |
| возможность добавления пользовательских атрибутов | да (атрибут .__dict__) | нет |
| возможность использовать операторы \| и \|= | да (начиная с Python 3.9) | да (начиная с Python 3.9) |

# 6. Счетчик (counter)

### 6.1. Для чего нужен Counter?

`collections.Counter` - Отображение, в котором с каждым ключом ассоциирован счетчик. Обновление существующего ключа увеличивает его счетчик. Этот класс можно использовать для подсчета количества хешируемых объектов. В классе `Counter` реализованы операторы `+` и `-` для объединения серий и другие полезные методы, например `most_common([n])`, который возвращает упорядоченный список кортежей, содержащий `n` самых часто встречающихся элементов вместе с их счетчиками.

Счетчик подсчитывает передаваемые ему объекты. Иногда очень удобно просто передать в счетчик какой-нибудь список и сразу получить структуру данных с подсчитанными элементами.

```Python
import collections

word = collections.Counter('abracadabra') # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
word.update('aaaaazzz') # Counter({'a': 10, 'b': 2, 'r': 2, 'c': 1, 'd': 1, 'z': 3})
word.most_common(3) # [('a', 10), ('z', 3), ('b', 2)]
```

### 6.2. Тип данных Counter

Тип `Counter` является подтипом типа `dict`, специально разработанный для **подсчета хешируемых объектов** в Python. `Counter` хранит **объекты** в качестве **ключей**, а их **количество** — в качестве **значений**.

Существует несколько способов создания объектов типа `Counter`. Самый простой и распространенный способ основан на передаче коллекции с данными (список, строка, кортеж и т.д.) в конструктор типа.

```Python
from collections import Counter


counter = Counter('mississippi')     # создаем счетчик на основе строки
print(counter)  # Counter({'i': 4, 's': 4, 'p': 2, 'm': 1})
```

Мы можем преобразовать объект типа Counter в обычный словарь с помощью функции `dict()`.

Тип Counter, будучи **подтипом типа** `dict`, наследует **все методы**, предоставляемые обычным словарем. При этом вызов метода `fromkeys()` всегда будет приводить к возникновению ошибки: `NotImplementedError`, такое поведение не случайно, оно позволяет избежать ошибок неоднозначности при создании объектов типа `Counter`.

Для изменения объектов типа `Counter` мы можем использовать метод `update()`. Реализация данного метода не заменяет значения как у обычных словарей (тип `dict`), а суммирует существующие значения. При этом для **новых** объектов метод `update()` создает **новые пары ключ: количество**.

```Python
from collections import Counter


letters = Counter({'i': 4, 's': 4, 'p': 2, 'm': 1})
print(letters)  # Counter({'i': 4, 's': 4, 'p': 2, 'm': 1})

letters.update('missouri')
print(letters)  # Counter({'i': 6, 's': 6, 'p': 2, 'm': 2, 'o': 1, 'u': 1, 'r': 1})
```

Метод `update()` принимает любой **итерируемый объект**: список, строку, кортеж и т.д.

Доступ к элементам и итерирование по `Counter` словарям работает так же, как и у обычных словарей. Мы можем перебирать ключи напрямую или можем использовать словарные методы `items()`, `keys()` и `values()`.

Если обратиться по ключу, которого нет в `Counter` словаре, то ошибка `KeyError` возникать не будет. Будет возвращено **нулевое** значение. При этом ключ создан не будет.

Для подсчета объектов тип `Counter` использует высокооптимизированную функцию, написанную на языке C. Поэтому беспокоиться об эффективности использования данного типа не стоит.

### 6.3. Методы Counter

Помимо доступных для всех словарей методов, словарь `Counter` поддерживает еще четыре дополнительных:

1.      `most_common()`
2.      `elements()`
3.      `total()` (начиная с Python 3.10)
4.      `subtract()`

Метод `most_common()` возвращает **список наиболее повторяемых** элементов и **количество** каждого из них. Метод возвращает список **кортежей** вида (ключ, число повторений). Если методу `most_common()` передать целочисленный аргумент **n**, то он вернет **n** самых часто повторяющихся элементов. Для поиска самых редких элементов, можно использовать срезы с **отрицательным** шагом.

```Python
from collections import Counter


letters = Counter('mississippi')
numbers = Counter([5, 6, 7, 1, 3, 9, 9, 1, 2, 5, 5, 7, 7, 9])

print(letters.most_common())  # [('i', 4), ('s', 4), ('p', 2), ('m', 1)]
print(letters.most_common(3))  # [('i', 4), ('s', 4), ('p', 2)]
print(numbers.most_common())  # [(5, 3), (7, 3), (9, 3), (1, 2), (6, 1), (3, 1), (2, 1)]
print(letters.most_common()[-1])  # ('m', 1)
print(letters.most_common()[::-1])  # [('m', 1), ('p', 2), ('s', 4), ('i', 4)]
print(numbers.most_common()[-3:-1])  # [(6, 1), (3, 1)]
```

Для корректной работы метода `most_common()` нужно, чтобы значения в `Counter` словаре поддерживали **сортировку**.

Метод` elements()` возвращает **итератор** по элементам, в котором **каждый элемент повторяется** столько раз, во сколько установлено его значение. Элементы возвращаются в порядке их появления.

```Python
from collections import Counter


letters = Counter('mississippi')
numbers = Counter([5, 6, 7, 1, 3, 9, 9, 1, 2, 5, 5, 7, 7, 9])

print(list(letters.elements()))  # ['m', 'i', 'i', 'i', 'i', 's', 's', 's', 's', 'p', 'p']
print(list(numbers.elements()))  # [5, 5, 5, 6, 7, 7, 7, 1, 1, 3, 9, 9, 9, 2]
```
Метод `elements()` возвращает **итератор**. Для того чтобы увидеть его элементы, требуется преобразовать его в список с помощью функции `list()`.Если количество элементов по некоторому ключу меньше единицы, то метод `elements()` просто **проигнорирует** его.

В Python 3.10 появился метод `total()`, который вычисляет **сумму всех значений Counter словаря**, включая отрицательные.

```Python
from collections import Counter


letters = Counter(i=4, s=4, a=0, p=2, b=-98, m=1)
print(letters.total())
```

Метод `subtract()` вычитает из значений элементов одного словаря `Counter` значения элементов другого словаря. Метод `subtract()` подобен методу `update()`, но вычитает количества, а не складывает их. При этом у результирующего словаря значения ключей могут быть нулевыми или отрицательными.

```Python
from collections import Counter


counter1 = Counter(i=4, s=40, a=1, p=20, b=98, z=69)
counter2 = Counter(i=2, s=20, a=6, p=12, m=1, z=69)
# обновляем значения в counter1
counter1.subtract(counter2)

print(counter1)  # Counter({'b': 98, 's': 20, 'p': 8, 'i': 2, 'z': 0, 'm': -1, 'a': -5})
```

Методы `update()` и `subtract()` объединяют `Counter` словари путем **сложения** и **вычитания количества соответствующих элементов**. Python предоставляет удобные операторы сложения (`+`) и вычитания (`-`), которые могут заменить вызовы данных методов. Python также предоставляет операторы пересечения (`&`) и объединения (`|`), которые возвращают минимум и максимум из соответствующих значений.

```Python
from collections import Counter


counter1 = Counter(i=10, s=40, p=10, m=1)
counter2 = Counter(i=2, s=8, p=10, m=3)

print(counter1 + counter2)  # Counter({'s': 48, 'p': 20, 'i': 12, 'm': 4})
print(counter1 - counter2)  # Counter({'s': 32, 'i': 8})
print(counter1 & counter2)  # Counter({'p': 10, 's': 8, 'i': 2, 'm': 1})
print(counter1 | counter2)  # Counter({'s': 40, 'i': 10, 'p': 10, 'm': 3})
```

# 7. ChainMap

### 7.1. Тип данных ChainMap

В Python 3.3 в модуль `collections` добавили новый тип данных `ChainMap`, который представляет из себя объединение нескольких словарей. Этот объект группирует несколько словарей вместе, что позволяет рассматривать их как единое целое.

Объекты типа `ChainMap` обычно создаются на основе словарей.

```Python
from collections import ChainMap


# создаем пустой ChainMap объект
empty_chain_map = ChainMap()
print(empty_chain_map)  # ChainMap({})

numbers = {'one': 1, 'two': 2}
letters = {'a': 'A', 'b': 'B'}
# создаем ChainMap на основе numbers и letters
chain_map = ChainMap(numbers, letters)

print(chain_map)  # ChainMap({'one': 1, 'two': 2}, {'a': 'A', 'b': 'B'})
```

Мы также можем создавать объекты типа `ChainMap`, используя метод `fromkeys()`.

```Python
from collections import ChainMap


chain_map1 = ChainMap.fromkeys(['one', 'two', 'three'])
chain_map2 = ChainMap.fromkeys(['one', 'two', 'three'], -1)

print(chain_map1)  # ChainMap({'one': None, 'two': None, 'three': None})
print(chain_map2)  # ChainMap({'one': -1, 'two': -1, 'three': -1})
```

Для получения значений по **ключу** в `ChainMap` объектах используется такой же механизм, как и в обычных словарях (тип `dict`). Либо мы используем **квадратные скобки**, либо метод `get()`.

```Python
from collections import ChainMap


numbers = {'one': 1, 'two': 2}
letters = {'a': 'A', 'b': 'B'}
alpha_num = ChainMap(numbers, letters)

print(alpha_num['one'])  # 1
print(alpha_num['b'])  # B
print(alpha_num.get('a'))  # A
print(alpha_num.get('c'))  # None
print(alpha_num.get('d', False))  # False
```

В ситуации, когда у объединяемых словарей есть **повторяющиеся ключи**, мы получаем только **значение из первого словаря**, в котором встречается этот ключ.

Итерирование по `ChainMap` объекту происходит в **обратном порядке** от последнего указанного словаря к первому.

```Python
from collections import ChainMap


numbers = {'one': 1, 'two': 2}
letters = {'a': 'A', 'b': 'B'}
alpha_num = ChainMap(numbers, letters)

for key in alpha_num:
    print(key, '->', alpha_num[key])
```

При этом если в `ChainMap` объекте есть повторяющиеся ключи в объединяемых словарях, то мы будем получать **первое** из значений. При итерировании по `ChainMap` объекту мы можем использовать методы `keys()`, `values()`, `items()`.

Для изменения объектов типа `ChainMap` мы можем использовать те же способы, что и для изменения обычного словаря (тип `dict`). Мы можем **обновлять, добавлять, удалять и извлекать** элементы из `ChainMap` объекта. При этом нужно знать, что все эти операции действуют **только на первый из объединяемых словарей**.

```Python
from collections import ChainMap


numbers = {'one': 1, 'two': 2}
letters = {'a': 'A', 'b': 'B'}

alpha_num = ChainMap(numbers, letters)
print(alpha_num)  # ChainMap({'one': 1, 'two': 2}, {'a': 'A', 'b': 'B'})

alpha_num['c'] = 'C'
print(alpha_num)  # ChainMap({'one': 1, 'two': 2, 'c': 'C'}, {'a': 'A', 'b': 'B'})

del alpha_num['c']
print(alpha_num)  # ChainMap({'one': 1, 'two': 2}, {'a': 'A', 'b': 'B'})

alpha_num.clear()
print(alpha_num)  # ChainMap({}, {'a': 'A', 'b': 'B'})
```

При попытке удаления значения по ключу, которого **нет в первом словаре** возникает ошибка `KeyError`. **Даже если указанный ключ есть в одном из объединяемых словарей, кроме первого**.

В качестве **альтернативы объединению нескольких словарей** с помощью `ChainMap` мы можем объединять их с помощью словарного метода `update()`.

Встроенная функция `len()` возвращает **количество уникальных ключей** `ChainMap` объекта.

Тип данных `ChainMap` удобен в том случае, когда мы уже имеем **некоторую коллекцию с большим количеством словарей** и нам требуется производить **поиск по всем словарям одновременно**.

### 7.2. Методы для работы с ChainMap

Объект `ChainMap` хранит все объединяемые словари во **внутреннем списке**. Этот список доступен через атрибут `maps` и может быть изменен. Порядок словарей в списке maps соответствует порядку, в котором словари были указаны при создании объекта `ChainMap`.

```Python
from collections import ChainMap


for_adoption = {'dogs': 15, 'cats': 8, 'pythons': 9}
vet_treatment = {'dogs': 7, 'cats': 2, 'tigers': 3}
pets = ChainMap(for_adoption, vet_treatment)

print(pets)  # ChainMap({'dogs': 15, 'cats': 8, 'pythons': 9}, {'dogs': 7, 'cats': 2, 'tigers': 3})
print(pets.maps)  # [{'dogs': 15, 'cats': 8, 'pythons': 9}, {'dogs': 7, 'cats': 2, 'tigers': 3}]
print(type(pets.maps))  # <class 'list'>
```

Атрибут `maps` является **обычным списком**, поэтому он поддерживает все основные операции со списками. Мы можем добавлять в него новые словари, удалять уже добавленные, а также изменять их порядок. Атрибут `maps` можно использовать для обработки абсолютно всех значений во всех словарях. С помощью этого атрибута мы можем обойти поведение по умолчанию, заключающееся в получении (изменении) первого значения из первого словаря.

```Python
for animals in pets.maps:
    for key, value in animals.items():
        print(key, '->', value)
```

Метод `new_child(m=None)` возвращает новый объект `ChainMap()`, содержащий новый словарь `m`, за которым следуют все словари текущего объекта:
-        если указан словарь `m`, то он вставляется первым в списке существующих словарей текущего объекта `ChainMap`
-        если `m` не указан, то используется пустой словарь, который также вставляется первым

Вызов метода `d.new_child()` эквивалентен вызову `ChainMap({}, d.maps)`.

```Python
from collections import ChainMap


dad = {'name': 'Tim', 'age': 33}
mom = {'name': 'Ros', 'age': 35}
old_family = ChainMap(dad, mom)
new_family = old_family.new_child()

print(old_family) # ChainMap({'name': 'Tim', 'age': 33}, {'name': 'Ros', 'age': 35})
print(new_family) # ChainMap({}, {'name': 'Tim', 'age': 33}, {'name': 'Ros', 'age': 35})
```

Атрибут `parents` возвращает новый объект `ChainMap`, содержащий все словари, кроме первого. Это полезно для пропуска первого словаря при поиске ключей. Обращение к атрибуту `d.parents` эквивалентно вызову `ChainMap(d.maps[1:])`.

```Python
from collections import ChainMap


dad = {'name': 'Tim', 'age': 29}
mom = {'name': 'Ros', 'age': 28}
son = {'name': 'Sol', 'age': 0}
family = ChainMap(son, dad, mom)

print(family)  # ChainMap({'name': 'Sol', 'age': 0}, {'name': 'Tim', 'age': 29}, {'name': 'Ros', 'age': 28})
print(family.parents)  # ChainMap({'name': 'Tim', 'age': 29}, {'name': 'Ros', 'age': 28})
print(type(family.parents))  # <class 'collections.ChainMap'>
```

# 8. Множество (set)

### 8.1. Что такое множество?

Множество - **хеш-таблица с набором уникальных объектов**. Поэтому один из основных способов его использования – **устранение дубликатов**. Реализуют все основные теоретико-множественные операции: *объединение, пересечение, проверку на подмножество и т. д*.

```Python
l = ['spam', 'spam', 'eggs', 'spam', 'bacon', 'eggs']

set(l) # {'bacon', 'eggs', 'spam'}
```

Элементы множества **должны быть хешируемыми**. Сам тип `set` хешируемым **не является**, поэтому объекты `set` не могут вложенными.
-        Все элементы множества различны (уникальны), два элемента не могут иметь одинаковое значение;
-        Множества неупорядочены, то есть элементы не хранятся в каком-то определенном порядке;
-        Элементы множества должны относиться к неизменяемым типам данных;
-        Хранящиеся в множестве элементы могут иметь разные типы данных.

В математике множество – совокупность объектов, понимаемых как единое целое. При этом предполагается, что объекты данной совокупности можно отличать друг от друга и от объектов, не входящих в эту совокупность.

Пустое множество создаётся исключительно через `set()`, создать пустое множество с помощью пустых фигурных скобок нельзя.

### 8.2. Операции над множествами

```Python
from typing import Set


big_cities: Set["str"] = {"New-York", "Los Angeles", "Ottawa"}
american_cities: Set["str"] = {"Chicago", "New-York", "Los Angeles"}
big_cities |= {"Sydney"}  # Добавить значение (или add())
american_cities |= {"Salt Lake City", "Seattle"}  # Сложить множества (или update())

print(big_cities, american_cities) # {'Los Angeles', 'Sydney', 'Ottawa', 'New-York'} {'Chicago', 'Los Angeles', 'New-York', 'Salt Lake City', 'Seattle'}

union_cities: Set["str"] = big_cities | american_cities  # Или union()

# {'Chicago', 'Los Angeles', 'New-York', 'Ottawa', 'Salt Lake City', 'Seattle', 'Sydney'}

intersected_cities: Set["str"] = big_cities & american_cities  # Или intersection()

# {'Los Angeles', 'New-York'}
dif_cities: Set["str"] = big_cities - american_cities  # Или difference()

# {'Ottawa', 'Sydney'}
symdif_cities: Set["str"] = big_cities ^ american_cities  # Или symmetric_difference()

{'Chicago', 'Ottawa', 'Salt Lake City', 'Seattle', 'Sydney'}

big_cities.add("London")

big_cities.remove("Ottawa")  # Удаляет значение, если оно имеется или выбрасывает KeyError

big_cities.discard("Los Angeles")  # Удаляет значение без выбрасывания KeyError

big_cities.pop()  # Возвращает и удаляет случайное значение (порядок в set неопределен) или выбрасывает KeyError

big_cities.clear()  # Очищает множество
```

### 8.3. Как реализовать множественное включение (setcomp)?

```Python
{i for i in range(50, 100) if i % 2 == 0}
```

### 8.4. Операции над множествами

**Объединение множеств** – множество, состоящее **из элементов, принадлежащих хотя бы одному** из объединяемых множеств. Для объединения множеств используется символ ∪. Для этой операции существует метод `union()`

![[obs-vault/Programming/Python/attachments/dataset/20230519124729.png]]

```Python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.union(myset2)  # {1, 2, 3, 4, 5, 6, 7, 8}
```

метод `union()` возвращает **новое множество** в которое входят все элементы множеств `myset1` и `myset2`. Для изменения текущего множества используется метод `update()`.Для объединения двух множеств можно также использовать оператор `|`

**Пересечение множеств** – множество, состоящее **из элементов, принадлежащих одновременно каждому** из пересекающихся множеств. Для пересечения множеств используется символ ∩. Для этой операции существует метод `intersection()`.

![[obs-vault/Programming/Python/attachments/dataset/20230519124850.png]]

```Python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.intersection(myset2)  # {3, 4}
```

метод `intersection()` возвращает новое множество в которое входят общие элементы множеств `myset1` и `myset2`. Для изменения текущего множества используется метод `intersection_update()`.

**Разность** множеств – множество, в которое входят только элементы первого множества, не входящие во второе множество. Для разности множеств используется символ ∖. Для этой операции существует метод `difference()`.

![[obs-vault/Programming/Python/attachments/dataset/20230519125037.png]]

```Python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.difference(myset2)  # {1, 2, 5}
```

Для разности двух множеств можно также использовать оператор `-`.

**Симметрическая разность** множеств – множество, включающее все элементы исходных множеств, не принадлежащие одновременно обоим исходным множествам. Для симметрической разности множеств используется символ `△`. Для этой операции существует метод `symmetric_difference()`.

![[obs-vault/Programming/Python/attachments/dataset/20230519125147.png]]

```Python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.symmetric_difference(myset2)  # {1, 2, 5, 6, 7, 8}
```

Для симметрической разности двух множеств можно также использовать оператор `^`

Методы `union(), intersection(), difference(), symmetric_difference()` **не изменяют исходные множества**, а возвращают новые. Часто на практике нужно изменять исходные множества. Для таких целей используются парные методы `update(), intersection_update(), difference_update(), symmetric_difference_update()`.

| **Операция** | **Метод** | **Описание** |
|--|--|--|
| A \| B | `A.union(B)` | Возвращает множество, являющееся объединением множеств `A` и `B` |
| A \|= B | `A.update(B)` | Добавляет в множество `A` все элементы из множества `B` |
| A & B | `A.intersection(B)` | Возвращает множество, являющееся пересечением множеств `A` и `B` |
| A &= B | `A.intersection_update(B)` | Оставляет в множестве `A` только те элементы, которые есть в множестве `B` |
| A - B | `A.difference(B)` | Возвращает разность множеств `A` и `B` |
| A -= B | `A.difference_update(B)` | Удаляет из множества `A` все элементы, входящие в `B` |
| A ^ B | `A.symmetric_difference(B)` | Возвращает симметрическую разность множеств `A` и `B` |
| A ^= B | `A.symmetric_difference_update(B)` | Записывает в `A` симметрическую разность множеств `A` и `B` |

### 8.5. Подмножества и надмножества

Множество `set1` является подмножеством множества `set2`, если все элементы первого входят во второе. При этом множество `set2` – надмножество множества `set1`.

Метод `issubset()` - Данный метод возвращает значение `True`, если одно множество является подмножеством другого, и `False`, если не является.

```Python
set1 = {2, 3}
set2 = {1, 2, 3, 4, 5, 6}
print(set1.issubset(set2))  # True
```

Метод `issuperset()` - Данный метод возвращает значение `True`, если одно множество является надмножеством другого, в противном случае он возвращает `False`.

```Python
set1 = {'a', 'b', 'c', 'd', 'e'}
set2 = {'c', 'e'}
print(set1.issuperset(set2))  # True
```

Метод `isdisjoint()` - Данный метод возвращает значение `True`, если множества не имеют общих элементов, и  `False`, когда множества имеют общие элементы.

```Python
set1 = {1, 2, 3, 4, 5}
set2 = {5, 6, 7}
set3 = {7, 8, 9}

print(set1.isdisjoint(set2))  # False
print(set1.isdisjoint(set3))  # True
print(set2.isdisjoint(set3))  # False
```

| **Операция** | **Описание** |
|--|--|
| set1 <= set2 set1.issubset(set2) | Возвращает True, если set1 является подмножеством set2 |
| set1 >= set2 set1.issuperset(set2) | Возвращает True, если set1 является надмножеством set2 |
| set1 < set2 | Эквивалентно set1 <= set2 and set1 != set2 (строгое подмножество) |
| set1 > set2 | Эквивалентно set1 >= set2 and set1 != set2 (строгое надмножество) |

### 8.6. Когда следует использовать множество?

Оператор принадлежности `in` работает очень быстро на **множествах**, намного быстрее чем на списках. Поэтому если требуется часто осуществлять поиск в коллекции уникальных данных, то множество – подходящий выбор.

Множества используют **много памяти**, зато **скорость обработки элементов заметно быстрее**.

Индексация и срезы **недоступны** для множеств

### 8.7. Детали реализации множества

Множества в **CPython** очень похожи на словари. По сути дела, они реализованы как словари с фиктивными значениями, где только ключи являются фактическими элементами коллекции.

Добавление, получение и удаление элемента, имеют среднюю сложность `O(1)`, худший случай - `O(n)`. Перебор элементов множества - `O(n)`.

|Операция|Ср. сложность|Пример|Примечание|
|---|---|---|---|
|len|O(1)|`len(s)`||
|.add|O(1)|`s.add(5)`||
|Проверка на входимость|O(1)|`x in s`|А у списков/кортежей — O(n).|
|.remove|O(1)|`s.remove(5)`|А у списков/кортежей — O(n).|
|.discard|O(1)|`s.discard(5)`||
|.pop|O(1)|`s.pop(i)`|А у списков/кортежей — O(n).|
|.clear|O(1)|`s.clear()`|Равно как и `s = set()`.|
|Создание|O(len(t))|`set(t)`||
|Проверки `==`, `!=`|O((len(s))|`s != t`||
|.issubset|O(len(s))|`s.issubset(t)`||
|.issuperset|O(len(t))|`s.issuperset(t)`||
|.union|O(len(s)+len(t))|`s.union(t)`||
|.intersection|O(min(len(s), len(t)))|`s.intersection(t)`|Заменить min на max, если `t` не множество.|
|.difference|O(len(s))|`s.difference(t)`||
|.symmetric_difference|O(len(s))|`s ^ t`||
|Проход|O(n)|`for v in s:`||
|.copy|O(n)|`s.copy()`||

# 9. Иммутабельное множество (frozen set)

### 9.1. Что такое frozen set?

Замороженное множество (`frozenset`) также является встроенной коллекцией в Python. Обладая характеристиками обычного множества, `frozenset` не может быть изменено после создания.

Замороженные множества являются неизменяемыми, а значит могут быть элементами других множеств.

**Frozen set** — то же множество, только **иммутабельное** и **хешируемое**. Напоминает разницу между списком и кортежем.

```Python
a = frozenset({"New-York", "Los Angeles", "Ottawa"})
```

# 10. Массив (array, bytes, bytearray)

### 10.1. Для чего нужен массив?

Массив хранит переменные определенного типа, поэтому, в отличие от списка, не требует создания нового объекта для каждой новой переменной и выигрывает у списка в размерах и скорости доступа.

Массив в Python не является структурой данных, выбираемой по умолчанию и используется только в случаях, когда решающую роль начинают играть размер структуры и скорость её обработки.

Если список содержит только числа, то тип array.array эффективнее, чем `list`: он поддерживает все операции над изменяемыми последовательностями, а также дополнительные методы для быстрой загрузки и сохранения, например `.frombytes` и `.tofile`. Массив Python занимает столько же памяти, сколько массив C. При создании экземпляра `array` задается код типа – буква, определяющая, какой тип языка C использовать для хранения элементов.

```Python
from array import array
from random import random


lst = [random() for i in range(100000)]
fl = array('d', (random() for i in range(100000)))

print(lst.__sizeof__())  # 824440
print(fl.__sizeof__())  # 816624
```

### 10.2. Типы массивов в Python?

Следует различать:
-        **array** («просто» массив);
-        **bytes** (иммутабельный массив, содержащий только байты, наследие str из Python 2);
-        **bytearray** (мутабельный байтовый массив);

```Python
from array import array


a1 = array("l", [1, 2, 3, -4])
a2 = array("b", b"1234567890a")
b = bytes(a2)

print(a1) # array('l', [1, 2, 3, -4])
print(a2) # array('b', [49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 97])
print(b) # b'1234567890a'
print(a1.index(-4)) # 3
```

# 11. Связанные списки

### 11.1. Что такое односвязный список?

**Односвязный список** представляет **набор связанных узлов**, каждый из которых хранит **собственные данные и ссылку на следующий узел**. В Python встроенной реализации не имеет, можно или использовать `deque` (в основе которого лежит двусвязный список), или написать свою реализацию.

### 11.1.1 Реализация односвязного списка

Важно отметить, что положение первого элемента должно быть определено явно. Поскольку мы знаем, где он находится, то можем найти местоположение второго и так далее. Внешнюю ссылку часто называют **головой** списка. Аналогично, последнему элементу нужно знать, что за ним больше ничего нет.

Основным блоком в реализации связанного списка является **узел**(Node). Каждый такой объект должен обладать как минимум двумя информационными составляющими. Во-первых, узел должен содержать сам элемент списка. Мы назовём это **полем данных** узла. Дополнительно он должен хранить ссылку на следующий узел.

```Python
class Node:
    def __init__(self, initdata):
        self.data = initdata
        self.next = None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data = newdata

    def setNext(self,newnext):
        self.next = newnext
```

Специальное ссылочное значение Python `None` играет важную роль и в классе `Node`, и в самом связанном списке. Обратите внимание, что конструктор первоначально создаёт узел с next, установленным в `None`. Явное присвоение `None` начальному значению ссылки на следующий элемент - неизменно хорошая идея.

![[Pasted image 20230717155346.png]]

Неупорядоченный список будет представлять из себя **коллекцию узлов, каждый из которых связан со следующим посредством явной ссылки**. Пока мы знаем, как найти первый узел (содержащий первый элемент), каждый последующий будет обнаружен с помощью успешного следования по ссылкам.

```Python
class UnorderedList:
    def __init__(self):
        self.head = None

	def isEmpty(self):
	    return self.head == None

	def add(self,item):
	    temp = Node(item)
	    temp.setNext(self.head)
	    self.head = temp

	def size(self):
	    current = self.head
	    count = 0
	    while current != None:
	        count = count + 1
	        current = current.getNext()
	
	    return count

	def search(self,item):
	    current = self.head
	    found = False
	    while current != None and not found:
	        if current.getData() == item:
	            found = True
	        else:
	            current = current.getNext()
	
	    return found

	def remove(self,item):
	    current = self.head
	    previous = None
	    found = False
	    while not found:
	        if current.getData() == item:
	            found = True
	        else:
	            previous = current
	            current = current.getNext()
	
	    if previous == None:
	        self.head = current.getNext()
	    else:
	        previous.setNext(current.getNext())


mylist = UnorderedList()
mylist.add(31)
mylist.add(77)
mylist.add(17)
mylist.add(93)
mylist.add(26)
mylist.add(54)
```

Метод `isEmpty`, просто проверяет, ссылается ли голова списка на `None`. Результат булева выражения `self.head==None` будет истинным только если в связанном списке нет узлов.

Метод `add`  - структура связанного списка предоставляет нам всего одну точку входа - *голову списка*. Все прочие узлы можно достигнуть только через доступ к первому узлу по цепочке из ссылок `next`. Это подразумевает, что самое простое место для добавления нового узла - это *голова, начало списка*. Другими словами, мы будем создавать новый элемент в качестве первого в списке, а существующие элементы нужно будет связать так, чтобы они следовали за ним. Каждый элемент должен быть обёрнут в объект `Node`. Строка 2 метода создаёт новый узел и размещает в его поле данных заданный элемент. Теперь нужно завершить процесс, связав новый узел с существующей структурой. Это требует двух шагов. 
1. Шаг 1 (строка 3) изменяет ссылку `next` нового узла, чтобы она указывала на предыдущий.
2. Шаг 2 (строка 4) Теперь, когда остаток соответствующим образом присоединён к новому узлу, мы можем изменить голову списка, чтобы она тоже ссылалась на новый узел. 

![[Pasted image 20230717161217.png]]

Метод `size` для его реализации достаточно просто обойти связанный список и подсчитать количество встреченных узлов.

![[Pasted image 20230717161730.png]]

Метод `search` - реализация поиска значения в связанном списке для неупорядоченного списка также использует технику обхода. В процессе посещения каждого узла мы запрашиваем, как его данные соотносятся с тем элементом, который мы ищем. Однако, в этом случае нам может и не понадобиться обходить весь список до конца. Фактически, если мы добрались до конца списка, то искомого элемента он не содержит. А если мы нашли нужное, то нет смысла продолжать обход. Как и в методе `size` обход начинается с головы списка (строка 2). Мы также используем булеву переменную `found`, чтобы помнить, нашли ли мы искомое. Поскольку в начале обхода ещё ничего не найдено, то `found` устанавливается в `False` (строка 3). Цикл в строке 4 принимает оба описанных выше условия. До тех пор, пока есть узлы для посещения и искомый элемент не найден, мы продолжаем проверку. Строка 5 спрашивает: не находится ли в этом узле то, что нам нужно? Если ответ “да”, то `found` выставляется в `True`.

![[Pasted image 20230717162106.png]]
Метод `remove` логически требует двух стадий. Сначала надо обойти список, чтобы найти удаляемый элемент. Как только это случится (напомним, что мы предполагаем наличие искомого в списке), последует удаление. Для того, чтобы удалить нужный узел, нам нужно изменить ссылку его предшественника таким образом, чтобы она ссылалась на узел после `current`. Чтобы это  осуществить мы будем использовать две внешние ссылки в процессе обхода списка. `current` будет вести себя как раньше, отмечая текущее положение обхода. Новая ссылка, которую мы назовём `previous`, будет всегда идти на один узел позади `current`. Таким образом, когда `current` остановится на удаляемом узле, `previous` будет указывать на место для соответствующей модификации связанного списка.

![[Pasted image 20230717162428.png]]

### 11.2. Что такое двусвязный список (Deque)?

**Двусвязный список** представляет **набор связанных узлов**, каждый из которых хранит **собственные данные и ссылки указывающие на предыдущий и на последующий узел** в списке. Можно использовать `deque` (двусторонняя очередь *FIFO*), или написать свою реализацию.

Класс `collections.deque` – это потокобезопасная двусторонняя очередь, предназначенная для быстрой вставки и удаления из любого конца. Эта структура удобна и для хранения списка «последних виденных элементов» и прочего в том же духе, т.к. `deque` можно сделать ограниченной (при создании задать максимальную длину). Тогда по заполнении `deque` добавление новых элементов приводит к удалению элементов с другого конца.

```Python
from collections import deque


d = deque([1, 2, 3, 4], maxlen=1000)  # Конструктор очереди
d.append(5)  _# Добавляет элемент в конец очереди_
d.appendleft(0)  _# Добавляет элемент в начало очереди_
d.extend([6, 7])  _# Расширяет очередь, добавляя элементы в конец_
d.extendleft([-1, -2])  _# Расширяет очередь, добавляя элементы в начало_
d.pop()  _# Удаляет элемент с конца очереди и возвращает его_
d.popleft()  _# Удаляет элемент с начала очереди и возвращает его_
```

Но существует и скрытая неэффективность: удаление элементов из середины deque производится медленно. Эта структура данных оптимизирована для добавления и удаления элементов только с любого конца.

Операции `append` и `popleft` атомарны, поэтому `deque` можно безопасно использовать как *FIFO*-очередь в многопоточных приложениях без явных блокировок.

### 11.3. Для чего предназначен модуль queue?

Содержит синхронизированные (т. е. потокобезопасные) классы:
- `Queue` (реализует *FIFO*), 
- `LifoQueue` (реализует *LIFO*) 
- `PriorityQueue` (реализует очереди с приоритетом). 
 
Они используются для **безопасной коммуникации между потоками**. Все три очереди можно сделать ограниченными, передав конструктору аргумент `maxsize`, больший `0`. Однако, в отличие от `deque`, в случае переполнения элементы не удаляются из очереди, чтобы освободить место, а блокируется вставка новых элементов, т. е. программа ждет, пока какой-нибудь другой поток удалит элемент из очереди. Это полезно для ограничения общего числа работающих потоков. Может быть особенно полезен при многопоточности, позволяя корректно обмениваться информацией между потоками.

# 12. Деревья

Дерево состоит из **набора узлов** и **набора ветвей**, соединяющих пары узлов. Оно имеет следующие свойства:
- Один из узлов дерева определён, как его корень.
- Каждый узел \(n\) (кроме корневого) соединяется ветвью с единственным другим узлом \(p\), где \(p\) - родитель \(n\).
- Каждый узел соединён с корнем единственно возможным путём.
- Если каждый из узлов дерева имеет максимум двух потомков, то такая структура называется **двоичным деревом**.

*Рекурсивное определение дерева*

Дерево либо пусто, либо содержит корень и нуль или более поддеревьев, каждое из которых тоже является деревом. Корень каждого поддерева соединён ветвью с родительским деревом.

**Узел** - это основная часть дерева. Он может иметь название, которое мы будем называть “ключом”. Также узел может содержать дополнительную информацию, которую мы будем называть “полезной нагрузкой”. Хотя во многих алгоритмах для деревьев ей не уделяется достаточно внимания, для приложений, использующих эту структуру данных, она часто оказывается критичным фактором.

**Ветвь** - другая фундаментальная часть дерева. Оно соединяет два узла вместе, показывая наличие между ними определённых отношений. Каждый узел (кроме корня) имеет ровно одну входящую ветвь. При этом он может иметь несколько исходящих ветвей.

**Корень дерева** - единственный узел, не имеющий входящих ветвей. На [_рисунке 2_](Pasted image 20230717172049.png) `/` - корень дерева.

**Путь** - это упорядоченный список узлов, соединённых ветвями. Например, Mammal -> Carnivora -> Felidae -> Felis -> Domestica - это путь.

**Дети (потомки)** - Набор узлов, имеющих входящие ветви от одного узла, называются его детьми. На *рисунке 2* узлы `log/`, `spool/` и `yp/` - потомки узла `var/`.

**Родитель (предок)** - Узел является родителем всех узлов, с которыми связан исходящими ветвями. На *рисунке 2* узел `var/` является родителем узлов `log/`, `spool/` и `yp/`.

**Братья** - Узлы дерева, являющиеся детьми одного родителя, называют братьями. Примером могут послужить `etc/` и `usr/` в дереве файловой системы.

**Поддерево** - это набор узлов и ветвей, состоящий родителя и всех его потомков.

**Лист** - это узел, у которого нет детей. Например, `/usr/bin/` и `/var/log/` - листья на *рисунке 1*.

**Уровень узла (n)** - это число ветвей в пути от корня до \(n\). Например, уровень `/var/log/` на *рисунке 1* равен двум. По определению, уровень корня - нулевой.

**Высота** дерева равна максимальному уровню любого его узла. Например, высота дерева на *рисунке 1* равна двум.


![[Pasted image 20230717172049.png]]

![[Pasted image 20230717172151.png]]


**Представление дерева в виде списка списков**

В дереве, представленном как список списков, на первой позиции мы будем хранить значение корневого узла. Второй элемент сам по себе будет списком и представит левое поддерево. Третий элемент станет правым поддеревом. Рисунок ниже демонстрирует простое дерево и связанную с ним списковую реализацию.

![[Pasted image 20230719134904.png]]

```Python
myTree = ['a',   #root
		    ['b',  #left subtree
			   ['d' [], []],
			   ['e' [], []] 
			],
		    ['c',  #right subtree
		       ['f' [], []],
		       [] 
		    ]
	     ]
```

Теперь у нас есть доступ к каждому из поддеревьев с использованием стандартной списковой индексации. Корень дерева - `myTree[0]`, левое поддерево - `myTree[1]`, правое - `myTree[2]`. Одно из приятных свойств подхода со списком списков заключается в том, что структура списка, представляющего поддерево, твёрдо придерживается определения дерева - она рекурсивна сама по себе! У поддерева есть корень и два пустых списка в качестве листьев. Другое положительное качество списка списков состоит в том, что он легко расширяется до дерева, имеющего много поддеревьев. Т.е. в случае, когда дерево не является двоичным, новое поддерево - это всего лишь новый подсписок.

```Python
myTree = ['a', ['b', ['d',[],[]], ['e',[],[]] ], ['c', ['f',[],[]], []] ]
print(myTree)
print('left subtree = ', myTree[1])
print('root = ', myTree[0])
print('right subtree = ', myTree[2])
```

Давайте формализуем это определение с помощью некоторых функций, которые сделают проще использование списков в качестве деревьев. Обратите внимание, мы не собираемся определять новый класс для двоичного дерева. Функции, которые будут написаны, всего лишь помогут манипулировать стандарным списком, с которым мы работаем, как с деревом.

```Python
def BinaryTree(root):
    return [root, [], []]
```

Функция `BinaryTree` просто создаёт список из корневого узла и двух пустых подсписков в качестве его потомков. Чтобы добавить к корню левое поддерево, нам нужно вставить на вторую позицию новый список. Тут следует быть внимательными. Если на второй позиции уже что-то имеется, то этот факт нужно отследить и сдвинуть элемент вниз по дереву, как левого потомка добавляемого списка.

```Python
def insertLeft(root, newBranch):
    t = root.pop(1)
    
    if len(t) > 1:
        root.insert(1,[newBranch,t,[]])
    else:
        root.insert(1,[newBranch, [], []])
    
    return root
```

Обратите внимание, что прежде, чем вставлять что-либо, мы получаем (возможно пустой) список, связанный с текущим левым потомком. Когда мы вставляем новое левое поддерево, то старое делаем его левым потомком. Благодаря этому мы можем встраивать новый узел на любую позицию в дереве. Код для `insertRight` аналогичен `insertLeft`

```Python
def insertRight(root,newBranch):
    t = root.pop(2)
    
    if len(t) > 1:
        root.insert(2,[newBranch,[],t])
    else:
        root.insert(2,[newBranch,[],[]])

    return root
```

Чтобы закончить с набором для создания дерева, давайте напишем несколько функций доступа для установки и получения значений в корне и правого и левого поддеревьев.

```Python
def getRootVal(root):
    return root[0]

def setRootVal(root,newVal):
    root[0] = newVal

def getLeftChild(root):
    return root[1]

def getRightChild(root):
    return root[2]
```

 Код демонстрирующий основные функции для работы с деревьями.

```Python
r = BinaryTree(3)
insertLeft(r,4)
insertLeft(r,5)
insertRight(r,6)
insertRight(r,7)
l = getLeftChild(r)
print(l)

setRootVal(l,9)
print(r)
insertLeft(l,11)
print(r)
print(getRightChild(getRightChild(r)))
```

Второй способ представления деревьев будет использовать узлы и ссылки. Для этого случая мы определим класс, чьими атрибутами станут корневое значение и левое и правое поддеревья.

Используя узлы и ссылки, о дереве можно думать, как о структуре, пример которой приведён ниже:
![[Pasted image 20230725092707.png]]

Начнём с простого определения класса для варианта с узлами и ссылками. Важно помнить, что в этом представлении атрибуты `left` и `right` являются ссылками на другие сущности класса `BinaryTree`. Например, когда мы вставляем нового левого потомка в дерево, мы создаём другой объект `BinaryTree` и изменяем `self.leftChild` корня, чтобы этот атрибут ссылался на новое дерево.

```Python
class BinaryTree:
    def __init__(self,rootObj):
        self.key = rootObj
        self.leftChild = None
        self.rightChild = None
```

Далее давайте рассмотрим функцию, которую требуется написать для строительства дерева за пределы корневого значения. Чтобы добавить левого потомка в дерево, мы создадим новый объект двоичного дерева и поместим в его атрибут корня `left` ссылку на новый объект. Код для `insertLeft` показан в ниже.

```Python
def insertLeft(self,newNode):
    if self.leftChild == None:
        self.leftChild = BinaryTree(newNode)
    else:
        t = BinaryTree(newNode)
        t.leftChild = self.leftChild
        self.leftChild = t
```

Нам необходимо рассмотреть два случая вставки. Первый - для узла, у которого нет левого потомка. В этом варианте узел просто вставляется в дерево. Второй вариант характеризуется узлом, имеющим левого потомка. Тогда нам надо вставить новый узел и спустить имеющегося потомка на один уровень ниже. Этот случай управляется оператором `else` в строке 4

Код для `insertRight` должен содержать симметричный набор случаев.

```Python
def insertRight(self,newNode):
    if self.rightChild == None:
        self.rightChild = BinaryTree(newNode)
    else:
        t = BinaryTree(newNode)
        t.rightChild = self.rightChild
        self.rightChild = t
```

Завершая наше определение простого двоичного дерева, напишем методы доступа к корню, правому и левому потомкам

```Python
def getRightChild(self):
    return self.rightChild

def getLeftChild(self):
    return self.leftChild

def setRootVal(self,obj):
    self.key = obj

def getRootVal(self):
    return self.key
```

## 12.1 Обход дерева

Существует три способа обхода дерева:

**Обход в прямом порядке**
В этом случае мы сначала посещаем корневой узел, затем рекурсивно обходим в прямом порядке левое поддерево, после чего таким же образом обходим правое.

```Python
def preorder(self):
    print(self.key)
    if self.leftChild:
        self.left.preorder()
    if self.rightChild:
        self.right.preorder()
```

**Симметричный обход**
Сначала мы симметрично обходим левое поддерево, затем посещаем корневой узел, затем - правое поддерево.

```Python
def inorder(tree):
  if tree != None:
      inorder(tree.getLeftChild())
      print(tree.getRootVal())
      inorder(tree.getRightChild())
```

**Обход в обратном порядке**
Сначала делается рекурсивный обратный обход левого и правого поддеревьев, после чего посещается корневой узел.

```Python
def postorder(tree):
    if tree != None:
        postorder(tree.getLeftChild())
        postorder(tree.getRightChild())
        print(tree.getRootVal())
```

## 12.2. Что такое Бинарное дерево (binary tree)?

**Иерархическая структура данных, в которой каждый узел имеет не более двух потомков**. В Python встроенной реализации не имеет.

## 12.3. Что такое Куча (heap)?

**Кучи** — это **бинарные деревья**, для которых каждый **родительский узел имеет значение, меньшее или равное любому из его дочерних элементов**, если `B` является узлом-потомком узла `A`, то `ключ(A) ≥ ключ(B)`. Куча является максимально эффективной реализацией абстрактного типа данных, который называется очередью с приоритетом и поддерживающего две обязательные операции — добавить элемент и извлечь минимум (или максимум, в зависимости от реализации).

В Python min-куча (наименьшее значение всегда лежит в корне) реализована на базе списка при помощи встроенного модуля `heapq`.

```Python
import heapq


h = [211, 1, 43, 79, 12, 5, -10, 0]

heapq.heapify(h) # Преобразует список в кучу
print(h) # [-10, 0, 5, 1, 12, 211, 43, 79]

heapq.heappush(h, 2)
print(h) # [-10, 0, 5, 1, 12, 211, 43, 79, 2]

min = heapq.heappop(h)
print(min, h) # -10 [0, 1, 5, 2, 12, 211, 43, 79]
```

## 12.4. Что такое Би-дерево (B-tree)?

**B-tree** - Сбалансированное дерево, оптимизированное для доступа к относительно медленным элементам памяти (например, дисковым структурам или индексам баз данных); как ветви, так и листья представляют собой списки (для того, чтобы можно было считать такой список в один проход для дальнейшего быстрого разбора в ОЗУ).

в Python не имеет встроенной реализации.

## 12.5. Что такое красно-черное дерево?

Самобалансирующееся двоичное дерево поиска, позволяющее быстро выполнять основные операции: добавление, удаление и поиск узла. Сбалансированность достигается за счёт введения дополнительного признака узла дерева — «цвета». Этот атрибут может принимать одно из двух возможных значений — «чёрный» или «красный». Листовые узлы КЧ деревьев не содержат данных, поэтому не требуют выделения памяти — достаточно просто записать в узле-предке нулевой указатель на потомка.

## 12.6. Что такое АВЛ-дерево?

АВЛ-дерево реализуется так же, как и обычное двоичное дерево поиска. Единственное отличие состоит в принципе его работы. Чтобы воплотить АВЛ-дерево, нам потребуется отслеживать **фактор сбалансированности** для всех узлов, следя за высотой левого и правого поддеревьев каждого из них. Более формально фактор сбалансированности равен разнице между высотами его правого и левого поддеревьев.

В АВЛ-деревьях операции вставки и удаления работают медленнее, чем в красно-черных деревьях, но поиск в АВЛ-дереве выполняется быстрее.

Несбалансированное, перевешивающее вправо дерево и факторы баланса для его узлов
![[Pasted image 20230725095335.png]]

## 12.7. Что такое префиксное дерево?

Структура данных, позволяющая хранить ассоциативный массив, ключами которого являются строки. Представляет собой корневое дерево, каждое ребро которого помечено каким-то символом так, что для любого узла все рёбра, соединяющие этот узел с его сыновьями, помечены разными символами. Получить ключ можно выписыванием подряд символов, помечающих рёбра на пути от корня до узла. Ключ корня дерева — пустая строка.

![[obs-vault/Programming/Python/attachments/dataset/20230519141650.png]]

# 13. Как выбрать структуру данных?

| **Структура** | **Реализация** | **Применение** | **Индексация** | **Поиск** | **Вставка** | **Удаление** | **Память** |
|--|--|--|--|--|--|--|--|
| Динамический массив | list |  | О(1) | О(n) |  О(n) |  О(n) |  О(n) |
| Хэш таблица | dict, set |  |  | О(1)[О(n)] | О(1)[О(n)] | О(1)[О(n)] | О(n) |
| Массив | array, bytes, bytearray | Для хранения однотипных данных | О(1) | О(n) |  О(n) |  О(n) |  О(n) |
| Односвязный список | - (~deque) |  | О(n) | О(n) |  О(1) |  О(1) |  О(n) |
| Двусвязный список | deque | FIFO, LIFO | О(n) | О(n) |  О(1) |  О(1) |  О(n) |
| Бинарное дерево | - |  | O(log n) [О(n)] | O(log n) [О(n)] |  O(log n) [О(n)] |  O(log n) [О(n)] |  О(n) |
| Куча | heapq | Очередь с приоритетом | О(1) | (find min) |  O(log n) |  O(log n) (del min) |  О(n) |
| B-tree (Би-дерево) | ~sqlite | Для памяти с медленным доступом | O(log n) | O(log n) |  O(log n) |  O(log n) |  O(log n) |
| КЧ дерево | - |  | O(log n) | O(log n) |  O(log n) |  O(log n) |  О(n) |
| АВЛ дерево | - |  | O(log n) | O(log n) |  O(log n) |  O(log n) |  О(n) |
| Префиксное дерево | - | T9,алгоритм [Ахо–Корасик](https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm),  алгоритм [LZW](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch) |  | key | key|  key |  |

# 14. Enum

### 14.1. Что такое перечисления (Enum, IntEnum)?

**Перечисления** - конструкции для определения заранее известных значений.

```Python
from enum import Enum, auto


class ResourceType(Enum):
    BOOK = auto()
    EBOOK = auto()
    VIDEO = auto()

ResourceType.BOOK     # <ResourceType.BOOK: 1>
ResourceType['BOOK']  # <ResourceType.BOOK: 1>
ResourceType(1)       # <ResourceType.BOOK: 1>

book = ResourceType(1)
book.name             # 'BOOK'
book.value            # 1
list_of_members = list(ResourceType) 
# [<ResourceType.BOOK: 1>, <ResourceType.EBOOK: 2>, <ResourceType.VIDEO: 3>]

member_names = [e.name for e in ResourceType]   # ['BOOK', 'EBOOK', 'VIDEO']
member_values = [e.value for e in ResourceType] # [1, 2, 3]
```

# 15. Range

### 15.1. Что такое целочисленный диапазон (range)?

**range()** возвращает *иммутабельную последовательность* чисел, которая часто используется как диапазон для цикла for.

```Python
r1: range = range(11)        # Возвращает последовательность чисел от 0 до 10_
r2: range = range(5, 21)     # Возвращает последовательность чисел от 5 до 20_
r3: range = range(20, 9, -2) # Возвращает последовательность чисел от 20 до 10 с шагом 2
```

# 16. Dataclass

### 16.1. Что такое классы данных (dataclass)?

**Класс данных** - **декоратор, автоматически создающий методы** `init()`, `repr()` и `eq()`. Нужен для создания классов, главной задачей которых является хранение данных. Аннотации типов обязательны. Существует начиная с версии Python 3.7.

```Python
from dataclasses import dataclass, field
from datetime import datetime


@dataclass
class Transaction:
    value: int
    issuer: str = "Default Bank"
    dt: datetime = datetime.now()
    cards: list = field(default_factory=list)

t1 = Transaction(value=1000_000, issuer="Deutsche Bank", dt = datetime(2022, 1, 1, 12))  # Transaction(value=1000, issuer='Default Bank', dt=datetime.datetime(2022, 11, 24, 11, 42, 43, 597194), cards=[])

t2 = Transaction(1000)  
# Transaction(value=1000000, issuer='Deutsche Bank', dt=datetime.datetime(2022, 1, 1, 12, 0), cards=[])
```

`dataclass` может быть сделан **иммутабельным** с директивой `frozen=True`.

```Python
from dataclasses import dataclass


@dataclass(frozen=True)
class User:
    name: str
    account: int
```

# 17. Строка (string)

### 17.1. Что такое строки в Python?

Строки в Python 3 — **неизменяемые** (**иммутабельные**) **последовательности** Unicode символов

### 17.2. Какие основные методы строк?

```Python
# Пустая строка
se: str = ""

# Создает строку из числа
si: str = str(12345)

# Собирает строку, используя указанный разделитель
sj: str = " ".join(["Follow", "the", "white", "rabbit"])  # “Follow the white rabbit”

# Проверка наличия подстроки в строке
is_contains: bool = "rabbit" in sj  # True
is_startswith: bool = sj.startswith("Foll")  # True
is_endswith: bool = sj.endswith("bbit")  # True

# Замена подстроки. Можно указать количество замен: sj.replace("rabbit", "sheep", times)
sr: str  = sj.replace("rabbit", "sheep")

# Возвращает стартовый индекс первого вхождения или -1.
i1 = sr.find("rabbit")

#  Возвращает стартовый индекс первого вхождения или выкидывает ValueError.
i2 = sr.index("sheep")

# замена символов в строке
d = str.maketrans({"a" : "x", "b" : "y", "c" : "z"})
st  = "abc".translate(d)  # “xyz”

# Реверс через slice с отрицательным шагом
sr = sj[::-1]  # tibbar etihw eht wolloF
```

# 18.  Datetime

### 18.1. Какие типы предназначены для работы с датой и временем?

Время в компьютере хранится для человека в довольно неудобном виде. Это количество секунд, прошедших с полуночи **1 января 1970 года (00:00:00 UTC)**, этот момент называют *«эпохой Unix*».

Модуль `datetime` **состоит из нескольких типов данных**. Все они **хешируемы и иммутабельны**. Благодаря их наличию, программист получает доступ ко многим полезным методам:
-        Получение текущих системных даты и времени
-        Вычисление разницы между датами и другие арифметические операции над ними
-        Сравнение даты и времени
-        Форматированный вывод информации о дате и времени

| **Название типа данных** | **Характеристика** |
|--|--|
| date | Представляет собой информацию о дате, исключая данные о времени, на основе Григорианского календаря |
| time | Представляет собой информацию о времени, полностью исключая сведения о дате |
| datetime | Содержит информацию о времени и дате, основываясь на данных из Григорианского календаря |
| timedelta | Описывает определенный период во времени, который находится между двумя различными моментами |
| tzinfo | Представляет различные сведения о часовом поясе |
| timezone | Описывает время, руководствуясь стандартом UTC |

```Python
from datetime import date, time, datetime, timedelta


# 1992-10-06
my_date = date(1992, 10, 6)  # тип date: год + месяц + день

# 1964-09-02
d: date = date(year=1964, month=9, day=2)

# 12:30:00
t: time  = time(hour=12, minute=30, second=0, microsecond=0, tzinfo=None, fold=0)

# 1964-09-02 10:30:00
dt: datetime = datetime(year=1964, month=9, day=2, hour=10, minute=30, second=0)

# 8 days, 12:13:14
td: timedelta = timedelta(weeks=1, days=1, hours=12, minutes=13, seconds=14)
```

### 18.2. Как получить текущую дату или дату/время?

```Python
from datetime import date, datetime
import time


d: date  = date.today()           # 2022-12-08
dt1: datetime = datetime.today()  # 2022-12-08 16:03:57.362000
dt2: datetime = datetime.utcnow() # 2022-12-08 13:03:57.362000

# Эпоха Unix
t1 = time.time()                  # 1670504637.3620002
t2 = time.ctime()                 # Thu Dec  8 16:03:57 2022
```

### 18.3. Сравнение дат и времени

Дату (тип date) и время (тип time) можно сравнивать с помощью операторов `==, !=, <, >, <= и  >=` .

```Python
from datetime import date, time


date1 = date(2022, 10, 15)
date2 = date(1999, 12, 26)
time1 = time(13, 10, 5)
time2 = time(21, 32, 59)

print(date1 < date2)  # True
print(time1 < time2)  # False
```

### 18.4. Форматирование даты и времени

По умолчанию вывод даты и времени осуществляется в *ISO* формате:
-        дата имеет вид: `YYYY-MM-DD`
-        время имеет вид: `HH:MM:SS` или `HH:MM:SS.ffffff`

Для форматированного вывода даты и времени используется метод `strftime()` (для обоих типов `date` и `time`).

```Python
from datetime import date, time


my_date = date(2021, 8, 10)
my_time = time(7, 18, 34)

print(my_date)                             # вывод в ISO формате
print(my_time)                             # вывод в ISO формате
print(my_date.strftime('%d/%m/%y'))        # форматированный вывод даты
print(my_date.strftime('%A %d, %B %Y'))    # форматированный вывод даты
print(my_time.strftime('%H.%M.%S'))        # форматированный вывод времени
```

| **Формат** | **Значение** |  **Пример**  |
|--|--|--|
| `%a` | Сокращенное название дня недели | Sun, Mon, …, Sat (en_US) Пн, Вт, ..., Вс (ru_RU) |
| `%A` | Полное название дня недели | Sunday, Monday, …, Saturday (en_US) понедельник, ..., воскресенье (ru_RU) |
| `%w` | Номер дня недели [0, …, 6] | 0, 1, …, 6 (0=воскресенье, 6=суббота) |
| `%d` | День месяца [01, …, 31] | 01, 02, …, 31 |
| `%b` | Сокращенное название месяца | Jan, Feb, …, Dec (en_US); янв, ..., дек (ru_RU) |
| `%B` | Полное название месяца | January, February, …, December (en_US); Январь, ..., Декабрь (ru_RU) |
| `%m` | Номер месяца [01, …,12] | 01, 02, …, 12 |
| `%y` | Год без века [00, …, 99] | 00, 01, …, 99 |
| `%Y` | Год с веком | 0001, 0002, …, 2013, 2014, …, 9999 \| В Linux год выводится без ведущих нулей: \| 1, 2, …, 2013, 2014, …, 9999 |
| `%H` | Час (24-часовой формат) [00, …, 23] | 00, 01, …, 23 |
| `%I` | Час (12-часовой формат) [01, …, 12] | 01, 02, …, 12 |
| `%p` | До полудня или после (при 12-часовом формате) | AM, PM (en_US) |
| `%M` | Число минут [00, …, 59] | 00, 01, …, 59 |
| `%S` | Число секунд [00, …, 59] | 00, 01, …, 59 |
| `%f` | Число микросекунд | 000000, 000001, …, 999999 |
| `%z` | Разница с UTC в формате ±HHMM[SS[.ffffff]] | +0000, -0400, +1030, +063415, ... |
| `%Z` | Временная зона | UTC, EST, CST |
| `%j` | День года [001,366] |001, 002, …, 366 |
| `%U` | Номер недели в году (неделя начинается с воскр.).Неделя, предшествующая первому воскресенью, является нулевой. [00, …, 53] | 00, 01, …, 53 |
| `%W` | Номер недели в году (неделя начинается с пон.) Неделя, предшествующая первому понедельнику, является нулевой. [00, …, 53] | 00, 01, …, 53 |
| `%c` | Дата и время | Tue Aug 16 21:30:00 1988 (en_US); 03.01.2019 23:18:32 (ru_RU) |
| `%x` | Дата | 08/16/88 (None); 08/16/1988 (en_US); 03.01.2019 (ru_RU) |
| `%X` | Время | 21:30:00 |

### 18.5. тип данных timedelta

Тип данных `timedelta` представляет из себя временной интервал (разница между двумя объектами `datetime` или `date`) и используется для удобного выполнения различных манипуляций над типами `datetime` или `date`.

При создании объекта `timedelta` можно указать следующие аргументы:
-        недели (weeks)
-        дни (days)
-        часы (hours)
-        минуты (minutes)
-        секунды (seconds)
-        микросекунды (microseconds)
-        миллисекунды (milliseconds)

все аргументы являются необязательными и по умолчанию равны `0`.

Тип `timedelta` внутренне хранит только сочетание `days`, `seconds`, `microseconds`, а остальные переданные в конструктор аргументы конвертируются в эти единицы:
-        `millisecond` преобразуется в 1000 microseconds
-        `minutes` преобразуется в 60 seconds
-        `hours` преобразуется в 3600 seconds
-        `weeks` преобразуется в7 days

Также временной интервал (`timedelta`) может быть отрицательным.

Временные интервалы (тип `timedelta`) можно сравнивать ( `==, !=, <, >, <=, >=` ), как и любые другие типы данных.

С помощью операторов `+` и `-` мы можем находить сумму и разность временных интервалов (тип `timedelta`).

```Python
from datetime import timedelta


delta1 = timedelta(days=5) + timedelta(seconds=3600)  # 5 дней + 1 час
delta2 = timedelta(days=5) - timedelta(seconds=3600)  # 5 дней - 1 час

print(delta1)  # 5 days, 1:00:00
print(delta2)  # 4 days, 23:00:00
```

С помощью оператора `*` мы можем умножать временной интервал (тип `timedelta`) на целое или вещественное число (типы `int` и `float`).

```Python
from datetime import timedelta


delta1 = 48 * timedelta(hours=1)
delta2 = timedelta(weeks=1) * (3/7)

print(delta1)  # 2 days, 0:00:00
print(delta2)  # 3 days, 0:00:00
```

**Операции** **над** **datetime и** **date**

К объектам типа `datetime` и `date` можно прибавлять (вычитать) временные интервалы (тип `timedelta`), тем самым формируя новые объекты.

```Python
from datetime import datetime, date, timedelta


my_datetime1 = datetime(2021, 1, 1, 12, 15, 20) + timedelta(weeks=1, hours=25)
my_datetime2 = datetime(2021, 1, 1, 12, 15, 20) - timedelta(weeks=1, hours=25)
my_date1 = date(2021, 1, 1) + timedelta(hours=49)
my_date2 = date(2021, 1, 1) - timedelta(hours=49)

print(my_datetime1, my_datetime2, my_date1, my_date2, sep='\n')
# 2021-01-09 13:15:20 2020-12-24 11:15:20 2021-01-03 2020-12-30
```

Объект типа `timedelta` также возникает при вычитании двух дат (тип `date`) или дат-времён (тип `datetime`).

```Python
from datetime import datetime, date, timedelta


delta1 = datetime(2021, 1, 1, 12, 15, 20) - datetime(2020, 5, 1, 10, 5, 10)
delta2 = date(2020, 2, 29) - date(2019, 9, 1)
delta3 = date(2019, 9, 1) - date(2020, 2, 29)

print(delta1)  # 245 days, 2:10:10
print(delta2)  # 181 days, 0:00:00
print(delta3)  # -181 days, 0:00:00
```

# 19. Полезные ссылки 

Серия статей о коллекциях: https://habr.com/ru/post/319164/


