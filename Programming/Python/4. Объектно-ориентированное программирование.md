![[Pasted image 20230530231932.png]]

# 1. ООП

### 1.1 Что такое ООП?

**Объектно-ориентированное программирование (ООП)** — методология (парадигма) программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.

В основе **ООП** лежит простая и элегантная идея, в соответствии с которой главное в программе - это **данные**. Именно они определяют, какие методы будут использоваться для их обработки. Т. е. данные первичны, код для обработки этих данных - вторичен.  
![[Smartiqa_Object_Orie.png]]

Преимущества ООП:
1.  Программа разбивается на объекты. Каждый объект отвечает за собственные данные и их обработку. Как результат - код становится проще и читабельней.
2.  Уменьшается дупликация кода. Нужен новый объект, содержимое которого на 90% повторяет уже существующий? Давайте создадим новый класс и унаследуем эти 90% функционала от родительского класса!
3.  Упрощается и ускоряется процесс написания программ. Можно сначала создать высокоуровневую структуру классов и базовый функционал, а уже потом перейти к их подробной реализации.

> Основное преимущество ООП перед процедурным программированием - изоляция кода на уровне классов, что позволяет писать более простой и лаконичный код.

### 1.2 Какие базовые принципы ООП?

ООП является самой востребованной и распространенной парадигмой программирования. Концепция ООП строится на основе 4 принципов

#### Принцип 1. Абстракция

**Абстракция** - принцип ООП, согласно которому объект характеризуется свойствами, которые отличают его от всех остальных объектов и при этом четко определяют его концептуальные границы.

Т. е. абстракция позволяет:  
1.  Выделить главные и наиболее значимые свойства предмета.
2.  Отбросить второстепенные характеристики.

Когда мы имеем дело с составным объектом - мы прибегаем к абстракции. Например, мы должны понимать, что перед нами абстракция, если мы рассматриваем объект как "дом", а не совокупность кирпича, стекла и бетона. А если уже представить множество домов как "город", то мы снова приходим к абстракции, но уже на уровень выше.  
  
**Зачем нужна абстракция?** Если мыслить масштабно - то она позволяет бороться со сложностью реального мира. Мы отбрасываем все лишнее, чтобы оно нам не мешало, и концентрируемся только на важных чертах объекта.

#### Принцип 2. Инкапсуляция

**Инкапсуляция** - принцип ООП, согласно которому сложность реализации программного компонента должна быть спрятана за его интерфейсом.

На что обратить внимание?
1.  Отсутствует доступ к внутреннему устройству программного компонента.
2.  Взаимодействие компонента с внешним миром осуществляется посредством интерфейса, который включает публичные методы и поля.

А теперь опять пример с домом. Как в данном случае будет работать инкапсуляция? Она будет позволять нам смотреть на дом, но при этом не даст подойти слишком близко. Например, мы будем знать, что в доме есть дверь, что она коричневого цвета, что она открыта или закрыта. Но каким способом и из какого материала она сделана, инкапсуляция нам узнать не позволит.  
  
**Для чего нужна инкапсуляция?**
1.  Инкапсуляция упрощает процесс разработки, т. к. позволяет нам не вникать в тонкости реализации того или иного объекта.
2.  Повышается надежность программ за счет того, что при внесении изменений в один из компонентов, остальные части программы остаются неизменными.
3.  Становится более легким обмен компонентами между программами.

> Фундаментально, инкапсуляция - это когда мы свойства и поведение относящееся к одной сущности инкапсулируем в класс и работаем с ними через созданный класс. Так же инкапсуляция – это предоставление пользователю класса такого интерфейса, который требуется для работы с классом и ничего больше (сокрытие данных/методов).

> Инкапсуляция – это связь свойств объекта с его методами

#### Принцип 3. Наследование 

**Наследование** - способ создания нового класса на основе уже существующего, при котором класс-потомок заимствует свойства и методы родительского класса и также добавляет собственные.

**На что обратить внимание?**  
1.  Класс-потомок = Свойства и методы родителя + Собственные свойства и методы.
2.  Класс-потомок автоматически наследует от родительского класса все поля и методы.
3.  Класс-потомок может дополняться новыми свойствами.
4.  Класс-потомок может дополняться новыми методами, а также заменять(переопределять) унаследованные методы. Переопределить родительский метод - это как? Это значит, внутри класса потомка есть метод, который совпадает по названию с методом родительского класса, но функционал у него новый - соответствующий потребностям класса-потомка.

**Для чего нужно наследование?**  
1.  Дает возможность использовать код повторно. Классы-потомки берут общий функционал у родительского класса.
2.  Способствует быстрой разработке нового ПО на основе уже существующих открытых классов.
3.  Наследование позволяет делать процесс написания кода более простым.

> наследование позволяет нам использовать функционал уже существующих классов для создания новых.

#### Принцип 4. Полиморфизм

**Полиморфизм** - это поддержка нескольких реализаций на основе общего интерфейса.

Другими словами, полиморфизм позволяет перегружать одноименные методы родительского класса в классах-потомках.

> За одинаковым названием могут скрываться методы с совершенно разным функционалом, который в каждом конкретном случае соответствует нуждам класса, к которому он относится.

> **Полиморфизм** – одинаковые операции приводят к разным результатам при воздействии на разные типы объектов. Полиморфизм – при наследовании (родительский/дочерний класс), мы можем использовать одни и те же имена за счет того, что мы можем перегружать методы родительского класса в дочернем, тем самым модифицируя их функционал

### 1.3 Что такое класс, что такое объект в ООП?

В Python **всё** является **объектом**. Каждый объект имеет **тип**. **Тип и класс – синонимы**. Класс – шаблон для уникальных экземпляров.

Мир, в котором мы живем, состоит из объектов. Это деревья, солнце, горы, дома, машины, бытовая техника. Каждый из этих объектов имеет свой набор характеристик и предназначение. Несложно догадаться, что именно объектная картина реального мира легла в основу ООП. 

**Класс** — в объектно-ориентированном программировании, представляет собой шаблон для создания объектов, обеспечивающий начальные значения состояний: инициализация полей-переменных и реализация поведения функций или методов.  

**Объект** — некоторая сущность в цифровом пространстве, обладающая определённым состоянием и поведением, имеющая определенные свойства (поля) и операции над ними (методы). Как правило, при рассмотрении объектов выделяется то, что объекты принадлежат одному или нескольким классам, которые определяют поведение (являются моделью) объекта. Термины «экземпляр класса» и «объект» взаимозаменяемы.

На что необходимо обратить внимание?  

1.  **Класс** описывает множество объектов, имеющих общую структуру и обладающих одинаковым поведением. Класс - это шаблон кода, по которому создаются объекты. Т. е. сам по себе класс ничего не делает, но с его помощью можно создать объект и уже его использовать в работе.
2.  Данные внутри класса делятся на свойства и методы. **Свойства класса** (они же поля) - это характеристики объекта класса.
3.  **Методы класса** - это функции, с помощью которых можно оперировать данными класса.
4.  **Объект** - это конкретный представитель класса.
5.  Объект класса и **экземпляр класса** - это одно и то же.

**Грубо говоря:** Класс = Свойства + Методы
![[Smartiqa_Python_Obje.webp]]

> Объекты класса на выходе похожие и одновременно разные. Различаются, как правило, свойства. Методы остаются одинаковыми.  

Теперь давайте посмотрим, как реализуется **ООП** в рамках языка программирования Python. Синтаксис для создания класса выглядит следующим образом:

```
class <название_класса>:
    <тело_класса>
```

А вот так компактно смотрится пример объявления класса с минимально возможным функционалом:

Python

```python
class Car:
    pass
```

Чтобы создать объект класса, нужно воспользоваться следующим синтаксисом:

```
<имя_объекта> = <имя_класса>()
```

И в качестве примера создадим объект класса **Car**:

```python
car_object = Car()
```

### 1.4 Атрибуты класса в Python

Атрибутом класса/объекта называется любой элемент класса/объекта (переменную, метод, подкласс), на который мы можем сослаться через символ точки. Т. е. вот так: **MyClass.<атрибут>** или **my_object.<атрибут>**.

Все атрибуты можно разделить на 2 группы:  
1.  Встроенные(служебные) атрибуты
2.  Пользовательские атрибуты

![[Smartiqa_OOP_1_attri.png]]

#### Встроенные атрибуты

Называть данную группу атрибутов встроенными - это своего рода условность, и сейчас мы объясним почему. Суть в том, что на самом деле все классы в Python (начиная с 3-й версии) имеют один общий родительский класс - **object**. Это значит, что когда вы создаете новый класс, вы неявно наследуете его от класса **object**, и потому свежесозданный класс наследует его атрибуты. Именно их мы и называем встроенными(служебными). Вот некоторые из них(заметьте, что в списке есть как поля, так и методы):  

| Атрибут | Назначение | Тип |
|--|--|--|
| `__new__(cls[, ...])` | Конструктор. Создает экземпляр(объект) класса. Сам класс передается в качестве аргумента. | Функция |
| `__init__(self[, ...])` | Инициализатор. Принимает свежесозданный объект класса из конструктора. | Функция |
| `__del__(self)` | Деструктор. Вызывается при удалении объекта сборщиком мусора | Функция |
| `__str__(self)` | Возвращает строковое представление объекта. | Функция |
| `__hash__(self)` | Возвращает хэш-сумму объекта. | Функция |
| `__setattr__(self, attr, val)` | Создает новый атрибут для объекта класса с именем attr и значением val | Функция |
| `__doc__` | Документация класса. | Строка (тип str) |
| `__dict__` | Словарь, в котором хранится пространство имен класса | Словарь (тип dict) |

#### Пользовательские атрибуты

Это атрибуты, которые непосредственно составляют основной функционал класса. Если служебные атрибуты наследуются от базового класса `object`, то пользовательские - пишутся программистом во время реализации начинки класса и дальнейшей работы с ним.  
  
Список атрибутов класса / объекта можно получить с помощью команды `dir()`. Если взять самый простой класс:

```python
class Phone:
    pass
```

То мы получим вот такой список атрибутов:  

```python
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
```

Как видим, в нем есть только встроенные атрибуты, которые наш класс по-умолчанию унаследовал от базового класса `object`. А теперь добавим ему функционала:

```python
class Phone:

    color = 'Grey'

    def turn_on(self):
        pass

    def call(self):
        pass

```

И теперь посмотрим, как изменился список атрибутов класса:  

```python
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'color', 'call', 'turn_on']
```

Несложно заметить, что в конце списка добавились три новых пользовательских атрибута: переменная `color` и методы `turn_on()` и `call()`.  

**Подытожим:**  
1.  Атрибутами называем совокупность полей и методов класса / объекта.
2.  Атрибуты делятся на встроенные и пользовательские.
3.  Все классы в Python имеют общий родительский класс - он называется **object**.
4.  Класс **object** предоставляет всем своим потомкам набор служебных атрибутов (как переменных (например, **__dict__** и **__doc__** ), так и методов (например, **__str__** ) ).
5.  Многие из служебных атрибутов можно переопределить внутри своего класса.
6.  Поля и методы, которые описываются программистом в теле класса, являются пользовательскими и добавляются в общий список атрибутов наряду со встроенными атрибутами.

### 1.4 Поля (свойства) класса в Python  

Поля(они же свойства или переменные) можно (так же условно) разделить на две группы:  
1.  Статические поля
2.  Динамические поля
![[Smartiqa_OOP_2_Field.png]]

#### Статические поля (они же переменные или свойства класса)

Это переменные, которые объявляются внутри тела класса и создаются тогда, когда создается класс. Создали класса - создалась переменная:

```python
class Phone:

    # Статические поля (переменные класса)
    default_color = 'Grey'
    default_model = ‘C385’

    def turn_on(self):
        pass

    def call(self):
        pass
```

Вот так выглядит список атрибутов класса после его создания:

```python
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'call', 'default_color', 'default_model', 'turn_on']
```

Кроме того, у нас есть возможность получить или изменить такое свойство, просто обратившись к самому классу по его имени(экземпляр класса при этом создавать не нужно).

```python
>>> Phone.default_color
'Grey'

# Изменяем цвет телефона по умолчанию с серого на черный
>>> Phone.default_color = 'Black'
>>> Phone.default_color
'Black'
```

#### Динамические поля (переменные или свойства экземпляра класса)

Это переменные, которые создаются на уровне экземпляра класса. Нет экземпляра - нет его переменных. Для создания динамического свойства необходимо обратиться к `self` внутри метода:

```python
class Phone:
    # Статические поля (переменные класса)
    default_color = 'Grey'
    default_model = 'C385'

    def __init__(self, color, model):
        # Динамические поля (переменные объекта)
        self.color = color
        self.model = model
```

Python - Интерактивный режим

```python
# Создадим экземпляр класса Phone - телефон красного цвета модели 'I495’
>>> my_phone_red = Phone('Red', 'I495')

# Полный список атрибутов созданного экземпляра:
>>> dir(my_phone_red)
'__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'color', 'default_color', 'default_model', 'model']

# Прочитаем статические поля объекта 
>>> my_phone_red.default_color
'Grey'
>>> my_phone_red.default_model
'C385'

# Прочитаем динамические поля объекта
>>> my_phone_red.color
'Red'
>>> my_phone_red.model
'I495'

# Создадим еще один экземпляр класса Phone - такой же телефон, но другого цвета
>>> my_phone_blue = Phone('Blue', 'I495')

# Прочитаем динамические поля объекта
>>> my_phone_blue.color
'Blue'
>>> my_phone_blue.model
'I495'
```

**Подытожим:**
1.  Для создания статической переменной достаточно объявления класса, причем данная переменная создается непосредственно в теле класса.
2.  Динамические переменные создаются только в рамках работы c экземпляром класса.
3.  Чтоб создать переменную экземпляра, необходимо воспользоваться конструкцией `self.<имя_переменной>` внутри одного из методов.
4.  Экземпляр класса сочетает в себе совокупность как статических (уровня класса), так и динамических (уровня самого экземпляра) полей.
5.  Значения динамических переменных для разных объектов класса могут (и чаще всего так и делают) различаться.

### 1.4 Методы (функции) класса в Python

Как вы уже знаете, функции внутри класса называются методами. Методы так же бывают разными, а именно - их можно разделить на 3 группы:  
1.  Методы экземпляра класса (они же обычные методы)
2.  Статические методы
3.  Методы класса
![[Smartiqa_OOP_3_Metho.png]]

#### Методы экземпляра класса (Обычные методы)

Это группа методов, которые становятся доступны только после создания экземпляра класса, то есть чтобы вызвать такой метод, надо обратиться к экземпляру. Как следствие - первым параметром такого метода является слово `self`. И как мы уже обсудили выше, с помощью данного параметра в метод передается ссылка на объект класса, для которого он был вызван.

```python
class Phone:

    def __init__(self, color, model):
        self.color = color
        self.model = model

    # Обычный метод
    # Первый параметр метода - self
    def check_sim(self, mobile_operator):
        if self.model == 'I785' and mobile_operator == 'MTS':
            print('Your mobile operator is MTS')
```

Python - Интерактивный режим

```python
# Импортируем наш класс для работы с ним
>>> from phone import Phone

# Создаем экземпляр класса
>>> my_phone = Phone('red', 'I785')

# Обращаемся к методу check_sim() через объект my_phone
>>> my_phone.check_sim('MTS')
Your mobile operator is MTS
```

Стоит заметить, что, как правило, данная группа методов является самой многочисленной и часто используемой в сравнении со статическими методами и методами класса.  

#### Статические методы

Статические методы - это обычные функции, которые помещены в класс для удобства и тем самым располагаются в области видимости этого класса. Чаще всего это какой-то вспомогательный код.  
  
Важная особенность заключается в том, что данные методы можно вызывать посредством обращения к имени класса, создавать объект класса при этом не обязательно. Именно поэтому в таких методах **не используется** `self` - этому методу не важна информация об объектах класса.  
  
Чтобы создать статический метод в Python, необходимо воспользоваться специальным декоратором - **@staticmethod**. Выглядит это следующим образом:

```python
class Phone:

    # Статический метод справочного характера
    # Возвращает хэш по номеру модели
    # self внутри метода отсутствует
    @staticmethod
    def model_hash(model):
        if model == 'I785':
            return 34565
        elif model == 'K498':
            return 45567
        else: 
            return None

    # Обычный метод
    def check_sim(self, mobile_operator):
        pass
```

Python - Интерактивный режим

```python
>>> from phone import Phone

# Вызываем статический метод model_hash, просто обращаясь к имени класса
# Объект класса Phone при этом создавать не надо
>>> Phone.model_hash('I785')
34565
```

#### Методы класса

Методы класса являются чем-то средним между обычными методами (привязаны к объекту) и статическими методами (привязаны только к области видимости). Как легко догадаться из названия, такие методы тесно связаны с классом, в котором они определены.  
  
Обратите внимание, что такие методы могут менять состояние самого класса, что в свою очередь отражается на **всех** экземплярах данного класса. Правда при этом менять конкретный объект класса они не могут (этим занимаются методы экземпляра класса).  
  
Чтобы создать метод класса, необходимо воспользоваться соответствующим декоратором - **@classmethod**. При этом в качестве первого параметра такого метода передается служебное слово `cls`, которое в отличие от `self` является ссылкой на сам класс (а не на объект). 

```python
class Phone:

    def __init__(self, color, model, os):
        self.color = color
        self.model = model
        self.os = os

    # Метод класса
    # Принимает 1) ссылку на класс Phone и 2) цвет в качестве параметров
    # Создает специфический объект класса Phone(особенность объекта в том, что это игрушечный телефон)
    # При этом вызывается инициализатор класса Phone
    # которому в качестве аргументов мы передаем цвет и модель,
    # соответствующую созданию игрушечного телефона
    @classmethod
    def toy_phone(cls, color):
        toy_phone = cls(color, 'ToyPhone', None)
        return toy_phone

    # Статический метод
    @staticmethod
    def model_hash(model):
        pass

    # Обычный метод
    def check_sim(self, mobile_operator):
        pass
```

Python - Интерактивный режим

```python
>>> from phone import Phone

# Создаем объект игрушечный телефон
# Обращаемся к методу класса toy_phone через имя класса и точку
>>> my_toy_phone = Phone.toy_phone('Red')
>>> my_toy_phone
<phone.Phone object at 0x101a236d0>
```

Как видно из примера, методы класса часто используются, когда  
1.  Необходимо создать специфичный объект текущего класса
2.  Нужно реализовать фабричный паттерн - создаём объекты различных унаследованных классов прямо внутри метода

### 1.5 Уровни доступа атрибутов в Python

Вам наверняка известно, что в классических языках программирования (таких как C++ и Java) доступ к ресурсам класса реализуется с помощью служебных слов **public**, **private** и **protected**:
1.  **Private.** Приватные члены класса недоступны извне - с ними можно работать только внутри класса.
2.  **Public.** Публичные методы наоборот - открыты для работы снаружи и, как правило, объявляются публичными сразу по-умолчанию.
3.  **Protected**. Доступ к защищенным ресурсам класса возможен только внутри этого класса и также внутри унаследованных от него классов (иными словами, внутри классов-потомков). Больше никто доступа к ним не имеет
  
С точки зрения разграничения доступа к атрибутам класса Python является особенным языком - в нем отсутствует механизм, который мог бы запретить доступ к переменной или методу внутри класса. Вместо этого создатели Python предложили соглашение, в соответствии с которым:  

1.  Если переменная/метод начинается с одного нижнего подчеркивания (`_protected_example`), то она/он считается защищенным (**protected**).
2.  Если переменная/метод начинается с двух нижних подчеркиваний (`__private_example`), то она/он считается приватным (**private**).
![[Smartiqa_OOP_4_Acces.png]]

Все члены класса в Python являются публичными по умолчанию. Любой член класса может быть доступен за пределами самого класса. Вот так выглядит создание и работа с публичными (**public**) методами в Python:

```python
class Phone:

    def __init__(self, color):
        # Объявляем публичное поле color
        self.color = color
```

```python
>>> from phone import Phone

# Создаем экземпляр класса Phone
>>> phone = Phone('Grey')

# Обращаемся к свойству color
>>> phone.color
'Grey'

# Изменяем свойство color
>>> phone.color = 'Red'
>>> phone.color
'Red'
```

Как видите, никаких проблем. Идем дальше. Как мы уже сказали, в соотвествии с соглашением чтобы сделать атрибут класса защищенным (**protected**), необходимо добавить к имени символ подчеркивания `_` . Как, например, здесь:  

Python

```python
class Phone:

    def __init__(self, color):
        # Объявляем защищенное поле _color
        self._color = color
```

Однако по факту в Python такой атрибут все равно будет **доступен** снаружи класса. Вы все еще можете выполнить операции, которые мы рассмотрели выше:

```python
# Создаем экземпляр класса Phone
>>> phone = Phone('Grey')

# Обращаемся к защищенному свойству _color
>>> phone._color
'Grey'

# Изменяем защищенное свойство _color
>>> phone._color = 'Red'
>>> phone._color
'Red'
```

Иными словами, это больше вопрос ответственности программиста - он не должен работать с атрибутами, имена которых начинаются с нижнего подчёркивания `_` , снаружи класса.  

Аналогично, два нижних подчеркивания **__** в названии свойства/метода делают его приватным (**private**). Здесь уже интереснее - получить доступ к таким атрибутам напрямую нельзя (но если очень хочется, то все равно можно - об этом чуть ниже):  

```python
class Phone:

    def __init__(self, color):
        # Объявляем приватное поле __color
        self.__color = color
```

```python
>>> from phone import Phone
>>> phone = Phone('Grey')

# Пытаемся обратиться к приватному свойству и получаем ошибку
>>> phone.__color
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Phone' object has no attribute '__color'
```

Однако если мы заглянем в список атрибутов нашего класса, то увидим, что на самом деле наше свойство просто получило другое имя. И как вы уже наверное догадались, оно все еще доступно извне, но теперь уже по другому имени:

```python
# Получаем список атрибутов класса, в котором находим новое имя свойства: '_Phone__color'
>>> dir(phone)
['_Phone__color', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']

# Обращаемся к защищенному свойству по новому имени
>>> phone._Phone__color
'Grey'

# Меняем значение защищенного свойства
>>> phone._Phone__color = 'Blue'
>>> phone._Phone__color
'Blue'
```

**Подытожим:**  
1.  Существует три уровня доступа к свойствам/методам класса: public, protected, private
2.  Физически данный механизм ограничения доступа к атрибутам класса в Python реализован слабо, что от части может противоречить одному из главных принципов ООП - инкапсуляции.
3.  Однако существует некоторое соглашение, по которому в Python задать уровень доступа к свойству/методу класса можно с помощью добавления к имени одного (**protected**) или двух (**private**) подчеркиваний. Ответственность за соблюдение данного соглашения ложится на плечи программистов.

### 1.4  Что такое магические методы и для чего нужны?

**Магическими методами** называют методы, имена которых начинаются и заканчиваются двойным подчеркиванием. Магические они потому, что почти никогда не вызываются явно. Их вызывают встроенные функции или синтаксические конструкции. Например, функция `len()` вызывает метод `len()` переданного объекта. Метод `add(self, other)` вызывается автоматически при сложении оператором `+`.

Некоторые магические методы:
-       `__init__`: конструктор класса
-       `__add__`: сложение с другим объектом
-       `__eq__`: проверка на равенство с другим объектом
-       `__cmp__`: сравнение (больше, меньше, равно)
-       `__iter__`: при подстановке объекта в цикл

### 1.5 Как в классе сослаться на родительский класс?

Функция **super** принимает класс и экземпляр:

```Python
class FirstClass():
    def __init__(self):
        print('__init__ FirstClass')


class NextClass(**FirstClass**):
    def __init__(self, x):
        super(NextClass, self).__init__()
        self.x = x


NextClass(1)
```

Метод **super** нужен для доступа из дочернего класса к функциям родительского класса (**super – ссылка на объект родительской сущности**). Метод **super** часто используется в магических методах, например, в `__init__`, когда необходимо вызвать родительский конструктор с некими параметрами.

### 1.6 Что такое абстрактный класс? Зачем они нужны? Как они реализуются в python?

В Python **нет** интерфейсов. И для того чтобы создавать контракты между объектами в Python используются абстрактные классы.

**Абстрактный класс** – это класс у которого **нельзя создать объект**, абстрактный класс создается для реализации в нём контрактов (в виде абстрактных методов), которые **должны реализовать дочерние классы**.

```Python
from abc import ABC, abstractmethod


class A(ABC):
    @abstractmethod
    def some(func):
        pass


class B(**A**):
    def some():
        pass
```

### 1.7 Что такое конструктор в Python?

**Конструктор** в Python – это особый тип метода (функции), который используется для инициализации членов экземпляра класса. Конструкторы также проверяют, что у объекта достаточно ресурсов для выполнения любой задачи запуска.

В Python метод `__init __` имитирует конструктор класса. Этот метод вызывается при создании экземпляра класса. Он принимает ключевое слово `self` в качестве первого аргумента, который позволяет получить доступ к атрибутам или методу класса.
-       **Непараметрический** конструктор используется, когда мы не хотим манипулировать значением, или конструктором, который имеет только self в качестве аргумента.
-       **Параметризованный** конструктор содержит несколько параметров

Более одного конструктора в одном классе

```Python
class Student:
    def __init__(self):
        print("The First Constructor")

    def __init__(self):
        print("The second contructor")


st = Student()  # The second contructor
```

В приведенном выше коде объект вызвал второй конструктор, тогда как оба имеют одинаковую конфигурацию. Первый метод недоступен для объекта st. Внутри объект класса всегда будет вызывать последний конструктор, если у класса есть несколько конструкторов.

> **Перегрузка конструктора в** **Python запрещена.**

Можно сделать типизированный конструктор проверкой типа:

```Python
class Sample:
    def __init__(self, *args):
        if isinstance(args[0], int):
            self.ans = args[0]*args[0]
        elif isinstance(args[0], str):
            self.ans = "Hello! "+args[0]+"."


s1 = sample(5)
print('Square of int :', s1.ans)

s2 = sample('Word')
print('String :', s2.ans)
```

**Это важно** 

В теории ООП **конструктор класса** - это специальный блок инструкций, который вызывается при создании объекта. При работе с питоном может возникнуть мнение, что метод `__init__` - это и есть конструктор, но это не совсем так. На самом деле, при создании объекта в Python вызывается метод `__new__` и именно он является конструктором класса.  
  
Также обратите внимание, что `__new__` - это метод класса, поэтому его первый параметр `cls` - ссылка на текущий класс. В свою очередь, метод `__init__` является так называемым **инициализатором** класса. Именно этот метод первый принимает созданный конструктором объект. Как вы уже, наверное, не раз замечали, метод `__init__` часто переопределяется внутри класса самим программистом. Это позволяет со всем удобством задавать параметры будущего объекта при его создании. 

### 1.8 Что такое diamond problem? Что такое MRO? Чем отличается MRO 2 от MRO 3? Зачем оно нужно?

**MRO** определяет **порядок обхода** родительских классов при поиске метода:

**MRO** – method resolution order, порядок разрешения методов. Алгоритм, по которому следует искать метод в случае, если у класса два и более родителей. Алгоритм линеаризует граф наследования. Коротко можно описать так: ищи слева направо. Поэтому чем левее стоит класс, тем больше у него приоритет при поиске метода.

```Python
class A():
      pass


class B(**A**):
      pass


class C(**A**):
      pass


class D(**B**, **C**):
      pass


D.mro()  # [__main__.D, __main__.B, __main__.C, __main__.A, object]
```

В Python 3 используется **MRO 3**, В котором используется поиск родителя в ширину. **MRO** – это простой список, в котором отображен порядок поиска в цепочке наследования метода или атрибута к которому необходимо обратиться.

### 1.9 Что такое Property?

**Property** - Pythonic way реализации геттеров и сеттеров

```Python
class Person:
      @property
      def name(self):
            return ' '.join(self._name)

      @name.setter
      def name(self, value):
            self._name = value.split()


person = Person()
person.name = '\t Guido van Rossum \n'
person.name  # 'Guido van Rossum'
```

### 1.10 Что такое self в классах?

Служебное слово **self** - это ссылка на текущий экземпляр класса. Как правило, эта ссылка передается в качестве первого параметра метода Python:  

```python
class Apple:  
    # Создаем объект с общим количеством яблок 12  
    def __init__(self):  
        self.whole_amount = 12  
  
    # Съедаем часть яблок для текущего объекта  
    def eat(self, number):
        self.whole_amount -= number
```
  
Стоит обратить внимание, что на самом деле слово **self** не является зарезервированным. Просто существует некоторое соглашение, по которому первый параметр метода именуется **self** и передает ссылку на текущий объект, для которого этот метода был вызван. Хотите назвать первый параметр метода по-другому - пожалуйста.  
  
В других языках программирования(например, Java или C++) аналогом этого ключа является служебное слово **this**.

**self** – в Python чтобы внутри метода понимать к какому объекту он относится, первым аргументом в этот метод передаётся **self** (ссылка на текущий уникальный объект некого класса)

### 1.11 Что такое Duck Types?

**Duck Types** - это неявный тип, предписывающий набор специальных методов. Любой объект, для которого определены эти методы, считается членом этого типа.

Comparable

**Хэшируемость (**Hashable**)**

Каждый встроенный неизменяемый тип Python — хешируемый. Протокол, определяющий хешируемость типа, состоит из двух методов:

1. `__hash__` — возвращает хеш-значение (целочисленное), которое необходимо для внутренней реализации типа `dict`. Для объектов — экземпляров пользовательских классов является производным от `id()`;

2. `__eq__` — проверяет два объекта на предмет одинаковости их значений. Все объекты, которые являются экземплярами пользовательских классов, по умолчанию не равны, если не сравниваются сами с собой

Sortable
Iterator
Callable
Iterable

### 1.12 Наследование в Python

Механизм наследования позволяет создать новый класс на основе уже существующего. При этом новый класс включает в себя как свойства и методы родительского класса, так и новые (собственные) атрибуты. Эти новые атрибуты и отличают свежесозданный класс от его родителя.  
  
Для того, чтобы в Python создать новый класс с помощью механизма наследования, необходимо воспользоваться следующим синтаксисом:

```python
class <имя_нового_класса>(<имя_родителя>):
```

Теперь давайте рассмотрим пример применения механизма наследования в действии. Перед нами класс **Phone** (Телефон), у которого есть одно свойство **is_on** и три метода:
1.  Инициализатор: `__init__`
2.  Включение: `turn_on()`
3.  Звонок: `call()`

```python
# Родительский класс
class Phone:

    # Инициализатор
    def __init__(self):
        self.is_on = False

    # Включаем телефон
    def turn_on(self):
        self.is_on = True

    # Если телефон включен, делаем звонок
    def call(self):
        if self.is_on:
            print('Making call...')
```

В результате объект такого класса получит следующий набор атрибутов: 

```python
>>> my_phone = Phone()
>>> dir(my_phone)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'call', 'is_on', 'turn_on']
```

Среди данной совокупности атрибутов нас больше всего интересуют пользовательские свойства и методы: `__init__`, `call`, `is_on`, `turn_on`  
  
А теперь предположим, что мы захотели создать новый класс - `MobilePhone` (Мобильный телефон). Хоть этот класс и новый, но это по-прежнему телефон, а значит - его все так же можно включить и по нему можно позвонить. А раз так, то нам нет смысла реализовывать этот функционал заново, а можно просто унаследовать его от класса **Phone**. Выглядит это так:  
```python
class Phone:

    def __init__(self):
        self.is_on = False

    def turn_on(self):
        self.is_on = True

    def call(self):
        if self.is_on:
            print('Making call...')


# Унаследованный класс
class MobilePhone(Phone):

    # Добавляем новое свойство battery
    def __init__(self):
        super().__init__()
        self.battery = 0

	# Заряжаем телефон на величину переданного значения
	def charge(self, num):
	    self.battery = num
	    print(f'Charging battery up to ... {self.battery}%')

```

В новом классе добавились свойство **battery** и метод **charge()**. При этом мы помним, что это класс-потомок **Phone**, а значит от унаследовал и его функционал тоже. Создадим объект нового класса и посмотрим список его атрибутов:

```python
>>> my_mobile_phone = MobilePhone()
>>> dir(my_mobile_phone)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'battery', 'call', 'charge', 'is_on', 'turn_on']
```

Теперь мы видим, что пользовательские атрибуты состоят из унаследованных (`is_on`, `call`, `turn_on`) и новых (`__init__`, `battery`, `charge`). Все они теперь принадлежат классу `MobilePhone`. Пример использования:  

```python
# Импортируем оба класса
>>> from phone import Phone, MobilePhone

# Создаем объект класса MobilePhone
>>> my_mobile_phone = MobilePhone()

# Включаем телефон и делаем звонок
>>> my_mobile_phone.turn_on()
>>> my_mobile_phone.call()
Making call...

# Заряжаем мобильный телефон
>>> my_mobile_phone.charge(76)
Charging battery up to ... 76%
```

**Что такое super?**  
Как вы могли заметить, в инициализаторе (метод `__init__`) наследуемого класса вызывается метод `super()`. Что это за метод и зачем он нужен?  
  
Главная задача этого метода - дать возможность наследнику **обратиться к родительскому классу**. В классе родителе `Phone` есть свой инициализатор, и когда в потомке `MobilePhone` мы так же создаем инициализатор (а он нам действительно нужен, так как внутри него мы хотим объявить новое свойство) - мы его **перегружаем**. Иными словами, мы заменяем родительский метод `__init__` собственным одноименным методом. Это чревато тем, что родительский метод просто в принципе не будет вызван, и мы потеряем его функционал в классе наследнике. В конкретном случае, потеряем свойство **is_on**.  
  
Чтобы такой потери не произошло, мы можем:  
1.  Внутри инициализатора класса-наследника вызвать инициализатор родителя (для этого вызываем метод `super().__init__()`)
2.  А затем просто добавить новый функционал

Давайте еще раз взглянем на метод `__init__()` класса `MobilePhone`:  

```python
def __init__(self):  
    super().__init__()  
    self.battery = 0 
```

Обратите внимание, что вызывать родительский метод необходимо в первую очередь.

### 1.13 Полиморфизм в Python

Полиморфизм позволяет перегружать одноименные методы родительского класса в классах-потомках. Что в свою очередь дает возможность использовать перегруженный метод в случаях, когда мы еще не знаем, для какого именно класса он будет вызван. Мы просто указываем имя метода, а объект класса, к которому он будет применен, определится по ходу выполнения программы. Чтобы стало более понятно, давайте рассмотрим пример:  

```python
# Родительский класс
class Phone:

    def __init__(self):
        self.is_on = False

    def turn_on(self):
        pass

    def call(self):
        pass

    # Метод, который выводит короткую сводку по классу Phone
    def info(self):
        print(f'Class name: {Phone.__name__}')
        print(f'If phone is ON: {self.is_on}')


# Унаследованный класс
class MobilePhone(Phone):

    def __init__(self):
        super().__init__()
        self.battery = 0

    # Такой же метод, который выводит короткую сводку по классу MobilePhone
    # Обратите внимание, что названия у методов совпадают - оба метода называются info()
    # Однако их содержимое различается
    def info(self):
        print(f'Class name: {MobilePhone.__name__}')
        print(f'If mobile phone is ON: {self.is_on}')
        print(f'Battery level: {self.battery}')


# Демонстрационная функция

# Создаем список из классов
# В цикле перебираем список и для каждого элемента списка(а элемент - это класс)
# Создаем объект и вызываем метод info()
# Главная особенность: запись object.info() не дает информацию об объекте, для которого будет вызван метод info()
# Это может быть объект класса Phone, а может - объект класса MobilePhone
# И только в момент исполнения кода становится ясно, для какого именно объекта нужно вызывать метод info()
def show_polymorphism():
    for item in [Phone, MobilePhone]:
        print('-------')
        object = item()
        object.info()
```

Вызываем демонстрационный метод: 

```python
>>> from phone import Phone, MobilePhone
>>> from phone import show_polymorphism
>>> show_polymorphism()
-------
Class name: Phone
If phone is ON: False
-------
Class name: MobilePhone
If mobile phone is ON: False
Battery level: 0
```

### 1.14 Создание копий объектов

Оператор присваивания в Python **не создает копию объекта**, он лишь **связывает имя переменной с объектом**. Для неизменяемых объектов это обычно не имеет значения, но для работы с изменяемыми объектами часто требуется создавать реальные копии.

Для создания реальных копий объектов в Python используют **модуль copy**.

Модуль copy содержит две функции:
-       **copy()**: копирует объект и возвращает его поверхностную копию
-       **deepcopy()**: копирует объект и возвращает его глубокую копию

#### Поверхностное копирование

Поверхностное копирование **создает отдельный новый объект**, но вместо копирования **дочерних элементов** в новый объект, оно просто **копирует ссылки на их адреса памяти**.

```Python
import copy


data1 = [1, 2, 3]
data2 = copy.copy(data1)
data1.append(4)

print(id(data1), data1)  # 92064768 [1, 2, 3, 4]
print(id(data2), data2)  # 115494016 [1, 2, 3]
```

так как переменная `data2` ссылается на **новый объект, который представляют копию списка** `[1, 2, 3]`. В данном примере элементами списка являются **целые числа (неизменяемый тип** **int)**, поэтому изменение одного списка **не отражается на другом**. Если бы элементами списка были бы **изменяемые типы**, то поверхностное копирование скопировало бы **лишь ссылки на их адреса памяти**. Следовательно, любое изменение элементов одного объекта отразилось бы также и на элементах другого объекта.

```Python
import copy


data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.copy(data1)
data1[0].append(7)
data2[1].append(8)

print(id(data1), data1)  # 120752576 [[1, 2, 3, 7], [4, 5, 6, 8]]
print(id(data2), data2)  # 120751680 [[1, 2, 3, 7], [4, 5, 6, 8]]
```

**Изменения затронули оба списка**, потому что оба они содержат **ссылки на один и тот же вложенный объект**. Так работает поверхностное копирование.

#### Глубокое копирование

Глубокое копирование **создает новую и отдельную копию всего объекта со своим уникальным адресом памяти**. Это означает, что любые изменения, внесенные вами в новую копию объекта, не будут отражаться в исходной, и наоборот.

```Python
import copy


data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.deepcopy(data1)
data1[0].append(7)
data2[1].append(8)

print(id(data1), data1)  # 120758592 [[1, 2, 3, 7], [4, 5, 6]]
print(id(data2), data2)  # 120758336 [[1, 2, 3], [4, 5, 6, 8]]
```

При глубоком копировании **временные затраты на создание копии, очевидно выше чем при создании поверхностной копии**. Если копируемый объект имеет сложную вложенную структуру, то глубокое копирование может тратить много времени.

У списков, множеств и словарей есть метод `copy()`, создающий их **поверхностную копию**. Встроенные функции, используемые при создании коллекций (`list`, `set`, `dict`, ...), также могут быть использованы для создания **поверхностной копии** объектов. Поверхностную копию списка также можно создать с помощью **среза всего списка** `[:]`.

### 1.15 Как определить размер объекта?

Для определения размера объектов встроенных типов можно использовать функцию `getsizeof()` модуля `sys`. Данная функция возвращает размер объекта в байтах.

### 1.16 Функции str() и repr()

На практике часто используются две встроенные функции `str()` и `repr()`. С их помощью можно получить строковое представление объекта.

Встроенная функция `str()` возвращает объект в **неформальном (понятном человеку)** строковом представлении.

```Python
from datetime import date, time


my_date = date(2021, 12, 31)
my_time = time(11, 20, 54)

print(my_date, my_time)  # 2021-12-31 11:20:54
```

Встроенная функция `repr()` возвращает объект в **формальном (понятном интерпретатору)** строковом представлении.

```Python
from datetime import date, time


my_date = date(2021, 12, 31)
my_time = time(11, 20, 54)

print(repr(my_date), repr(my_time))  # datetime.date(2021, 12, 31) datetime.time(11, 20, 54)
```

### 1.17 Использование slots

Когда мы создаем объекты для классов, требуется память, а атрибут хранится в виде словаря (в `dict`). Это очень удобно, поскольку позволяет добавлять новые атрибуты во время исполнения программы. Но, в случае, если нам нужно выделить тысячи объектов, это займет достаточно много места в памяти.

К счастью, есть выход — **слоты,** они обеспечивают специальный механизм уменьшения размера объектов. Он включает использование `__slots__`, чтобы Python не создавал словари под хранение атрибутов, а выделял заданный объём памяти для ограниченного числа атрибутов (*концепция оптимизации памяти на объектах*). Также, использование **слотов** позволяет ускорить доступ к атрибутам.

Пример объекта python без слотов:

```Python
class NoSlots:
	def __init__(self):
		self.a = 1
		self.b = 2 


ns = NoSlots()
print(ns.__dict__)  # {'a': 1, 'b': 2}
```

Поскольку каждый объект в Python содержит динамический словарь, который позволяет добавлять атрибуты. Для каждого объекта экземпляра у нас будет экземпляр словаря, который потребляет больше места и тратит много оперативной памяти.

Использование **slots** уменьшает потери пространства и ускоряет работу программы, выделяя пространство для фиксированного количества атрибутов.

Пример объекта python со слотами:

```Python
class WithSlots(object):
	__slots__ = ['a', 'b']
	
	def __init__(self):
		self.a = 1
		self.b = 2

    
ws = WithSlots()
print(ws.__slots__)  # ['a', 'b']
```

Нужно понимать, что значение **slots** наследуется, однако это не предотвращает создание **dict**.

Таким образом, дочерние классы не будут запрещать добавлять динамические атрибуты, и добавляться они будут в__dict__, со всеми вытекающими расходами (по памяти и производительности).

```Python
class SlotsClass:
	__slots__ = ('foo', 'bar')

  
class ChildSlotsClass(SlotsClass):
	pass
```

```Python
>>> obj = ChildSlotsClass()
>>> obj.__slots__
('foo', 'bar')
>>> obj.foo = 5
>>> obj.something_new = 3
>>> obj.__dict__
{'something_new': 3}
```

Если нам нужно, чтобы и дочерний класс тоже был ограничен слотами, там придётся и в нём присвоить значение атрибуту `slots`. Кстати, дублировать уже указанные в родительском классе слоты не нужно.

```Python
class SlotsClass:
	__slots__ = ('foo', 'bar')

  
class ChildSlotsClass(SlotsClass):
	__slots__ = ('baz',)
```

```Python
>>> obj = ChildSlotsClass()
>>> obj.foo = 5
>>> obj.baz = 6
>>> obj.something_new = 3
Traceback (most recent call last):
File "python", line 12, in <module>
AttributeError: 'ChildSlotsClass' object has no attribute 'something_new'
```

Гораздо хуже обстоит дело с **множественным наследованием**. Если у нас есть два родительских класса, у каждого из которых определены слоты, то попытка создать дочерний класс, обречена на провал.

```Python
class BaseOne:
  __slots__ = ('param1',)

  
class BaseTwo:
  __slots__ = ('param2',)


>>> class Child(BaseOne, BaseTwo): __slots__ = ()
>>> # `Traceback (most recent call last):   File "<pyshell#68>", line 1, in <module>   class Child(BaseOne, BaseTwo): __slots__ = ()   TypeError: Error when calling the metaclass bases   multiple bases have instance lay-out conflict`
```

Один из способов решения этой проблемы — **абстрактные классы**.

**Выводы:**

- Без переменной словаря `dict`, экземплярам нельзя назначить атрибуты, не указанные в определении `slots`. При попытке присвоения имени переменной, не указанной в списке, вы получите ошибку `AttributeError`. Если требуется динамическое присвоение новых переменных, добавьте значение `'dict'` в объявлении атрибута `slots`.
- Атрибуты `slots`, объявленные в родительских классах, доступны в дочерних классах. Однако дочерние подклассы получат `dict`, если они не переопределяют `slots`.
- Если класс определяет слот, также определенный в базовом классе, переменная экземпляра, определенная слотом базового класса, недоступна. Это приводит к неоднозначному поведению программы.
- Атрибут `slots` не работает для классов, наследованных, от встроенных типов _переменной длины_, таких как `int`, `bytes` и `tuple`.
- Атрибуту `slots` может быть назначен любой нестроковый итерируемый объект. Могут использоваться словари, значениям, соответствующим каждому ключу, может быть присвоено особое значение.
- Назначение `class` работает, если оба класса имеют одинаковые `slots`.
- Может использоваться множественное наследование с несколькими родительскими классами с разделением на слоты, но только одному родительскому элементу разрешено иметь атрибуты, созданные с помощью слотов (другие классы должны иметь макеты пустых слотов), нарушение вызовет исключение `TypeError`.

### 1.18 Метаклассы

```Python
class User:
    pass

user = User()
print(user)
print(user.__class__)
print(type(user))
```

```
<__main__.User object at 0x1ea0e38>
<class '__main__.User'>
<class '__main__.User'>
```

```python
type(user) # <class '__main__.User'>
type(User) # <class 'type'>
```

при объявлении объекта (`user = User()`) мы работаем с экземпляром типа `User`, но у класса `User` тоже есть свой тип (*метакласс*). Когда мы внедряем метакласс, то он встает между классом и базовым типом `type`

![[Pasted image 20250925214845.png]]
Т.е. `metaclass` становится типом для класса

Так же мы можем создать класс `User` с помощью `type`

```python
User = type("User", (), {})

user = User()
print(type(user)) # <class '__main__.User'>
print(type(User)) # <class 'type'>
```

Метод `__new__` позволяет проинициализировать класс

