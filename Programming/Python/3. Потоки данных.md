![[Pasted image 20230530172652.png]]

# 1. Itertools

### 1.0 Модуль itertools

Встроенный модуль `itertools` включает в себя множество функций, предназначенных для созданий итераторов. Как мы уже знаем, код, основанный на итераторах, обеспечивает лучшие характеристики использования памяти, чем код, основанный на использовании списков.

Кроме функций, определенных в модуле `itertools`, в примерах данного урока используются уже изученные нами встроенные функции, предназначенные для работы c итераторами (`map(), filter(), zip(), enumerate()` и т.д.).

Функции модуля `itertools` можно разделить на следующие категории:
1. порождающие данные
2. фильтрующие данные
3. преобразующие данные
4. группирующие данные
5. объединяющие или разделяющие данные
6. порождающие комбинаторные данные

> При импортировании модуля `itertools` полностью его обычно называют `it`:

```python
import itertools as it
```

### 1.1 Функции, порождающие данные (Infinite Iterators)

К этой категории относятся следующие функции:

- `count()`
- `cycle()`
- `repeat()`

Все функции данной категории по умолчанию порождают **бесконечные итераторы**.

### 1.1.1 Функция count()

Функция `count()` возвращает итератор, генерирующий бесконечную последовательность чисел.

Аргументы функции:
- `start` — начало отсчета, по умолчанию имеет значение 00
- `step` — шаг, по умолчанию имеет значение 11

В отличие от встроенной функции `range()`, в функции `count()` аргумент для задания верхней границы не предусмотрен.

```Python
from itertools import count

count1 = count()

print(next(count1))
print(next(count1), next(count1), next(count1))

count2 = count(69, 10)

print(next(count2))
print(next(count2))
print(next(count2), next(count2), next(count2))

for i in zip(count(10), ['a', 'b', 'c']):
    print(i)
```

выводит:

```no-highlight
0
1 2 3
69
79
89 99 109
(10, 'a')
(11, 'b')
(12, 'c')
```

Аргументами `start` и `step` функции `count()` могут быть любые числовые значения, допускающие операцию сложения.

Функция `count()` примерно эквивалентна следующему коду:

```python
def count(start=0, step=1):
    n = start
    while True:
        yield n
        n += step
```

### 1.1.2 Функция cycle()

Функция `cycle()` возвращает итератор, циклично генерирующий последовательность элементов переданного итерируемого объекта.

Аргументы функции:
- `iterable` — итерируемый объект

Обратите внимание на то, что функция `cycle()` сохраняет копию каждого элемента из `iterable`. Когда итерируемый объект `iterable` исчерпан, функция начинает возвращать элементы из сохраненной копии.

Приведенный ниже код:

```python
from itertools import cycle

for index, char in enumerate(cycle('abcd')):
    if index < 7:
        print(char)
    else:
        break

cycle_iter = cycle([0, 1])
print(next(cycle_iter), next(cycle_iter), next(cycle_iter), next(cycle_iter), next(cycle_iter))

for i in zip(range(7), cycle(['a', 'b', 'c'])):
    print(i)
```

выводит:

```no-highlight
a
b
c
d
a
b
c
0 1 0 1 0
(0, 'a')
(1, 'b')
(2, 'c')
(3, 'a')
(4, 'b')
(5, 'c')
(6, 'a')
```

### 1.1.3 Функция repeat()

Функция `repeat()` возвращает итератор, бесконечно генерирующий единственное значение, переданное в качестве аргумента. Количество генераций можно ограничить c помощью необязательного аргумента `times`.

Аргументы функции:
- `obj` — любой Python объект
- `times` — количество повторений, по умолчанию имеет значение `None`

Приведенный ниже код:

```python
from itertools import repeat

for i in repeat('test', 5):
    print(i)

repeat_iter = repeat([1, 2, 3])

print(next(repeat_iter))
print(next(repeat_iter))
print(next(repeat_iter))
```

выводит:

```no-highlight
test
test
test
test
test
[1, 2, 3]
[1, 2, 3]
[1, 2, 3]
```

> Функция `repeat()` является ленивой, она использует только память, необходимую для хранения одного элемента.

Функцию `repeat()` удобно использовать совместно c функциями `zip()` и `map()`, если со значениями, генерируемыми другими итераторами, должно сочетаться некое постоянное значение.

Приведенный ниже код объединяет значения `0, 1, 2, 3, 4, ...` со строкой `bee-and-geek`, возвращаемой функцией `repeat()`:

```python
from itertools import count, repeat

for i, s in zip(count(), repeat('bee-and-geek', 5)):
    print(i, s)
```

и выводит: 

```no-highlight
0 bee-and-geek
1 bee-and-geek
2 bee-and-geek
3 bee-and-geek
4 bee-and-geek
```

Приведенный ниже код использует встроенную функцию `map()` для умножения на 22 чисел в диапазоне от 00 до 55.

```python
from itertools import repeat

for a, b, c in map(lambda x, у: (x, у, x * у), repeat(2), range(6)):
    print(f'{a} * {b} = {c}')
```

выводит: 

```no-highlight
2 * 0 = 0
2 * 1 = 2
2 * 2 = 4
2 * 3 = 6
2 * 4 = 8
2 * 5 = 10
```

В данном случае итератор, возвращаемый функцией `repeat()`, не нуждается в явном ограничении числа генераций, поскольку обработка c помощью функции `map()` прекращается сразу же, как только исчерпывается любой из ее входных итерируемых объектов, а функция `range()` возвращает только шесть элементов.

### 1.1.4 Функция starmap()

Функция `starmap()` возвращает итератор, элементами которого являются элементы переданного итерируемого объекта `iterable`, к которым была применена функция `func`.

Аргументы функции:
- `func` — произвольная функция
- `iterable` — итерируемый объект, элементами которого являются итерируемые объекты

Функция `starmap()` используется вместо `map()` в том случае, когда элементами итерируемого объекта являются другие итерируемые объекты, скажем, кортежи, и каждый элемент этих кортежей должен быть передан в функцию `function` в качестве самостоятельного аргумента.

Приведенный ниже код:

```python
from itertools import starmap


persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')]
pairs = [(1, 3), (2, 5), (6, 4)]
points = [(1, 1, 1), (1, 1, 2), (2, 2, 3)]

full_names = list(starmap(lambda name, surname: f'{name} {surname}', persons))

print(full_names)
print(*starmap(lambda a, b: a + b, pairs))
print(*starmap(lambda x, y, z: x * y * z, points))
```

выводит:

```no-highlight
['Timur Guev', 'Arthur Kharisov']
4 7 10
1 2 12
```

Разница между функциями `map()` и `starmap()` заключается в способе передачи аргументов вызываемой функции `function` и аналогична разнице между `function(a, b)` и `function(*c)`.

### 1.2 Функции, фильтрующие данные (Finite Iterators)

### 1.2.1 Функция accumulate()

Функция `accumulate()` возвращает итератор, элементами которого являются накопленные суммы или накопленные результаты функции `func`.

Аргументы функции:
- `iterable` — итерируемый объект
- `func` — функция, принимающая два аргумента, по умолчанию используется функция сложения `operator.add`
- `initial` — начальное значение, по умолчанию имеет значение `None`

Функция работает аналогично функции `reduce()` за тем исключением, что функция `accumulate()` генерирует все промежуточные результаты, а не только конечный.

Приведенный ниже код:

```python
from itertools import accumulate
import operator

data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]

print(list(accumulate(data)))
print(list(accumulate(data, operator.mul)))
print(list(accumulate(data, max)))
print(list(accumulate(data, min)))
```

выводит:

```no-highlight
[3, 7, 13, 15, 16, 25, 25, 32, 37, 45]
[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]
[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]
[3, 3, 3, 2, 1, 1, 0, 0, 0, 0]
```

Обычно количество элементов результирующего итератора совпадает с количеством элементов итерируемого объекта. Однако, если задано значение аргумента `initial`, то накопление начинается с начального значения `initial`, и в этом случае результирующий итератор будет иметь один дополнительный элемент.

 ​​​​​​Приведенный ниже код:

```python
from itertools import accumulate

print(list(accumulate([1, 2, 3, 4, 5], initial=100)))
```

выводит:

```no-highlight
[100, 101, 103, 106, 110, 115]
```

### 1.2.2 Функция dropwhile()

Функция `dropwhile()` возвращает итератор, который генерирует элементы из входного итерируемого объекта сразу же после того, как для заданного условия будет получено ложное значение.

Аргументы функции:
- `predicate` — фильтрующая функция, возвращающая `bool` значение
- `iterable` — итерируемый объект

Приведенный ниже код:

```python
from itertools import dropwhile

numbers = [1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3]
words = ['is', 'an', 'of', 'python', 'C#', 'beegeek', 'is']

new_numbers = list(dropwhile(lambda num: num <= 5, numbers))
print(new_numbers)

for word in dropwhile(lambda s: len(s) == 2, words):
    print(word)
```

выводит:

```no-highlight
[6, 7, 8, 9, 10, 1, 2, 3]
python
C#
beegeek
is
```

> Функция `dropwhile()` не выдает никаких выходных данных до тех пор, пока функция `predicate` не вернет ложное значение, поэтому она может иметь длительное время запуска.

### 1.2.3 Функция takewhile()

Функция `takewhile()` возвращает итератор, который генерирует элементы из входного итерируемого объекта до тех пор пока для заданного условия не будет получено ложное значение. По сути, действия функции `takewhile()` противоположны действиям функции `dropwhile()`.

Аргументы функции:

- `predicate` — фильтрующая функция, возвращающая `bool` значение
- `iterable` — итерируемый объект

Приведенный ниже код:

```python
from itertools import takewhile

numbers = [1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3]
words = ['is', 'an', 'of', 'python', 'C#', 'beegeek', 'is']

new_numbers = list(takewhile(lambda num: num <= 5, numbers))
print(new_numbers)

for word in takewhile(lambda s: len(s) == 2, words):
    print(word)
```

выводит:

```no-highlight
[1, 1, 2, 3, 4, 4, 5]
is
an
of
```

### 1.2.4 Функция filterfalse()

Функция `filterfalse()` возвращает итератор, который генерирует элементы из входного итерируемого объекта для которых заданное условие ложно. По сути, действия функции `filterfalse()` противоположны действиям встроенной функции `filter()`.

Аргументы функции:
- `predicate` — фильтрующая функция, возвращающая `bool` значение
- `iterable` — итерируемый объект

Приведенный ниже код:

```python
from itertools import filterfalse

numbers = [1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3]
words = ['is', 'an', 'of', 'python', 'C#', 'beegeek', 'is']

new_numbers = list(filterfalse(lambda num: num <= 5, numbers))
print(new_numbers)

for word in filterfalse(lambda s: len(s) == 2, words):
    print(word)
```

выводит:

```no-highlight
[6, 7, 8, 9, 10]
python
beegeek
```

### 1.2.5 Функция compress()

Функция `compress()` предлагает другой способ фильтрации содержимого итерируемого объекта. Вместо того чтобы вызывать функцию, она использует значения другого итерируемого объекта для индикации того, следует ли принять значение или игнорировать его.

Аргументы функции:
- `iterable` — итерируемый объект
- `selectors` — итерируемый объект, состоящий из значений `True, False`, который предоставляет значения, указывающие на то, какие входные значения следует брать, а какие следует игнорировать

Приведенный ниже код:

```python
from itertools import compress

data = 'ABCDEF'
selectors = [True, False, True, False, True, False]

result = compress(data, selectors)
print(list(result))
```

выводит:

```no-highlight
['A', 'C', 'E']
```

Обратите внимание на то, что функция `compress()` останавливается, когда исчерпан любой из итерируемых объектов `iterable` или `selectors`.

Приведенный ниже код:

```python
from itertools import compress

data = 'ABCDEF'
selectors = [True, False, True]

result = compress(data, selectors)
print(list(result))
```

выводит:

```no-highlight
['A', 'C']
```

### 1.2.6 Функция islice()

Функция `islice()` возвращает итератор, который генерирует последовательность из выбранных элементов переданного итерируемого объекта. Другими словами, функция `islice()` позволяет получить срез итерируемого объекта, для которого не всегда можно получить срез обычными средствами.

Аргументы функции:

- `iterable` — итерируемый объект
- `start` — начало среза, по умолчанию имеет значение 00
- `stop` — конец среза (не включительно)
- `step` — шаг среза, по умолчанию имеет значение 11

По сути, функция `islice()` имеет те же аргументы, что и оператор взятия среза списка: `start`, `stop` и `step`. При этом аргументы `start` и `step` — необязательные. Таким образом, вызывать функцию `islice()` можно одним из трех способов:

```python
islice(iterable, stop)
islice(iterable, start, stop)
islice(iterable, start, stop, step)
```

при этом, если `stop` равен `None`, срез берется до конца.

Приведенный ниже код:

```python
from itertools import islice

print(*islice(range(10), None))
print(*islice(range(100), 5))
print(*islice(range(100), 5, 10))
print(*islice(range(100), 0, 100, 10))
```

выводит:

```no-highlight
0 1 2 3 4 5 6 7 8 9
0 1 2 3 4
5 6 7 8 9
0 10 20 30 40 50 60 70 80 90
```

> Буква `i` в начале названия функции `islice()` говорит о том, что будет возвращен итератор. В Python есть встроенная функция `slice()`, о которой можно почитать в [документации](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/klass-slice/).

### 1.2.7 Функция chain()

Функция `chain()` возвращает итератор, который последовательно генерирует элементы всех переданных итерируемых объектов.

Аргументы функции:
- `*iterables` — итерируемые объекты

Приведенный ниже код:

```python
from itertools import chain

chain_iter1 = chain('ABC', 'DEF')
print(*chain_iter1)

chain_iter2 = chain(enumerate('ABC'))
print(*chain_iter2)

for i in chain([1, 2, 3], ['a', 'b', 'c'], ('Timur', 29, 'Male', 'Teacher')):
    print(i, end=' ')
```

выводит:

```no-highlight
A B C D E F
(0, 'A') (1, 'B') (2, 'C')
1 2 3 a b c Timur 29 Male Teacher 
```

> Функция `chain()` упрощает обработку нескольких итерируемых объектов, не требуя предварительного конструирования объединенного списка.

### 1.2.8 Функция zip_longest()

Как мы уже знаем, встроенная функция `zip()` возвращает итератор, объединяющий элементы нескольких итерируемых объектов в кортежи. При этом функция `zip()` прекращает работу, как только исчерпывается самый короткий итерируемый объект. Чтобы обеспечить обработку всех входных элементов, когда итерируемые объекты имеют разные длины, используется функция `zip_longest()`.

Аргументы функции:
- `*iterables` — итерируемые объекты
- `fillvalue` — заполнитель, по умолчанию имеет значение `None`

Приведенный ниже код:

```python
from itertools import zip_longest

print(*zip([1, 2, 3], ['a', 'b', 'c', 'd', 'e']))
print(*zip_longest([1, 2, 3], ['a', 'b', 'c', 'd', 'e']))                     # fillvalue=None
print(*zip_longest([1, 2, 3], ['a', 'b', 'c', 'd', 'e'], fillvalue='*'))
print(*zip_longest(['a', 'b', 'c', 'd', 'e'], [1, 2, 3], fillvalue=777))
```

выводит:

```python
(1, 'a') (2, 'b') (3, 'c')
(1, 'a') (2, 'b') (3, 'c') (None, 'd') (None, 'e')
(1, 'a') (2, 'b') (3, 'c') ('*', 'd') ('*', 'e')
('a', 1) ('b', 2) ('c', 3) ('d', 777) ('e', 777)
```

### 1.2.9 Функция pairwise()

Функция `pairwise()` возвращает итератор, содержащий последовательные перекрывающиеся пары в виде кортежей, взятые из исходного итерируемого объекта.

Аргументы функции:
- `iterable` — итерируемый объект

Приведенный ниже код:

```python
from itertools import pairwise

print(*pairwise('ABCDEFG'))
print(*pairwise([1, 2, 3, 4, 5]))
```

выводит:

```no-highlight
('A', 'B') ('B', 'C') ('C', 'D') ('D', 'E') ('E', 'F') ('F', 'G')
(1, 2) (2, 3) (3, 4) (4, 5)
```

Функция `pairwise()` примерно эквивалентна следующему коду:

```python
def pairwise(iterable):
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)
```

> Функция `pairwise()` была добавлена только в Python 3.10.

### 1.3 Функции, группирующие данные

К этой категории относится единственная функция:

- `groupby()`

### 1.3.1 Функция groupby()

Функция `groupby()` используется для группировки смежных элементов итерируемого объекта. Она возвращает итератор, содержащий кортежи, каждый из которых состоит из двух элементов: первый — значение, характеризующее группу, второй — итератор, содержащий элементы соответствующей группы.

Аргументы функции:

- `iterable` — итерируемый объект
- `key` — функция, вычисляющая значение, характеризующее группу

Приведенный ниже код:

```python
from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

group_iter = groupby(numbers)

print(type(group_iter))
print(*group_iter, sep='\n')
```

выводит:

```no-highlight
<class 'itertools.groupby'>
(1, <itertools._grouper object at 0x0000022424FCA590>)
(7, <itertools._grouper object at 0x0000022424FCA410>)
(15, <itertools._grouper object at 0x0000022424FCB2B0>)
(7, <itertools._grouper object at 0x0000022424FCBBB0>)
```

Как мы видим, не только сам результат вызова функции `groupby()` является итератором, но и вторые элементы результирующих кортежей также являются итераторами. Чтобы взглянуть на элементы, содержащиеся в данных итераторах, мы можем воспользоваться любым известным нам способом, например, преобразованием в список.

Приведенный ниже код:

```python
from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

group_iter = groupby(numbers)

for key, values in group_iter:
    print(f'{key}: {list(values)}')            # преобразуем итератор в список
```

выводит:

```no-highlight
1: [1, 1, 1]
7: [7, 7, 7, 7]
15: [15]
7: [7, 7, 7]
```

Приведенное ниже изображение демонстрирует работу функции `groupby()` на примере, указанном выше:

![[Pasted image 20230713163824.png]]
Приведенный выше пример демонстрирует особенность работы функции `groupby()`. Поскольку список `numbers` не является отсортированным, то у нас получаются разные группы для равных чисел. В частности, мы получили две группы для числа 77.

Если бы мы хотели получить группы, в которые включены все соответствующие элементы, нам бы пришлось сначала отсортировать список.

Приведенный ниже код:

```python
from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

group_iter = groupby(sorted(numbers))

for key, values in group_iter:
    print(f'{key}: {list(values)}')            # преобразуем итератор в список
```

выводит:

```no-highlight
1: [1, 1, 1]
7: [7, 7, 7, 7, 7, 7, 7]
15: [15]
```

Таким образом, нужно запомнить правило: если мы хотим, чтобы все равные элементы попали в одну группу, необходимо сначала отсортировать начальные данные.

#### Использование аргумента key

Как уже было сказано в начале урока, функция `groupby()` принимает в качестве необязательного аргумента `key` — функцию, которая вычисляет по элементу значение группирующего признака.

С аргументом `key` мы уже сталкивались много раз в прошлом, в таких функциях как `min(), max(), sorted()`.

Приведенный ниже код:

```python
numbers = [-81, 2, -6, -3, 9, -17, -8, -6, 7]

print(min(numbers, key=abs))                       # минимальный элемент по модулю
print(max(numbers, key=lambda num: num**2))        # элемент с максимальным квадратом
print(sorted(numbers, key=abs))                    # сортировка элементов по модулю
```

выводит:

```no-highlight
2
-81
[2, -3, -6, -6, 7, -8, 9, -17, -81]
```

Аналогичным образом работает аргумент `key` у функции `groupby()`.

Приведенный ниже код:

```python
from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

group_iter = groupby(numbers, key=lambda num: num < 10)

for key, values in group_iter:
    print(f'{key}: {list(values)}')
```

выводит:

```no-highlight
True: [1, 1, 1, 7, 7, 7, 7]
False: [15]
True: [7, 7, 7]
```

Первые семь чисел образуют первую группу, поскольку для всех них функция `key` возвращает значение `True`. Элемент со значением 1515 — образует вторую группу, так как для него функция `key` уже возвращает значение `False`, отличное от `True`. Наконец, следующие три элемента вновь образуют новую группу, так как для них функция `key` снова возвращает значение `True`, отличное от `False`.

Для того чтобы у нас было всего две группы, необходима предварительная сортировка по той же ключевой функции.

Приведенный ниже код:

```python
from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

key_func = lambda num: num < 10

group_iter = groupby(sorted(numbers, key=key_func), key=key_func)

for key, values in group_iter:
    print(f'{key}: {list(values)}')
```

выводит:

```no-highlight
False: [15]
True: [1, 1, 1, 7, 7, 7, 7, 7, 7, 7]
```

Таким образом, нужно запомнить правило: если мы хотим, чтобы все элементы для которых ключевая функция `key` возвращает одно и то же значение попали в одну группу, необходимо сначала отсортировать начальные данные по той же ключевой функции.

#### Примеры использования функции groupby()

**Пример 1.** Удалить подряд идущие одинаковые элементы в списке.

**Решение.** Будем использовать функцию `groupby()`.

Приведенный ниже код:

```python
from itertools import groupby

data = ['A', 'A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'D', 'A', 'A', 'B', 'B', 'B']

result = [key for key, group in groupby(data)] 

print(result)
```

выводит:

```no-highlight
['A', 'B', 'C', 'D', 'A', 'B']
```

**Пример 2.** Получить список с уникальными элементами списка.

**Решение.** Будем использовать функцию `groupby()`.

Приведенный ниже код:

```python
from itertools import groupby

data = ['A', 'A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'D', 'A', 'A', 'B', 'B', 'B']

result = [key for key, group in groupby(sorted(data))] 

print(result)
```

выводит:

```no-highlight
['A', 'B', 'C', 'D']
```

**Пример 3.** Определить, какой символ встречается чаще всего в строке.

**Решение.** Будем использовать функцию `groupby()`, предварительно отсортировав данные.

Приведенный ниже код:

```python
from itertools import groupby

data = 'aaabcdaabcccdddcccccccbrttbcc'
group_iter = groupby(sorted(data))

max_result = max(group_iter, key=lambda tpl: sum(1 for i in tpl[1]))

print('Символ встречающийся чаще всего в строке:', max_result[0])
```

выводит:

```no-highlight
Символ встречающийся чаще всего в строке: c
```

Не забываем, что функция `groupby()` возвращает итератор, содержащий кортежи вида `(key, group)`, при этом `group` также является итератором. Функция `len()` не работает с итераторами, поэтому для подсчета длины итератора мы используем выражение `sum(1 for i in group)`.

### 1.4 Функции, порождающие комбинаторные данные

К этой категории относятся следующие функции:
- `permutations()`
- `combinations()`
- `combinations_with_replacement()`
- `product()`

### 1.4.1 Функция permutations()

Функция `permutations()` возвращает итератор, который содержит все перестановки из элементов переданного итерируемого объекта. Каждая перестановка заключена в кортеж нужной длины.

Аргументы функции:
- `iterable` — итерируемый объект
- `r` — целое число, длина возвращаемых кортежей; по умолчанию имеет значение `None`

> Если значение аргумента `r` не указано или равно `None`, тогда по умолчанию `r` равно длине итерируемого объекта `iterable`, и генерируются все возможные перестановки полной длины.

Приведенный ниже код:

```python
from itertools import permutations

numbers = [1, 2, 3, 4]
letters = 'cba'

all_num_permutations = permutations(numbers)
all_let_permutations = permutations(letters)

print(list(all_num_permutations))
print(list(all_let_permutations))
```

выводит:

```no-highlight
[(1, 2, 3, 4), (1, 2, 4, 3), (1, 3, 2, 4), (1, 3, 4, 2), (1, 4, 2, 3), (1, 4, 3, 2), (2, 1, 3, 4), (2, 1, 4, 3), (2, 3, 1, 4), (2, 3, 4, 1), (2, 4, 1, 3), (2, 4, 3, 1), (3, 1, 2, 4), (3, 1, 4, 2), (3, 2, 1, 4), (3, 2, 4, 1), (3, 4, 1, 2), (3, 4, 2, 1), (4, 1, 2, 3), (4, 1, 3, 2), (4, 2, 1, 3), (4, 2, 3, 1), (4, 3, 1, 2), (4, 3, 2, 1)]
[('c', 'b', 'a'), ('c', 'a', 'b'), ('b', 'c', 'a'), ('b', 'a', 'c'), ('a', 'c', 'b'), ('a', 'b', 'c')]
```

Обратите внимание на то, что перестановки генерируются в лексикографическом порядке сортировки переданного итерируемого объекта. Таким образом, если входной итерируемый объект отсортирован, то кортежи перестановок будут созданы в отсортированном порядке.

Для задания длины возвращаемых кортежей функции `permutations()` нужно задать значение аргумента `r`.

Приведенный ниже код:

```python
from itertools import permutations

letters = ['a', 'b', 'c']

permutations1 = permutations(letters, r=1)
permutations2 = permutations(letters, r=2)
permutations3 = permutations(letters, r=3)

print(list(permutations1))
print(list(permutations2))
print(list(permutations3))
```

выводит:

```no-highlight
[('a',), ('b',), ('c',)]
[('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')]
[('a', 'b', 'c'), ('a', 'c', 'b'), ('b', 'a', 'c'), ('b', 'c', 'a'), ('c', 'a', 'b'), ('c', 'b', 'a')]
```

Другими словами, если в качестве второго аргумента указать некоторое число `r`, то мы получим все размещения из `n` элементов по `r`, где `n` — длина переданного итерируемого объекта.

### 1.4.2 Функция combinations()

Функция `combinations()` возвращает итератор, который содержит все сочетания из элементов переданного итерируемого объекта. Каждое сочетание заключено в кортеж нужной длины.

Аргументы функции:
- `iterable` — итерируемый объект
- `r` — целое число, длина возвращаемых кортежей

Приведенный ниже код:

```python
from itertools import combinations

numbers = [1, 2, 3, 4]

print(list(combinations(numbers, r=1)))
print(list(combinations(numbers, r=2)))
print(list(combinations(numbers, r=3)))
print(list(combinations(numbers, r=4)))
```

выводит:

```no-highlight
[(1,), (2,), (3,), (4,)]
[(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]
[(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]
[(1, 2, 3, 4)]
```

Обратите внимание на то, что сочетания генерируются в лексикографическом порядке сортировки переданного итерируемого объекта.

Приведенный ниже код:

```python
from itertools import combinations

letters = 'dbca'

print(list(combinations(letters, 1)))
print(list(combinations(letters, 2)))
print(list(combinations(letters, 3)))
print(list(combinations(letters, 4)))
```

выводит:

```no-highlight
[('d',), ('b',), ('c',), ('a',)]
[('d', 'b'), ('d', 'c'), ('d', 'a'), ('b', 'c'), ('b', 'a'), ('c', 'a')]
[('d', 'b', 'c'), ('d', 'b', 'a'), ('d', 'c', 'a'), ('b', 'c', 'a')]
[('d', 'b', 'c', 'a')]
```

Обратите внимание на то, что элементы итерируемого объекта рассматриваются как уникальные в зависимости от их положения, а не от их значения. Поэтому, если элементы уникальны, повторных значений в каждом сочетании не будет. Если же не уникальны, то будут повторы.

Приведенный ниже код:

```python
from itertools import combinations

letters = [1, 2, 2, 2]

print(list(combinations(letters, 2)))
```

выводит:

```no-highlight
[(1, 2), (1, 2), (1, 2), (2, 2), (2, 2), (2, 2)]
```

### 1.4.3 Функция combinations_with_replacement()

Функция `combinations_with_replacement()` возвращает итератор, который содержит все сочетания из элементов переданного итерируемого объекта с повторами. Другими словами, один элемент в одном сочетании может встречаться более одного раза. Каждое сочетание заключено в кортеж нужной длины.

Аргументы функции:
- `iterable` — итерируемый объект
- `r` — целое число, длина возвращаемых кортежей

Приведенный ниже код:

```python
from itertools import combinations_with_replacement

numbers = [1, 2, 3, 4]

print(list(combinations_with_replacement(numbers, 1)))
print(list(combinations_with_replacement(numbers, 2)))
print(list(combinations_with_replacement(numbers, 3)))
```

выводит:

```no-highlight
[(1,), (2,), (3,), (4,)]
[(1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (4, 4)]
[(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4), (1, 2, 2), (1, 2, 3), (1, 2, 4), (1, 3, 3), (1, 3, 4), (1, 4, 4), (2, 2, 2), (2, 2, 3), (2, 2, 4), (2, 3, 3), (2, 3, 4), (2, 4, 4), (3, 3, 3), (3, 3, 4), (3, 4, 4), (4, 4, 4)]
```

Обратите внимание на то, что сочетания генерируются в лексикографическом порядке сортировки переданного итерируемого объекта.

Приведенный ниже код:

```python
from itertools import combinations_with_replacement

letters = 'bca'

print(list(combinations_with_replacement(letters, 1)))
print(list(combinations_with_replacement(letters, 2)))
```

выводит:

```no-highlight
[('b',), ('c',), ('a',)]
[('b', 'b'), ('b', 'c'), ('b', 'a'), ('c', 'c'), ('c', 'a'), ('a', 'a')]
```

### 1.2 Что такое итератор?

**Итератор** — механизм поэлементного обхода данных, который использует метод `next()` для получения следующего значения последовательности. В «нормальные» данные итераторы перегоняются при помощи `for`, `next` или `list()`.

**Итератор** – это интерфейс, который позволяет перебирать элементы последовательности. Он используется, например, в цикле `for ... in ...`, но этот механизм скрыт от глаз разработчика. При желании итератор можно получить "в сыром виде", воспользовавшись функцией `iter()`.Чтобы получить следующий элемент коллекции или строки, нужно передать итератор функции `next()`.

В python итератор реализуется двумя методами `iter` и `next`
1.      **iter** – возвращает ссылку на итератор(последовательность)
2.      **next** – возвращает следующий объект этой последовательности

```Python
class SimpleIterator:

    def __iter__(self):
        return self

    def __init__(self, limit):
        self.limit = limit
        self.counter = 0

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1
            return 1
        else:
            raise StopIteration

simple_iter = SimpleIterator(5)

for i in simple_iter:
    print(i)  # 1 1 1 1 1
```

### 1.3 Что такое итерируемый объект?

**Итерируемый объект** – такой объект в python по которому можно пройтись поэлементно

### 1.4 Пример работы с бесконечными итераторами:

```Python
from itertools import count, repeat, cycle


# Итератор, возвращающий равномерно распределенные значения
i1 = count(start=0, step=.1)

print(next(i1))  # 0
print(next(i1))  # 0.1
print(next(i1))  # 0.2

# Итератор, циклично и бесконечно возвращающий элементы итерируемого объекта
i2 = cycle([1, 2])

print(next(i2))  # 1
print(next(i2))  # 2
print(next(i2))  # 1

# Итератор, возвращающий один и тот же объект бесконечно, если не указано значение аргумента times
i3 = repeat("Wow!", times=3)

print(list(i3))  # ['Wow!', 'Wow!', 'Wow!']
```

### 1.5 Пример работы с конечными итераторами:

```Python
from itertools import accumulate, chain, compress, dropwhile, takewhile
import operator


# Итератор, возвращающий накопленный результат выполнения указанной функции (по умолчанию — сложение)
i1 = accumulate([1, 2, 3, 4])
i2 = accumulate([1, 2, 3, 4], initial=10)

print(list(i1), list(i2))  # [1, 3, 6, 10] [10, 11, 13, 16, 20]

i3 = accumulate([ -3, -2, -1, 1, 2, 3, 4], operator.mul)

print(list(i3))  # [-3, 6, -6, -6, -12, -36, -144]

# Можно использовать свою функцию
def myfunc(accumulated, current):
    return accumulated + 2 * current

i4 = accumulate([1, 2, 3, 4], func=myfunc)

print(list(i4))  # [1, 5, 11, 19]

# Можно использовать лямбду
i5 = accumulate([1, 2, 3, 4], lambda accumulated, current: accumulated + 2 * current)

print(list(i5))  # [1, 5, 11, 19]

# Итератор, возвращающий только те элементы входной последовательности,
# которые имеют соответствующий элемент, равный True или 1 в последовательности selectors
i6 = compress("ABCDEF", [1, 1, 1, 0, 0, 1])

print(list(i6))  # ['A', 'B', 'C', 'F']

# Итератор, отбрасывающий элементы входной последовательности, если результат выполнения функции равен True.
# Как только предикат становится False, то отбрасывание прекращается (предикат больше не применяется)
i7 = dropwhile(lambda x: x<5, [1, 4, 6, 4, 1, 1, 1, 0])

print(list(i7))  # [6, 4, 1, 1, 1, 0]

# takewhile, в отличие от dropwhile, наоборот, возвращает элементы входной последовательности,

# если результат выполнения функции равен True
i8 = takewhile(lambda x: x<5, [1, 4, 6, 0, 4, 1, 2, 1])

print(list(i8))  # [1, 4]

# Итератор, формирующий из нескольких входных последовательностей одну общую
i2 = chain(["A", "B", "C"],["D", "E", "F"],["G", "H", "I"])

print(list(i2))  # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']

# Кстати, такой же трюк можно провернуть при помощи обычной sum(), задав ей начальный параметр [] (т. е. пустой список)
a = sum([["A", "B", "C"],["D", "E", "F"],["G", "H", "I"]], [])

print(a)  # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
```

### 1.6 Пример работы с комбинаторными итераторами

```Python
from itertools import product, combinations, combinations_with_replacement, permutations


# Создает множество, содержащее все упорядоченные пары элементов из входных множеств
a = product("abc", "xyz")

print(list(a))  # [('a', 'x'), ('a', 'y'), ('a', 'z'), ('b', 'x'), ('b', 'y'), ('b', 'z'), ('c', 'x'), ('c', 'y'), ('c', 'z')]

b = product([0, 1], repeat=3)

print(list(b))  # [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]

# Возвращает подпоследовательности длины r из элементов входного итерируемого объекта, повторяющиеся элементы не допускаются
c = combinations("abc", r=2)

print(list(c))  # [('a', 'b'), ('a', 'c'), ('b', 'c')]

# Выдает перестановки элементов итерируемого объекта
d = permutations("abc", r=2)

print(list(d))  # [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')]

# Возвращает подпоследовательности длины r из элементов входного итерируемого объекта, повторяющиеся элементы допустимы
e = combinations_with_replacement("abc", r=2)

print(list(e))  # [('a', 'a'), ('a', 'b'), ('a', 'c'), ('b', 'b'), ('b', 'c'), ('c', 'c')]
```

### 1.7 Общие сведения. Итераторы.

#### Итерируемые объекты

В языке Python под **итерируемым объектом** подразумевают объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом. К примеру, уже известные нам списки (тип `list`), строки (тип `str`), кортежи (тип `tuple`), множества (тип `set`), словари (тип `dict`) являются итерируемыми, поскольку мы можем перебирать каждый элемент этих объектов.

Приведенный ниже код:

```python
numbers = [1, 2, 3]
name = 'python'

for num in numbers:        # итерируем по списку, перебирая каждый элемент
    print(num)

for c in name:             # итерируем по строке, перебирая каждый символ
    print(c)

print(2 in numbers)        # неявное итерирование по списку
print('A' in name)         # неявное итерирование по строке
print(*numbers)            # неявное итерирование по списку при распаковке
```

Если подходить более формально в Python, существует два типа итерируемых объектов:

1.  итераторы
2.  коллекции и последовательности

#### Итераторы

**Итератор** — специальный объект, который выдает свои элементы по одному за раз.

Если итератор передать во встроенную функцию `next()`, то эта функция вернет его следующий элемент. При этом сам итератор также сдвинется на следующий элемент. При следующем вызове функция `next()` вернет следующий элемент и т.д. Если же в итераторе элементов больше не осталось, то вызов функции `next()` приведет к возникновению исключения `StopIteration`.

#### Коллекции и последовательности

**Коллекция** — объект, хранящий набор значений одного или различных типов, позволяющий обращаться к этим значениям, а также применять специальные функции и методы, зависящие от типа коллекции.

Также среди коллекций можно выделить те, элементы которых пронумерованы индексами и расположены в строгом порядке. Такие коллекции называются **последовательностями**. Например, списки, строки и кортежи являются последовательностями, а множества и словари нет.

Коллекции не являются итераторами сами по себе, но позволяют создать итератор на своей основе.

Для того чтобы создать итератор на основе некоторой коллекции, достаточно вызвать встроенную функцию `iter()`, передав нужную коллекцию в качестве ее аргумента.

Например, список не является итератором, но на его основе можно создать сколько угодно итераторов, каждый из которых будет перебирать элементы списка от первого до последнего.

Большинство функций, которые работают с итераторами, работают также и с коллекциями.

Приведенный ниже код:

```python
numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основании списка

print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
print(next(iterator))             # запрашиваем и печатаем третий элемент итератора
```

выводит:

```no-highlight
1
2
3
```

Получить итератор можно из любого итерируемого объекта, для этого нужно передать итерируемый объект во встроенную функцию `iter()`.

![](https://ucarecdn.com/2e2c1aea-ef6c-4a42-8e73-aea25d40efd1/)

После того как мы получили итератор, мы можем передать его встроенной функции `next()`. При каждом новом вызове, функция `next()` возвращает очередной элемент итератора. Если же в итераторе элементов больше не осталось, то функция `next()` возбуждает исключение `StopIteration`.

Приведенный ниже код:

```python
numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основе списка

print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
print(next(iterator))             # запрашиваем и печатаем третий элемент итератора

print(next(iterator))             # возбуждается исключение StopIteration
```

приводит к возникновению исключения `StopIteration`.

Единственное, что мы можем сделать с итератором, — передать его функции `next()`. Как только итератор становится пустым и порождается исключение `StopIteration`, он становится совершенно бесполезным.

Основная разница между последовательностями и итераторами, заключается в том, что в последовательностях элементы пронумерованы индексами, начиная от нуля. Мы можем обратиться к конкретному элементу таких объектов по индексу. В итераторах мы можем лишь последовательно запрашивать следующий элемент.

Приведенный ниже код:

```python
numbers = [1, 2, 3, 4]            # список
letters = ('a', 'b', 'c')         # кортеж
language = 'python'               # строка

print(numbers[3])                 # обращение по индексу
print(letters[2])                 # обращение по индексу
print(language[5])                # обращение по индексу
```

выводит:

```no-highlight
4
c
n
```

Приведенный ниже код:

```python
letters = ('a', 'b', 'c')

iterator = iter(letters)           # создаем итератор на основе кортежа

print(iterator[1])                 # обращение по индексу
```

приводит к возникновению исключения:

```no-highlight
TypeError: 'tuple_iterator' object is not subscriptable
```

#### Преимущества итераторов

Основными преимуществами использования итераторов являются:

-   однотипность работы с объектами разных типов
-   ленивые вычисления и экономия потребляемой памяти
-   комбинация множества итераторов для создания понятной и читабельной программы

#### Однотипность работы с объектами разных типов

Итераторы позволяют разным объектам притворяться одинаковыми. Списки, кортежи, строки, множества, словари, объекты типа `range` имеют разные типы, но мы можем использовать любой из этих объектов:

-   в цикле `for`
-   в функциях высшего порядка `map(), filter(), reduce(), reversed()` и т.д.
-   для проверки наличия некоторого значения с помощью оператора принадлежности `in`
-   для распаковки элементов с помощью `*` и т.д.

Цикл `for` в Python работает по следующему принципу:

-   создает итератор на основе итерируемого объекта
-   запрашивает очередной элемент из итератора с помощью функции `next()` и передает его в выполняемый блок кода (тело цикла)
-   останавливается при получении исключения `StopIteration`

Благодаря этому, в цикл `for` можно передать и список, и кортеж, и строку, и объект типа `range`, и многие другие объекты, которые имеют свои итераторы.

По сути, приведенный ниже код:

```python
numbers = [1, 2, 3, 4]

for num in numbers:
    print(num)
```

за кулисами превращается в:

```python
numbers = [1, 2, 3, 4]

iterator = iter(numbers)           # создается итератор

while True:
    try:
        item = next(iterator)
        print(item)
    except StopIteration:
        break
```

#### Ленивые вычисления и экономия потребляемой памяти

Ленивые вычисления предполагают, что не нужно ничего делать до тех пор, пока в этом нет необходимости. Это не просто удобно, но и позволяет экономить память и время на вычисление.

Приведенный ниже код:

```python
numbers = range(5)             # 5 чисел в последовательности

for num in numbers:
    print(num)
```

выводит:

```no-highlight
0
1
2
3
4
```

Объекты типа `range` являются итерируемыми объектами. Цикл `for` создает на основе объекта `range` итератор, у которого запрашивает элементы по одному, пока не будет достигнут конец последовательности чисел. В нашем примере, пока не будет получено число 44.

Важно понимать, что объект типа `range` не хранит весь набор чисел. Он создает новое число (на лету) только тогда, когда оно потребуется, при этом старые значения не хранятся. Размер объектов `range` не зависит от количества чисел, которые предполагается перебрать, ведь нужно помнить только начальное и конечное значения последовательности, шаг и текущее значение.

Приведенный ниже код:

```python
from sys import getsizeof

numbers1 = range(5)                  # 5 чисел в последовательности
numbers2 = range(100000)             # 100000 чисел в последовательности
numbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности

print(getsizeof(numbers1))
print(getsizeof(numbers2))
print(getsizeof(numbers3))
```

выводит (размер в байтах):

```no-highlight
48
48
48
```

Все объекты `range` имеют один и тот же размер в памяти — 4848 байт. Такой подход позволяет создавать "большие" итераторы (даже бесконечные), не занимая много памяти.

Заметим, что мы можем преобразовать любой итерируемый объект в список. Однако при таком преобразовании все элементы итерируемого объекта будут записаны в память.

Приведенный ниже код:

```python
from sys import getsizeof

numbers1 = list(range(5))                  # 5 чисел в списке
numbers2 = list(range(100000))             # 100000 чисел в списке

print(getsizeof(numbers1))
print(getsizeof(numbers2))
```

выводит (размер в байтах):

```no-highlight
96
800056
```

Чем больше элементов в списке, тем больше памяти он занимает. Преобразование итерируемого объекта в список не всегда будет заканчиваться удачно.

Приведенный ниже код:

```python
from sys import getsizeof

numbers3 = list(range(10000000000000))     # 10000000000000 чисел в списке

print(getsizeof(numbers3))
```

приводит в возникновению исключения `MemoryError`. Python не позволяет нам создать такой большой список 😔.

Объекты типа `range` являются ленивыми, преобразовывать их в списки стоит с особенной аккуратностью и только тогда, когда это действительно необходимо.

#### Комбинация множества итераторов

У итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом.

Приведенный ниже код:

```python
sentence = 'In the face of ambiguity refuse the temptation to guess'

filter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем
map_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем
enumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем

for index, value in enumerate_iterator:                                  # выводим
    print(f'{index}. {value}')
```

выводит:

```no-highlight
1. AMBIGUITY
2. REFUSE
3. TEMPTATION
4. GUESS
```

Обратите внимание на то, что все три объекта `filter_iterator, map_iterator, enumerate_iterator` являются итераторами. Они не хранят все данные в памяти, а создают и выдают их по мере того, как их запрашивают. Другими словами, при обращении к очередному элементу `enumerate_iterator` произойдет последовательное обращение сначала к элементу `map_iterator`, а затем к элементу `filter_iterator`.

 Имейте в виду, что от порядка, в котором комбинируются итераторы, зависит итоговый результат.
 
**Примечание 1.** Встроенной функции `next()` можно передать второй аргумент, который будет возвращен вместо возбуждения исключения `StopIteration`, если в итераторе больше не осталось элементов.

Приведенный ниже код:

```python
nums = iter([1, 2, 3, 4])

print(next(nums))
print(next(nums))
print(next(nums))
print(next(nums))
print(next(nums, -1))  # -1
print(next(nums, -1))  # -1
```

**Примечание 2.** Не забывайте, что коллекции не являются итераторами.  Поэтому встроенная функция `next()` не позволяет получить очередной элемент, например списка, строки и т.д.

Приведенный ниже код:

```python
nums = [1, 2, 3, 4]

print(next(nums))
```

приводит к возникновению исключения:

```no-highlight
TypeError: 'list' object is not an iterator
```

**Примечание 3.** Итераторы могут **генерировать бесконечное число значений**, не занимая много дополнительной памяти. Например, итератор может генерировать все натуральные числа или все простые числа. Или генерировать значения, количество которых заранее неизвестно.

Встроенная функция `len()` не работает с большей частью итерируемых объектов, потому что их длина может быть очень большой или даже бесконечной.

Приведенный ниже код:

```python
numbers = [1, 2, 3, 4, 5, 6]

evens = filter(lambda num: num % 2 == 0, numbers)
print(len(evens))
```

приводит к возникновению ошибки:

```no-highlight
TypeError: object of type 'filter' has no len()
```

В случае с итерируемыми объектами, которые являются итераторами, посчитать длину можно только если полностью пройти итератор от начала до конца, что может быть очень долго. Для итераторов, про которые заранее неизвестно, бесконечные они или нет, функция `len()` могла бы работать не просто долго, а вечно. Именно поэтому функция `len()` не применима к итераторам.

**Примечание 3.** Подробнее о возможностях типа `range` можно почитать по [ссылке](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/klass-range/).

**Примечание 4.** Важно понимать разницу между итерируемыми объектами и итераторами:

-   `iterable` (итерируемый) — это свойство того, по кому будет происходить итерирование
-   `iterator` (итерирующий) — это тот, кто ходит

Другими словами, `iterable` — сущность, по которой ходим, книга, которую листаем, а `iterator` — листающая сущность, палец, который указывает на нужный лист в книге.

**Примечание 5.** Классифицировать контейнерный тип данных в Python, то есть определить, является ли он, например, последовательностью, можно проверкой наличия соответствующих методов. Подробнее по [ссылке](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes).

![](https://ucarecdn.com/c4eee96c-4366-453d-b225-08c0c94710a8/)
#### Особенности итераторов

Как мы уже выяснили, итератор — специальный объект, который выдает свои элементы по одному за раз.

Если итератор передать во встроенную функцию `next()`, то эта функция вернет его следующий элемент. При этом сам итератор также сдвинется на следующий элемент. При следующем вызове функция `next()` вернет следующий элемент и т.д. Если же в итераторе элементов больше не осталось, то вызов функции `next()` приведет к возбуждению исключения `StopIteration`, а сам итератор становится совершенно бесполезным, так как опустошен.

Итераторы очень глубоко интегрированы в язык Python, и многие языковые конструкции позволяют их использовать.

#### Цикл for

Самое простое, что можно сделать с итератором, — это его последовательный обход с помощью цикла `for`.

Приведенный ниже код:

```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)     # создаем объект итератора

for num in positive_numbers:             # обходим итератор циклом for
    print(num)
```

выводит:

```no-highlight
3
6
1
90
34
25
23
21
```

По сути, за кулисами цикл `for` вызывает встроенную функцию `next()`, передавая ей в качестве аргумента итератор `positive_numbers`. Функция `next()` последовательно возвращает значения итератора, применяя к ним функцию `abs()` до тех пор, пока не будет возвращено последнее значение, после чего возбуждается исключение `StopItеration`, и цикл `for` завершается. По мере вызова функции `next()` итератор `positive_numbers` опустошается и в конце концов становится совершенно бесполезным.

Приведенный ниже код:

```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)     # создаем объект итератора

for num in positive_numbers:             # обходим итератор циклом for
    print(num)

for num in positive_numbers:             # обходим пустой итератор, тело цикла выполнено не будет
    print(num)
```

выводит все тот же результат:

```no-highlight
3
6
1
90
34
25
23
21
```

поскольку после первого цикла `for` итератор `positive_numbers` становится пустым и его повторный обход ни к чему не приведет.

Обратите внимание на то, что цикл `for` сам перехватывает исключение `StopIteration`. Если самостоятельно вызвать функцию `next()` на пустом итераторе, мы получим исключение.

Приведенный ниже код:

```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)     # создаем объект итератора

for num in positive_numbers:             # обходим итератор циклом for
    print(num)

print(next(positive_numbers))            # пытаемся получить элемент из пустого итератора
```

приводит к возбуждению исключения `StopIteration`.

#### Преобразование в коллекцию

Помимо последовательного прохода по итератору с помощью цикла `for` мы можем использовать встроенные функции `list()`, `tuple()` и т.д. для преобразования итератора в коллекцию.

Приведенный ниже код:

```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)                 # создаем объект итератора
positive_numbers_list = list(positive_numbers)       # преобразуем итератор в список

print(positive_numbers_list)
```

выводит:

```no-highlight
[3, 6, 1, 90, 34, 25, 23, 21]
```

Функция `list()` в данном случае преобразует итератор в список и за кулисами обходит итератор до конца, тем самым опустошая его.

Приведенный ниже код:

```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)                  # создаем объект итератора

positive_numbers_list1 = list(positive_numbers)       # преобразуем итератор в список
positive_numbers_list2 = list(positive_numbers)       # преобразуем пустой итератор в список

print(positive_numbers_list1)
print(positive_numbers_list2)
```

выводит:

```no-highlight
[3, 6, 1, 90, 34, 25, 23, 21]
[]
```

Так как получить элементы итератора возможно лишь единожды, второй список оказывается пустым.

#### Оператор принадлежности in

Оператор принадлежности `in` работает и с итераторами. Проверка на вхождение проверяется путем перебора всех элементов последовательно, и как только элемент обнаружен, поиск прекращается.

Приведенный ниже код:

```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator)
```

выводит:

```no-highlight
True
```

Однако тут нужно понимать, что по мере поиска итератор опустошается, поскольку оператор `in` за кулисами вызывает функцию `next()` для получения следующего элемента.

Приведенный ниже код:

```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator)
print(15 in iterator)
```

выводит:

```no-highlight
True
False
```

При этом после второй проверки на принадлежность итератор `iterator` полностью опустошается и последующие поиски по нему всегда будут приводить к результату `False`.

Приведенный ниже код:

```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator)
print(23 in iterator)
```

выводит:

```no-highlight
True
True
```

поскольку как только элемент 1515 обнаружен, поиск прекращается, и в итераторе остается три числа 16,23,4216,23,42.

#### Распаковка итератора

Мы также можем распаковывать содержимое итератора, автоматически опустошая его.

Приведенный ниже код:

```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(*iterator)
print(list(iterator))
```

выводит:

```no-highlight
4 8 15 16 23 42
[]
```

#### Функция map()

Функция `map(function, *iterable)` применяет пользовательскую функцию `function` к каждому элементу итерируемого объекта `iterable`. Каждый элемент `iterable` отправляется в функцию `function` в качестве аргумента.

**Возвращаемое значение:** функция `map()` возвращает итератор типа `<class 'map'>`.

**Примечание:** если в функцию `map()` передаётся несколько итерируемых объектов `iterable`, то пользовательская функция `function` должна принимать количество аргументов, соответствующее количеству переданных итерируемых объектов, при этом `function` будет применяться к элементам из всех итераций параллельно.

**Преимущества использования:** функция `map()` написана на языке C и хорошо оптимизирована, ее внутренний цикл более эффективный, чем обычный цикл `for` в Python. Функция `map()` потребляет мало памяти, так как возвращает ленивый итератор элементы которого извлекаются по запросу.

**Примеры использования:** приведенный ниже код

```python
from sys import getsizeof

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
letters = 'beegeek'

squares = map(lambda num: num ** 2, numbers)
capitals = map(str.upper, letters)

print(f'Тип итератора squares: {type(squares)}, размер: {getsizeof(squares)}')
print(f'Тип итератора capitals: {type(capitals)}, размер: {getsizeof(capitals)}')

print(*squares, sep=' ')
print(*capitals, sep=' ')
```

выводит:

```no-highlight
Тип итератора squares: <class 'map'>, размер: 48
Тип итератора capitals: <class 'map'>, размер: 48
1 4 9 16 25 36 49 64 81 100
B E E G E E K
```

Обратите внимание на размер итератора типа `<class 'map'>`, он всегда равен 48 байтам, независимо от размера итерируемого объекта.

#### Функция filter()

Функция `filter(function, iterable)` фильтрует (отбирает) элементы переданного итерируемого объекта `iterable` при помощи пользовательской функции `function`. Если фильтрующая функция `function` вернёт `True`, то элемент из итерируемого объекта `iterable` попадёт в результат выполнения функции `filter()`, если `False` — не попадёт.

**Возвращаемое значение:** функция `filter()` возвращает итератор типа `<class 'filter'>`.

**Примечание:** Если `function=None`, то в результат выполнения функции `filter()` попадут те элементы, которые при переводе в логический тип имеют значение `True`.

**Преимущества использования:** функция `filter()` написана на языке C и хорошо оптимизирована, ее внутренний цикл более эффективный, чем обычный цикл `for` в Python. Функция `filter()` потребляет мало памяти, так как возвращает итератор, элементы которого извлекаются по запросу.

**Примеры использования:**

Приведенный ниже код:

```python
from sys import getsizeof

numbers = [45, -90, -21, 4, 89, 43, 1234, 112, 999, 777, -765, -666]
objects = ('a', None, 45, True, 69.69, False, -1, 0, 'empty', '')

positive_numbers = filter(lambda num: num > 0, numbers)
not_nulls = filter(None, objects)

print(f'Тип итератора positive_numbers: {type(positive_numbers)}, размер: {getsizeof(positive_numbers)}')
print(f'Тип итератора not_nulls: {type(not_nulls)}, размер: {getsizeof(not_nulls)}')

print(*positive_numbers, sep=' ')
print(*not_nulls, sep=' ')
```

выводит:

```no-highlight
Тип итератора positive_numbers: <class 'filter'>, размер: 48
Тип итератора not_nulls: <class 'filter'>, размер: 48
45 4 89 43 1234 112 999 777
a 45 True 69.69 -1 empty
```

Обратите внимание на размер итератора типа `<class 'filter'>`, он всегда равен 48 байтам, независимо от размера итерируемого объекта.

#### Функция enumerate()

Функция `enumerate(iterable, start=0)` нумерует элементы итерируемого объекта `iterable`, начиная со значения `start`.

**Возвращаемое значение:** функция `enumerate()` возвращает итератор типа `<class 'enumerate'>`, содержащий кортежи вида `(счётчик, элемент)`.

**Примечание:** по умолчанию нумерация начинается с нуля.

**Преимущества использования:** функция `enumerate()` потребляет мало памяти, так как возвращает итератор, элементы которого извлекаются по запросу.

**Примеры использования:**

Приведенный ниже код

```python
from sys import getsizeof

seasons = ['Spring', 'Summer', 'Fall', 'Winter']
letters = 'beegeek'

numbered_seasons = enumerate(seasons)
numbered_letters = enumerate(letters, start=1)

print(f'Тип итератора numbered_seasons: {type(numbered_seasons)}, размер: {getsizeof(numbered_seasons)}')
print(f'Тип итератора numbered_letters: {type(numbered_letters)}, размер: {getsizeof(numbered_letters)}')

print(*numbered_seasons, sep=' ')
print(*numbered_letters, sep=' ')
```

выводит:

```no-highlight
Тип итератора numbered_seasons: <class 'enumerate'>, размер: 64
Тип итератора numbered_letters: <class 'enumerate'>, размер: 64
(0, 'Spring') (1, 'Summer') (2, 'Fall') (3, 'Winter')
(1, 'b') (2, 'e') (3, 'e') (4, 'g') (5, 'e') (6, 'e') (7, 'k')
```

Обратите внимание на размер итератора типа `<class 'enumerate'>`, он всегда равен 6464 байтам, независимо от размера итерируемого объекта.

#### Функция zip()

Функция `zip(*iterables, strict=False)` объединяет элементы каждого из переданных итерируемых объектов `*iterables`.

**Возвращаемое значение:** функция `zip()` возвращает итератор типа `<class 'zip'>`, содержащий кортежи, где ii-й кортеж содержит ii-й элемент из каждого итерируемого объекта.

**Примечание:** по умолчанию значение аргумента `strict=False`, то есть функция `zip()` останавливается, когда исчерпывается самый короткий итерируемый объект. Если установить значение `strict=True`, то функция `zip()` проверяет длины итерируемых объектов, вызывая ошибку `ValueError`, если они не совпадают. C одним итерируемым аргументом функция `zip()` возвращает итератор из кортежей с одним элементом, без аргументов функция возвращает пустой итератор.

**Преимущества использования:** функция `zip()` потребляет мало памяти, так как возвращает итератор, элементы которого извлекаются по запросу.

**Примеры использования:** приведенный ниже код

```python
from sys import getsizeof

languages = ['Python', 'C#', 'C', 'Delphi'] 
years = [1991, 2000, 1972, 1986]
authors = ('Guido van Rossum', 'Anders Hejlsberg', 'Dennis MacAlistair Ritchie', 'Anders Hejlsberg')

zip_iterator1 = zip(languages, years)
zip_iterator2 = zip(languages, years, authors)

print(f'Тип итератора zip_iterator1: {type(zip_iterator1)}, размер: {getsizeof(zip_iterator1)}')
print(f'Тип итератора zip_iterator2: {type(zip_iterator2)}, размер: {getsizeof(zip_iterator2)}')

print(*zip_iterator1, sep=' ')
print(*zip_iterator2, sep=' ')
```

выводит:

```no-highlight
Тип итератора zip_iterator1: <class 'zip'>, размер: 64
Тип итератора zip_iterator2: <class 'zip'>, размер: 64
('Python', 1991) ('C#', 2000) ('C', 1972) ('Delphi', 1986)
('Python', 1991, 'Guido van Rossum') ('C#', 2000, 'Anders Hejlsberg') ('C', 1972, 'Dennis MacAlistair Ritchie') ('Delphi', 1986, 'Anders Hejlsberg')
```

Обратите внимание на размер итератора типа `<class 'zip'>`, он всегда равен 64 байтам, независимо от размера итерируемого объекта.

#### Функция reversed()

Функция `reversed(seq)` перебирает элементы итерируемого объекта `seq` в обратном порядке.

**Возвращаемое значение:** функция `reversed()` возвращает итератор, содержащий элементы итерируемого объекта в обратном порядке.

**Примечание 1:** итерируемый объект, передаваемый в функцию `reversed()`, должен являться последовательностью.

**Примечание 2:** функция `reversed()` не создает копию и не изменяет оригинал исходного итерируемого объекта.

**Преимущества использования:** функция `reversed()` потребляет мало памяти, так как возвращает ленивый итератор элементы которого извлекаются по запросу.

**Примеры использования:** приведенный ниже код

```python
from sys import getsizeof

years = [1991, 2000, 1972, 1986]
letters = 'beegeek'

backward_years = reversed(years)
backward_letters = reversed(letters)

print(f'Тип итератора backward_years: {type(backward_years)}, размер: {getsizeof(backward_years)}')
print(f'Тип итератора backward_letters: {type(backward_letters)}, размер: {getsizeof(backward_letters)}')

print(*backward_years, sep=' ')
print(*backward_letters, sep=' ')
```

выводит:

```no-highlight
Тип итератора backward_years: <class 'list_reverseiterator'>, размер: 48
Тип итератора backward_letters: <class 'reversed'>, размер: 48
1986 1972 2000 1991
k e e g e e b
```

 Обратите внимание на размер итератора, он всегда равен 48 байтам, независимо от размера итерируемого объекта.

#### Магические методы

В Python существуют методы, которые редко вызываются напрямую, при этом они постоянно вызываются встроенными функциями и операторами, даже если мы об этом не знаем. Такие методы называются магическими и обрамляются двойным нижним подчеркиванием с двух сторон.

Использование магических методов позволяет сделать работу с создаваемыми пользователем объектами удобной за счет схожести с встроенными объектами языка.

 Магические методы еще называют dunders от double underscore (двойное нижнее подчеркивание).

Например, у объектов типа `list` есть магические методы `__len__()` и `__str__()`. Первый магический метод вызывается автоматически встроенной функцией `len()`, которая возвращает длину списка, второй метод вызывается встроенной функцией `str()`, которая возвращает строковое представление списка.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

print(len(words))         # за кулисами вызывается магический метод __len__()
print(str(words))         # за кулисами вызывается магический метод __str__()
```

выводит:

```no-highlight
3
['hello', 'beegeek', 'python']
```

Нам ничего не мешает вызвать указанные магические методы напрямую.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

print(words.__len__())
print(words.__str__())
```

также выводит:

```no-highlight
3
['hello', 'beegeek', 'python']
```

На практике нам редко приходится явно вызывать магические методы. Обычно за нас это делают встроенные функции языка Python.

Посмотреть список всех методов и атрибутов Python объекта можно с помощью встроенной функции `dir()`.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

print(dir(words))
```

выводит:

```no-highlight
['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
```

Обратите внимание на то, что публичные методы, то есть методы которые вызываются явно (`append(), count(), extend(), index()` и т.д.), не имеют нижних подчеркиваний.

 Подробно тема магических методов будет рассматриваться в курсе по ООП =)

#### Протокол итерируемых объектов и итераторов

**У всех итерируемых объектов** есть магический метод `__iter__()`, который преобразует итерируемый объект в итератор. Встроенная функция `iter()` вызывает за кулисами именно этот магический метод.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator = iter(words)      # за кулисами вызывается метод words.__iter__()

print(type(words))
print(type(iterator))
```

выводит:

```1c
<class 'list'>
<class 'list_iterator'>
```

**У всех итераторов** есть магический метод `__next__()`, который обеспечивает выдачу очередного элемента. Встроенная функция `next()` вызывает за кулисами именно этот магический метод.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator = iter(words)      # за кулисами вызывается метод words.__iter__()

print(next(iterator))       # за кулисами вызывается метод iterator.__next__()
print(next(iterator))       # за кулисами вызывается метод iterator.__next__()
```

выводит:

```no-highlight
hello
beegeek
```

Когда элементы в итераторе закончились, очередной вызов функции `next()` возбуждает исключение `StopIteration`.

Если объект итератором не является, то есть у него нет магического метода `__next__()`, то вызов функции `next()` приведет к ошибке.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

print(next(words))
```

приводит к возникновению исключения:

```no-highlight
TypeError: 'list' object is not an iterator
```

**У всех итераторов** также есть и метод `__iter__()`, который возвращает сам итератор (сам себя). Таким образом, любой итератор является итерируемым объектом, но не наоборот, не любой итерируемый объект является итератором.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator1 = iter(words)          # за кулисами вызывается метод words.__iter__()
iterator2 = iter(iterator1)      # за кулисами вызывается метод iterator1.__iter__()

print(iterator1 == iterator2)
```

выводит:

```no-highlight
True
```

Таким образом, если функции `iter()` передается итератор, то она возвращает его же. Если же функции `iter()` передать итерируемый объект, не являющийся итератором (например, список), то она вернет совсем другой объект – итератор на основе этого итерируемого объекта.

Возникает вопрос, для чего итераторы содержат магический метод `__iter__()`. Все дело в том, что цикл `for` ожидает, что у объекта, по которому идет итерирование, есть не только магический метод `__next__()`, но и `__iter__()`. Задача метода `__iter__()` – превращать итерируемый объект в итератор. Если в цикл `for` передается уже итератор, то метод `__iter__()` этого объекта должен возвращать сам объект.

Если циклу `for` передается не итератор, а итерируемый объект, то его метод `__iter__()` должен возвращать не сам объект, а итератор на основе этого итерируемого объекта.

Получается, в итераторах метод `__iter__()` нужен лишь для совместимости. Ведь если `for` работает как с итераторами, так и итерируемыми объектами, но последние требуют преобразования к итератору, и `for` вызывает `__iter__()` без оценки того, что ему передали, то требуется, чтобы оба – итератор (`iterator`) и итерируемый объект (`iterable`) – поддерживали этот метод. С точки зрения наличия в классе метода `__iter__()` итераторы можно считать подвидом итерируемых объектов.

![](https://ucarecdn.com/6d97deae-aee6-4738-b5c8-64b28668deb2/)

#### Протокол итератора

Теперь формализуем протокол итератора :

1.  чтобы получить итератор, мы должны передать функции `iter()` итерируемый объект
2.  далее мы передаём итератор функции `next()`
3.  когда элементы в итераторе закончились, вызов функции `next()` возбуждает исключение `StopIteration`

Особенности:

1.  любой объект, передаваемый функции `iter()` без исключения `TypeError` — итерируемый объект
2.  любой объект, передаваемый функции `next()` без исключения `TypeError` — итератор
3.  любой объект, передаваемый функции `iter()` и возвращающий сам себя — итератор

Любой итерируемый объект реализует протокол итератора.

#### Особенность функции iter()

Встроенная функция `iter()`, как мы уже знаем, преобразует итерируемый объект в итератор. Именно в таком виде функция используется в большинстве случаев.

```no-highlight
iter(iterable) -> iterator
```

Однако мы можем использовать функцию `iter()` в еще одном полезном сценарии:

```no-highlight
iter(callable, sentinel) -> iterator
```

Если функции `iter()` передается два аргумента, то первый аргумент `callable` должен являться функцией, а второй аргумент `sentinel` — некоторым стоп-значением. В этом случае, созданный итератор будет вызывать указанную функцию `callable` и проверять полученное значение на равенство со значением `sentinel`. Если полученное значение равно `sentinel`, то возбуждается исключение `StopIteration`, иначе итератор выдает значение, полученное из функции `callable`.

Например, с помощью функции `iter()` мы можем создать бесконечный итератор, генерирующий единственное значение — 00.

Приведенный ниже код:

```python
zero_iterator = iter(int, -1)

for i in range(5):
    print(next(zero_iterator))

print(type(zero_iterator))
```

выводит:

```no-highlight
0
0
0
0
0
<class 'callable_iterator'>
```

Функция `int()`, которую мы передаем в качестве первого аргумента в функцию `iter()`, всегда возвращает значение 00, при этом вторым аргументом (стоп-значением) является −1−1, которое не будет возвращено никогда. Таким образом, мы построили бесконечный итератор, генерирующий единственное нулевое значение.

Мы также можем написать итератор, который генерирует неопределенное количество случайных чисел.

Приведенный ниже код:

```python
from random import choice

def test_iter():
    values = list(range(1, 11))
    return choice(values)

random_iterator = iter(test_iter, 2)

for num in random_iterator:
    print(num)
```

может вывести:

```no-highlight
1
3
3
9
4
3
5
```

Итератор `random_iterator` будет генерировать случайное число от 11 до 1010 до тех пор, пока не будет возвращено число 22.

Одним из применений второго аргумента `sentinel` является чтение строк файла до тех пор, пока не будет достигнута строка `sentinel`.

Приведенный ниже код:

```python
with open('data.txt') as file:
    for line in iter(file.readline, ''):    # читаем, пока не попадется пустая строка 
        # Делаем что-то с line.
```

считывает строки текстового файл `data.txt` до тех пор, пока очередная строка не окажется пустой.

##### Примечания

**Примечание 1.** Итерируемый объект (`iterable`) и итератор (`iterator`) – это протоколы, правила.

**Примечание 2.** В Python есть встроенный модуль `collections.abc`, который предоставляет абстрактные базовые классы различного типа коллекций. Изучите данный модуль по [ссылке](https://docs.python.org/3/library/collections.abc.html).

#### Протокол итератора и итерируемого объекта

**У всех итерируемых объектов** есть магический метод `__iter__()`, который преобразует итерируемый объект в итератор. Встроенная функция `iter()` вызывает за кулисами именно этот магический метод.

**У всех итераторов** есть магический метод `__next__()`, который обеспечивает выдачу очередного элемента. Встроенная функция `next()` вызывает за кулисами именно этот магический метод. Когда элементы в итераторе закончились, очередной вызов функции `next()` возбуждает исключение `StopIteration`.

**У всех итераторов** также есть и метод `__iter__()`, который возвращает сам итератор (сам себя). Таким образом, любой итератор является итерируемым объектом, но не наоборот, не любой итерируемый объект является итератором.

![](https://ucarecdn.com/32304fa5-6053-48ce-a16e-d6f8b41b0970/)

Таким образом, для создания собственных итераторов нам нужно определить класс (тип), соответствующий протоколу итератора, то есть содержащий методы `__next__()` и `__iter__()`. Несмотря на то что мы еще не работали с созданием классов, в этом нет ничего сложного.

#### Магический метод __init__()

Для создания собственных классов итераторов нам потребуется определить в них метод `__init__()`.

Магический метод `__init__()` используется для **инициализации создаваемого объекта**. Точнее говоря, в методе `__init__()` мы устанавливаем начальные атрибуты создаваемого объекта. При использовании метода `__init__()` мы не вызываем его напрямую, вместо этого он становится основой метода конструктора класса.

Например, вспомним тип `Fraction` из модуля `fractions`. При создании объекта типа `Fraction` мы указываем значение для числителя и знаменателя дроби:

```python
from fractions import Fraction

frac1 = Fraction(3, 4)      # конструктор за кулисами вызывает магический метод __init__(3, 4)
frac2 = Fraction(6, 9)      # конструктор за кулисами вызывает магический метод __init__(6, 9)
```

#### Примеры создания собственных итераторов

**Пример 1.** Создадим итератор `Counter`, который генерирует последовательность целых чисел от значения `low` до `high` с шагом один. Значения `low` и `high` передаются при создании итератора в конструкторе.

**Реализация итератора.** Определяем класс `Counter` с тремя методами:

1.  `__init__()`: конструктор класса, вызывается единожды при создании объекта
2.  `__iter__()`: метод, который возвращает ссылку на сам итератор для поддержания протокола итератора
3.  `__next__()`: метод, который возвращает следующий элемент или возбуждает исключение `StopIteration`

```python
class Counter:                             
    def __init__(self, low, high):         # конструктор принимает два аргумента low и high (помимо self)
        self.low = low
        self.high = high
    
    def __iter__(self):
        return self
    
    def __next__(self): 
        if self.low > self.high:
            raise StopIteration
        else:
            self.low += 1
            return self.low - 1
```

Приведенный ниже код:

```python
counter1 = Counter(3, 10)         # создаем итератор Counter, передавая значения low=3, high=10

for i in counter1:                # неявно вызываем функцию next()
    print(i)

counter2 = Counter(100, 103)      # создаем итератор Counter, передавая значения low=100, high=103
print(next(counter2))             # явно вызываем функцию next()
print(next(counter2))             # явно вызываем функцию next()
```

выводит:

```no-highlight
3
4
5
6
7
8
9
10
100
101
```

Напомним, что цикл `for` за кулисами вызывает один раз магический метод `__iter__()` у итерируемого объекта для получения итератора, а затем метод `__next__()` до тех пор, пока не будет возбуждено исключение `StopIteration`.

**Пример 2.** Создадим бесконечный итератор`EvenNumbers`, который генерирует последовательность всех целых четных чисел от значения `begin`. Значение `begin` передается при создании итератора в конструкторе.

**Реализация итератора.** Определяем класс `EvenNumbers` с тремя методами:

1.  `__init__()`: конструктор класса, вызывается единожды при создании объекта
2.  `__iter__()`: метод, который возвращает ссылку на сам итератор для поддержания протокола итератора
3.  `__next__()`: метод, который возвращает следующий элемент или возбуждает исключение `StopIteration`

```python
class EvenNumbers:                             
    def __init__(self, begin):                 # конструктор принимает один аргумент begin (помимо self)
        self.begin = begin +  begin % 2
    
    def __iter__(self):
        return self
    
    def __next__(self):
        value  = self.begin
        self.begin += 2
        return value
```

Приведенный ниже код:

```python
evens1 = EvenNumbers(10)                     # все четные числа от 10 до бесконечности

for index, num in enumerate(evens1):
    if index > 5:
        break
    print(num)

evens2 = EvenNumbers(101)                    # все четные числа от 102 до бесконечности

print(next(evens2))
print(next(evens2))
print(next(evens2))
print(next(evens2))
```

выводит:

```no-highlight
10
12
14
16
18
20
102
104
106
108
```

Обратите внимание на то, что наш итератор является бесконечным, так как метод `__next__()` не возбуждает исключения `StopIteration`. При работе с бесконечными итераторами нужно быть осторожными, чтобы не попасть в бесконечный цикл.

Приведенный ниже код:

```python
evens = EvenNumbers(2)                     # все четные числа от 2 до бесконечности

for num in evens:
    print(num)
```

будет бесконечно печатать четные числа:

```no-highlight
2
4
6
8
10
12
14
16
...
```

**Пример 3.** Создадим итератор`StringWrapper`, который генерирует последовательность всех символов строки `text`, обрамленных специальным символом `symbol`. Значения `text` и `symbol` передаются при создании итератора в конструкторе.

**Реализация итератора.** Определяем класс `StringWrapper` с тремя методами:

1.  `__init__()`: конструктор класса, вызывается единожды при создании объекта
2.  `__iter__()`: метод, который возвращает ссылку на сам итератор для поддержания протокола итератора
3.  `__next__()`: метод, который возвращает следующий элемент или возбуждает исключение `StopIteration`

```python
class StringWrapper:                             
    def __init__(self, text, symbol):
        self.text = text
        self.symbol = symbol
        self.index = -1                      # вспомогательное поле для отслеживания текущего индекса
    
    def __iter__(self):
        return self
    
    def __next__(self):
        self.index += 1
        if self.index >= len(self.text):
            raise StopIteration
        return self.symbol + self.text[self.index] + self.symbol
```

Приведенный ниже код:

```python
string_wrapper1 = StringWrapper('beegeek', '~')

for char in string_wrapper1:
    print(char)
 
string_wrapper2 = StringWrapper('Python', '+')

print(next(string_wrapper2))
print(next(string_wrapper2))
print(next(string_wrapper2))

print(list(StringWrapper('stepik', '-')))
```

выводит:

```no-highlight
~b~
~e~
~e~
~g~
~e~
~e~
~k~
+P+
+y+
+t+
['-s-', '-t-', '-e-', '-p-', '-i-', '-k-']
```

Обратите внимание на то, что класс итератора `StringWrapper` помимо атрибутов `self.text` и `self.symbol` содержит и вспомогательное поле `self.index` для поддержания и сохранения текущего индекса символа в строке.

**Пример 4.** Создадим бесконечный итератор `Factorials`, который генерирует последовательность факториалов всех натуральных чисел (от 11 до бесконечности). Конструктор итератора не принимает аргументов.

```python
class Factorials:
    def __init__(self):
        self.value = 1
        self.index = 1
        
    def __iter__(self):
        return self
        
    def __next__(self):
        self.value *= self.index
        self.index += 1
        return self.value
```

Приведенный ниже код:

```python
infinite_factorials = Factorials()

for index, num in enumerate(infinite_factorials, 1):
    if index <= 10:
        print(f'Факториал числа {index} равен {num}')
    else:
        break
```

выводит:

```no-highlight
Факториал числа 1 равен 1
Факториал числа 2 равен 2
Факториал числа 3 равен 6
Факториал числа 4 равен 24
Факториал числа 5 равен 120
Факториал числа 6 равен 720
Факториал числа 7 равен 5040
Факториал числа 8 равен 40320
Факториал числа 9 равен 362880
Факториал числа 10 равен 3628800
```

 Все итераторы, реализованные нами выше, обладают теми же особенностями, которыми обладают встроенные итераторы.

##### Примечания

**Примечание 1.** Вы наверняка обратили внимание на первый параметр `self`, который указывался выше в определении методов, а также при использовании атрибутов объекта в методах. Параметр `self` является ссылкой на конкретный экземпляр класса. При этом само имя `self` не является особенным, а лишь является договоренностью. Вместо `self` можно использовать другое имя, но так делать не рекомендуется.

Наличие такого параметра позволяет нам вызывать методы через точечную нотацию.

Приведенный ниже код:

```python
text = 'beegeek'

print(text.upper())
```

равнозначен коду:

```python
text = 'beegeek'

print(str.upper(text))     # self = text
```

В противоположность некоторым другим языкам, в которых объект (экземпляр класса) доступен в методах под специальным именем (например, `this`) и не числится среди аргументов метода, в Python он обозначен явно.

**Примечание 2.** Встроенные типы `list, tuple, str, set, dict, range` содержат уже реализованные типы итераторов.

Приведенный ниже код:

```python
numbers = iter([1, 2, 3, 4, 5])
timur = iter(('Timur', 29, 'Male'))
text = iter('beegeek')
chars = iter({'a', 'b', 'c'})
info = iter({'name': 'Timur', 'age': 29, 'gender': 'Male'})
even_numbers = iter(range(2, 10, 2))

print(type(numbers))
print(type(timur))
print(type(text))
print(type(chars))
print(type(info))
print(type(even_numbers))
```

выводит:

```no-highlight
<class 'list_iterator'>
<class 'tuple_iterator'>
<class 'str_iterator'>
<class 'set_iterator'>
<class 'dict_keyiterator'>
<class 'range_iterator'>
```

Все указанные типы итераторов следуют общепринятому в Python протоколу.

Например, тип `list_iterator` реализован примерно так:

```python
class list_iterator:
    def __init__(self, data): 
        self.data = data
        self.index = -1
        
    def __iter__(self): 
        return self 
        
    def __next__(self):
        self.index += 1
        if self.index == len(self.data):
            raise StopIteration  
        return self.data[self.index]
```

**Примечание 3.** Важно понимать, что итераторы, создаваемые на основе итерируемых объектов, содержат ссылки на эти итерируемые объекты. Таким образом, изменение итерируемого объекта приводит к изменению возвращаемых итератором значений.

Приведенный ниже код:

```python
numbers = [10, 20, 30, 40, 50]

iterator = iter(numbers)

print(next(iterator))
print(next(iterator))

del numbers[2]

print(next(iterator))
```

выводит:

```no-highlight
10
20
40
```

Наиболее частыми ошибками являются изменение итерируемого объекта во время итерации по нему в цикле `for` и повторное считывание строк файла во время итерации по файловому объекту.

### 2. Что такое enumerate?

Иногда, при переборе объектов в цикле `for`, нужно получить не только сам объект, но и его порядковый номер.

**Enumerate** — синтаксический сахар и позволяющего проще и нагляднее работать с объектами, поддерживающими итерацию. Метод `next()` `enumerate` возвращает кортеж, содержащий значение индекса и соответствующее этому индексу значение.

`enumerate` —  итератор, реализован на С:

```Python
values = ["a", "b", "c", "d"]

for count, value in enumerate(values, start=10 ):
    print(count, value)  # 10 a 11 b 12 c 13 d
```

### 3. Генераторы

### 3.1 Что такое генератор (generator)?

Любая функция, содержащая ключевое слово **yield**, вернет **генератор**. Генератор не хранит в памяти все необходимые элементы, а просто содержит метод для вычисления очередного элемента; результат может создаваться на основе математического алгоритма или брать элементы из другого источника данных (коллекция, файл, сетевое подключение и т. д.), при необходимости модифицируя их.

Пройти генератор в цикле можно только один раз, на каждом шаге возможно вычислить только следующий элемент, но не предыдущий. Элемент генератора нельзя извлечь по индексу, будет выброшена ошибка, т. к. генератор не поддерживает метод `__getitem__()`.

**Генератор** – это функция у которой вместо `return` – `yield`, а также такая ф-ция умеет принимать и отдавать контроль управления

Ключевое слово `yield` используется в функциях так же, как и `return` – для возвращения результата работы. Разница заключается в том, что `yield` возвращает генератор.

Любой генератор является итератором, но не наоборот.

Первый метод — объявить функцию с `yield`

```Python
def count(start, stop, step):
    current = start
    while current <= stop:
        yield current
        current += step

c = count(100, 200, 10)

print(next(c))  # 100
print(next(c))  # 110
print(next(c))  # 120
print(list(c))  # [130, 140, 150, 160, 170, 180, 190, 200]
```

Второй метод — использовать **генераторное выражение** (generator expression):

```Python
r = range(1, 11)
squares = (n**2 for n in r)

print(list(squares))  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

### 3.2 Чем отличается генератор от итератора?

В `yield`(генератор) можно послать значение (оператор `send`) в итератор нет

### 3.3 Ключевое слово yield?

Ключевое слово `yield` используется в функциях так же, как и `return` – для возвращения результата работы. Разница заключается в том, что `yield` возвращает генератор.

Для эффективного использования нужно понимать главную особенность `yield`: **при вызове функции код в теле функции не исполняется**. Функция просто **возвращает объект-генератор**. Код вызывается каждый раз, когда `for` обращается к генератору. При первом запуске функции она будет исполняться, пока не дойдет до `yield`, после чего вернет первое значение из цикла. При каждом последующем вызове будет происходить следующая итерация и возвращение значения цикла. Процесс будет повторяться, пока генератор не окажется пустым. Генератор считается пустым, если функция не встречает `yield` – это происходит либо в конце цикла, либо при невыполнении условий `if` и `else`.

### 3.4 Общие сведения. Генераторы.

В Python можно реализовывать собственные итераторы путем создания классов, содержащих два магических метода `__iter__()` и `__next__()` для поддержания протокола итератора. Делать это несложно, однако достаточно долго и не очень удобно.

В Python создавать собственные итераторы можно намного проще с помощью генераторов, которые делятся на два типа:
-   функции генераторы
-   выражения генераторы

#### Функции генераторы

**Функция генератор** – это функция, которая возвращает итератор. Она выглядит как обычная функция, за исключением того, что использует выражение `yield`, а не `return`.

Когда вызывается обычная функция, она получает личное пространство имен, в котором создаются ее локальные переменные. Когда обычная функция достигает оператора `return`, локальные переменные уничтожаются и значение возвращается вызывающей стороне. Последующий вызов той же функции создает новое локальное пространство имен и новый набор локальных переменных.

Функция генератор, напротив сохраняет локальные переменные от вызова к вызову. Это своего рода **возобновляемая функция**.

Рассмотрим пример функции генератора, которая порождает последовательность целых чисел от 0 (включительно) до n (не включительно).

```python
def generate_ints(n):
    for num in range(n):
        yield num
```

Приведенный ниже код:

```python
generator1 = generate_ints(5) # создаем генератор, порождающий числа 0 1 2 3 4

print(type(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))

generator2 = generate_ints(3) # создаем генератор, порождающий числа 0 1 2

for num in generator2:
    print(num)

num1, num2 = generate_ints(2) # создаем генератор, порождающий числа 0 1

print(num1, num2)
```

выводит:

```no-highlight
<class 'generator'>
0
1
2
3
4
0
1
2
0 1
```

По сути, функция `generate_ints()` просто возвращает генератор, порождающий последовательность нужных чисел.

**Генератор – это итератор**, который порождает значения, переданные `yield`. Когда выполнение доходит до конца функции, объект генератор возбуждает исключение `StopIteration` в полном соответствии с протоколом итератора.

Работа с генератором происходит по стандартному сценарию работы с итератором. Мы можем:

-   вызывать функцию `next()` для получения очередного значения генератора
-   итерироваться с помощью цикла `for` по генератору
-   распаковывать генератор
-   проверять принадлежность с помощью оператора `in`
-   и т.д.

Функция генератор возвращает объект специального типа `<class 'generator'>`, который реализует протокол итератора, то есть является самым настоящим итератором.

Как несложно понять, мы можем достичь эффекта генераторов вручную, написав свой собственный класс, поддерживающий протокол итератора.

Класс `GenerateInts` полностью аналогичен указанной выше функции генератору:

```python
class GenerateInts:                             
    def __init__(self, n): # конструктор принимает верхнюю границу диапазона
        self.n = n
        self.current = 0
    
    def __iter__(self):
        return self
    
    def __next__(self): 
        if self.current == self.n:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1
```

Приведенный ниже код:

```python
iterator1 = GenerateInts(5) # создаем итератор, содержащий числа 0 1 2 3 4

print(type(iterator1))

print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))

iterator2 = GenerateInts(3) # создаем итератор, содержащий числа 0 1 2

for num in iterator2:
    print(num)

num1, num2 = GenerateInts(2) # создаем итератор, содержащий числа 0 1

print(num1, num2)
```

выводит:

```no-highlight
<class 'GenerateInts'>
0
1
2
3
4
0
1
2
0 1
```

На данном примере видно, насколько генераторные функции упрощают процесс реализации собственных итераторов, значительно сокращая количества строк кода.

Обратите внимание на стиль именования класса `GenerateInts` и функции генератора `generate_ints()`.

Может показаться, что в теле функции генератора всегда должен быть цикл, но это необязательно.

Приведенный ниже код:

```python
def generate_1234():
    yield 1
    yield 2
    yield 3
    yield 4

print(*generate_1234()) # распаковка генератора
```

содержит определение функции генератора `generate_1234()`, которая порождает последовательность значений 1,2,3,4 и выводит:

```
1 2 3 4
```

#### Функции генераторы с побочными действиями

Функция генератор может не только порождать значения, но и совершать различные побочные действия во время выполнения, такие как:

-   вывод текста на экран
-   запись данных в файл
-   приостановка исполняющейся программы на некоторое время
-   и т.д.

Рассмотрим определение функции генератора, которая печатает текст во время выполнения.

Приведенный ниже код:

```python
def generate_AB():
    print('start')
    yield 'A'
    print('continue')
    yield 'B'
    print('end')

for char in generate_AB():
    print('-->', char)
```

выводит:

```no-highlight
start
--> A
continue
--> B
end
```

Как мы уже знаем, для итерирования цикл `for` сначала получает итератор, то есть выполняет следующий код:

```python
iterator = iter(generate_AB())
```

а затем на каждой итерации вызывает функцию `next(iterator)`. В теле цикла на каждой итерации печатается строка `-->` и значение, полученное при вызове `next(iterator)`.

Во время первой итерации и первом вызове `next(iterator)` генератор, перед тем как сгенерировать значение `'A'` (то есть дойти до строки `yield 'A'`), сначала выполняет строку `print('start')`.

Во время второй итерации и втором вызове `next(iterator)` генератор, перед тем как сгенерировать значение `'B'` (то есть дойти до строки `yield 'B'`), сначала выполняет строку `print('continue')`.

Во время третьей итерации и третьем вызове `next(iterator)` генератор выполняет строку `print('end')` и завершает свою работу, возбуждая исключение `StopIteration`. Цикл `for` перехватывает это исключение и нормально завершается.

#### Ключевое слово return в теле функции генератора

До версии Python 3.3 наличие ключевого слова `return` внутри функции генератора приводило к возникновению ошибки:

```no-highlight
SyntaxError: 'return' with argument inside generator
```

Теперь это допускается, при этом инструкция `return` приводит к возбуждению исключения `StopIteration`.

Приведенный ниже код:

```python
def generate_ints():
    yield 1
    yield 2
    return 3
    yield 4

for num in generate_ints():
    print(num)
```

выводит:

```no-highlight
1
2
```

Строка кода `return 3` в функции генераторе `generate_ints()` возбуждает исключение `StopIteration`, которое перехватывает цикл `for`, после чего он завершается. Обратите внимание на то, что само значение 3 не выводится.

#### Особенности и ограничения функций генераторов

Основные особенности, присущие всем функциям генераторам:

-   любая функция, содержащая ключевое слово `yield`, является функцией генератором
-   когда вызывается функция генератор, то она **не возвращает единственное значение**, как это делает обыкновенная функция
-   функция генератор всегда возвращает объект типа `generator`, который поддерживает протокол итератора

Разница между `yield` и оператором `return` заключается в том, что для ключевого слова `yield` состояние выполнения генератора приостанавливается и локальные переменные сохраняются. При следующем вызове метода генератора `__next__()` функция возобновляет свое выполнение из той точки, из которой завершила в прошлый раз.

Генератор является итератором, поэтому он обладает всеми его особенностями:

-   нельзя получить длину генератора функцией `len()`
-   нельзя распечатать элементы генератора функцией `print()` без предварительной распаковки
-   у генератора нельзя получить элемент по индексу
-   после итерации по генератору он становится пустым

#### Примеры использования функций генераторов

В прошлом уроке мы рассматривали примеры по созданию собственных итераторов с помощью создания соответствующих классов. Давайте перепишем их с использованием функций генераторов.

**Пример 1.** Реализуем функцию генератор `counter()`, которая возвращает генератор, порождающий последовательность целых чисел значения `low` до `high` включительно с шагом один. Значения `low` и `high` передаются в качестве аргументов в функцию генератор.

**Реализация функции генератора:**

```python
def counter(low, high):
    for num in range(low, high + 1):
        yield num
```

Приведенный ниже код:

```python
counter1 = counter(3, 10)

for i in counter1:
    print(i)

counter2 = counter(100, 103)
print(next(counter2))
print(next(counter2))
```

выводит:

```no-highlight
3
4
5
6
7
8
9
10
100
101
```

Ручная реализация соответствующего класса итератора

**Пример 2.** Реализуем функцию генератор `even_numbers()`, которая возвращает генератор, порождающий бесконечную последовательность целых четных чисел от значения `begin`. Значение `begin` передается в качестве аргумента в функцию генератор.

**Реализация функции генератора:**

```python
def even_numbers(begin):
    begin += begin % 2
    while True:
        yield begin
        begin += 2
```

Приведенный ниже код:

```python
evens1 = even_numbers(10)                     # все четные числа от 10 до бесконечности

for index, num in enumerate(evens1):
    if index > 5:
        break
    print(num)

evens2 = even_numbers(101)                    # все четные числа от 102 до бесконечности

print(next(evens2))
print(next(evens2))
print(next(evens2))
print(next(evens2))
```

выводит:

```no-highlight
10
12
14
16
18
20
102
104
106
108
```

Ручная реализация соответствующего класса итератора

**Пример 3.** Реализуем функцию генератор `string_wrapper`, которая возвращает генератор, порождающий последовательность символов строки `text`, обрамленных специальным символом `symbol`. Значения `text` и `symbol` передаются в качестве аргументов в функцию генератор.

**Реализация функции генератора:**

```python
def string_wrapper(text, symbol):
    for char in text:
        yield symbol + char + symbol
```

Приведенный ниже код:

```python
string_wrapper1 = string_wrapper('beegeek', '~')

for char in string_wrapper1:
    print(char)
 
string_wrapper2 = string_wrapper('Python', '+')
print(next(string_wrapper2))
print(next(string_wrapper2))
print(next(string_wrapper2))

print(list(string_wrapper('stepik', '-')))
```

выводит:

```no-highlight
~b~
~e~
~e~
~g~
~e~
~e~
~k~
+P+
+y+
+t+
['-s-', '-t-', '-e-', '-p-', '-i-', '-k-']
```

Ручная реализация соответствующего класса итератора

**Пример 4.** Реализуем функцию генератор `factorials()`, которая возвращает генератор, порождающий бесконечную последовательность факториалов всех натуральных чисел (от 11 до бесконечности). Функция генератор не принимает аргументов.

**Реализация функции генератора:**

```python
def factorials():
    value = 1
    index = 1
    while True:
        yield value
        index += 1
        value *= index
```

Приведенный ниже код:

```
infinite_factorials = factorials()

for index, num in enumerate(infinite_factorials, 1):
    if index <= 10:
        print(f'Факториал числа {index} равен {num}')
```

выводит:

```no-highlight
Факториал числа 1 равен 1
Факториал числа 2 равен 2
Факториал числа 3 равен 6
Факториал числа 4 равен 24
Факториал числа 5 равен 120
Факториал числа 6 равен 720
Факториал числа 7 равен 5040
Факториал числа 8 равен 40320
Факториал числа 9 равен 362880
Факториал числа 10 равен 3628800
```

Ручная реализация соответствующего класса итератора

##### Примечания

**Примечание 1.** Функция генератор и генераторная функция – это одно и то же.

**Примечание 2.** Любой итератор является итерируемым объектом, в то время как любой генератор является итератором, а значит и итерируемым объектом.

![](https://ucarecdn.com/c0edc415-5530-478a-8a99-0f6d3abb21db/)

**Примечание 3.** Приведенный ниже код:

```python
def generate_1():
    yield 1

gen = generate_1()

print(dir(gen))
```

выводит список всех атрибутов генератора, среди которых есть методы `__iter__()` и `__next__()`:

```python
['__class__', '__del__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__name__', '__ne__', '__new__', '__next__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'gi_code', 'gi_frame', 'gi_running', 'gi_yieldfrom', 'send', 'throw']
```

**Примечание 4.** Итерируемый объект и итератор – это протоколы, то есть правила реализации. Генератор – это не протокол, а конкретная реализация. Это специальный механизм в языке Python, который позволяет создать однократно перебираемую функцию, логика перебора которой легко и красиво описывается.

**Примечание 5.** Единственное синтаксическое различие между обычной функцией и функцией генератором – тот факт, что в теле последней встречается ключевое слово `yield`. Многие разработчики из команды Python считали, что для функций генераторов следовало бы ввести новое ключевое слово `gen` вместо `def`, но Гвидо не согласился.

#### Конструкция yield from

Рассмотрим генераторную функцию`get_data()`, которая порождает последовательность чисел `0, 1, 2, 3, 4`, а затем символов `A, B, C`:

```python
def get_data():
    for num in range(5):
        yield num
    for char in 'ABC':
        yield char
```

Приведенный ниже код:

```no-highlight
for i in get_data():
    print(i)
```

выводит:

```no-highlight
0
1
2
3
4
A
B
C
```

Генераторную функцию `get_data()` можно упростить, если использовать синтаксическую конструкцию `yield from <iterable>`, которая появилась в Python 3.3.

Приведенный ниже код равнозначен первому определению генераторной функции `get_data()`:

```python
def get_data():
    yield from range(5)
    yield from 'ABC'
```

Таким образом, синтаксическая конструкция `yield from <iterable>` позволяет объединить две конструкции: `yield` и цикл `for`.

Реализуем генераторную функцию `chain(*iterables)`, которая принимает произвольное количество итерируемых объектов и возвращает генератор, который последовательно порождает все значения сначала первого итерируемого объекта, затем второго, третьего и т.д.

Приведенный ниже код:

```python
def chain(*iterables):
    for it in iterables:
        for value in it:
            yield value

for i in chain('AB', [1, 2], (4, 5), {'name': 'Timur', 'age': 29}):
    print(i, end=' ')
```

выводит:

```no-highlight
A B 1 2 4 5 name age 
```

С помощью конструкции `yield from <iterable>` мы можем упростить тело генераторной функции`chain()`:

```python
def chain(*iterables):
    for it in iterables:
        yield from it

```

Как мы видим, конструкция `yield from` полностью заменяет внутренний цикл `for` и код действительно смотрится несколько проще.

Объединение конструкции `yield` и цикла `for` лишь часть возможностей `yield from`. На самом деле конструкция `yield from`  позволяет вкладывать один генератор в другой, таким образом создавать субгенераторы (вложенные генераторы).

Приведенный ниже код:

```python
def generator2():
    yield 'Red'
    yield 'Blue'

def generator1():
    yield 'Green'
    yield from generator2()            # запрашиваем значение из субгенератора
    yield 'Yellow'
    yield 'Black'

for color in generator1():
    print(color, end=' ')
```

выводит:

```no-highlight
Green Red Blue Yellow Black 
```

Когда генератор `generator1()` вызывает `yield from generator2()`, субгенератор `generator2()` перехватывает управление и начинает отдавать значения туда, откуда был вызван `generator1()`. А тем временем `generator1()` остается блокированным в ожидании завершения `generator2()`. Таким образом, эффект получается таким же, как если бы тело субгенератора было встроено в месте, где находится выражение `yield from`.

Конструкция `yield from` позволяет программисту легко управлять сразу несколькими генераторами, настраивать их взаимодействие.

#### Рекурсивные функции генераторы

Конструкции `yield` и `yield from` можно использовать для написания рекурсивных генераторов.

Приведенный ниже код:

```python
def numbers(start):
    if not isinstance(start, int):
        raise TypeError('Аргументом должно быть целое число')
    yield start
    yield from numbers(start + 1)
```

определяет бесконечный генератор `numbers(start)`, который порождает все целые числа со значения `start`.

Приведенный ниже код:

```python
for index, number in enumerate(numbers(3)):
    if index > 5:
        break
    print(number)
```

выводит:

```no-highlight
3
4
5
6
7
8
```

##### Примечания

**Примечание 1.** Прочитать подробнее о конструкции `yield from` и субгенераторах можно в официальной [документации](https://www.python.org/dev/peps/pep-0380/). Данная конструкция имеет много практических применений.

### 3.3 Генераторные выражения

Существует еще более простой, чем генераторные функции, содержащие оператор `yield`, способ создания итераторов – **генераторные выражения**. Они подходят, когда код тела генераторной функции можно записать в одно выражение.

Синтаксис генераторных выражений подобен синтаксису генераторов списков, но в отличие от них, в генераторных выражениях используются круглые скобки, а не квадратные.

> В Python существуют генераторы словарей и множеств, в которых используются фигурные скобки.

Напомним, как выглядят генераторы списков.

Приведенный ниже код:

```python
from sys import getsizeof

numbers = [1, 9, 8, 7, 90, -56, -34, 56, 100, 90, 2, 8]

even_numbers = [num for num in numbers if num % 2 == 0]

print(type(even_numbers))
print(even_numbers)
print(getsizeof(even_numbers))
```

выводит:

```no-highlight
<class 'list'>
[8, 90, -56, -34, 56, 100, 90, 2, 8]
184
```

Результат выражения, стоящего до `for`, в данном случае `num`, добавляется на каждой итерации цикла в итоговый список. Выполнение выражения генератора списка сразу заполняет список, который **целиком хранится в памяти**.

В случае генераторных выражений создается генератор, у которого очередной элемент будет вычисляться только при вызове встроенной функции `next()` (явно или неявно).

Приведенный ниже код:

```python
from sys import getsizeof

numbers = [1, 9, 8, 7, 90, -56, -34, 56, 100, 90, 2, 8]

even_numbers = (num for num in numbers if num % 2 == 0)         # используем круглые скобки

print(type(even_numbers))
print(even_numbers)
print(getsizeof(even_numbers))
```

выводит:

```no-highlight
<class 'generator'>
<generator object <genexpr> at 0x0000020E9C767300>
104
```

Обратите внимание на то, что переменная `even_numbers` имеет уже знакомый нам тип `generator`, то есть является генератором, который в полной мере реализует протокол итератора. Для того чтобы посмотреть содержимое генератора `even_numbers`, мы должны проитерироваться по нему любым известным нам способом (явный вызов функции `next()`, цикл `for`, распаковка и т.д.).

Приведенный ниже код:

```python
squares = (i ** 2 for i in range(1, 7))         # создаем генератор с помощью генераторного выражения
capitals = (s.upper() for s in 'abc')           # создаем генератор с помощью генераторного выражения
stars = ('*' for i in range(5))                 # создаем генератор с помощью генераторного выражения

for num in squares:
    print(num)

print(next(capitals))

print(*stars, end=' ')
```

выводит:

```no-highlight
1
4
9
16
25
36
A
* * * * * 
```

В отличие от генераторных выражений, генераторные функции более универсальны не только из-за произвольного количества кода в их теле. В них вы можете передавать разные значения аргументов. А значит, одна и та же функция может использоваться для создания нескольких разных генераторов.

#### Особенности генераторных выражений

1) Генераторные выражения нельзя писать без скобок – это синтаксическая ошибка.

Приведенный ниже код:

```python
squares = i*i for i in range(10)
print(*squares)
```

приводит к синтаксической ошибке `SyntaxError: invalid syntax`.

2) При передаче генераторного выражения в функцию в качестве единственного аргумента скобки можно опускать 🧐.

Приведенный ниже код:

```python
print(sum(i*i for i in range(10)))          # передача без скобок
print(sum((i*i for i in range(10))))        # передача со скобками
```

выводит:

```no-highlight
285
285
```

3) Согласно PEP8 – то, что указано в скобках, можно переносить. Значит, генераторные выражения можно записывать так, чтобы их было удобно читать.

Приведенный ниже код:

```python
even_squares = (
                i ** 2
                for i in range(10)
                if i % 2 == 0
               )
```

равнозначен:

```python
even_squares = (i ** 2 for i in range(10) if i % 2 == 0)
```

#### Ограничения генераторных выражений

Генераторное выражение является итератором, поэтому оно обладает всеми его особенностями:

1) Нельзя получить длину генераторного выражения с помощью встроенной функции `len()`.

Приведенный ниже код:

```python
squares = (i*i for i in range(10))
print(len(squares))
```

приводит к возбуждению исключения:

```no-highlight
TypeError: object of type 'generator' has no len()
```

2) Нельзя распечатать элементы генераторного выражения с помощью функции `print()`, без предварительной распаковки.

Приведенный ниже код:

```python
squares = (i*i for i in range(10))
print(squares)
print(*squares)
```

выводит:

```no-highlight
<generator object <genexpr> at 0x0000022B9D967370>
0 1 4 9 16 25 36 49 64 81
```

3) Генераторные выражения не поддерживают получение элемента по индексу.

Приведенный ниже код:

```python
squares = (i*i for i in range(10))
print(squares[7])
```

приводит к возбуждению исключения:

```no-highlight
TypeError: 'generator' object is not subscriptable
```

4) К генераторному выражению нельзя применить обычные операции среза.

Приведенный ниже код:

```python
squares = (i*i for i in range(10))
print(squares[1:6])
```

приводит к возбуждению исключения:

```no-highlight
TypeError: 'generator' object is not subscriptable
```

5) После использования генераторного выражения, оно остается пустым.

Приведенный ниже код:

```python
squares = (i*i for i in range(10))

first, second = next(squares), next(squares)

nums1 = list(squares)
nums2 = list(squares)

print(first)
print(second)
print(nums1)
print(nums2)
```

выводит:

```no-highlight
0
1
[4, 9, 16, 25, 36, 49, 64, 81]
[]
```

#### Генераторные выражения VS функции map(), filter()

Генераторные выражения могут использоваться в качестве альтернативы использования функций `map(), filter()`, которые преобразуют и фильтруют данные. И генераторные выражения, и функции `map(), filter()` возвращают ленивые объекты, поддерживающие протокол итератора и не потребляющие много памяти.

Приведенный ниже код:

```python
fruits = ['apple', 'apricot', 'avocado', 'pineapple', 'banana', 'bergamot', 'durian', 'grapefruit']

fruits_filter = filter(lambda s: len(s) > 7, fruits)
fruits_map = map(lambda s: s.upper(), fruits)
fruits_filter_map = map(lambda s: s.upper(), filter(lambda s: len(s) > 7, fruits))

print(*fruits_filter)
print(*fruits_map)
print(*fruits_filter_map)

print(type(fruits_filter))
print(type(fruits_map))
```

выводит:

```no-highlight
pineapple bergamot grapefruit
APPLE APRICOT AVOCADO PINEAPPLE BANANA BERGAMOT DURIAN GRAPEFRUIT
PINEAPPLE BERGAMOT GRAPEFRUIT
<class 'filter'>
<class 'map'>
```

Альтернативный код с использованием генераторных выражений:

```python
fruits = ['apple', 'apricot', 'avocado', 'pineapple', 'banana', 'bergamot', 'durian', 'grapefruit']

fruits_filter = (s for s in fruits if len(s) > 7)
fruits_map = (s.upper() for s in fruits)
fruits_filter_map = (s.upper() for s in fruits if len(s) > 7)

print(*fruits_filter)
print(*fruits_map)
print(*fruits_filter_map)

print(type(fruits_filter))
print(type(fruits_map))
```

выводит:

```no-highlight
pineapple bergamot grapefruit
APPLE APRICOT AVOCADO PINEAPPLE BANANA BERGAMOT DURIAN GRAPEFRUIT
PINEAPPLE BERGAMOT GRAPEFRUIT
<class 'generator'>
<class 'generator'>
```

Несложно заметить, что генераторные выражения выглядят намного понятнее, лаконичнее и читабельнее, чем их соответствующие аналоги `map(), filter()` с лямбда функциями.

#### Сравнение занимаемой памяти

Генераторные выражения занимают немного больше памяти, чем соответствующие аналоги `map(), filter()` с лямбда функциями.

```python
from sys import getsizeof

range_object = range(1000000)
list_object = list(range_object)
filter_object = filter(lambda num: True, range_object)
map_object = map(lambda num: num, range_object)
generator_object = (num for num in range_object)

print(getsizeof(range_object))
print(getsizeof(list_object))
print(getsizeof(filter_object))
print(getsizeof(map_object))
print(getsizeof(generator_object))
```

выводит:

```no-highlight
48
8000056
48
48
104
```

Заметим, что увеличив размер диапазона `range` до 22 млн, увеличится размер лишь списка. При этом размеры остальных объектов останутся неизменными.

#### Генераторные выражения VS генераторные функции

Генераторные выражения и генераторные функции являются, как правило, взаимозаменяемыми.

Приведенная ниже генераторная функция:

```python
def do_something(elements):
    for item in elements:
        yield some_operation(item)
```

может быть записана в виде функции, возвращающей генератор с помощью генераторного выражения:

```python
def do_something(elements):
    return (some_operation(item) for item in elements)
```

Рассмотрим генераторную функцию `trim_line_endings()`, которая принимает в качестве аргумента файловый объект (открытый текстовый файл) и возвращает генератор, порождающий последовательность строк переданного файла без символа `\n`:

```python
def trim_line_endings(lines):
    for line in lines:
        yield line.rstrip('\n')
```

Данная функция может быть в виде функции, возвращающей генератор с помощью генераторного выражения:

```python
def trim_line_endings(lines):
    return (line.rstrip('\n') for line in lines)
```

##### Примечания

**Примечание 1.** Генераторные выражения более компактны, но менее универсальны, чем полные генераторные функции.

**Примечание 2.** Обратите внимание, если обрабатывается большая структура данных (список, словарь и т.д.) без использования генератора, то она сразу вся загружается в память, что может занять значительную часть памяти, а в некоторых случаях оперативной памяти может не хватить, тогда будет возбуждено исключение `MemoryError`. В случае использования генераторного выражения (генераторной функции) такого не происходит, так как элементы создаются и обрабатываются по одному.

**Примечание 3.** Очень часто начинающие программисты думают, что генераторное выражение является генератором кортежа 😄. Это не так, в Python нет генераторов кортежей. Но при этом генераторное выражение можно передавать в качестве аргумента любой функции конструктору стандартных типов данных Python.

Приведенный ниже код:

```python
squares_tuple = tuple(i*i for i in range(5))
squares_list = list(i*i for i in range(5))
squares_set = set(i*i for i in range(5))

print(squares_tuple, type(squares_tuple))
print(squares_list, type(squares_list))
print(squares_set, type(squares_set))
```

выводит:

```no-highlight
(0, 1, 4, 9, 16) <class 'tuple'>
[0, 1, 4, 9, 16] <class 'list'>
{0, 1, 4, 9, 16} <class 'set'>
```

**Примечание 4.** Python поддерживает четыре вида генераторов:

-   генераторы списков (list comprehension)
-   генераторы множеств (set comprehension)
-   генераторы словарей (dict comprehension)
-   генераторные выражения (generator expressions, а не tuple comprehensions).

**Примечание 5.** Разумное применение генераторов может улучшить читаемость кода, в то время как неразумное их использование может сделать код абсолютно нечитаемым. Во всем нужно соблюдать баланс 😉.

На случай, если вы забыли как выглядит синтаксис генераторов.

**Синтаксис генератора списков** устроен следующим образом:

```python
new_list = [выражение for элемент in последовательность if условие]
```

**Синтаксис генератора словарей** устроен следующим образом:

```python
new_dict = {ключ:значение for (ключ,значение) in dict.items() if условие}
```

**Синтаксис генератора множеств** устроен следующим образом:

```python
new_set = {выражение for элемент in последовательность if условие}
```

**Синтаксис генераторных выражений** устроен следующим образом:

```python
new_gen = (выражение for элемент in последовательность if условие)
```

Обратите внимание, что генераторы множеств и словарей используют одинаковые скобки, разница в том, что у словаря указывается двойной элемент `ключ: значение`.

**Примечание 6.** В Python синтаксис позволяет использовать переносы строк внутри скобок. Используя эту возможность, можно сделать синтаксис генераторов выражений более легким для чтения:

```
numbers = range(10)

# Before
squared_evens = [n ** 2 for n in numbers if n % 2 == 0]

# After
squared_evens = [
    n ** 2
    for n in numbers
    if n % 2 == 0
]
```

#### Конвейеры генераторов

Как мы уже знаем, у итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом. К примеру, мы часто использовали встроенные функции `filter()` и `map()`, для того чтобы сначала отфильтровать данные, а затем их преобразовать.

Приведенный ниже код:

```python
numbers = [1, 2, -9, 8, 3, -4, -2, -1, 0, 2, 91, 69]

odd_numbers = filter(lambda num: num % 2, numbers)

abs_odd_numbers = map(abs, odd_numbers)

print(*abs_odd_numbers)
```

выводит:

```no-highlight
1 9 3 1 91 69
```

Генераторы являются итераторами, поэтому мы можем компоновать их, создавая тем самым так называемые конвейеры (цепочки) генераторов.

Приведенный ниже код:

```python
def integers(n):
    for i in range(1, n + 1):
        yield i

def evens(iterable):
    for i in iterable:
        if not i % 2:
            yield i

def squared(iterable):
    for i in iterable:
        yield i * i

def negated(iterable):
    for i in iterable:
        yield -i

chain = negated(squared(evens(integers(10))))

print(*chain)
```

выводит:

```no-highlight
-4 -16 -36 -64 -100
```

Самое главное в конвейерах генераторов это то, что обработка данных происходит по одному элементу за раз. Между этапами обработки в цепочке нет буферизации: генератор целых чисел выдает единственное значение, скажем, 44. Это активирует генератор четных чисел, который обрабатывает это значение, и поскольку оно четное, передает его на следующий этап в виде числа 44. Далее активируется генератор квадратов, который обрабатывает значение 44 и передает его на следующий этап как 42=1642=16. Далее активируется генератор инвертирования знака, который изменяет знак числа 1616 на противоположный и порождает значение −16−16.

Мы можем продолжать расширять эту цепочку генераторов, чтобы построить конвейер обработки со многими шагами. Он по-прежнему будет работать эффективно и может быть легко изменен, поскольку каждый шаг в цепочке представляет собой отдельную генераторную функцию.

Конвейеры данных выглядят еще нагляднее, если они построены на основе генераторных выражений.

Приведенный ниже код:

```python
n = 10

integers = (i for i in range(1, n + 1))
evens = (i for i in integers if not i % 2)
squared = (i * i for i in evens)
negated = (-i for i in squared)

print(*negated)
```

полностью аналогичен примеру выше.

> Читабельность кода повышается за счет того, что вместо цикла с перемешанными этапами обработки данных, мы пишем небольшие блоки, отвечающие за конкретные задачи, которые стыкуются друг с другом.

#### Обработка больших файлов с помощью конвейеров генераторов

Конвейеры данных, построенные на генераторах позволяют скомпоновать код для обработки больших наборов данных без использования большого количества памяти компьютера. Представим, что у нас есть очень большой текстовый файл в формате `csv` с именем `data.csv`, содержащий данные посещения сайтов, которые нужно обработать.

Заголовок файла `data.csv` имеет вид:

```no-highlight
user_id,user_name,user_ip,date,page_url
```

Для обработки такого файла необходимо проделать следующие шаги:

1.  открыть файл для чтения
2.  прочитать каждую строку файла
3.  разбить каждую строку через разделитель `,` на список значений
4.  извлечь имена столбцов
5.  использовать имена столбцов и список значений из строк для создания словарей
6.  отфильтровать не подходящие строки
7.  обработать интересующие значения

Все указанные выше шаги можно выполнить при помощи нескольких генераторов.

**Шаг 1.** Открываем файл `data.csv` для чтения:

```python
with open('data.csv', 'r', encoding='utf-8') as file:
    # обрабатываем содержимое файла
```

**Шаг 2.** Читаем каждую строку с помощью генераторного выражения:

```python
with open('data.csv', 'r', encoding='utf-8') as file:
    file_lines = (line for line in file)
```

**Шаг 3.** Разбиваем строки файла через разделитель `,` на список значений:

```python
with open('data.csv', 'r', encoding='utf-8') as file:
    file_lines = (line for line in file)
    line_values = (line.rstrip().split(',') for line in file_lines)
```

**Шаг 4.** Извлекаем первую строку, которая является названием столбцов:

```python
with open('data.csv', 'r', encoding='utf-8') as file:
    file_lines = (line for line in file)
    line_values = (line.rstrip().split(',') for line in file_lines)
    file_headers = next(line_values)
```

**Шаг 5.** Соединяем названия столбцов с соответствующими им значениями:

```python
with open('data.csv', 'r', encoding='utf-8') as file:
    file_lines = (line for line in file)
    line_values = (line.rstrip().split(',') for line in file_lines)
    file_headers = next(line_values)
    line_dicts = (dict(zip(file_headers, data)) for data in line_values)
```

**Шаг 6.** Фильтруем неподходящие строки и оставляем только те, в которых столбец `page_url` содержит текст `stepik.org`:

```python
with open('data.csv', 'r', encoding='utf-8') as file:
    file_lines = (line for line in file)
    line_values = (line.rstrip().split(',') for line in file_lines)
    file_headers = next(line_values)
    line_dicts = (dict(zip(file_headers, data)) for data in line_values)

    result = (
        line['user_name'], line['user_ip']
        for line in line_dicts
        if 'stepik.org' in line['page_url']
        )
    
```

Необходимо понимать и помнить, что приведенный выше код не перебирает содержимое в генераторе `result`. Ничего не будет исполняться, пока не будет задействована итерация (явная или неявная) по генератору `result`.

**Шаг 7.** Обрабатываем интересующие значения:

```python
with open('data.csv', 'r', encoding='utf-8') as file:
    file_lines = (line for line in file)
    line_values = (line.rstrip().split(',') for line in file_lines)
    file_headers = next(line_values)
    line_dicts = (dict(zip(file_headers, data)) for data in line_values)

    result = (
        line['user_name'], line['user_ip']
        for line in line_dicts
        if 'stepik.org' in line['page_url']
        )

    for index, (name, ip) in enumerate(set(result), 1):
        print(f'{index}. {name} --- {ip}')
    
```

Функция `set()` заставляет работать все созданные генераторы вместе. Все они функционируют как один конвейер больших данных, при этом в память попадают только нужные строки.

> Для работы с `csv` файлами используется встроенный модуль `csv`, о котором говорилось в курсе. Здесь чтение `csv` файла при помощи генераторных выражений показано в качестве примера и понимания конвейеров генераторов.

#### Производительность при использовании генераторов

Как уже было сказано, генераторы (генераторные выражения или генераторные функции) идеально подходят, когда необходимо прочитать содержимое большого файла.

Чтобы наглядно показать преимущество использования генераторов, создадим две функции `read_immediately()` и `read_lazy()`, которые читают содержимое текстового файла:

-   первая функция читает все непустые строки файла и заносит их в список, который затем возвращает с помощью оператора `return`
-   вторая функция читает все непустые строки файла и возвращает их с помощью оператора `yield`

```python
def read_immediately(file_name):
    with open(file_name, 'r', encoding='utf-8') as file:
        result = []
        for line in file:
            line = line.rstrip('\n')
            if line != '':
                result.append(line)
        return result

def read_lazy(file_name):
    with open(file_name, 'r', encoding='utf-8') as file:
        for line in file:
            line = line.rstrip('\n')
            if line != '':
                yield line
```

Запустив указанные функции на файлах разных размеров, получим следующие результаты:

Размер файла

**return**

**yield**

Память

Время

Память

Время

4 Кбайт

5,3 Мбайт

0.023 с

5,42 Мбайт

0.08 c

324 Кбайт

9,98 Мбайт

0.028 с

5,37 Мбайт

0,32 с

26 Мбайт

392 Мбайт

27 с

5.52 Мбайт

29.61 с

263 Мбайт

3,65 Гбайт

273.56 с

5,55 Мбайт

292,99 с

Видно, что в обоих случаях время увеличивается с примерно одинаковой скоростью, а количество потребляемой памяти сильно различается. Чем больше обрабатываемый файл, тем заметнее различие.

##### Примечания

**Примечание 1.** Мы можем использовать и генераторные функции и генераторные выражения для построения конвейеров обработки данных. При проектировании конвейеров генераторов один генератор вкладывается в другой.

**Примечание 2.** Генераторы — невероятно мощная программная конструкция. Они позволяют писать потоковый код с меньшим количеством промежуточных данных. Кроме того, они более эффективно используют память и ЦП.

Программный код:

```python
def something():
    result = []
    for ... in ...:
        result.append(x)
    return result
```

можно заменить на:

```python
def iter_something():
    for ... in ...:
        yield x
```

При этом, если действительно нужны возможности списка (тип `list`), то можно написать:

```python
def something():
    return list(iter_something())
```

#### Особенности итераторов

Очень часто начинающие программисты ошибочно считают, что `range` объекты (объекты, которые возвращает встроенная функция `range()`) являются итераторами. Эта ошибка может показаться незначительной, но на самом деле она является достаточно грубой. И `range` объекты, и итераторы являются ленивыми, но ленивы они по-разному.

В языке Python под итерируемым объектом подразумевают объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом. При этом под итератором подразумевают объект, который возвращает свои элементы по одному за раз.

Получить итератор из любого итерируемого объекта можно, используя встроенную функцию `iter()`:

```python
list_iterator = iter([1, 2, 3])       # итератор на основе списка
str_iterator = iter('beegeek')        # итератор на основе строки
```

Когда у нас есть итератор, единственное, что мы можем с ним сделать, это получить его следующий элемент, используя встроенную функцию `next()`.

Приведенный ниже код:

```python
list_iterator = iter([1, 2, 3])
str_iterator = iter('beegeek')

print(next(list_iterator))
print(next(list_iterator))

print(next(str_iterator))
print(next(str_iterator))
print(next(str_iterator))
```

выводит:

```no-highlight
1
2
b
e
e
```

Как только итератор вернул все свои элементы, мы будем получать исключение `StopIteration` при очередном вызове функции `next()`.

Приведенный ниже код:

```python
list_iterator = iter([1, 2, 3])

print(next(list_iterator))
print(next(list_iterator))
print(next(list_iterator))

print(next(list_iterator))
```

приводит к возбуждению исключения `StopIteration`.

Все итераторы также являются итерируемыми объектами, то есть мы можем получить итератор от итератора, при этом он вернет сам себя.

Приведенный ниже код:

```python
list_iterator = iter([1, 2, 3])
new_iterator = iter(list_iterator)

print(list_iterator is new_iterator)
```

выводит:

```no-highlight
True
```

Важно отметить, что итераторы являются одноразовыми объектами, то есть они сохраняют свое состояние. Это означает, что как только мы получили очередной элемент итератора, получить его вновь мы уже не сможем.

Приведенный ниже код:

```python
list_iterator = iter([1, 2, 3])

print(list(list_iterator))         # получаем все элементы итератора
print(list(list_iterator))
```

выводит:

```no-highlight
[1, 2, 3]
[]
```

Приведенный ниже код:

```python
list_iterator = iter([1, 2, 3])

print(2 in list_iterator)
print(2 in list_iterator)
print(2 in list_iterator)
```

выводит:

```no-highlight
True
False
False
```

В Python встроенные функции `enumerate(), zip(), reversed()` и другие возвращают итераторы.

Приведенный ниже код:

```python
numbers = [1, 2, 3]

print(enumerate(numbers))
print(zip(numbers, numbers))
print(reversed(numbers))
```

выводит:

```no-highlight
<enumerate object at 0x000001C060DCE0C0>
<zip object at 0x000001C060DCE0C0>
<list_reverseiterator object at 0x000001C060CEA230>
```

Генераторы (генераторная функция или генераторное выражение) — это один из самых простых способов создания собственных итераторов.

Приведенный ниже код:

```python
numbers = [1, 2, 3]

squares = (n**2 for n in numbers)
print(squares)
```

выводит:

```no-highlight
<generator object <genexpr> at 0x0000018A8F4AC9E0>
```

Таким образом, итераторы — это ленивые, одноразовые итерируемые объекты. Они ленивые, потому что у них есть возможность вычислять элементы только по мере того, как мы их перебираем. Они одноразовые, потому что как только мы использовали элемент из итератора, он исчезает навсегда.

#### Особенности range объектов

Объекты, возвращаемые функцией `range()`, являются итерируемыми объектами.

Приведенный ниже код:

```python
for i in range(3):
    print(i)

print(list(range(5, 10)))
print(tuple(range(5, 50, 5)))
```

выводит:

```no-highlight
0
1
2
[5, 6, 7, 8, 9]
(5, 10, 15, 20, 25, 30, 35, 40, 45)
```

С помощью функции `iter()` мы можем получить итератор на основе `range` объекта.

Приведенный ниже код:

```python
range_iterator = iter(range(3))

print(range_iterator)
```

выводит:

```no-highlight
<range_iterator object at 0x0000020B272B3C70>
```

Важно понимать, что сам `range` объект итератором не является. Мы не можем вызвать функцию `next()`, передав в нее в качестве аргумента `range` объект.

Приведенный ниже код:

```python
range_obj = range(3)

print(next(range_obj))
```

приводит к возникновению исключения:

```no-highlight
TypeError: 'range' object is not an iterator
```

В отличие от итераторов, мы можем итерировать по одному `range` объекту сколько угодно раз, каждый раз получая все его элементы.

Приведенный ниже код:

```python
range_obj = range(3)

print(list(range_obj))
print(list(range_obj))
```

выводит:

```no-highlight
[0, 1, 2]
[0, 1, 2]
```

> Объекты, возвращаемые функцией `range()`, в отличие от объектов, возвращаемых функциями `enumerate(), zip(), reversed()`, итераторами не являются.

Объект `range` в некотором смысле ленив, потому что он не хранит все свои элементы явно, вместо этого он генерирует нужные значения по мере необходимости.

В отличие от итераторов, мы можем использовать встроенную функцию `len()`, индексацию и срезы на `range` объектах.

Приведенный ниже код:

```python
range_obj = range(5, 50, 5)

print(*range_obj)
print(len(range_obj))
print(range_obj[3])
print(range_obj[-1])
print(range_obj[4:8])
```

выводит:

```no-highlight
5 10 15 20 25 30 35 40 45
9
20
45
range(25, 45, 5)
```

Мы также можем повторно определять принадлежность некоторого значения `range` объекту с помощью оператора `in`.

Приведенный ниже код:

```python
range_obj = range(5, 50, 5)

print(15 in range_obj)
print(15 in range_obj)
print(15 in range_obj)
```

выводит:

```no-highlight
True
True
True
```

Таким образом, наиболее подходящее описание `range` объектов — это ленивые последовательности. Это последовательности (подобно спискам, кортежам и строкам), но не хранящие в памяти все свои элементы.

##### Примечания

**Примечание 1.** `range` объекты содержат три атрибута: `start, stop, step`.

```python
range1 = range(10)
range2 = range(3, 20)
range3 = range(5, 50, 10)

print(range1.start, range1.step, range1.stop)
print(range2.start, range2.step, range2.stop)
print(range3.start, range3.step, range3.stop)
```

выводит:

```no-highlight
0 1 10
3 1 20
5 10 50
```

**Примечание 2.** `range` объекты можно сравнивать между собой с помощью операторов сравнения `==` и `!=`. Два `range` объекта считаются равными, если они представляют равные последовательности чисел.

Приведенный ниже код:

```python
range1 = range(10)
range2 = range(0, 10, 1)
range3 = range(5, 50, 10)

print(range1 == range2)
print(range1 == range3)
```

выводит:

```no-highlight
True
False
```

Обратите внимание на то, что два равных `range` объекта могут иметь разные значения атрибутов `start, step` и `stop`.

Приведенный ниже код:

```python
print(range(0) == range(2, 1, 3))
print(range(0, 3, 2) == range(0, 4, 2))
```

выводит:

```no-highlight
True
True
```

**Примечание 3.** Поиск по `range` объекту с помощью оператора `in` работает очень быстро, без последовательного перебора всех значений.

**Примечание 4.** Тип `range` реализован на языке Cи и является очень быстрым и оптимизированным. Исходный код доступен по [ссылке](https://github.com/python/cpython/blob/main/Objects/rangeobject.c).

**Примечание 5.** Документация по типу `range` доступна по [ссылке](https://docs.python.org/3/library/stdtypes.html#typesseq-range).

# 4. Декораторы

### 4.1 Что такое декоратор?

**Декоратор** в широком смысле – это паттерн проектирования, реализуется с помощью класса, посредством которого изменяется поведение другого класса без изменения исходной реализации этого класса.

В Python декоратор, как правило, это функция `A`, которая принимает функцию `B` и возвращает функцию `C`. При этом функция `C` задействует в себе функцию `B`.

В Python функции – это объекты первого класса (в python всё является объектом, даже функция и в Python функция может принимать аргументом и возвращать в качестве результата другую функцию). Для декораторов в Python существует «синтаксический сахар» `@decorator`

Задекорировать функцию значит заменить ее на результат работы декоратора.

### 4.2 Что может быть декоратором? К чему может быть применен декоратор?

Декоратором может быть любой вызываемый объект: функция, лямбда, класс, экземпляр класса. В последнем случае определите метод `call`.

Применять декоратор можно к любому объекту. Чаще всего к функциям, методам и классам. Декорирование встречается настолько часто, что под него выделен особый оператор `@`.

### 4.3 Написать параметризированный декоратор, который печатает время выполнения декорированной функции.

```Python
import time

def timer(timer_round=None):  # дополнительная ф-ция для параметров декоратора
    def decorator(func):  # ф-ция декоратор
        def wrapper(*args, **kwargs):  # ф-ция обёртка
            start_time = time.time()
            result = func(*args, **kwargs)
            spend_time = time.time() - start_time
            spend_time = round(spend_time, timer_round) if timer_round else spend_time
            print(f'Затраченное время: {spend_time} с.')
            return result
        return wrapper  # возврат без вызова
    return decorator


@timer(5)
def f(n):
    return sum([i for i in range(n)])


print(f(10**7))
```

### 4.4. Общие сведения. Декораторы

**Декоратор** — это функция, которая принимает другую функцию, расширяет ее поведение, не изменяя ее явно, и возвращает новую функцию.

важные особенности функций:
-        функции являются объектами первого класса, то есть функции можно передавать и использовать в качестве аргументов
-        функции можно определять внутри других функций
-        вложенные функции могут использовать локальные переменные родительских функций
-        функции могут возвращать другие функции в качестве результата

Простой декоратор `null_decorator()`, который возвращает исходную функцию без каких-либо изменений:

```Python
def null_decorator(func):
    return func
```

`null_decorator()` — это функция высшего порядка, которая принимает другую функцию в качестве аргумента и возвращает эту же функцию, не изменяя ее.

Применим данный декоратор для декорирования функции say().

```Python
def say():
    print('Привет Мир!')

say = null_decorator(say)      # декорируем функцию
say()                          # вызываем декорированную функцию
```

декоратор, который меняет поведение декорируемой функции:

```Python
def sample_decorator(func):  # определяем декоратор
    def wrapper():
        print('Начало функции')
        func()
        print('Конец функции')
    return wrapper

def say():
    print('Привет Мир!')

say = sample_decorator(say)  # декорируем функцию
say()                        # вызываем декорированную функцию
```

Декорирование функции say() происходит в следующей строке:

```Python
say = sample_decorator(say)
```

После декорирования переменная say указывает на **внутреннюю функцию wrapper()**. Важно понимать то, что при вызове функции sample_decorator(say) с переданной в качестве аргумента функцией say() **возвращается вложенная функция** wrapper() **в качестве результата**. Функция wrapper(), в свою очередь, имеет ссылку на переданную в качестве аргумента функцию say() и вызывает эту функцию между двумя вызовами встроенной функции print().

```Python
print(say)  # до декорирования: <function say at 0x00000122AD3F0F70>

say = sample_decorator(say)

print(say)  # после декорирования: <function sample_decorator.<locals>.wrapper at 0x00000122AD3F1090>
```

Таким образом после декорирования мы получаем совершено другую функцию, которая расширяет функционал начальной функции.

Проще говоря: **декораторы обертывают функцию, изменяя ее поведение**.

**Специальный синтаксис применения декораторов**

Способ, который декорирует функцию say(), — многословен, приходится набирать имя функции несколько раз. Кроме того, декорирование скрывается под определением функции. Вместо этого Python позволяет использовать декораторы более простым способом с помощью символа **@**.

```Python
def null_decorator(func):
    return func


# декорируем функцию
@null_decorator  
def say():
    print('Привет Мир!')


say()
```

Просто добавив `@null_decorator` перед определением функции `say()`, мы модифицировали её поведение. Однако, как вы уже могли догадаться, запись с `@` является всего лишь синтаксическим сахаром для записи:

```Python
say = sample_decorator(say)
```

Иными словами, выражение @sample_decorator вызывает функцию sample_decorator() с say в качестве аргумента и присваивает имени say возвращаемую функцию.

**Изменение поведения функции**

Декоратор может менять поведение декорируемой функции. Напишем декоратор, который преобразует строковый результат декорированной функции в верхний регистр.

```Python
def uppercase_decorator(func):
    def wrapper():
        original_result = func()
        modified_result = original_result.upper()
        return modified_result
    return wrapper
```

Вместо того чтобы просто возвращать исходную функцию, как это делал `null_decorator()`, декоратор `uppercase_decorator()` определяет и возвращает новую функцию `wrapper()`. Функция `wrapper()`, являясь замыканием, имеет доступ к недекорированной функции `func` и может выполнять дополнительный код до и после вызова функции `func`.

```Python
@uppercase_decorator
def greet():
    return 'Hello world!'

print(greet())
```

Декоратор uppercase_decorator() сам по себе является функцией. Единственный способ повлиять на новое поведение функции, которую он декорирует, — это **заменить исходную функцию замыканием**. Вот почему декоратор uppercase_decorator() определяет и возвращает другую функцию wrapper(), которую затем можно вызвать позже, запустить исходную функцию и изменить ее результат.

**Применение нескольких декораторов**

Мы можем без каких-либо проблем применять к функции несколько различных декораторов. Это накапливает их эффекты, и делает декораторы очень полезными на практике.

Рассмотрим два декоратора bold() и italic(), которые заключают результат вызова функции в HTML-теги:

```Python
def bold(func):
    def wrapper():
        return '<b>' + func() + '</b>'
    return wrapper


def italic(func):
    def wrapper():
        return '<i>' + func() + '</i>'
    return wrapper

```

Применим их к функции greet().

```Python
@bold
@italic
def greet():
    return 'Hello world!'

print(greet())  # <b><i>Hello world!</i></b>
```

Декораторы применяются в порядке снизу-вверх. Таким образом, мы можем явно использовать декорирование, обойдясь без специального синтаксиса. В таком случае цепочка вызовов функций декораторов будет выглядеть так:

```Python
greet = bold(italic(greet))
```

Таким образом, сначала применяется декоратор `italic()`, который оборачивает результат вызова декорируемой функции в теги `<i></i>`, а затем результирующая обернутая функция снова обертывается декоратором `bold()`, который оборачивает результат вызова декорируемой функции в теги `<b></b>`.

Глубокие уровни наложения декораторов в итоге могут повлиять на производительность, поскольку они продолжают добавлять вложенные вызовы функций. Обычно на практике это не создает проблем, но об этом следует помнить, если вы работаете с кодом, требующим высокой производительности.

**Декорирование функций, принимающих аргументы**

```Python
def bold(func):
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'
    return wrapper


@bold
def greet1(name):
    return f'Hello {name}!'


@bold
def greet2():
    return 'Hello world!'


@bold
def greet3(name, surname):
    return f'Hello {name} {surname}!'


print(greet1('Timur'))
print(greet2())
print(greet3('Timur', 'Guev'))
```

В примере выше, вложенная функция wrapper() принимает произвольное число позиционных и именованных аргументов и передает их в декорируемую функцию func(). Теперь декоратор @bold будет работать как для функций, которые вообще не принимают аргументы, так и для функций которые принимают произвольное количество позиционных и именованных аргументов.

**Возврат значений из декорируемой функции**

В Python все функции возвращают значение. Даже если тело функции не содержит явно инструкции return, она вернет значение None. Нужно быть очень внимательным к декорированию функций, которые возвращают значения, которые затем используются.

```Python
def talk(func):
    def wrapper(*args, **kwargs):
        dash = '-' * 15
        result = func(*args, **kwargs)
        return dash + '\n' + result + '\n' + dash
    return wrapper


@talk
def greet(name):
    return f'Hello {name}!'


print(greet('Timur'))
```

**Сохранение атрибутов `__name__` и `__doc__` для декорируемой функции**

Как мы уже знаем, все функции содержат специальные атрибуты __name__ и __doc__, которые содержат полезную информацию:
-        __name__ — имя функции
-        __doc__ — строка документирования

```Python
def greet(name):
    '''Функция приветствия пользователя.'''
    return f'Hello {name}!'


print(greet.__name__)  #greet
print(greet.__doc__)  # Функция приветствия пользователя.
```

Рассмотрим применение декоратора bold к функции greet().

```Python
def bold(func):
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'
    return wrapper


@bold
def greet(name):
    '''Функция приветствия пользователя.'''
    return f'Hello {name}!'


print(greet.__name__)  # wrapper
print(greet.__doc__)   # None
```

После того как к функции `greet()` был применен декоратор, её атрибуты `__name__` и `__doc__` изменились на имя и строку документирования внутренней функции `wrapper()` декоратора `bold`. Хотя чисто технически это верно, это не очень хорошо.

```Python
def bold(func):
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'
    wrapper.__name__ = func.__name__
    wrapper.__doc__ = func.__doc__
    return wrapper


@bold
def greet(name):
    '''Функция приветствия пользователя.'''
    return f'Hello {name}!'


print(greet.__name__)  # greet
print(greet.__doc__)  # Функция приветствия пользователя.
```

**Применение декоратора** `functools.wraps`

Решение проблемы, связанное с перетиранием атрибутов `__name__` и `__doc__` является рабочим, однако каждый раз писать в декораторе строки кода, которые восстанавливают значения данных атрибутов, не очень хорошо.

Для решения проблемы перетирания данных атрибутов на практике используют другой декоратор, который находится в модуле `functools` и называется `wraps`. Таким образом, чтобы предотвратить перетирание атрибутов `__name__` и `__doc__` декорируемой функции, декораторы должны использовать декоратор `functools.wraps`, который сохраняет информацию о первоначальной функции.

```Python
import functools


def bold(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'
    return wrapper


@bold
def greet(name):
    '''Функция приветствие пользователя.'''
    return f'Hello {name}!'


print(greet.__name__)
print(greet.__doc__)
```

**Шаблон декоратора общего назначения**

Все декораторы в большинстве случаев делают примерно одно и то же. Наиболее частый шаблон декоратора выглядит следующим образом:

```Python
import functools


def decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # Что-то выполняется до вызова декорируемой функции
        value = func(*args, **kwargs)
        # декорируется возвращаемое значение функции
        # или что-то выполняется после вызова декорируемой функции
        return value
    return wrapper
```

**Декоратор измерения времени работы функции**

Следующий декоратор измеряет и выводит время выполнения декорируемой функции. Декоратор вычисляет время непосредственно перед запуском функции и сразу после ее завершения и выводит разницу подсчитанных времен.

```Python
import functools, time


def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        val = func(*args, **kwargs)
        end = time.perf_counter()
        work_time = end - start
        print(f'Время выполнения {func.__name__}: {round(work_time, 4)} сек.')
        return val
    return wrapper


@timer
def test(n):
    return sum([(i/99)**2 for i in range(n)])


@timer
def sleep(n):
    time.sleep(n)


res1 = test(10000)
res2 = sleep(4)

print(f'Результат функции test = {res1}')
print(f'Результат функции sleep = {res2}')
```

**Декоратор отслеживания количества вызовов функции**

Иногда полезно иметь декоратор, который может отслеживать состояние вызова функции. Создадим декоратор, который подсчитывает, сколько раз вызывается функция. Для сохранения состояния счетчика будем использовать пользовательский атрибут функции.

```Python
import functools


def counter(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        wrapper.num += 1
        print(f'Вызов {func.__name__}: {wrapper.num}')
        val = func(*args, **kwargs)
        return val
    wrapper.num = 0
    return wrapper

@counter
def greet(name):
    return f'Hello {name}!'


print(greet('Timur'))
print(greet('Ruslan'))
print(greet('Arthur'))
print(greet('Gvido'))
```

**Декоратор замедления времени выполнения функции**

Иногда полезно иметь декоратор, который замедляет время выполнения функции. Создадим декоратор slow_down, который будет добавлять задержку выполнения программы в 11 секунду, прежде чем вызовет декорируемую функцию.

```Python
import functools
import time


def slow_down(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        time.sleep(1)
        return func(*args, **kwargs)
    return wrapper


@slow_down
def countdown(number):
    if number < 1:
        print('Конец!')
    else:
        print(number)
        countdown(number - 1)


countdown(5)
```

**Декораторы с аргументами**

Назовем рассматриваемые до сих пор декораторы стандартными. Стандартный декоратор — это функция, которая принимает в качестве аргумента функцию и возвращает другую функцию, подменяющую исходную.

```Python
import functools


def stars(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print('*' * 30)
        return func(*args, **kwargs)
    return wrapper


def lines(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print('-' * 10)
        return func(*args, **kwargs)
    return wrapper


def equals(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print('=' * 40)
        return func(*args, **kwargs)
    return wrapper


@stars
def add(a, b):
    return a + b


@lines
def mult(a, b):
    return a * b


@equals
def diff(a, b):
    return a - b


print(add(3, 9))
print(mult(10, 20))
print(diff(100, 1))

******************************
12
----------
200
========================================
99
```

Несложно заметить, что все три декоратора выполняют примерно одно и то же. Куда удобнее иметь один декоратор, который можно настраивать, передавая ему соответствующие аргументы. Для того чтобы **создать декоратор, принимающий аргументы**, необходимо **добавить еще один уровень вложенности**, то есть создать функцию, которая возвращает нужный декоратор:

```Python
def print_symbols(symbol, length):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(symbol * length)
            return func(*args, **kwargs)
        return wrapper
    return decorator


@print_symbols('*', 30)
def add(a, b):
    return a + b


@print_symbols('-', 10)
def mult(a, b):
    return a * b


@print_symbols('=', 40)
def diff(a, b):
    return a - b


print(add(3, 9))
print(mult(10, 20))
print(diff(100, 1))
```

Функция print_symbols() на первый взгляд может показаться декоратором, но на самом деле таковым не является. **Это обычная функция, которая принимает аргументы** symbol и length, а **затем возвращает декоратор**. В свою очередь, он декорирует функции add(), mult() и diff().

### 4.5 Кэширование и мемоизация

**Кэширование** – это способ оптимизации хранения данных, при котором операции с данными производятся эффективнее.

**Мемоизация** — это разновидность кэширования. Обычно под кэшированием понимают довольно широкий набор способов сохранения чего-либо для последующего использования. **Мемоизация же означает кэширование возвращаемых значений функций**.
-        Вот некоторые соображения, касающиеся использования мемоизации:
-        для того чтобы функцию можно было подвергнуть мемоизации, она должна быть чистой
-        мемоизация — это компромисс между производительностью и потреблением памяти
-        мемоизация хороша для функций, имеющих сравнительно небольшой диапазон входных значений, что позволяет достаточно часто, при повторных вызовах функций, задействовать значения, найденные ранее, не тратя на хранение данных слишком много памяти
-        лучше всего функции с мемоизацией показывают себя там, где выполняются сложные, ресурсоёмкие вычисления

```Python
import functools


def cached(func):
    cache = {}

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        key = args + tuple(kwargs.items())
        result = cache.get(key)
        if result is None:
            result = func(*args, **kwargs)
            cache[key] = result
        return result
    return wrapper
```

В этой простой реализации мемоизации есть очевидная проблема: содержимое словаря `cache` будет неограниченно расти при каждом вызове декорируемой функции с новыми аргументами.

Для решения такого рода проблемы существуют различные стратегии кэширования.

### 4.6 LRU cache

#### Стратегии кэширования

Существует несколько различных стратегий, которые можно использовать для удаления элементов из кэша и предотвращения превышения его максимального размера. Пять самых популярных перечислены в таблице ниже.

|**Стратегия**|**Какую запись удаляем**|**Эти записи чаще других используются повторно**|
|---|---|---|
|First-In, First-Out (FIFO)|самую старую|новые|
|Last-In, First-Out (LIFO)|самую недавнюю|старые|
|Least Recently Used (LRU)|которая использовалась наиболее давно|недавно прочитанные|
|Most Recently Used (MRU)|которая использовалась последней|прочитанные первыми|
|Least Frequently Used (LFU)|которая использовалась наиболее редко|которые использовались часто|

Стратегия **LRU** предполагает: чем позже использовался объект, тем больше вероятность, что он понадобится в будущем. Алгоритм сохраняет такой объект в кэше в течение максимально длительного времени. Кэш, реализованный посредством стратегии LRU, упорядочивает элементы в порядке их использования. Каждый раз, когда мы обращаемся к записи, алгоритм LRU перемещает ее в верхнюю часть кэша. Таким образом, алгоритм может быстро определить запись, которая дольше всех не использовалась, проверив конец списка.

#### Декоратор lru_cache

В модуле `functools` уже реализован декоратор `lru_cache`, дающий возможность кэшировать результат вычисления функции, используя стратегию **Least Recently Used**. Это простой, но мощный метод, который позволяет использовать в коде возможности кэширования.

Декоратор `lru_cache` доступен начиная с Python 3.2.

```Python
from functools import lru_cache


@lru_cache()
def fibonacci(n):
    if n <= 2:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)
```

добавляет кэширование к функции `fibonacci()`. Декоратор `lru_cache` сохраняет результаты вызова `fibonacci()` для каждого уникального значения аргумента.

**Аргументы декоратора lru_cache**

При декорировании функций с помощью декоратора `lru_cache` мы можем использовать следующие аргументы:

-         `maxsize=128` — максимальный размер кэша (тип `int`)
-         `typed=False` — как кэшировать при разных типах аргументов (тип `bool`)

Если для параметра `maxsize` установлено значение `None`, то кэш может расти без ограничений.

Если для `typed` задано значение `True`, то аргументы функций разных типов будут кэшироваться отдельно. Например, `f(3)` и `f(3.0)` будут рассматриваться как отдельные вызовы с разными результатами. Если для `typed` задано значение `False`, то вызовы будут рассматриваться как одинаковые.

```Python
from functools import lru_cache


@lru_cache(typed=False)
def concat(text, num):
    return text + ' ' + str(num)


print(concat('beegeek', 4))  # beegeek 4
print(concat('beegeek', 5.0))  # beegeek 5.0
print(concat('beegeek', 4.0))  # beegeek 4
```

третий вызов функции с аргументами `('beegeek', 4.0)` использует закэшированный результат первого вызова с аргументами `('beegeek', 4)`.

**Дополнительные методы декоратора lru_cache**

Чтобы помочь измерить эффективность кэша и настроить параметр `maxsize`, декорированная функция имеет метод `cache_info()`, который возвращает именованный кортеж, показывающий `hits, misses, maxsize и currsize`.

Мы можем использовать информацию, возвращаемую `cache_info()`, чтобы понять, как работает кэш, и настроить его, чтобы найти подходящий баланс между скоростью работы и объемом памяти:
-         `hits` – количество значений, которые lru_cache вернул непосредственно из памяти, поскольку они присутствовали в кэше
-         `misses` – количество значений, которые были вычислены, а не взяты из памяти
-         `maxsize` – это размер кэша, который мы определили, передав его декоратору
-         `currsize` – текущий размер кэша

```Python
from functools import lru_cache


@lru_cache(typed=False)
def concat(text, num):
    return text + ' ' + str(num)


print(concat('beegeek', 1))
print(concat('beegeek', 1.0))
print(concat('beegeek', True))
print(concat('beegeek', 4.0))
print(concat('beegeek', 5))

print(concat.cache_info())  # CacheInfo(hits=2, misses=3, maxsize=128, currsize=3)
```

Декоратор `lru_cache` также предоставляет метод `cache_clear()` для очистки кэша.

```Python
from functools import lru_cache


@lru_cache(typed=False)
def concat(text, num):
    return text + ' ' + str(num)


print(concat('beegeek', 1))
print(concat('beegeek', 1.0))
print(concat('beegeek', True))
print(concat('beegeek', 4.0))
print(concat('beegeek', 5))

print(concat.cache_info())
concat.cache_clear()
print(concat.cache_info())
```

**Кэширование** – один из подходов, который при правильном использовании значительно ускоряет работу и снижает нагрузку на вычислительные ресурсы. Кэширование очень часто используется в реальных проектах.

Будьте осторожны с мемоизацией функций, которые принимают изменяемые типы данных в качестве аргументов. Встроенный декоратор lru_cache не позволяет работать с нехэшируемыми объектами, так как за кулисами использует словарь.

В Python 3.9 появился декоратор `cache`, который работает так же, как и `lru_cache`, но без ограничений на размер кэша. По сути, применение декоратора cache равнозначно применению декоратору `lru_cache(maxsize=None)`. Такой декоратор работает быстрее чем `lru_cache` c заданным `maxsize`, но потребляет больше памяти.

# 5. Контекстный менеджер

### 5.1 Что такое менеджер контекста, зачем он нужен?

Размещенный внутри оператора `with` код выполняется с особенностью: **до и после гарантированно срабатывают события входа в блок with и выхода из него**. **Объект**, который **определяет логику событий**, называется контекстным менеджером.

На уровне класса события определены методами `__enter__` и `__exit__`.
-       `__enter__` срабатывает в тот момент, когда ход исполнения программы переходит внутрь with. Метод может вернуть значение. Оно будет доступно низлежащему внутри блока with коду.
-       `__exit__` срабатывает в момент выхода блока, в т.ч. и в случае исключения. В этом случае в метод будет передана тройка значений (exc_class, exc_instance, traceback). В этот метод передаются параметры завершения процесса, а код этого метода будет выполнен гарантированно.

Самый распространённый контекстный менеджер – класс, порожденный функцией `open`. Он гарантирует, что файл будет закрыт даже в том случае, если внутри блока возникнет ошибка. Преимущество использования ключевого слова `with` перед вызовом функции `open()` в том, что функция `file.close()` вызовется автоматически и освободит занятые ресурсы после того, как отработает код.

Желательно выходить из контекстного менеджера _как можно быстрее_, чтобы освобождать контекст и ресурсы.

```Python
with open('file.txt') as f:
    data = f.read()

process_data(data)
```

### 5.2 Написать пример произвольного менеджера контекста.

```Python
class CustomOpen:
    def __init__(self, filename):
        self.filename = filename

    # сработает при переходе внутрь блока with
    def __enter__(self): 
        self.file = open(self.filename)
        return self.file

    # гарантированно сработает при выходе из блока with
    def __exit__(self, exc_type, exception, traceback):         
        self.file.close()

with CustomOpen('1.bin') as file:
    # начало работы __enter__
    print(file.read())

# сработает __exit__
```

