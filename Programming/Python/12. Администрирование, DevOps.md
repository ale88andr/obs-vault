![[Pasted image 20230710094911.png]]

# 1. Git

### 1.0 Системы управления версиями

**Система управления версиями (от англ. Version Control System, VCS)** — программное обеспечение для облегчения работы с изменяющейся информацией. Система управления версиями позволяет хранить несколько версий одного и того же документа, при необходимости возвращаться к более ранним версиям, определять, кто и когда сделал то или иное изменение, и многое другое.

Такая система фиксирует изменения, что позволяет вам в случае чего откатиться к любой предыдущей версии файла. Кроме отката изменений, система контроля версий позволяет сравнивать версии одного и того же файла, чтобы найти в нем изменения, видеть, кто эти изменения внес, когда это было сделано и что могло вызвать проблему.

Существует три основных разновидности архитектур систем контроля версий: **локальная, централизованная и распределенная**.

- **Локальная система контроля версий**

Почему нельзя просто сохранять файл под разными именами, а затем открывать нужный? Да, так делать можно, но это вызовет массу проблем. Вы можете забыть, какой файл содержит итоговую версию, можете запутаться в миллионе одинаковых файлов, отличающихся парой строк кода. Вы не сможете быстро сравнить две версии, чтобы посмотреть, какие изменения были внесены.  
  
Для решения этих проблем была придумана **локальная система контроля версий**. Схематически она представляет из себя следующее:

![[Pasted image 20230720093000.png]]

Одной из самых популярных локальных систем контроля версий на сегодняшний день (не считая Git) остается система **RCS**. Она работает по принципу сохранения изменений в ваших файлах. То есть она хранит не целую новую версию, а только указания к изменению первоначального файла. Например, "добавить к предыдущей версии строку **import math**". Таким образом, последовательно изменяя файл, система воссоздает любую из его версий.

**Преимущества:**  
1. Позволяет хранить историю изменения файлов локально, без интернета.  
2. Вы независимы от сторонних серверов.  
  
**Недостатки:**  
1. Вы можете потерять все файлы, если с вашем компьютером что-то случится.  
2. Вы не можете работать в команде, поскольку репозиторий доступен только вам.

- **Централизованная система контроля версий**

Как было сказано выше, одна из проблем, с которой вы столкнетесь, работая в команде разработчиков - это то, что вам нужно **делиться файлами** (и их версиями) с другими разработчиками.  
  
Например, чтобы старший разработчик проверил ваш код на ошибки, перед тем, как дать вам разрешение на внесение изменений в рабочий файл. Для решения этой проблемы была придумана **централизованная система контроля версий**. Схематически она устроена так:

![[Pasted image 20230720093157.png]]

Централизованная VCS хранит все данные на сервере, а сотрудники получают к ним доступ.  
  
Примерами удаленных систем контроля версий являются **CVS**, **Subversion** и **Perforce**.  
  
**Преимущества** централизованных VCS:  
1. Вы можете работать в команде с другими разработчиками.  
2. Ваше начальство видит, чем вы занимаетесь.  
3. У администратора есть четкий контроль, кто и что может делать. Администрировать центральную VCS намного проще, чем локальные на каждой машине.  
  
**Недостатки** централизованных VCS:  
1. Все данные хранятся только на одном сервере. Если он выключится, то работу всей компании парализует.  
2. Если с сервером что-то случится, а копий данных нет, то весь проект может быть потерян.  
3. Для работы необходим хороший интернет на протяжении целого дня.

- **Распределенная система контроля версий**

**Распределенная система контроля версий** решает все описанные выше проблемы. К этой группе систем относится **Git**, **Mercurial**, **Bazaar** и некоторые другие. На схеме распределенные системы контроля версий выглядят так:

![[Pasted image 20230720093458.png]]

Особенность этой архитектуры в том, что клиенты не хранят у себя отдельные файлы, они хранят **полную копию** всех версий проекта. Поэтому, если что-то случится с сервером, работа не остановится, а продолжится, как ни в чем не бывало. Работники будут сохранять версии у себя на компьютере, а как только сервер восстановится, они загрузят все эти версии на него.

Распределенные VCS - лидер по популярности на сегодняшний день. Примеры таких систем - это **Git**, **Mercurial** и **Bazaar**.  
  
**Преимущества** распределенных VCS:  
1. Работа компании теперь не зависит от работы сервера. Если сервер отключится, то каждый сотрудник продолжит работу с локальной копией репозитория, а после загрузит ее на сервер.  
2. Можно работать с несколькими удаленными репозиториями, делиться кодом с другими людьми и коллаборировать целыми компаниями.

**VCS** открывает перед вами следующие возможности:  

1. **Сохранять все изменения** в файлах в хронологическом порядке, при этом не путаясь в именах миллионов копий одного и того же файла.  
2. **Избегать неприятных ошибок** в коде, вызванных непредвиденным поведением новых функций.  
3. **Отслеживать, над какими файлами вы работаете** (и работаете ли вообще). Вам это вряд ли пригодится, а вот вашему начальству – очень.  
4. **Работать параллельно** над одним и тем же проектом **вместе с командой,** не боясь конфликтов, например, одновременного изменения одного и того же файла.  
5. **Делиться своим кодом.** А разработчики со всего мира могут улучшать его и записывать изменения на ваш сервер.

### 1.1 Основы Git

Git обладает следующими **преимуществами.*:

- **Полная копия репозитория лежит у вас на машине.**  

Отсюда вытекает **два** серьезных **преимущества:** все работает очень быстро, и вы получаете полный контроль над репозиторием:  
1. Чтобы создать репозиторий нужна всего одна команда - **git init**.
2. Все файлы VCS хранятся только в одной папке **.git**. Никаких **.svn** в каждой директории.
3. Вам не нужен постоянный и бесперебойный интернет. Утром - скачали данные с сервера к себе на машину, днем - поработали у себя, вечером - залили данные обратно на север. Проще, чем заливать каждый файл после изменения.
4. В локальном репозитории вы можете создавать дополнительные ветки, тестировать что-то новое и делать все, что угодно. Никто не увидит этого, ведь репозиторий только ваш.

![[Pasted image 20230720093954.png]]
- **Контроль**

В Git можно делать что угодно с **коммитами**:  
1. Удалить
2. Изменить
3. Поменять местами
4. Объединить несколько коммитов в один
5. Разделить один коммит на несколько
6. Перетаскивать коммиты между ветками

- **Ветки**

**Ветки** в Git - это настолько мощный и функциональный инструмент, что все выполняется в них. От маленьких задач до релиза.  

1. Создать ветку, переключиться между ветками, слить ветки, удалить ветку - рутинные операции.
2. За исключением релизных, ветки живут 1-3 дня. Создали ветку, написали новую функцию, протестировали, убедились, что все работает, слили с основной и удалили.

- **Коммиты**

Чтобы сделать **коммит** (фиксацию изменений), нужно указать, какие изменения в него необходимо добавить (именно изменения, а не файлы). Преимущество этого в следующем.  

1. Перед тем, как делать коммит, можно посмотреть и настроить, какие файлы в него попадут. Например, если вы хотите зафиксировать изменения только **в одном файле** из целого проекта - Git позволит вам это сделать.
2. Вы можете занести в коммит только **часть изменения** в файле. А остальные изменения откатить, или положить в другой коммит.
3. Просмотр **истории** коммитов и различий в файлах
4. Можно посмотреть, какие изменения были внесены в файл в разных коммитах.
5. Можно посмотреть историю коммитов всей ветки, чтобы проследить, как менялись файлы.

- **Stash**

**Stash** - это очень удобная функция Git. Она позволяет заморозить текущие изменения и переключиться на другую ветку.  
  
Например, коллега попросил вас срочно помочь ему с его работой, а у вас множество изменений в файлах, которые еще рано класть в коммит. Вы просто прописываете **git stash**, после чего переключаетесь на ветку коллеги и помогаете ему. Вам не придется создавать бесполезный коммит, только чтобы сохранить изменения в своих файлах, но при этом вы их и не потеряете при смене ветки.

- **Работа в команде**

Вся работа выполняется **атомарно** в соответствующих ветках. После завершения работы, она отправляется на **ревью**, и только после этого ветка может быть слита с основной. Это позволяет не допустить присутствие непроверенного кода на основной ветке.  
  
Очень удобно проводить ревью задачи, которая выполнена в отдельной ветке. Посмотреть различия коммитов, что-то исправить, прокомментировать, отправить обратно на доработку, а потом объединить отдельные коммиты и слить в основную ветку.

- **GitHub, BitBucket etc.**

**Гитхаб**, **битбакет** и другие бесплатные удаленные репозитории очень удобны и часто используются для **open-source** проектов. Там делают форки этих проектов, обсуждают их и развивают.

> Почему стоит использовать **git**:
> - Позволяет сохранять различные версии проектов
> - Быстрый переход между различными версиями проекта
> - Откат к предыдущим версиям при необходимости
> - Улучшает процесс командной работы над одними и теми же проектами
> - Независимая одновременная разработка различных новых функций в проекте

**Основные понятия**  

1. **Репозиторий** – папка проекта, отслеживаемого Git, содержащая дерево изменений проекта в хронологическом порядке. Все файлы истории хранятся в специальной папке **.git/** внутри папки проекта.
2. **Индекс** – файл, в котором содержатся изменения, подготовленные для добавления в коммит. Вы можете добавлять и убирать файлы из индекса.
3. **Коммит** – фиксация изменений, внесенных в индекс. Другими словами, коммит – это единица изменений в вашем проекте. Коммит хранит измененные файлы, имя автора коммита и время, в которое был сделан коммит. Кроме того, каждый коммит имеет уникальный идентификатор, который позволяет в любое время к нему откатиться.
4. **Указатели** **HEAD**, **ORIGHEAD** и т. д. – это ссылка на определенный коммит. Ссылка – это некоторая метка, которую использует Git или сам пользователь, чтобы указать на коммит.
5. **Ветка** – это последовательность коммитов. Технически же, ветка – это ссылка на последний коммит в этой ветке. Преимущество веток в их независимости. Вы можете вносить изменения в файлы на одной ветке, например, пробовать новую функцию, и они никак не скажутся на файлах в другой ветке. Изначально в репозитории одна ветка, но позже мы рассмотрим, как создавать другие.
6. **Рабочая копия**. Директория **.git/** с её содержимым относится к Git. Все остальные файлы называются рабочей копией и принадлежат пользователю

### 1.2 Настройка Git

В зависимости от области действия и места хранения в Git cуществуют 3 типа настроек:  
1. **Системные.** Представляют собой настройки на уровне всей системы, то есть они распространяются на всех пользователей. Файл с этими настройками хранится по следующему пути: **C:\Program Files\Git\etc\gitconfig** для Windows и **/etc/gitconfig** для пользователей Linux/MacOS.
2. **Глобальные.** Эти настройки одинаковы для всех репозиториев, созданных под вашим пользователем. Среди них есть, например, имя ветки по умолчанию. Файл с этими параметрами хранятся по следующему адресу: **C:/User/<имя пользователя>/.gitconfig** в windows, или **~ /.gitconfig** в Unix системах.
3. **Локальные.** Это настройки на уровне репозитория, они не будут применяться к другим вашим проектам. Эти параметры хранятся в каждом вашем репозитории по адресу: **.git/config**.
![[Pasted image 20230720094641.png]]
**Команда git config**

Формат

```
git config <ключ> <параметр> <значение> 
``` 

Ключи

`--global  ` - Изменение настроек на уровне пользователя. Без указания данного ключа настройки будут изменены только на уровне текущего репозитория.  
  
`--system ` - Изменение настроек на уровне системы (то есть сразу для всех пользователей).
Работа с файлом настройки `.gitconfig`

Работать с файлом конфигурации `.gitconfig` можно с помощью команды `git config` с ключом `--global` (`config` - изменение конфигурации Git, `--global` - параметры будут настроены глобально для всех репозиториев) . При этом не имеет значения, в какой директории вы находитесь прямо сейчас: вызов `git config --global` сработает везде.

```Git
$ git config --global user.name "User" 
# имя или ник нужно написать латиницей и в кавычках

$ git config --global user.email user@mail.com
# здесь нужно указать свой настоящий email 
```

Все глобальные настройки Git хранит в файле `.gitconfig` в домашней директории. Команда запишет в этот файл указанные имя и почту. Чтобы убедиться в этом, можно вызвать команду для чтения файлов.

```bash
$ cat ~/.gitconfig 
```

```
[user]
	name = Ale88andr
	email = ale88andr@gmail.com
```

Другой способ проверки — вывести содержимое файла конфигурации Git той же командой `git config` с флагом `--list`

```bash
$ git config --list 
```

### 1.3. Инициализация репозитория

**Сделать папку репозиторием** — `git init`

Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать **Git-репозиторием** (от англ. _repository_ — «хранилище»). Для этого следует переместиться в неё и ввести команду `git init` 

После инициализации создается скрытая папка `.git`

```
<project_name>/.git
├── HEAD
├── branches
├── config
├── description
├── hooks
├── info
│   └── exclude
├── objects
│   ├── info
│   └── pack
└── refs
    ├── heads
    └── tags
```

Репозиторий Git условно можно разделить на три составляющие:  

1. **Рабочая директория - Working directory**. Это файловая структура, с которой непосредственно работает пользователь в конкретный момент времени. Технически же - это копия определенной версии вашего проекта, которую вы извлекли из базы Git и в которую пытаетесь внести свои изменения.
2. **Индекс или Область подготовленных файлов - Index / Staging area**. Это область, где хранятся имена файлов и изменения в них, которые должны войти в следующий коммит. Технически индекс - это просто файл.
3. **Директория Git - Git Directory**. Папка, в которой Git хранит все версии вашего проекта и также свои служебные файлы. Данная папка носит название **.git** и располагается в корневой директории вашего проекта.

Области Git:

![[Pasted image 20230710170823.png]]

1. **Рабочая директория** (working directory) – это область git, которая содержит текущие (актуальные) файлы и папки в проекте![[Pasted image 20230710170914.png]]
2. **Индекс** (staging area) - это область git, которая содержит файлы, подготовленные для добавления в репозиторий. ![[Pasted image 20230710173002.png]] Добавление файлов в индекс, просмотр содержимого индекса:
		- `git add <filename>`
		- `git status`
3. **Репозиторий** (repository) - это область git, которая фиксирует изменения файлов, кроме этого в репозитории фиксируются коммиты. Все объекты git сохраняются в папке `.git/objects`. ![[Pasted image 20230710173410.png]] Сохранение файла (изменений) в репозиторий:
	`git commit –m “Комментарий”`

	Перейти к определенной версии файла в репозитории, при этом файлы в рабочей директории перезапишутся изменениями из репозитория 
	`git checkout <objectHash>`

Таким образом, получается, что ваши файлы путешествуют между этими тремя областями. Файлы, с которыми вы напрямую работаете - это **Working Directory**. Что-то изменили в этих файлах - изменилось состояние **Working Directory**.  
  
Хотите зафиксировать эти изменения - скажите Git, какие именно из всех изменений, вы хотите сохранить. Для этого вы добавляете изменения в файлах во вторую область - **Staging** (он же **Index**). Это некое среднее состояние между **Working Directory** и **Git Directory** - изменения уже на пути к фиксации, но еще не сохранены в базе Git.  
  
Если вы уверены, что все изменения, которые вы добавили в **Index** / **Staging**, необходимо сохранить в базу Git, то вы делаете коммит, и они в сжатом виде помещаются в **Git Directory**. Теперь все надежно сохранено в папке **.git**.

![[Pasted image 20230720100040.png]]

А теперь давайте более подробно разберемся с тем, в каких состояниях могут быть файлы с точки зрения Git. Каждый файл может находится только в одном из двух состояний:  
  
**1.** **Отслеживаемый.** Об этих файлах Git знает и отслеживает изменения в них. Отслеживаемые файлы в свою очередь могут находится в следующих состояниях:  
1. **Неизмененный** (**Unmodified**) То есть с момента последнего коммита в файле не было никаких изменений
2. **Измененный (Modified)** То есть с последнего коммита в файле были произведены какие-то изменения.
3. **Подготовленный к коммиту (Staged)** Это значит, что вы внесли изменения в этот файл и затем проиндексировали их, и эти изменения будут добавлены в следующий коммит.
  
**2.** **Неотслеживаемый** (**Untracked**) О неотслеживаемых файлах Git не знает, поэтому изменения в них не будут добавлены в коммит. Это любые файлы в вашем рабочем каталоге, которые не входили в последний коммит и не подготовлены к текущему коммиту.  
  
Приведем наглядную визуализацию состояний и переходов между ними.
![[Pasted image 20230720100222.png]]

Чтобы посмотреть статус текущих файлов, нам потребуется команда `git status`.

### 1.4. Внутреннее устройство Git

Всю информацию Git представляет в виде "объектов". **Объект** – это файл, содержащий определенную информацию о репозитории и его файлах. Все объекты хранятся в директории **.git/objects/**. Объекты бывают трех типов:  
  
1. **Blob** (англ. **binary large object**) – большой бинарный объект, другими словами просто бинарный файл. Для каждого файла в репозитории формируется **blob-файл**, который содержит его имя и сжатое содержимое. **Blob-файл** формируется, когда мы добавляем файл в индекс.
2. **Tree**. **Дерево** – это такой тип графа. Оно нужно нам, чтобы показывать связи между файлами в репозитории. Деревья формируются для каждой директории репозитория (в том числе для корневой) во время коммита и показывают, какие файлы (или поддиректории) лежат в данной директории. Таким образом, объект дерева состоит из имен 1) **blob-объектов** для файлов, которые лежат в данной директории, и 2) других деревьев для всех поддиректорий.
3. **Объект коммита.** Этот объект содержит в себе имя автора коммита, время коммита и объект дерева корневой директории проекта.
4. **Аннотированный тег** (**Annotated** **Tag**) – версия проекта, определенная метка ссылающаяся на определенный снимок репозитория;

Кроме этих трех объектов, важным во внутреннем устройстве Git является файл индекса.  
**Индекс** – файл, в котором содержатся изменения, подготовленные для добавления в коммит. Во время добавления файлов командой **git add**, Git:  
1. Сжимает содержимое этого файла и создает **blob-объект**.
2. Записывает имя этого объекта в файл индекса.

![[Pasted image 20230720100809.png]]
**Каждый объект в git имеет уникальный id (SHA1 хэш)**
![[Pasted image 20230710174019.png]]

На сгенерированных хэшах объектов git формируются названия подпапок в папке `.git/objects` и файлов, которые находятся в этих подпапках. При этом названия подпапок состоят из первых двух символов хэша, а названия файлов формируются из оставшихся символов хэша![[Pasted image 20230710174359.png]]

**Коммит - указатель на дерево**

![[Pasted image 20230710174509.png]]

*Пример*: проект состоящий из корневой папки содержащую файл и подпапку, содержащую два файла. При фиксации такого коммита в git репозиторий запишется **6 объектов**: 2 Tree-объекта и 3 blob-объекта и 1 Commit-объект ссылающийся на корневую папку![[Pasted image 20230710174649.png]]

**Из чего состоит коммит:**
-        Хэш коммита;
-        Имя и email автора;
-        Описание;
-        Ссылка на родительский коммит (может быть несколько);
-        Ссылка на дерево;

![[Pasted image 20230710174808.png]]

Git выстраивает **цепочки коммитов**, что бы можно было в любой момент перейти к определенному коммиту по ссылкам родительских коммитов. Первый коммит не имеет ссылки на родительский коммит и называется **корневым коммитом.**

Кроме этого в git есть определенный указатель – **HEAD.** Этот указатель ссылается на определенный коммит (обычно это последний коммит). Это означает что в рабочей дирректории будет та версия проекта на которую указывает **HEAD**. Двигая указатель **HEAD** можно перемещаться по истории изменений в репозитории.

**HEAD** – это указатель на текущую версию проекта, которая находится в рабочей директории. Но обычно **HEAD** ссылается на какую-либо **ветку**, а ветка уже ссылается на **коммит**.
![[Pasted image 20230710174958.png]]

**Ветка** всегда ссылается на **последний коммит**, при создании коммита текущая ветка автоматически ссылается на него.

##### Пример репозитория

![[Pasted image 20230710175220.png]]

Папка **MY_PROJECT** содержит папку `.git`

При создании первого (корневого) коммита git создаст ряд объектов:

1.       **Tree**-объект папки `MY_PROJECT`
2.       **Blob**-объект файла `first-file.txt`
3.       **Tree**-объект подпапки `first-subfolder`
4.       2 **Blob**-объекта файлов подпапки `first-subfolder`: `second-file.txt` и `third-file.txt`
5.       **Commit**-объект для того, чтобы закрепить в памяти **git** версию проекта и этот коммит указывает на **Tree**-объект папки `MY_PROJECT` из пункта 1

![[Pasted image 20230710175248.png]]

При внесении изменений (вторая версия проекта) и создании второго коммита в **git** произойдет следующее:

1.       Создастся **новый** **Tree**-объект папки `MY_PROJECT` (т.к. по сути Tree-объект – это текстовый файл, содержащий хэш суммы каждого объекта ссылающегося на это дерево, т.е. всех файлов и папок)
2.       **Tree**-объект подпапки `first-subfolder` останется прежним
3.       2 **Blob**-объекта файлов подпапки `first-subfolder`: `second-file.txt` и `third-file.txt` не изменятся
4.       Создастся **Tree**-объект подпапки `second-subfolder`
5.       Создастся 2 **Blob**-объекта файлов подпапки `second-subfolder`: `fourth-file.txt` и `fifth-file.txt`
6.       Создастся новый **Commit**-объект для того, чтобы закрепить в памяти **git** версию проекта и этот коммит указывает на новый **Tree**-объект из пункта 1
7.       Указатель **HEAD** автоматически станет ссылаться на последний коммит

> **Подытожим**  
> 1. **Git** – это большая картотека объектов.
> 2. Git хранит все файлы и связи между ними, как объекты в директории **.git/objects**.
> 3. **Объект** – это файл с некоторой информацией о репозитории.
> 4. Объекты бывают трех типов: **Blob**, **Tree** и **Commit**.
> 5. **Blob-объекты** хранят информацию о файлах репозитория и их содержимом.
> 6. **Tree-объекты** хранят информацию о расположении этих файлов в репозитории.
> 7. **Индекс** же нужен Git, чтобы понимать, какие из файлов мы добавим в последующий коммит, а какие – нет.

### 1.5. Основные команды git

- `git status` - отображает текущее состояние Git репозитория
- `git add <files>` - подготовка файлов перед коммитом
- `git commit -m "<message>"` - Создание коммита с записью изменений в репозиторий
- `git log` - просмотр истории изменений (коммитов)
- `git checkout <commit hash>` - переход в определенную версию проекта по **SHA1 хэшу коммита**. Перейдет к определенному коммиту, при этом git будет находится в режиме ‘*detached HEAD*’, это означает, что указатель **HEAD** ссылается на определённый коммит, а не на ветку! Чтобы перейти обратно к последним изменениям достаточно переключится на текущую ветку: `git checkout <branch name>` - Перейдет к определенной ветке
- `git checkout <branch name>` - переход в определенную версию проекта по **названию ветки**

### 1.6. Команда git add

Чтобы сделать файл отслеживаемым (добавить файлы в индекс), существует команда `git add`.

```Git
git add apha.txt
```
![[Pasted image 20230720101236.png]]
**Что происходит внутри Git** 

**1. Создался новый blob-объект.**  
  
Имя этого файла – **SHA-1** хэш – 40-символьная контрольная сумма содержимого и заголовка. Вычисляется он так:  

1. К типу файла (т.е. blob) через пробел дописывается длина содержимого и нулевой байт. В нашем случае для файла **alpha.txt**, содержащего **a** мы получим: **blob 1\0**.
2. Затем к полученной строке прибавляется само содержимое файла. То есть **blob 1\0a**.
3. Затем эта строка отдается хэш-функции **SHA-1**, которая и выдает нам 40-символьный результат.
  
Первые два символа полученной суммы определяют имя поддиректории в базе объектов, а остальные 38 – имя файла. Например, хэш файла `alpha.txt` получился такой:

```
ca87a297fe24e72165a6c462b2e1df12a01cbc34
```

Это значит, что Git создаст директорию `.git/objects/ca/` и сохранит в нее **blob-файл** с именем `87a297fe24e72165a6c462b2e1df12a01cbc34`.

![[Pasted image 20230720101921.png]]

Хэширование нужно затем, чтобы однозначно определить файл его содержимым (если содержимое файлов различно хотя бы одним символом, то хэши будут сильно отличаться друг от друга). А разбиение по поддиректориям нужно затем, чтобы потом было проще найти нужный нам файл среди множества других.  
  
Заметьте, что простое добавление файла в Git приводит к сохранению его содержимого в директории **objects**. Оно будет храниться там, даже если мы удалим alpha.txt из рабочей копии.

**2. После сохранения blob-файла, гит добавляет его имя в индекс.**  
  
Как было сказано выше, индекс – это список файлов, за которыми следит Git. Он хранится в `.git/index`. Каждая строчка состоит из имени файла и его хэша. Вот таким получился индекс репозитория после добавления файла:

```
alpha.txt ca87a297fe24e72165a6c462b2e1df12a01cbc34.
```
![[Pasted image 20230720102327.png]]

Добавим таким же образом, файл **num.txt**:

```Git
git add num.txt
```

И посмотрим статус:

```Git
git status

On branch develop

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   alpha.txt
        new file:   num.txt
```

Теперь допустим, что мы передумали и решили изменить содержимое файла `num.txt` c **1** на **1024**. Сделаем это и посмотрим статус снова:

```Git
git status

On branch develop

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   alpha.txt
        new file:   num.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   num.txt
```

Видно, что файл `num.txt` одновременно находится в двух состояниях: **подготовленный к коммиту** и **измененный**.

Помните, мы находили хэш-сумму от содержимого файла? Теперь мы это содержимое поменяли и хэш-сумма стала другой. Git это заметил, и предупредил нас. Если мы сейчас сделаем коммит, то в него попадет файл **num.txt** со значением **1**, а не **1024**. Чтобы в коммит попали новые изменения, нам нужно заново проиндексировать файл `num.txt`.

```Git
git add num.txt
```

![[Pasted image 20230720102853.png]]
Можем убедиться, что все хорошо, заново просмотрев статус:

```Git
git status

On branch develop

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   alpha.txt
        new file:   num.txt
```

>**Подведем итог**  
>1. Чтобы сделать файл отслеживаемым, существует команда **git add**.
>2. Когда мы делаем файл отслеживаемым, происходит следующее:  
>	2.1. Создается **blob-объект** для этого файла. Имя **blob-объекта** – 40-символьный хэш содержимого файла, причем первые две буквы хэша отводятся под имя поддиректории в папке **.git/objects**, а остальные 38 – под имя самого файла. Такое разделение имени ускоряет поиск blob-файла среди других.  
>	2.2. Имя этого **blob-файла** записывается в индекс (**.git/index**). С этого момента GIt считает файл подготовленным к коммиту.
>3. Если мы поменяем содержимое файла, нам нужно снова добавить его в индекс командой **git add**.

### 1.7. Команда git commit

Коммит хранит не только снимок (все индексированные файлы) репозитория, но и имя автора со временем, что бывает полезно. Чтобы сделать коммит в Git, есть команда **git commit**.

#### Делаем первый коммит

```Git
git commit -m "Initial commit"
[develop (root-commit) 10962e7] Initial commit
 2 files changed, 2 insertions(+)
 create mode 100644 data/alpha.txt
 create mode 100644 data/num.txt
```

Теперь давайте разберемся, что только что произошло и что это за буквы с цифрами `10962e7` в первой строчке вывода.  

В целом команда **git commit** делает три шага:  
1. Создает **граф (дерево)**, представляющий содержимое версии проекта, для которой делают коммит.
2. Создает **объект коммита**.
3. Направляет **текущую ветку** на новый коммит

- **Создание коммита. Этап 1. Создание графа.**  

Git представляет текущее состояние проекта, как древовидный граф, информация для которого читается из индекса. Этот граф записывает расположение и содержание файлов в проекте. **Граф** - это объект-дерево, о котором упоминалось выше. Каждая строчка любого графа записана по следующему правилу:

```
<режим доступа> <тип объекта> <хэш объекта> <имя файла, из которого создан объект>.
```

Разберем все по порядку.  

1. **Режим доступа** это одно из следующих чисел:  
    - **100644** – обычный файл.  
    - **100755** – исполняемый файл.  
    - **120000** – символическая ссылка (напр. **HEAD**).  
    Режимы доступа в Git сложно назвать гибкими: указанные три режима – единственные доступные для файлов в Git, хотя существуют и другие режимы, используемые для директорий и подмодулей.
2. **Тип объекта** – это строка, которая может принимать значение **blob**, если объект – это **blob-файл**, либо **tree**, если **объект** – это дерево.
3. Третье значение – **хэш** объекта. Это тот самый 40-символьный **SHA-1** хэш.
4. Ну и последнее значение – это **имя файла**, из которого был создан **blob-файл** и получен хэш.

Как было сказано выше, граф состоит из двух типов объектов: 
1. **Blob-файлы**
2. **Tree-файлы**, они же деревья.

Первые сохраняются во время выполнения команды **git add**, вторые – во время выполнения **git commit**. Для примера рассмотрим репозиторий со следующей структурой:

```
test_repository
└───data
│	└─alpha.txt
│	└─num.txt
└─── outer.txt
```

То есть у нас есть вложенная папка `data` с файлами `alpha.txt`, `num.txt` и отдельный файл `outer.txt`. Граф директории `data`, созданный при коммите, будет выглядеть так:

```
cat .git/objects/09/d20c0539...

100644 blob ca87a297fe24e72165a6c462b2e1df12a01cbc34    alpha.txt
100644 blob 81c545efebe5f57d4cab2ba9ec294c4b0cadf672    num.txt
```
![[Pasted image 20230720104139.png]]
А дерево для корневой директории репозитория **test_repository** будет выглядеть следующим образом:

```Git
cat .git/objects/c0/d2cc3e13...

040000 tree 09d20c0539d97b2a60d06db73135cda7dcac4121    data
100644 blob 5ef136008f1e8f921622f7eed1fe1925331c9665    outer.txt
```

Первая строчка – это дерево директории `data/`, рассмотренное выше, а вторая – файл `outer.txt`.  
  
При этом само это дерево, включающее директорию `data/` и файл `outer.txt` будет иметь хэш `c0d2cc3e13d34e7043d2afddb4af8867cc972741` (оно пригодится для объекта коммита).  
  
Визуализируя граф корневой директории **test_repository** получим следующее:

![[Pasted image 20230720104522.png]]

Все эти объекты сохраняются в директорию `.git/objects/` по тому же принципу, то есть первые два символа хэша – имя поддиректории в папке `.git/objects/`, а остальные 38 – имя файла в этой поддиректории.

> **Подведем итог**  
> 1. Первым шагом в создании коммита является создание древовидных графов.
> 2. **Древовидный граф** - это объект типа **tree**, который хранится в директории **.git/objects/**.
> 3. Деревья нужны, чтобы отразить взаимное расположение файлов и директорий в репозитории.
> 4. Дерево создается для каждой директории репозитория, в том числе и для корневой.
> 5. Каждая строчка файла дерева устроена по следующей схеме: **<режим доступа> <тип объекта> <хэш объекта> <имя файла, из которого создан объект>**.

- **Создание коммита. Этап 2. Создание объекта коммита**  

После того, как был создан граф репозитория, Git создает объект коммита. Объект коммита – точно такой же текстовый файл в директории `.git/objects/`, как деревья и **blob-файлы**. Объект коммита репозитория из примера выглядит так:

```Git
cat .git/objects/f9/8b4a7891...

tree c0d2cc3e13d34e7043d2afddb4af8867cc972741
author ale88andr <info@smartiqa.com@email> 1606261256 +0300
committer ale88andr <info@smartiqa.com@email> 1606261256 +0300

Initial commit
```

**Первая** строчка записи указывает на дерево корня репозитория, то есть тот самый граф (**test_repository**) с хэшем `c0d2cc3…`  
  
**Вторая** строчка говорит, кто и когда создал коммит, 

**Третья** – кто и когда записал коммит в репозиторий. Обычно эти две строчки совпадают, но бывают и ситуации, когда один человек записывает в свой репозиторий коммит другого человека, тогда эти строчки будут различаться. Тот, кто запишет коммит к себе будет значится в поле **committer**, а тот, кто создал этот коммит – в поле **author**.  
  
Ну и в последней, **четвертой**, строчке содержится комментарий коммита. В нашем случае – **Initial commit**.

![[Pasted image 20230720105031.png]]

Теперь мы знаем, что коммит – это объект коммита. Хэш этого объекта и есть хэш коммита – уникальный идентификатор, по которому можно найти любой коммит. Обычно хэш не надо писать полностью, достаточно первых 6-8 цифр. Например:

```Git
git commit -m “Initial commit”

[develop (root-commit) f98b4a7] initial commit
 3 files changed, 3 insertions(+)
 create mode 100644 data/alpha.txt
 create mode 100644 data/num.txt
 create mode 100644 outer.txt
```

Здесь **f98b4a7** это и есть часть хэша коммита. Git создаст директорию `.git/objects/f9` и сохранит в нее объект коммита **8b4a7…**, к которому мы потом сможем обращаться.

> **Подведем итог**  
> 1. После создания объектов деревьев для всех директорий репозитория, создается объект коммита.
> 2. Объект коммита состоит из:  
    2.1. Объекта дерева корневой директории репозитория  
    2.2. Информации о том, кто и когда создал коммит  
    2.3. Кто и когда записал коммит в историю репозитория  
    2.4. Комментария коммита  
    3. Обычно пункты 2.2 и 2.3 совпадают, но не всегда.
    4. Имя объекта коммита – его хэш. По этому хэшу можно найти любой коммит. Не обязательно использовать все 40 символов хэша, обычно 6-8 бывает достаточно.

- **Создание коммита. Этап 3. Направить ветку на текущий коммит.**

В заключение нам нужно сообщить указателю-ветке, что у нас есть новый коммит. Делает это Git следующим образом:  
  
1. Для начала, нужно посмотреть, на какой ветке мы сейчас работаем (их может быть несколько). Git идет в файл `.git/HEAD` и видит следующее: **ref: refs/heads/develop**. Такая запись говорит нам, что **HEAD** указывает на ветку `develop`, т. е. ветка, в которой мы сейчас работаем – **develop**.  
2. Затем Git ищет файл `.git/refs/heads/develop`, но такого файла не существует, поскольку это был первый коммит в нашем репозитории и до сих пор ветке `develop` было не на что указывать. Поэтому Git создает файл `.git/refs/heads/develop` и задает его содержимое – хэш объекта-коммита, который мы получили **f98b4a7...**.
  
Теперь наш граф репозитория выглядит вот так:
![[Pasted image 20230720105419.png]]
#### Делаем второй коммит

Для начала заметим, что наш индекс снова пуст, поскольку все файлы уже добавлены в коммит, а новых изменений нет:

```Git
git status

On branch develop
nothing to commit, working tree clean
```

Давайте рассмотрим, как выглядит рабочая копия и индекс нашего репозитория на графе.
![[Pasted image 20230720105652.png]]

Рабочая копия и индекс указывают на одни и те же файлы из первого коммита. Это значит, что изменений в файлах нет. Теперь давайте поменяем содержимое файла `alpha.txt` и посмотрим индекс снова:

```Git
git status

On branch develop
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   data/alpha.txt

no changes added to commit (use "git add" and/or "git commit -a")
```
![[Pasted image 20230720105755.png]]

Как видно, теперь в рабочей копии находится измененный файл `alpha.txt`, но он еще не проиндексирован. Поэтому индекс указывает на первоначальный файл, а вот в рабочей копии находится уже измененный. Давайте проиндексируем его и посмотрим на статус.

```Git
git add -A
git status

On branch develop
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   data/alpha.txt
```
![[Pasted image 20230720105903.png]]

Теперь рабочая копия указывает на тот же файл, что и индекс, причем этот файл не находится в последнем коммите. Это значит, что у нас есть проиндексированные изменения. Зафиксируем их, то есть сделаем второй коммит.

```Git
git commit -m "change alpha.txt"

[develop 4117d58] change alpha.txt
 1 file changed, 1 insertion(+), 1 deletion(-)
```

Теперь Git создаст новый граф для представления данных из индекса. Старое дерево **data/** больше не отражает состояние проиндексированной директории **data/** (т.к. файл `alpha.txt` был изменен), поэтому создается новое. Объект этого дерева(для папки **data**) выглядит так:

```Git
cat .git/objects/3b/95bcd6d0...

100644 blob 7e74e68b2a782a3aead46d987a63ca1c91091c13    alpha.txt
100644 blob 81c545efebe5f57d4cab2ba9ec294c4b0cadf672    num.txt
```

Поскольку хэш нового дерева **data/** отличается от старого, нужно создать новое дерево для всего репозитория. Объект для корневой директории `test_repository` будет выглядеть так:

```Git
cat .git/objects/22/d4301816...

040000 tree 3b95bcd6d0a76177985b5d3b2fd046b48e9110ba    data
```

И уже только на основе этого дерева можно создавать объект второго коммита.

```Git
cat .git/objects/41/17d584a7...

tree 22d4301816880a569417c908ee00b2f6680efb33
parent 0790c287b727b43156de737f5840cb6584261830
author ale88andr <info@smartiqa.com> 1606271955 +0300
committer ale88andr <info@smartiqa.com> 1606271955 +0300

change alpha.txt
```

Здесь все, как и в объекте первого коммита, за исключением второй строчки – она новая. Теперь у коммита есть родитель (предок, предшествующий коммит). Чтобы найти родителя, Git проходит в файл `.git/refs/heads/develop` и смотрит на хэш коммита, который там записан. 
  
После этого Git меняет содержимое `.git/refs/heads/develop` на хэш текущего коммита. Графически, наш репозиторий теперь выглядит так:
![[Pasted image 20230720110315.png]]

Заметьте, что мы не меняли `num.txt`, поэтому Git не стал заново добавлять его в коммит. Вместо этого, в новый коммит вошла ссылка на файл `num.txt` из прошлого коммита. Такая функция позволяет экономить место и не засорять репозиторий одинаковыми файлами.



### 1.8. Просмотр изменений в папке `.git`

- `git cat-file -t <hash>` - тип файла git
- `git cat-file -p <hash>` - содержимое файла git

например:

![[Pasted image 20230711110643.png]]

![[Pasted image 20230711110700.png]]

![[Pasted image 20230711110715.png]]

Видим, что коммит ссылается на дерево tree `79e275c048…..`

![[Pasted image 20230711110740.png]]
И т.д. , можно просматривать содержимое папки `.git`

### 1.8. Ветки

Дадим два определения ветки: на логическом и физическом уровнях.  
  
**1. Логический уровень.**  
С точки зрения логики, **ветка** – это последовательность коммитов. Чтобы проще было понять, что такое ветка, рассматривайте ее как некоторую временную шкалу. Коммиты в ней – снимки интересных моментов, идущие друг за другом в хронологической последовательности.
![[Pasted image 20230720135521.png]]
На рисунке выше изображены три ветки: **main**, **develop** и **feature**. Каждая представляет из себя "поток" коммитов в хронологической последовательности. Важно заметить, что эти потоки не пересекаются, то есть работа в ветках идет параллельно.

**2. Физический уровень**  
На физическом уровне, то есть с точки зрения внутренней реализации Git, **ветка** – это ссылка на последний коммит в этой ветке.
![[Pasted image 20230720135619.png]]
> **Указатель** – это ссылка на определенный коммит или ветку. А **ссылка** – это некоторая метка, которую использует Git или сам пользователь, чтобы указать на коммит или ветку.  И как мы уже сказали, физически ветки – самые настоящие указатели. Давайте приведем примеры еще некоторых часто используемых указателей:
> 1. **HEAD** – так называемый курсор Git. Главное назначение **HEAD** - определять, в каком состоянии находится рабочая копия (напомним, что рабочая копия – это все файлы репозитория, за исключением директории **.git/**). На какой коммит указывает **HEAD** – из того коммита и загружаются файлы в рабочую директорию.
> 2. **ORIG_HEAD** – указатель, который появляется, когда мы вручную передвигаем **HEAD** на какой-нибудь НЕ последний коммит. **ORIG_HEAD** указывает на тот же коммит, на который указывал **HEAD** до передвижения назад. Нужен он, чтобы мы имели возможность вернуться на хронологически последний коммит без существенных затрат (в истории мы не будем видеть все коммиты старше нашего, а поэтому не сможем узнать хэш последнего).
> 3. Пользовательские указатели. Пользователи сами могут создавать указатели. Например, вы можете создать указатель **version-1.2.1**, который будет указывать на коммит, в котором хранится **версия 1.2.1** вашего проекта. Это довольно удобно, поскольку вы можете переключаться на коммит с той или иной версией, не запоминая его хэш.

Преимущество веток в их независимости. Вы можете вносить изменения в файлы в одной ветке, например, пробовать новую функцию, и они никак не скажутся на файлах в другой ветке. Изначально в репозитории одна ветка. 

На самом деле, вначале, когда мы делаем свой первый коммит, Git автоматически создает основную ветку? ее имя по умолчанию "main или master". Каждый раз, когда мы создаем новый коммит, Git автоматически перемещает указатель **main** на последний коммит.
![[Pasted image 20230720140003.png]]
На рисунке овалы с хэшами – наши коммиты, **main** – ветка по умолчанию и в то же время указатель на коммит **62aa**, а **HEAD** – указатель на ветку, с которой мы сейчас работаем, то есть на ветку **main**.

#### Зачем нужны ветки

Пока мы разбирались, что такое ветка, у вас мог возникнуть вопрос: зачем нужны такие сложности, ведь можно просто делать коммиты и откатывать изменения, когда нужно.  
  
Дело в том, что Git – универсальная система контроля версий: она подходит и большим командам крупных корпораций, и индивидуальным разработчикам для их личных проектов.  
  
Если вы работаете один – скорее всего вы будете редко использовать ветки, но если вы работаете в большой компании, без веток вам не обойтись.  
  
Итак, чаще всего ветки используются в следующих случаях.  
1. Ветки нужны, чтобы несколько программистов могли **вести работу** над одним и тем же проектом или даже файлом **одновременно**, при этом не мешая друг другу.
2. Кроме того, ветки используются **для тестирования экспериментальных функций**: чтобы не повредить основному проекту, создается новая ветка специально для экспериментов. Если эксперимент удался, изменения с экспериментальной ветки переносятся на основную, если нет – новая ветка попросту удаляется, а проект остается нетронутым.
3. Помимо прочего, ветки можно использовать **для** разных выходящих **параллельно релизов** одного проекта. Например, в репозитории Python может быть две ветки: **python-2** и **python-3**. До закрытия **python-2** релизы этих версий языка выходили независимо друг от друга, поэтому могло иметь место такое разделение на ветки.

На самом деле, у веток есть еще множество применений – все зависит от конкретного проекта, – мы же перечислили только самые распространенные практики их использования. Ветвление в Git – это действительно мощный инструмент, поэтому важно уметь им пользоваться.

#### Создание новых веток

Мы можем создавать свои ветки и переключаться между ними. Создать свою ветку можно двумя способами.  

**Способ 1. Команды git branch + git checkout**  

Этот способ является классическим. В нем для начала работы с новой веткой нужно выполнить два действия:  
- Создать ветку с помощью команды `git branch`  
- Переключиться на свежесозданную ветку с помощью команды `git checkout <имя ветки>`

**Способ 2. Команда git checkout -b**  

В основе данного способа лежит тот факт, что команда `git checkout` умеет создавать ветки и сразу переключаться на них. Это намного удобнее, чем выполнять два этих действия по отдельности. Поэтому данный способ является более предпочтительным, так как задействует только одну команду `git checkout` со специальным ключом `-b` .

Как и `git branch`, `git checkout` – очень многофункциональная команда. Главное ее назначение – перемещать указатель **HEAD**.

Внутри Git создание ветки работает довольно просто. Выполняются следующие шаги:  
1. В директории `.git\refs\heads` создается новый файл, имя которого – имя ветки, которую вы хотите создать (при условии, что такого файла не существует). Например, если мы выполним команду `git branch feature`, то создастся файл `.git\refs\heads\feature`.
2. В созданный файл записывается хэш текущего коммита. С него ветка и начнется. После этого файл `.git\refs\heads\feature` будет выглядеть так:

```Shell
cat .git\refs\heads\feature

971ef6a7e178324b732e2ed6cbc3b66c1c989e15
```

Важно понимать, что как только вы создали новую ветку, она указывает на тот же коммит, что и основная ветка, и **HEAD**. Графически ситуация выглядит так:
![[Pasted image 20230720140650.png]]
Как видно из картинки, сейчас **HEAD** указывает на основную ветку (коммит **62aa**). Если же вы переключитесь на ветку **feature** и сделаете два новых коммита (**4b00** и **6670**), ситуация будет выглядеть так:
![[Pasted image 20230720140720.png]]
Как мы видим, указатели **feature** и **HEAD** передвинулись на последний коммит **6670**.  
  
С помощью команд **git branch** и **git checkout** вы можете создать неограниченное количество веток и переключаться между ними по мере необходимости. Обычно если ветка вам больше не нужна, ее сливают с основной и удаляют.

#### Просмотр списка веток

Когда вы работаете с большим количеством веток, можно легко забыть имя нужной, а без имени ветки переключится на нее не получится. Для таких ситуаций существует команда просмотра списка веток. На самом деле, это уже знакомая нам `git branch`, но с другими ключами.

```Git
git branch <ключи>
```

`-r` - От англ. remote – удаленный. С этим ключом будут выведены только удаленные ветки. О них мы поговорим в следующем уроке.
`-a` - От англ. all – все. С этим ключом будут выведены и локальные, и удаленные ветки.

#### Переключение между ветками

Итак, настало время подробнее разобраться с тем, как переключаться между ветками. Как уже было сказано выше, чтобы переключиться на ветку, вам нужно знать ее имя. Напомним, что просмотреть список всех веток можно с помощью команды `git branch`. Просмотрим список веток в некотором репозитории:

```Git
git branch
  develop
  main
* feature
```

Звездочка перед веткой означает, что сейчас мы находимся на данной ветке. Если мы хотим переключиться на другую, нам нужна команда `git checkout`.

```
git checkout <ключи> <имя ветки>
```

```Git
# Выведем список локальных веток
$ git branch
  develop
  feature
* main

# Переключимся на ветку develop
$ git checkout develop
Switched to branch 'develop’

# Переключимся на ветку feature
$ git checkout feature
Switched to branch ‘feature’

# Вернемся на ветку develop
$ git checkout -
Switched to branch 'develop'
```

Теперь приведем список действий, которые производит `git checkout`, чтобы **переключить** нас **на новую ветку**:  

1. Программа проверяет, существует ли указанная ветка.
2. Затем программа переключает указатель **HEAD** на новую ветку.
3. Последним шагом программа меняет рабочую копию так, чтобы она соответствовала новой ветке.

**Шаг 1. Проверка существования ветки**  

Нужен этот этап, чтобы случайно не переключиться на ветку, которой не существует. Чтобы понять, как происходит этот процесс, нужно сделать небольшое отступление и рассказать, как вообще Git хранит информацию о существующих ветках.  
  
Итак, мы помним, что ветка – это тоже указатель, как и **HEAD**. Она указывает на последний коммит в "потоке" коммитов ветви графа Git. Графически это выглядит так:
![[Pasted image 20230720141615.png]]
Как видно из рисунка, у нас есть две ветки: **main** и **feature**. **HEAD** сейчас указывает на main, поэтому сейчас рабочая копия репозитория находится в состоянии коммита **5с5с**.  
  
Все, что нужно, чтобы задать ветку – просто записать, на какой коммит она указывает. Этого достаточно, поскольку по предкам этого коммита можно восстановить весь остальной граф. Поэтому внутри Git ветка – это просто файл в директории `.git\refs\heads`, названный так же, как и сама ветка. Например, в случае репозитория, граф которого изображен на картинке выше, мы получим:

```Shell
ls .git\refs\heads

main 
feature
```

Содержимое файла `main`

```Shell
cat main

5с5с…
```

Содержимое файла `feature`

```Shell
cat main

6670…
```

Таким образом, если файл с именем ветки присутствует в директории `.git\refs\heads`, можно однозначно сказать, что такая ветка существует.

**Шаг 2. Переключение HEAD на нужную ветку**

Теперь, когда Git убедился, что ветка с нужным именем существует, необходимо как-то переключить указатель **HEAD** на эту самую ветку. То есть сделать так, чтобы **HEAD** указывал на файл ветки. Делается это очень просто: нужно в файл `.git\HEAD` записать путь до нужной нам ветки: `refs\heads\<имя ветки>`. Тогда **HEAD** будет указывать на новую ветку.  
  
В нашем случае, при переключении на ветку **feature**, файл **.git/HEAD** будет выглядеть так:

```Shell
cat .git\HEAD

refs\heads\feature
```

После этого шага граф Git будет выглядеть следующим образом:
![[Pasted image 20230720142155.png]]
Как видно, **HEAD** теперь указывает на ветку-указатель **feature**. Картинка поменялась, поскольку мы записали в файл `.git\HEAD` новый адрес. В данном случае, это `refs\heads\feature`. Таким образом, до полного переключения на другую ветку остался всего один шаг.

**Шаг 3. Изменение рабочей копии**

Рабочие копии на разных ветках могут отличаться, поскольку ветки работают независимо друг от друга. Поэтому последним шагом при переключении на новую ветку станет **изменение рабочей копии** так, чтобы она соответствовала нашей ветке. Git просто смотрит на последний сделанный в данной ветке коммит, после чего восстанавливает структуру и файлы в рабочей копии, подгружая данные из **blob-** и **tree-** объектов, о которых мы говорили в прошлом уроке. То есть Git будет действовать так:  

1. Любой файл, который есть в новом коммите (**6670**) на рисунке выше и которого нет в коммите, с которого мы переключились (**5с5с**), будет добавлен в рабочую копию.
2. Любой файл, который был в коммите, с которого мы переключились (**5с5с**), и которого нет в новом коммите (**6670**), будет удален.
3. Любой файл, которого нет ни в одном из этих двух коммитов, будет просто проигнорирован. То есть удален он НЕ будет.
  
Как только все три эти условия выполняются для всех файлов в рабочей копии, можно говорить о том, что Git полностью переключил нас на нужную ветку.  
  
У внимательного читателя мог возникнуть вопрос: почему файлы в рабочей копии подгружаются именно из последнего коммита ветки? **Что если до переключения с данной ветки, в ней были какие-то изменения, еще не добавленные в коммит? Что с ними будет?** Ответ довольно прост. Согласно трем шагам, указанным выше, Git просто проигнорирует все такие файлы. То есть они останутся в вашей рабочей копии в том же состоянии, в котором и были до этого. Как правило, такое поведение очень неудобно, поскольку позволяет легко запутаться в структуре собственного проекта. Представьте: у вас два параллельных релиза, а вы, переключаясь между ветками, случайно занесли файлы одного релиза в ветку другого.  
  
Таким образом, у вас есть **два варианта** выхода из ситуации:  

1. Либо добавить все изменения в коммит и благополучно сменить ветку
2. Либо "отложить" изменения, не добавляя их в коммит, воспользовавшись командой **git stash**.

#### Просмотр состояния ветки. Команды: git status, git log, git diff.

Чтобы просмотреть состояния файлов конкретной ветки нужно выполнить последовательность из двух команд:  

1. **git checkout <имя ветки> # переключаемся на нужную ветку**
2. **git status # просматриваем статус файлов ветки**

Выше мы говорили, что файлы, не добавленные в коммит одной ветки, будут перенесены на другую при переключении на нее. Пример такой ситуации можно увидеть ниже.

В идеальном случае до и сразу после переключения ветки вывод **git status** должен быть "пустым", то есть говорить о том, что измененных файлов нет. Если вы не уверены, что закоммитили все изменения, лучше лишний раз убедитесь в этом, прописав **git status**. Это спасет вас от многих проблем, вызванных "перетаскиванием" файла не на ту ветку.

В работе программиста часто бывает нужно просмотреть историю коммитов:  

1. либо чтобы узнать, кто внес те или иные изменения,
2. либо чтобы вспомнить хэш коммита, к которому хочется откатиться,
3. либо просто проследить за историей развития проекта.

Просмотреть историю коммитов нам поможет команда **git log**:

```
git log <ключи> --<путь>
```

Ключи

`-<число>, -n <число>`  - Вывести только последние несколько коммитов. Их число вы указываете в параметре к этому ключу.  
  
`--pretty=<значение>` - Красивый вывод истории. Доступные значения: **oneline**, **short**, **medium**, **full** и др.  
  
`-p` - Показывает изменения, сделанные в данном коммите.  
  
`--graph`  - Рисует **ASCII-граф** взаимосвязи коммитов.  
  
`--all` - Выводит историю всех имеющихся коммитов на всех ветках.

Бывает необходимо просмотреть различия между двумя коммитами. Так вы сможете понять, какие конкретно изменения были внесены вместе с данным коммитом. Для реализации такой возможности в Git существует команда `git diff`.

```
git diff <ключи> <путь до файла> <путь до файла>
```

Ключи

`--diff-filter=<метка> ` - Позволяет выбирать, изменения между какими файлами показывать. Возможные значения метки: **A** (от англ. **to add** – добавить) – файлы, добавленные в индекс, **D** (от англ. **to delete** – удалить) – удаленные файлы, **M** (от англ. **to modify** – изменить) – файлы, в которые были внесены изменения с момента последнего коммита, и некоторые другие.  
  
`--word-diff=color` - Подсвечивает добавленные слова зеленым цветом, а удаленные – красным. По умолчанию словом считается неразрывная последовательность символов между пробелами.

#### Удаление веток

Большинство веток в ваших репозиториях, скорее всего, будут короткоживущими: создали ветку, протестировали новую функцию, **слили ветку с основной** и удалили ее.  

Итак, для удаления мы воспользуемся уже знакомой командой `git branch` с ключами `-d` и `-D`.

```
git branch <ключ> <имя ветки>
```

Ключи

`-d  --delete`  - С этим ключем команда удалит вашу ветку. Ветка будет удалена только в том случае, если она полностью слита с одной из других веток. В противном случае, Git выдаст предупреждение, о том, что в ветке есть неслитые изменения, и не даст ее удалить.  
  
`-D`  - Этот ключ нужен, если вы хотите удалить ветку, игнорируя предупреждения Git. В отличие от **-d**, этот ключ удалит ветку в любом случае, даже если в ней есть изменения, которые вы можете потерять.

### 1.9. Ветки в GIT

**Ветка - ссылка на коммит**

Одна ветка
![[Pasted image 20230711111206.png]]

Несколько веток
![[Pasted image 20230711111226.png]]

Переход от одной ветки в другую осуществляется перемещением указателя **HEAD**
`git checkout <branch name>`

`git checkout feature1`
![[Pasted image 20230711111303.png]]

При перемещении указателя **HEAD** на другую ветку, git **_берет содержимое конкретного дерева (коммит на который ссылается ветка) и заменяет этим содержимым текущую рабочую директорию_**

Создание новой ветки (рекомендуется давать такие названия веток, которые отражают разрабатываемый функционал, который будет реализован):

`git branch <branch name>`

После создания, переход в ветку осуществляется командой:

`git checkout <branch name>`

Этой командой **git** всего лишь перемещает указатель **HEAD** на новую ветку

Команды для создания и перехода в созданную ветку можно объединить:

`git checkout -b <branch name>`

Отображение списка всех веток:

`git branch`

Переименование текущей ветки:

`git branch -m <new branch name>`

Удаление ветки (текучею ветку удалить нельзя):

`git branch -d <branch name>`

#### Слияние веток

Ветки могут развиваться параллельно

![[Pasted image 20230711111445.png]]

Из ветки main будут видны 3 коммита, а из ветки `new-feature` – 4

При слиянии двух веток будет создан новый коммит (**merge commit**) **с двумя родителями**, т.о. сохранится история изменений двух веток. Git автоматически переместит указатель HEAD на этот коммит.
![[Pasted image 20230711111557.png]]

Слияние другой ветки (feature branch) в текущую ветку (receiving branch)

`git merge <feature branch name>`

**Процесс слияния веток**
1.       Создать новую ветку `new-feature` из ветки `main`
2.       Перейти в новую ветку `new-feature`
3.       Внести изменения в проект (создать новые файлы и папки, изменить существующие)
4.       Создать коммит или несколько коммитов в ветке `new-feature`
5.       Перейти обратно в ветку `main` и также создать коммиты
6.       Выполнить слияние ветки `new-feature` в ветку `main`
7.       После слияния ветку `new-feature` можно удалить

Например:

`git merge -m "Merging new-feature into main" new-feature`

![[Pasted image 20230711111828.png]]

`Merge made by the 'ort' strategy.` – означает стратегию, которую использовал git при слиянии веток. Эта стратегия используется по умолчанию начиная с версии 2.31.0. В этой стратегии если у разных веток есть изменения которые отличаются (т.е. есть коммиты которые внесли изменения в обоих ветках) то git создаст merge commit, у которого будет два родительских коммита.
![[Pasted image 20230711111912.png]]

Merge коммит ссылается на два хэша родителей

`git cat-file -p 9ab6e2134c4d1`

![[Pasted image 20230711111943.png]]

### 1.10. Репозитории на удаленных серверах

![[Pasted image 20230711112036.png]]

На удаленном сервере хранится **удаленный репозиторий** (**remote**), аналогичный локальному (local).

-     `git clone <url>` - Клонирование удаленного репозитория в локальный (все необходимые git объекты скачиваются в локальный репозиторий а так же клонируется рабочая директория и создается связь локального репозитория с удаленным)

#### Что такое origin

**Origin** - имя удаленного репозитория по-умолчанию.

- `git branch -a` - Отображает все ветки, включая те, которые находятся в удаленных репозиториях
- `git pull` - загрузка и применение изменений с удаленной ветки в локальную
- `git push` - загрузка изменений из локальной ветки в ветку удаленного репозитория

**Взаимодействие между локальным и удаленным сервером** **происходит на основе веток**

#### Связь существующего локального репозитория с удаленным

`git remote add origin <url>` - Подключение удаленного репозитория

`git push -u origin <branch>` - Загрузка изменений из локальной ветки в удаленную с созданием связи между ними

`git push` - Дальнейшие загрузки изменений в ветку удаленного репозитория после установки связи между локальной и удаленной ветками

Для того чтобы связать локальный сервер с удаленным необходимо:
1.    указать ссылку на удаленный сервер
2.    добавить удаленный сервер с помощью команды `git remote add origin <url>`
3.    при первой загрузки изменений с определенной ветки указать **upstream branch** с помощью опции **–****u** (выполнить команду `git push -u origin <branch>`)
4.    осуществлять взаимодействие между локальным и удаленным репозиторием с помощью команды `git pull` / `git push`

### 1.11 Удаляем и восстанавливаем файлы. Команды git rm и git restore.

Когда мы делаем файл отслеживаемым или подготавливаем его к коммиту, информация об этом файле записывается в **индекс** (файл `.git/index`). Эта информация никуда не денется, даже если мы удалили файл из рабочей копии. Рассмотрим пример. Допустим, мы выполним следующие действия:  
  
1. Создадим файл `sample.txt` и внесем в него какие-то изменения;  
2. Сделаем его отслеживаемым;  
3. Удалим файл `sample.txt`;  
4. Сделаем коммит;
  
В таком случае, просматривая содержимое нового коммита, мы обнаружим, что файл `sample.txt` в нем **присутствует**, несмотря на то, что мы вроде бы его **удалили**. Это произошло из-за того, что хоть мы и удалили файл из рабочей копии, но не удалили информацию о нем из индекса.  
  
В Git существует специальная команда, чтобы удалять файлы "правильно".

```
git rm <ключ> <имя файла>
```

Ключи

`-f, --forced`  - Форсированное удаление. Файл будет удален, несмотря на все предупреждения. Используйте этот ключ осторожно.  
  
--cached - С этим ключом команда очистит только информацию о файле в индексе. Сам файл в рабочей копии останется нетронутым, независимо от того, изменен он или нет. При этом файл из области "подготовленный к коммиту" (англ. **staged**) перейдет в область "неотслеживаемый" (англ. **untracked**).

Почему нельзя удалить файл из репозитория обычным образом, а затем добавить изменения в индекс командой `git add` и сделать коммит? На самом деле можно. Команда `git rm` является сокращением вышеописанных действий. Ее применение считается более правильным, поскольку она короче и красивее.

Если мы захотим **восстановить файл** после удаления или изменения в рабочей копии или индексе? Для этого существует команда `git restore`.

```
git restore <ключ> <имя файла>
```

Ключи

`-s, --source=<tree>`  - Этот ключ нужен, чтобы передать команде путь к коммиту (ветке, пользовательскому указателю), откуда мы будем восстанавливать файл. По умолчанию файл берется из области индекса.  
  
`--worktree` (англ. рабочая копия)  
`--staged` (англ. область индекса) 
Эти два ключа позволяют указать, где именно восстанавливать файл. По умолчанию, если ни один из этих двух ключей не передан, файл восстанавливается только в рабочей копии.  
Если же передан ключ --staged, файл восстанавливается только в области индекса. В этом случае источником восстановления по умолчанию является коммит, на который указывает **HEAD** (поскольку мы не можем восстановить файл в области индекса из самой же области индекса). Если же вы хотите восстановить файл и в рабочей копии, и в области индекса, вам нужно передать оба ключа.

С помощью команды `git restore` можно сделать неотслеживаемыми файлы, которые вы случайно добавили командой `git add`

```Git
git restore --staged file_not_for_commit.txt
```

### 1.13 Просмотр старых коммитов и перемещение указателя HEAD

Про указатель HEAD:

1. Весь репозиторий – это **древовидный граф**, ноды которого – наши коммиты, а ребра – родительские отношения между коммитами.  
2. **HEAD** – это **указатель** (то есть ссылка на один из коммитов), главное назначение которого - определять, в каком состоянии находится рабочая копия. На какой коммит указывает **HEAD** – в таком состоянии файлы и находятся в рабочей области.  
3. Обычно **HEAD** указывает не на определенный коммит, а на **указатель ветки**, который в свою очередь указывает на конкретный коммит.  
4. **HEAD** можно перемещать: при перемещении указателя **файлы в рабочей копии изменятся** так, чтобы соответствовать коммиту, на который указывает **HEAD**.  
5. Указывая путь до чего бы то ни было, вы можете использовать как **абсолютные** указатели, например, хэш коммита или имя ветки, так и **относительные**. Вспомним, как пользоваться относительными указателями:
	- Знак **^** означает "предыдущий". Например путь **HEAD^** означает "предыдущий коммит перед тем, на который указывает **HEAD**"
	- Знак **~** позволяет вам указать число коммитов. Например, запись **HEAD~7** означает "7 коммитов назад от коммита, на который указывает **HEAD**".

Итак, чтобы перемещать указатель, нужно воспользоваться командой `git checkout`.

```
git checkout <путь>
```

Можно заметить, что **синтаксис** совершенно такой же, как и в переключении ветки. Все верно, ведь **переключение ветки** – ни что иное, как передвижение указателя **HEAD** с указателя одной ветки на указатель другой. Чтобы подробно разобраться, что происходит при передвижении указателя, давайте рассмотрим пример. Изначально у нас есть такой репозиторий.
![[Pasted image 20230720152210.png]]
Серыми овалами обозначены коммиты, текст на них – часть хэша соответствующего коммита. Коричневым прямоугольником обозначен указатель ветки: она у нас одна и называется **main**. Белым прямоугольником обозначен указатель **HEAD**, иногда его называют курсором. Его-то мы и будем двигать. Давайте попробуем сдвинуть **HEAD** на **два коммита назад** (то есть на коммит с хэшем **90ab…**) и посмотрим, что будет.

```Git
git checkout HEAD~2
Note: switching to 'HEAD~2'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 90abf7e L-04: Fixing gradient bug
```

Мы оказались в следующем состоянии:
![[Pasted image 20230720152328.png]]
Как видно из рисунка, указатель **HEAD** сейчас действительно передвинут на два коммита назад. Но указатель ветки **main** остался на месте и все еще указывает на последний коммит. Такое состояние, когда **HEAD** указывает не на указатель ветки, а непосредственно на сам коммит, называется **detached head**.

> **Detached head** (англ. дословно – отрубленная голова, имеется в виду указатель **HEAD**, отключенный от графа) – состояние, при котором указатель **HEAD** не указывает ни на одну из веток репозитория, а ссылается непосредственно на сам коммит.

**Как переключиться обратно?** 

Если мы хотим перенести **HEAD** обратно, достаточно выполнить:

```Git Bash
git checkout -
Previous HEAD position was 90abf7e L-04: Fixing gradient bug
Switched to branch 'main'
```

или

```Git
git checkout main
Previous HEAD position was 90abf7e L-04: Fixing gradient bug
Switched to branch 'main
```

Как видно по выводу Git, мы успешно вернулись обратно на ветку **main** и вышли из состояния **detached head**.

> Подведем итог  
> 1. Указатель **HEAD** можно перемещать на разные коммиты, точно так же, как мы перемещали его между ветками. Для этого нужно использовать команду **git checkout**.
> 2. Когда мы перемещаем **HEAD** с указателя ветки на коммит, мы попадаем в состояние **detached head**.
> 3. В состоянии **detached head** стоит быть осторожным: если планируете делать коммиты, лучше сразу создайте ветку командой **git checkout -b <имя ветки>**.
> 4. Если вы сделали несколько коммитов из состояния **detached head**, забыв создать ветку – ничего страшного, ветку можно создать в любой момент.
> 5. Обычно **detached head** используется редко, но вы можете использовать его, чтобы просматривать старые версии файлов или экспериментировать с предыдущими версиями проекта.

### 1.14 Откат коммитов. Команда git revert

Пожалуй одна из самых важных частей в изучении Git – научиться откатываться к предыдущим коммитам. Ваш проект может перестать работать по непонятным вам причинам после внесения некоторых изменений в код, в таком случае важно быстро вернуть все к рабочему состоянию и только потом заниматься поиском ошибки. В этом-то случае нам и поможет откат коммитов и команда `git revert`.
  
Суть работы данной команды в том, что она создает новый коммит, который отменяет изменения внесенные в переданном коммите (последовательности коммитов).

```
git revert <ключи> <адрес коммита>
```

Ключи

`-n` - Не делает коммит. С данным ключом изменения коснутся только рабочей копии.

`--abort` - Данный ключ используется только при разрешении конфликтов.  Прерывает выполнение команды после разрешения конфликтов.  

`--continue` - Данный ключ используется только при разрешении конфликтов.  
Продолжает выполнение команды после разрешения конфликтов.

Допустим, мы хотим отменить изменения предпоследнего коммита.

```Git
# Выполним реверт предпоследнего коммита.
$ git revert HEAD~1
```

> Подведем итог
> 1. **git revert** – команда, отменяющая изменения переданного коммита. Она заменяет файлы в рабочей копии на файлы предка переданного коммита, а затем делает коммит, чтобы сохранить изменения.
> 2. Иногда во время отката возникают конфликты. Их не стоит бояться, но нужно быть внимательным и разобраться, откуда возникает конфликт.
> 3. Если вы столкнулись с конфликтом во время отката и передумали продолжать **git revert**, выполните команду **git revert --abort**. Она вернет все как было и отменит откат.
> 4. В сообщении реверт-коммита следует указывать полезную информацию: зачем вы сделали откат, каким образом вы сливали файлы, если были конфликты, и т.д.

### 1.15 Удаление и объединение коммитов. Команда git reset

Команда `git reset` позволяет нам перемещать указатель ветки вместе с указателем **HEAD**.

```
git reset <ключи> <адрес коммита>
```

Ключи

`--soft` - С этим ключом, команда не отменяет изменения ни в индексе, ни в рабочей копии. Все ваши файлы останутся в том же состоянии, в котором были, но указатель ветки будет передвинут.  
  
`--hard` - С этим ключом команда удалит все изменения так, чтобы состояние индекса и рабочей копии полностью соответствовали коммиту, к которому мы сделали **reset**

Чтобы лучше понять смысл этой команды приведем граф репозитория. Изначально он выглядел так.
![[Pasted image 20230720154135.png]]
Теперь выполним "мягкий" **reset** последних двух коммитов.

```Git
git reset --soft HEAD~2
```

Теперь наш граф выглядит так.
![[Pasted image 20230720154220.png]]
Причем файлы в рабочей копии остались в том же состоянии, что и были в коммите **62aa**.  
  
Как видно из рисунка, Git создал новый указатель – **ORIG_HEAD**. Этот указатель создается при выполнении команды **git reset** и ссылается на тот коммит, от которого мы делали **reset**. Как мы увидим ниже, это очень полезный в работе с **git reset** указатель.

#### Объединение нескольких коммитов в один.  

Иногда на практике возникают ситуации, когда для удобства восприятия и красивой истории необходимо **объединить** **несколько** последних **коммитов** в один. Порядок действий тут почти такой же, как и в случае редактирования последнего коммита:  
  
1. Выполните `git reset --soft HEAD~n`, где `n` это число коммитов, которые вы хотите объединить. Эта команда вернет указатель ветки на **n** коммитов назад, оставив изменения в индексе и рабочей копии нетронутыми. То есть после выполнения этой команды вы откатитесь на **n** коммитов назад, но все изменения внесенные этими коммитами останутся у вас в рабочей копии и индексе.
2. Выполните `git commit -c ORIG_HEAD`, а затем отредактируйте сообщение коммита должным образом. Эта команда сделает коммит всех изменений в индексе. То есть она сделает коммит, который по своему содержимому представляет объединение последних **n** коммитов.

#### Удаление последних нескольких коммитов.  

Пожалуй, самая простая ситуация. Чтобы удалить последние **n** коммитов, выполните

```Git
git reset --hard HEAD~n
```

#### Отмена изменений команды git reset.

Если вы каким-то образом случайно выполнили `git reset` и решили все **вернуть**, просто переместите указатель ветки обратно, использовав команду

```Git
git reset ORIG_HEAD
```

Эта команда вернет указатель ветки на коммит, с которого вы делали `git reset`, и вы вернете все изменения, даже если использовали ключ `--hard`.

> **Подведем итог** 
> Команда `git reset` используется, чтобы перемещать указатель ветки по графу Git. На практике ее в основном применяют для  
> 1. Редактирования или удаления последнего сделанного коммита.
> 2. Объединения последних нескольких коммитов в один.
> 3. Удаления последних нескольких коммитов. 
> После использования **git reset**, Git создаёт указатель **ORIG_HEAD**, который ссылается на коммит, с которого мы сделали **reset**. +

### 1.16 Слияние изменений и продвинутая работа с ветками. Команды: merge, cherry-pick, rebase.

**Что такое слияние и зачем оно нужно**

Ветка – независимая последовательность коммитов. Ветки нужны, чтобы тестировать новые функции и распараллеливать работу над проектом. Первоначально мы работаем в основной ветке. У нас она называется main. Обычно в основной ветке находится та же версия кода, что и в продакшене. То есть если в основную ветку попадут какие-то непроверенные изменения, код может сломаться и повлечь за собой поломку приложения у конечного пользователя. Поэтому во всех командах, работающих над серьезными проектами, принято, что в **основной ветке** находятся только **протестированные изменения**, которые в идеале не придется экстренно исправлять.

То есть общий **ход** нашей **работы** выглядит следующим образом:  
1. Решили добавить новую функцию – создали отдельную ветку. Дальше работаем в новой ветке.  
2. Написали функцию, протестировали ее работу, внесли все необходимые исправления, еще раз протестировали и убедились, что функция работает исправно и не привнесла ошибок в остальной код.  
3. Теперь нужно как-то перенести изменения с тестовой ветки на основную – в продакшн. Тут нам на помощь и приходит **слияние**: мы просто сливаем (т.е. переносим) изменения с нашей тестовой ветки в основную.

> **Сливаемая ветка** – та ветка, с которой мы берем изменения, чтобы влить их в целевую.
> **Целевая ветка** – та ветка, в которую мы сливаем наши изменения.
> **Слияние веток** – это перенос изменений с одной ветки на другую. При этом слияние не затрагивает сливаемую ветку, то есть она остается в том же состоянии, что позволяет нам потом продолжить работу с ней.

#### Слияние в Git. Команда git merge

Чтобы выполнить мердж (от англ. **merge** – слияние), в Git предусмотрена команда `git merge`.

```
git merge <сливаемая ветка>
```

Ключи

`--ff , --no-ff и --ff-only`  - Эти ключи определяют стратегию слияния. 

`--abort`  - Ключ, использующийся только при разрешении конфликтов. Позволяет прервать слияние и вернуть все к моменту начала операции.  
  
`--continue`  - Ключ, использующийся только при разрешении конфликтов. Позволяет продолжить слияние после разрешения всех конфликтов.

**Разберем стратегии слияния.**

**Стратегия слияния** – это набор правил, которыми руководствуется Git при выполнении слияния.

Существует две основных стратегии слияния:  

1. Явное слияние
2. Неявное слияние.

Их различие заключается в том, что при **явном** всегда создается новый коммит, а при **неявном** – используются существующие коммиты.

**Явное слияние**  

Во время явного слияния создается так называемый **merge-коммит**. Основное предназначение этого коммита состоит в том, чтобы "соединить" изменения двух веток. У этого коммита есть одна особенность: **два родительских коммита**. Один родитель – последний коммит сливаемой ветки, второй – последний коммит целевой ветки.  
  
Допустим, у нас есть граф вида:
![[Pasted image 20230720160303.png]]
То есть у нас есть две ветки: **main** – основная и **develop** – ветка для разработки новых функций. Давайте посмотрим, что будет происходить, если мы выполним команду:

```Git
git checkout main
git merge --no-ff develop
```

Флаг **--no-ff** в данной ситуации необходим, поскольку мы хотим выполнить именно явное слияние.

Итак, `git merge` делает следующие шаги:  

1. Проверяет, нет ли конфликтов, т.е. не удалят и не перепишут ли наши изменения какую-либо уже существующую информацию. Если возникает конфликт **git merge** останавливается, чтобы получить инструкции от пользователя.
2. Добавляет все изменения из коммитов 3-5 в индекс ветки **main**
3. Делает коммит

После `git merge` граф репозитория будет выглядеть следующим образом:
![[Pasted image 20230720160521.png]]
**Неявное слияние**  

Во время неявного слияния не создается новых коммитов: используются только уже существующие. Суть этого слияния заключается в том, что из вливаемой ветки извлекаются несколько коммитов, а затем они применяются к последнему коммиту целевой ветки. Такое слияние называется **fast-forward**.  
  
Давайте рассмотрим пример. Допустим, у нас есть все тот же граф репозитория:
![[Pasted image 20230720160630.png]]
Попробуем выполнить слияние, но уже без флага `--no-ff`:

```Git
git checkout main
git merge develop
```

Тогда **git merge** поступит так:  

1. Проверит, что в ветке main нет коммитов, сделанных после ответвления **develop**.
2. Проверит, что не возникает конфликтов, если конфликты возникнут, Git попросит пользователя разрешить их.
3. Перенесет указатель main на **Commit-5**. Теперь ветка **develop** как бы стала веткой **main**.

Графически ситуация выглядит следующим образом:
![[Pasted image 20230720160753.png]]
Как видно из рисунка, новый коммит действительно не был создан. Вместо него, Git "подставил" в ветку **main** уже существующие коммиты из ветки **develop**.

> **В чем разница между fast-forward и явным слиянием?**  Режим **fast-forward** считается более удобным, поскольку в нем не нужно создавать лишних merge-коммитов, засоряющих историю репозитория. С другой стороны, если мы продолжим пользоваться веткой **develop** после **fast-forward** слияния, потом будет довольно трудно разобраться в ее истории. Так что каждый раз выполняя слияние, задумайтесь, хотите ли вы, чтобы оно прошло в режиме **fast-forward**, или для вас лучше явно создать **merge-коммит**, собирающий все воедино.

#### Разрешение конфликтов слияния

Очень часто во время слияния веток оказывается, что ваши изменения удаляют или переписывают информацию в уже существующих файлах. Такая ситуация называется **файловым конфликтом**. Git останавливает выполнение слияния, пока вы не разрешите конфликт.  
  
По сути, Git сталкивается с проблемой: у него есть два файла с одним и тем же именем, и он не знает, какой из них взять. Поэтому обращается к нам за помощью.  
  
Давайте сразу начнем с примера и по ходу будем учиться разрешению конфликтов. Так будет нагляднее. Итак, допустим есть следующий репозиторий:
![[Pasted image 20230720161058.png]]
Содержимое Docs.md, C2

```
- This is documentation
```

Содержимое Docs.md, C6

```
- This is documentation
- It contains lots of info
```

Содержимое Docs.md, C5

```
- This is documentation
- New feature info
- It has lots of info
```

Наша задача состоит в том, чтобы слить ветку **develop** в ветку **main**. Давайте попробуем сделать это.

```Git
git merge develop
Auto-merging Docs.md
CONFLICT (content): Merge conflict in Docs.md
Automatic merge failed; fix conflicts and then commit the result.
```

Вот так Git и сообщает нам о конфликте: в файле **Docs.md** из коммита **C5** вторая строка переписывает вторую строку фалйа **Docs.md** из коммита **C6**. Таким образом Git просит нас разобраться, какой файл оставлять. Давайте научимся делать это.  
  
Общий подход к **разрешению конфликтов** такой:  

1. Непосредственно разрешить конфликт одним из двух рассмотренных немного ниже способов. Либо, если возникновение конфликта стало неожиданным для вас, можно выполнить `git merge --abort`. Эта команда прервет слияние и вернет все, как было.
2. Сообщить Git, что мы разрешили конфликт, добавив все файлы с разрешенными конфликтами в индекс. Сделать это можно уже знакомой командой `git add <конфликтный файл>` для каждого конфликтного файла.
3. Продолжить слияние, выполнив `git merge --continue`. Либо вручную создать **merge-коммит** уже знакомой командой **git commit**.

Существует **два способа разрешать конфликты**, вот они:  

1. Первый способ. Разрешить конфликт вручную. Тогда мы можем самостоятельно изменить конфликтные файлы, сделав их такими, какими мы хотим их видеть.
2. Второй способ. Просто выбрать один из двух файлов.

**Ручное разрешение конфликта**  

Для этого в любом текстовом редакторе откройте конфликтный файл (если файлов несколько, конфликт нужно устранять в каждом). Приведем содержимое файла **Docs.md**.

```
- This is documentation
<<<<<<< HEAD
- It contains lots of info
=======
- New feature info
- It has lots of info
>>>>>>> develop
```

Видим, что Git оставил нам пометки, чтобы нам было проще устранять конфликт:  

1. **Текст до** `<<<<<<< HEAD` – это общая часть двух файлов, она не конфликтует. В нашем случае оба файла имеют одинаковую первую строку: **- This is documentation**
2. **Текст между** `<<<<<<< HEAD` **и** `=======` – это конфликтующее содержимое файла, на который указывает **HEAD**, то есть файла из целевой ветки. В нашем случае это вторая строка, именно она переписывается изменениями из ветки **develop**.
3. **Все, что находится между** `=======` и `>>>>>>>` develop – это содержимое файла из ветки **develop**. В нашем случае это вторая и третья строки: **- New feature info** и **- It has lots of info**.
![[Pasted image 20230720161652.png]]
**Наша задача** – объяснить Git, каким мы хотим видеть файл **Docs.md**. Для этого нам нужно вручную отредактировать файл **Docs.md**. Нам не обязательно выбирать один из двух приведенных вариантов – в этом вся **прелесть ручного редактирования**. Мы можем удалить вообще весь текст из файла, оставить часть первого файла и часть второго или вообще написать что-то свое.

**Выбор одного из двух файлов**  

Если вы точно знаете, что вам нужно оставить только один из двух конфликтных файлов (вся информация из другого файла при этом потеряется), можно сказать об этом Git:  

1. Выполните `git checkout --ours Docs.md`, чтобы выбрать файл ветки **main** (то есть целевой ветки)
2. Либо `git checkout --their Docs.md`, чтобы выбрать файл из ветки **develop** (то есть сливаемой ветки).

Эта команда скопирует в `docs.md` из рабочей копии содержимое одного из конфликтных файлов. То есть Git полностью заменит файл в рабочей копии выбранным вами файлом.

```
# Разрешим конфликт выбором файла из коммита, к которому мы откатываемся.
git checkout --their Docs.md
Updated 1 path from the index
```

### 1.16 Команда git rebase

Команда `git rebase` позволяет нам не только объединять изменения с разных веток, но и менять историю репозитория, **манипулируя коммитами**.

Если говорить кратко, `git rebase` переносит коммиты текущей ветки на вершину переданной.

Пусть у нас есть репозиторий со следующим графом.
![[Pasted image 20230721091732.png]]
Если бы мы хотели выполнить слияние ветки **develop** в ветку **main** прямо сейчас, мы бы не смогли сделать его в режиме **fast-forward**. И нам бы пришлось создавать **merge-коммит**, засоряющий историю репозитория. На помощь приходит **git rebase**.  
  
Если вы примените команду `git rebase main`, находясь на ветке **develop**, репозиторий примет следующий вид.
![[Pasted image 20230721091622.png]]
То есть команда `git rebase` перенесла коммиты ветки **develop** так, чтобы ветка **develop** брала свое начало на последнем коммите **main**. Попросту говоря, она перенесла коммиты ветки **develop** на вершину ветки **main**. Такое состояние очень выгодно нам тем, что в нем уже можно сделать **fast-forward** слияние. Таким образом, мы избавились от необходимости создания **merge-коммита**.

Перемещает все коммиты: от общего коммита двух веток до последнего коммита текущей ветки на вершину переданной ветки.

```
git rebase <целевая ветка>
```

Ключи

`-i, --interative`  - Эти ключи позволяют нам делать **rebase** в интерактивном режиме. Мы будем активно пользоваться ими при редактировании старых коммитов.  
  
`--abort`  - Ключ, использующийся только при разрешении конфликтов. Позволяет прервать ребейз и вернуть все к моменту до начала операции.  
  
`--continue` -Ключ, использующийся только при разрешении конфликтов. Позволяет продолжить ребейз после разрешения всех конфликтов.  
  
`--skip` - Ключ, использующийся только при разрешении конфликтов. Позволяет пропустить текущий коммит.

Посмотрим, что происходит при выполнении команды

```Git
git rebase main
```

Git rebase выполняет следующие **действия**:  
1. Первым делом, Git находит общий коммит двух веток. В нашем случае это коммит **B**.  
2. После этого Git начинает двигаться от коммита **B** к положению указателя **HEAD**, и делает следующее для каждой пары коммитов.  
	2.1. Вычисляет дельту между **B** и **D**: **delta_bd = D - B**  
	2.2. Пытается применить дельту к последнему коммиту ветки **main**. Так получается коммит **D-new**. Т.е. **D-new = C + delta_bd**. Если при этом возникает конфликт, Git останавливается, пока мы не разрешим конфликт.  
	2.3. Вычисляет дельту между **D** и **E**: **delta_de = E - D**  
	2.4. Применяет эту дельту к коммиту **D-new** и получает коммит **E-new = D-new + delta_de**  
	2.5. Вычисляет дельту между коммитами **E** и **F**: **delta_ef = F - E**  
	2.6. Применяет вычисленную дельту к коммиту **E-new** и получает коммит **F-new = E-new + delta_ef**  
3. Переносит указатель ветки **develop** на коммит **F-new**.  
4. Переносит **HEAD** на указатель ветки **develop**.  
5. Создает указатель **ORIG_HEAD** на коммите **F**.

После выполнения всех вышеуказанных операций, граф репозитория будет выглядеть так.
![[Pasted image 20230721093613.png]]
Как видно из схемы действий, **HEAD** переносится в самом конце, поэтому если во время выполнения одного из шагов по применению дельты возникнет конфликт, вы обнаружите, что находитесь в состоянии **detached head**. В это время в вашей рабочей копии будут все изменения дельты, кроме конфликтных. Не стоит пугаться, просто разрешите конфликты, добавьте изменения в индекс и продолжите ребейз командой:

```Git
git rebase --continue
```

Также не стоит забывать, что как и с командой `git merge`, вы в любой момент можете отменить ребейз, выполнив

```Git
git rebase --abort
```

Если же вы уже выполнили ребейз, но по какой-то причине решили все **вернуть обратно,** не стоит переживать - это легко сделать. Git оставил нам указатель **ORIG_HEAD** на последнем коммите первоначальной ветки **develop**. Давайте этим и воспользуемся. Итак, чтобы отменить `git rebase` уже после его завершения, просто выполните:

```Git
git reset --hard ORIG_HEAD
```

находясь на ветке **develop**. Как вы помните из прошлого урока, эта команда перенесет наш указатель ветки вместе с **HEAD** на место указателя **ORIG_HEAD**, то есть ветка **develop** начнет указывать на коммит **F** как и раньше. По сути это и есть отмена действий `git rebase`.

#### Интерактивный git rebase. Редактирование коммитов любой давности.

На самом деле `git rebase` можно выполнять **для одной и той же ветки**. В обычном режиме это нам ничего не даст, но вот в интерактивном режиме мы сможем поменять сообщения, содержимое и вообще манипулировать коммитами, как нам только вздумается, вплоть до удаления. Давайте на примере разберем, как происходит изменение коммитов. Итак, допустим у нас есть репозиторий, граф которого выглядит так:
![[Pasted image 20230721095339.png]]
Допустим, нам нужно поменять сообщение коммита **C**. Как это сделать? Давайте попробуем взять все коммиты, начиная с коммита **С** и заканчивая коммитом **Е**, и перенести их на вершину той же ветки. Если бы мы не меняли сообщение коммита **С**, то такая манипуляция ничего не изменила бы. В этом и кроется **небольшая хитрость**: если мы поменяем коммит **С**, поменяется его хеш-сумма, и, соответственно, нам придется менять все последующие коммиты. А теперь вспомним, как работает **rebase**. На каждом шаге она заново вычисляет дельту и создает новый коммит на основе старого. Именно то, что нам нужно. Давайте поменяем сообщение коммита **С**. Для этого выполним:

```Git
git rebase -i HEAD~3
```

Итак, когда мы выполним указанную команду, перед нами в консольном **текстовом редакторе** откроется примерно такой экран:

```
pick f831285 C
pick c06b382 D
pick 0874316 E
```

Это так называемый **TO-DO файл** `git rebase`. В нем мы указываем, как хотим манипулировать коммитами. Чтобы что-то сделать с коммитом, нужно слово **pick** перед хешем соответствующего коммита заменить на одну из команд. Либо, если команда это позволяет, вставить ее между коммитами. Вы также можете менять порядок инструкций. Данный файл с инструкциями будет выполняться сверху вниз.  
  
Все доступные команды можно посмотреть в документации, мы же разберем только те, которые необходимы, чтобы изменять коммиты:  

1. **p**, **pick <коммит>** – просто использовать коммит, ничего не менять
2. **r**, **reword <коммит>** – использовать коммит, но поменять его сообщение
3. **e**, **edit <коммит>** – использовать коммит, но остановить ребейз, чтобы добавить в коммит больше файлов
4. **s**, **squash <коммит>** – использовать коммит, объединив его с предыдущим
5. **f**, **fixup <коммит>** – как **squash**, но удаляет информацию об объединенном коммите из истории.

В нашем случае, если мы хотим поменять сообщение коммита **С**, нужно отредактировать файл следующим образом заменив `pick` коммита **С** на `reword` :

```
reword f831285 C
pick c06b382 D
pick 0874316 E
```

То есть мы заменили команду **pick** на **reword** напротив коммита **С**. Сохраняем файл и выходим обратно в консоль. Перед нами сразу же откроется редактор сообщения коммита **С**. Вводим новое сообщение, сохраняем файл и выходим из редактора. Если мы теперь просмотрим историю, то обнаружим, что сообщение коммита **С** действительно поменялось, а вместе с ним поменялись и хэши последующих коммитов. Аналогичным образом можно объединять и удалять любые коммиты, а также добавлять в них новые файлы.

>**Подведем итог**  
>1. **git rebase** – команда, перемещающая все коммиты: от общего коммита двух веток до последнего коммита текущей ветки на вершину переданной ветки.
>2. Такое перемещение может быть необходимо, чтобы стало возможным слияние в **fast-forward** режиме.
>3. Помимо обычного **git rebase**, существует интерактивный режим этой команды: **git rebase** **-i**. В основном им пользуются, чтобы отредактировать, объединить или удалить старые коммиты. Стоит быть осторожным с этой командой, особенно работая в чужих репозиториях: изменение уже записанных в истории коммитов в некоторых случаях может повлечь непредвиденные последствия, поэтому хорошо подумайте, прежде чем выполнять ребейз.

### 1.17 Команда git cherry-pick

Иногда возникает ситуация, когда изменения внесенные другим разработчиком в своей ветке нужны вам в вашей ветке прямо сейчас. Конечно, можно сделать merge, но это только засорит историю и сломает логику репозитория: зачем делать слияние, если ветка другого разработчика еще к нему не готова. В этом случае нам на помощь придет команда `git cherry-pick`.

**Что делает**

Берет переданный коммит и создает в текущей ветке его точную копию.  
  
Также в команду можно передать первый и последний коммит последовательности, тогда та же операция будет выполнена для всех коммитов последовательности.

**Формат**

```
git cherry-pick <хеш коммита>  
git cherry-pick <хеш первого коммита> … <хеш последнего коммита>
```

**Ключи**

`-e, --edit` - С этим ключом вы сможете отредактировать сообщение коммита.  
  
`-n, --no-commit` - С этим ключом команда не создаст коммит на вашей ветке, а только скопирует все изменения в вашу рабочую копию. То есть с этим ключом данная команда идентичная **git checkout <коммит> ***  
  
`--abort` - Ключ, использующийся только при разрешении конфликтов. Позволяет прервать операцию и вернуть все к моменту до начала операции.  
  
`--continue` - Ключ, использующийся только при разрешении конфликтов. Позволяет продолжить операцию после разрешения всех конфликтов.

Никаких особых тонкостей или подводных камней данная команда не имеет. Это действительно мощный инструмент, который поможет вам в работе, однако не всегда хорошо использовать именно **cherry-pick**. Из-за чрезмерного использования этой команды у вас могут возникнуть коммиты-дубликаты, а история репозитория станет абсолютно нечитаемой. Поэтому нужно хорошо понимать, в каких случаях использовать **cherry-pick**, а в каких – **merge**. Всего можно выделить три случая, когда нужно использовать именно **cherry-pick**, а не **merge**. Давайте рассмотрим их по очереди.  
  
**1. Случай первый. Работа в команде.**  
Этот случай был описан во введении к данной части. Часто в команде несколько разработчиков работают над одним и тем же участком кода, но каждый – в своей ветке. Соответственно могут возникать ситуации, когда одному из разработчиков для реализации своей части задачи потребуется часть кода, написанная другим разработчиком. **Merge** в данном случае делать нерационально, поскольку ни одна из веток не пришла к своему логическому завершению, а вот **cherry-pick** – то, что надо.  
  
**2. Случай второй. Быстрые исправления багов.**  
Если в коде был обнаружен баг, очень важно как можно быстрее донести исправления до конечного пользователя. В таком случае, разработчик, обнаруживший ошибку, срочно создает коммит, в котором исправляет ее. Этот коммит может быть перенесен в основную ветку с помощью cherry-pick, чтобы не задерживать исправление бага слияниями в различные пре-релизные ветки.  
  
**3. Случай третий. Восстановление утерянных коммитов.**  
Иногда возникают ситуации, когда вы из-за каких-то манипуляций потеряли определенный коммит. Например, сделали **git reset --hard**, начали новую ветку, сделали несколько коммитов и только тут обнаружили пропажу. С помощью **git log** и **git reflog** вы можете узнать хеш утерянного коммита, а затем выполнить **git cherry-pick**, чтобы вернуть его обратно.


### 1.18 Git tools

#TODO 

### 1.19 GitHub, удаленные репозитории

> Удаленный репозиторий – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель **HEAD**, своя история коммитов и так далее.

Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория. То есть, например, у удаленного репозитория есть ветка **main**, а у нас будет копия этой ветки – **origin/main**. Все такие ссылочные объекты (указатели, ветки и теги) удаленного репозитория хранятся почти там же, где и у локального – в директории `.git/refs/remotes/<имя_удаленного_репозитория>`.

#### Настройка подключения удаленного репозитория. Группа команд git remote.

Необходимость подключить удаленный репозиторий к уже существующему локальному возникает в ситуациях, когда вы решаете выгрузить уже написанный код на удаленный сервер. Это нужно, чтобы другие разработчики смогли получить к нему доступ или чтобы вы сами могли заниматься разработкой с нескольких компьютеров (например, домашнего и рабочего).  
  
Для управления подключением удаленных репозиториев в Git предусмотрена целая группа команд – **git remote**.

Команда `git remote add`

**Что делает**

Подключает удаленный репозиторий к вашему под переданным именем.

**Формат**

```
git remote add <название удаленного репозитория> <ссылка на удаленный репозиторий>
```

**Имя удаленного репозитория** в команде **git remote add** вы можете придумать сами. Впоследствии, при работе с этим удаленным репозиторием, вы будете обращаться к нему по придуманному имени. Принято называть удаленный репозиторий **origin**, но строго говоря, никаких ограничений здесь нет.  

Со ссылкой на удаленный репозиторий тоже все просто. Мы работаем с GitHub, поэтому эту ссылку можно взять, нажав на большую зеленую кнопку **Code** на странице репозитория на GitHub.

![[Pasted image 20230721100935.png]]

Вам предложат выбрать одну из трех ссылок: для протоколов **https** и **ssh** и для клиента GitHub на компьютер. Вот примеры этих трех ссылок для репозитория **geometric_lib** известного вам по практическим занятиям этого курса:  

1. **HTTPS-ссылка**: [https://github.com/<project_name>.git](https://github.com/<project_name>.git)
2. **SSH-ссылка**: `git@github.com:<project_name>.git`
3. **GitHub CLI ссылка**: `gh repo clone <project_name>`

Давайте разберемся, в чем отличие. Начнем с **последней** - эта ссылка используется в клиенте GitHub, который нужен для упрощения работы с Git (специальной программе для компьютера с графическим **UI** от создателей GitHub). Но в чем разница между первыми двумя?  
  
Дело в том, что существует **два** основных протокола подключения к **git-серверу**: **HTTPS** и **SSH**. **SSH** считается более надежным, но он немного сложнее в настройке. Давайте разберемся, как настроить подключение для каждого из них.

**Настройка подключения по HTTPS**  

Раньше можно было подключаться по **HTTPS**, используя имя пользователя и пароль от аккаунта GitHub. Но потом эту возможность отключили в целях безопасности. Сейчас вместо пароля нужно использовать персональный **токен**. Давайте разберемся, как создать такой токен.  
  
Итак, чтобы создать токен персонального доступа, следуйте инструкции:  
1. Подтвердите свой email-адрес, который вы использовали при регистрации аккаунта GitHub (если он не подтвержден)
2. Кликните на свою аватарку в правом верхнем углу, в открывшемся окне выберите **Settings** (Настройки):  
3. Перед вами откроются настройки. В меню слева выберите **Developer settings** (Настройки разработчика)
4. Перед вами откроются Настройки разработчика. В меню слева выберите **Personal access tokens** (токены персонального доступа).  
5. Нажмите **Generate new token** (сгенерировать новый токен)  
6. Придумайте имя для своего токена. Имя должно описывать, зачем токен был создан.  
7. Дайте токену разрешения. Пользователь токена сможет выполнять с удаленным репозиторием только то, что вы указали в этих разрешениях. Чтобы дать токену доступ к управлению удаленным репозиторием из командной строки, выберите **repo**.  
8. Нажмите **Generate token** (сгенерировать токен).
9. Скопируйте токен. В целях безопасности, как только вы покинете страницу создания токена, вы больше не сможете просмотреть этот токен.

При первой загрузке/скачивании изменений из удаленного репозитория, вас попросят ввести имя пользователя на GitHub и пароль. Нужно будет ввести свое имя пользователя, а вместо пароля вставить этот токен.

**Настройка подключения по SSH**  

Чтобы настроить подключение по **SSH**, вам нужно на своем компьютере сгенерировать два **SSH-ключа**: публичный (**public**) и секретный (**private**).

> Как работает **SSH протокол** и зачем ему ключи? Если коротко, то публичный ключ передается на удаленный сервер, а секретный все время остается с вами. Удаленный сервер использует публичный ключ, чтобы удостовериться, что у вас действительно есть секретный ключ. Как только сервер убеждается в наличии у вас секретного ключа, он понимает, что вы – это вы, ведь секретный ключ нельзя подделать.

Давайте рассмотрим этот процесс подробнее:  
  
1. Откройте **Git Bash**
2. Выполните в нем команду **ssh-keygen -t rsa 4096 -C "<ваша-почта>@example.com"**  
	2.1. Вам предложат ввести путь к директории, в которой будет сохранен ключ, а также будет выведена директория для сохранения по умолчанию. Нажмите **Enter**, чтобы выбрать директорию по умолчанию, либо введите любую другую директорию и тоже нажмите **Enter**.  
	2.2. Затем вам предложат ввести пароль для файла с секретным ключом. Нажмите **Enter**, чтобы оставить файл без пароля, либо введите пароль и нажмите **Enter**.  
3. Теперь нужно добавить ключ в **SSH-агента**. Запустим агента командой **eval `ssh-agent -s`**  
4. Теперь выполните команду **ssh-add <путь до приватного ключа>**. Если вы оставили путь по умолчанию, ваша команда будет выглядеть так: **ssh-add ~/.ssh/id_ed25519**  
5. Отлично, последний этап: добавляем публичный ключ на GitHub. Для этого откройте файл с публичным ключом (он должен иметь расширение **.pub**). Если вы оставили путь по умолчанию, то ваш ключ будет располагаться по адресу **~/.ssh/id_ed25519.pub**.  
6. Скопируйте содержимое файла.  
7. Перейдите в настройки GitHub  
8. Откройте раздел **SSH and GPG keys** (**ssh** и **gpg** **ключи**)
9. Нажмите **New SSH key** (новый **ssh-ключ**)  
10. В поле **Title** (заголовок) введите содержательное название ключа, например **ключ для ноутбука** или **ключ рабочего компьютера**
11. Скопированный ключ вставьте в раздел **Key** (ключ)  
12. Нажмите **Add SSH key** (добавить ssh-ключ)  
13. Возможно потребуется ввести пароль для подтверждения действия.

Теперь SSH-ключ добавлен. Вам больше не нужно вводить имя пользователя и пароль при каждой загрузке или скачивании изменений из удаленного репозитория

#### Изменение имени удаленного репозитория. Просмотр всех удаленных репозиториев. Команды git remote rename, git remote show.

**Формат**

```
git remote rename <старое имя удаленного репозитория> <новое имя удаленного репозитория>
```

**Что делает**

Меняет имя переданного удаленного репозитория

Еще более частая задача – просмотреть список всех подключенных удаленных репозиториев и получить информацию о каждом из них. Для этого существует команда **git remote show**.

**Формат**

```
git remote show [имя удаленного репозитория]
```

**Что делает**

Выводит список всех подключенных удаленных репозиториев. Если передано имя репозитория, то выводит информацию об этом репозитории.

#### Клонирование удаленного репозитория. Команда git clone.

Необходимость клонировать существующий удаленный репозиторий возникает в ситуациях, когда вы решаете поработать над уже существующим кодом. Для выполнения этой операции в Git предусмотрена команда **git clone**.

**Формат**

```
git clone <ссылка на удаленный репозиторий>
```

**Что делает**

Клонирует переданный репозиторий на ваш компьютер.

Заметьте, что клонирование по https возможно вообще всегда, а по ssh – нет. Чтобы клонировать репозитории по ssh, нужно, чтобы владелец удаленного репозитория на GitHub добавил к себе публичный ssh-ключ из пары, в то время, как секретный ssh-ключ от той же пары хранится у вас на компьютере, с которого вы выполняете **git clone**. Таким образом, если вы настроили ssh в своем аккаунте, то вы сможете беспрепятственно клонировать свои репозитории и по https, и по ssh. Но если вы пытаетесь клонировать чужой репозиторий по ssh, то скорее всего получите ошибку доступа.

Давайте на примере разберем, как происходит клонирование. При выполнении команды `git сlone https://github.com/<project_name>.git` произойдет следующее:  

1. В директории, откуда вы запустили команду **git clone**, создается директория с именем репозитория.
2. В созданную директорию копируется репозиторий, все его ветки и коммиты.
3. В новосозданный локальный репозиторий добавляется удаленный репозиторий с именем **origin** и ссылкой, которую мы передавали в **git clone**. Это избавляет нас от необходимости вручную писать `git remote add origin https://github.com/<project_name>.git`. На этом процесс клонирования заканчивается.

#### Получение изменений из удаленного репозитория. Команда git fetch

Чтобы получить изменения из удаленного репозитория, в Git предусмотрена команда `git fetch`.

**Формат**

```
git fetch [ключи] [имя удаленного репозитория]
```

**Что делает**

Получает изменения из переданного удаленного репозитория. Если не было передано ни одного удаленного репозитория, ни ключа **--all**, команда пытается получить изменения из репозитория с именем **origin**.


#### Получение изменений из удаленного репозитория. Команда git pull

**Формат**

```
git pull [ключи] [имя удаленного репозитория]
```

**Что делает**

Получает изменения из переданного удаленного репозитория и обновляет рабочую копию в соответствии с удаленным репозиторием. По умолчанию слияние удаленной ветки с локальной происходит именно в **fast-forward** режиме, так что включать его специально не требуется

Команда **git pull** это просто сокращение последовательного применения **git fetch** и **git merge**.

#### Отправка изменений в удаленный репозиторий. Команда git push

**Формат**

```
git push [ключи] [имя удаленного репозитория] [имя ветки]
```

**Ключи**

`--all ` - Пушит все имеющиеся ветки  
  
`-f, --force` - Перезаписывает удаленную ветку, вне зависимости от ее содержимого. Старайтесь не использовать этот флаг без крайней необходимости.  
  
`--force-with-lease` - Удаляет все коммиты, которых нет в локальном репозитории. Если коммит, который команда соберется удалять был создан другим пользователем, то выполнение закончится с ошибкой.

**Что делает**

Загружает изменения в удаленный репозиторий. Если слияние изменений в удаленном репозитории нельзя сделать в режиме **fast-forward**, и при этом не был передан ключ **force**, выполнение закончится с ошибкой.

#### GitHub. Работа с репозиторием, создание форков и пулл-реквестов

GitHub – это, наверное, самый популярный сервис бесплатного хостинга удаленных репозиториев с множеством дополнительных функций. Среди них есть, например, создание **issue** – запросов, в которых можно сообщить разработчикам об ошибках, создание репозиториев-форков и пулл-реквестов. Кроме того, на GitHub можно подписаться на обновления какого-то конкретного пользователя или включить отслеживание репозитория вашего любимого проекта. Все это превращает GitHub в настоящую социальную сеть для разработчиков по всему миру.

**Создание репозитория на GitHub**  

Прежде всего вам необходимо зарегистрироваться на GitHub, но это довольно тривиальный процесс, так что его мы здесь опустим. После регистрации вы попадете на главную страницу. На ней будут отображаться действия людей, на которых вы подписались и обновления в репозиториях, которые вы добавили в избранное.  
  
Чтобы создать свой репозиторий, нажмите на зеленую кнопку **New**, как показано на рисунке.
![[Pasted image 20230721103414.png]]
Перед вами откроется страница создания репозитория. Давайте разберем, что за **поля** нам предлагают заполнить.  
  

1. Итак, первое поле **Repository name** – имя репозитория. Здесь все просто, вам нужно придумать имя, которое будет отображаться на странице вашего репозитория. Здесь нет никаких ограничений, но старайтесь давать как можно более содержательные имена своим репозиториям.
2. Второе поле – **Description** – описание. Его заполнять необязательно. Но другим пользователям, которые попали на страницу вашего репозитория, будет проще понять, что перед ними, если вы заполните графу описания.
3. Затем вы можете выбрать, будет ли репозиторий открытым, то есть доступным абсолютно всем пользователям GitHub, или закрытым, то есть доступным только вам и людям, которым вы предоставите доступ.
4. Последние три поля предлагают нам добавить, соответственно, **README-файл**, **.gitignore** файл и выбрать лицензию для нашего проекта.

  
После заполнения полей страница выглядит примерно так.
![[Pasted image 20230721103439.png]]
Завершим процесс создания репозитория, нажав кнопку **Create repository**.

После создания репозитория, мы попадем на его страницу на GitHub. В нашем случае эта страница будет выглядеть так.

![[Pasted image 20230721103518.png]]
Как видно из рисунка, GitHub автоматически создал первый коммит, добавив в него файл **.gitignore** и файл **README**.  
  
Кстати, можно заметить, что содержимое файла **README** выводится под рабочей копией репозитория. Это одна из особенностей GitHub. Вы в любое время можете создать файл с именем **README.md** и запушить его в свой удаленный репозиторий на GitHub. Тогда содержимое этого файла будет отображаться прямо на странице вашего репозитория.  
  
В верхнем меню мы видим **9 разных вкладок**. Давайте разберем их по порядку.  
  
1. Вкладка **Code**. Сейчас открыта именно она. В ней содержится рабочая копия нашего репозитория (по центру), описание (справа), вывод файла **README** (под рабочей копией), история коммитов, а также кнопки для клонирования репозитория и просмотра файлов.  
2. Вкладка **Issues**. В этой вкладке будут отображаться все запросы, сделанные другими пользователями. Как правило, пользователи используют запрос, чтобы сообщить о найденном баге, либо чтобы задать какой-то вопрос о вашем приложении.  
3. Вкладка **Pull-requests**. На этой вкладке будут отображаться все пулл-реквесты, сделанные другими пользователями. О том, что такое пулл-реквесты, мы поговорим ниже.  
4. Вкладки **Actions** и **Project** относятся скорее к системе **CI/CDI**, которую предоставляет GitHub, в этом курсе мы не будем затрагивать их.  
5. Вкладка **Wiki** открывает вам доступ к созданию и размещению документации о собственном проекте.  
6. На вкладке **Security** содержатся различные настройки безопасности вашего проекта. Там же можно включить инспекцию вашего кода, чтобы узнать, если вы случайно загрузите какой-нибудь секретный токен на GitHub.  
7. Вкладка **Insight** содержит различную информацию и статистические данные об активности репозитория. Там вы сможете посмотреть на зависимость количества коммитов в репозитории от времени или на процент коммитов, сделанных вами.  
8. Последняя вкладка – **Settings**. В ней находятся различные настройки вашего репозитория. Там вы можете поменять видимость репозитория, сделав его частным, или вовсе удалить репозиторий.

#### Создание форка репозитория на GitHub. Пулл-реквесты.

> **Форк** (от англ. **fork** – вилка) – точная копия репозитория, но в вашем аккаунте. Форки нужны, чтобы вносить свои изменения в проект, к репозиторию которого у вас нет прямого доступа.

> **Пулл-реквест** (от англ. **pull-request** – запрос **pull**) – функция GitHub, позволяющая попросить владельца репозитория, от которого мы сделали форк, загрузить наши изменения обратно в свой репозиторий.

Если коротко, форки и пулл-реквесты нужны, чтобы любой пользователь мог внести свой вклад в любой открытый проект, репозиторий которого есть на GitHub. Кроме того, перед тем как влить ваши изменения в основной репозиторий, ответственные обязательно проверят ваш код на наличие ошибок и уязвимостей. Таким образом, даже если ваши изменения не примут, вы получите первоклассный **code-review** с указанием всех неточностей.  
  
Теперь давайте рассмотрим **пайплайн контрибуции** (англ. **contribution** – внесение вклада) на примере реального репозитория. То есть научимся вносить свой вклад в разработку проектов с открытым исходным кодом на GitHub.  
  
1. Для начала зайдем на страницу репозитория проекта. Нажимаем на кнопку **Fork**, как показано на картинке. После этого Git создаст точную копию этого репозитория в вашем аккаунте.
![[Pasted image 20230721103724.png]]
![[Pasted image 20230721103740.png]]
2. Клонируем репозиторий к себе на компьютер командой **git clone**. Создадим файл **README.md** с описанием проекта, чтобы другим пользователям было понятно, в чем отличие этой реализации от остальных.  
  
3. Сделаем коммит и выполним **git push**, чтобы загрузить наши изменения в удаленный репозиторий.  
  
4. Теперь GitHub подсказывает нам, что наша ветка опережает ветку исходного репозитория на один коммит и предлагает сделать пулл-реквест.

![[Pasted image 20230721103805.png]]
5. Нажимаем на кнопку **Compare** на подсказке GitHub, либо переходим на вкладку **Pull Requests** и нажимаем **New pull request**.

![[Pasted image 20230721103832.png]]
6. Перед нами откроется страница создания пулл-реквеста.

![[Pasted image 20230721103848.png]]
Здесь мы можем просмотреть внесенные изменения и выбрать две ветки: одну в исходном репозитории, на нее будут залиты наши изменения, вторую – в нашем репозитории, с нее будут скачаны изменения. Как только мы выбрали ветки и убедились, что не внесли никаких лишних изменений, нажимаем кнопку **Create pull request**.  
  
7. Теперь мы попадаем на страницу описания наших изменений.

![[Pasted image 20230721103919.png]]
Здесь необходимо описать, что за изменения вы внесли и почему они были необходимы. Сообщение, которое оставили мы, видно на картинке. Оно отражает суть и необходимость внесенных изменений. Как только мы закончили с описанием, можно нажимать кнопку **Create pull request**.  
  
8. Теперь мы попадаем на страницу уже созданного пулл-реквеста в изначальном репозитоии. В нашем случае он выглядит так.

![[Pasted image 20230721103944.png]]
Именно так будет выглядеть наш пулл-реквест и для владельца репозитория. На этой странице он сможет писать комментарии, указывая на ошибки или задавая вопросы. После того, как владелец репозитория просмотрит наши изменения и убедится, что они не имеют вредоносный характер, он сможет принять наш пулл-реквест. Тогда все изменения, добавленные в этот пулл-реквест нами, будут залиты в исходный репозиторий.

### 1.20 Модель ветвления Git

**Центральный репозиторий**  

Итак, основой нашей модели будет центральный репозиторий. Строго говоря, в Git не может быть никаких центральный репозиториев, поскольку это распределенная система контроля версий. Поэтому центральный репозиторий является таковым только с точки зрения логики его использования, с технической же точки зрения – это точно такой же репозиторий, как и все остальные. У каждого из разработчиков в команде есть копия основного репозитория. Схематически ситуация выглядит так.
![[Pasted image 20230721104138.png]]

Центральный репозиторий на картинке назван **origin**. Как мы уже упоминали выше, это одно из общепринятых наименований в Git.  
  
Процесс разработки построен на том, что каждый разработчик пушит свой код в основной репозиторий и пуллит код других разработчиков из него. Кроме того, допускаются ситуации, когда разработчики обмениваются кодом друг с другом, – минуя центральный репозиторий. Необходимость такого обмена может возникнуть, когда, например, два девелопера работают над одной функцией. В таком случае им необходим код друг друга, но пушить не готовую функцию в основной репозиторий ни один из них не может. Взаимодействие между разработчиками и основным репозиторием изображены на картинке выше с помощью стрелок.

**Основные ветки**  

В нашей модели существуют **две главные ветки**:  

1. **main** – ветка, в которой содержится только код, готовый к релизу.
2. **develop** – ветка, в которой содержатся изменения, готовые ко включению в последующий релиз.

Эти ветви называются главными, поскольку существуют в центральном репозитории и всех его копиях все время. Логика работы с ними не предполагает их удаления после выпуска очередного релиза, в отличие от, например, вспомогательных ветвей группы **release**.  
  
Как только в ветке **develop** появляется достаточно изменений для создания нового релиза, она вливается в ветку **main** (напрямую или посредством создания специальной ветки **release-***, о которой мы поговорим позже). После чего соответствующий коммит слияния в ветке **main** помечается тегом с указанием версии релиза (напомним, что тег – это статический указатель, нужный для удобства переключения между коммитами).  
  
Таким образом, коммит в ветке origin/main означает выпуск **нового релиза**. Кстати, если строго придерживаться этого правила, можно организовать непрерывную интеграцию при помощи как встроенных средств GitHub, так и сторонних инструментов, специализирующихся на **CI/CD**.

**Вспомогательные ветки**  

Чтобы поддерживать независимость разработки отдельных частей проекта, наша модель включает в себя несколько групп вспомогательных ветвей. Главное отличие таких ветвей от главных в том, что срок жизни этих ветвей ограничен. После завершения выполнения определенной работы, вспомогательная ветвь вливается в одну из главных, после чего удаляется.  
  
Наша модель предполагает существование следующих групп вспомогательных ветвей:  

1. Ветви для разработки новых функций. Они же **feature branches**.
2. Ветви релизов, то есть **release branches**.
3. Ветви срочных исправлений – **hotfix branches**.

Чуть ниже мы разберем предназначение каждой группы. Кроме того, мы договоримся о правилах создания, именования и слияния ветвей из каждой группы. Конечно, Git не ограничивает ни в именах ветвей, ни в чем либо другом, – эти условности мы придумываем сами. Тем не менее, такие правила необходимы для облегчения взаимодействия нескольких разработчиков внутри одного большого проекта.

**Feature-ветки**  

Могут порождаться от: **develop**  
Могут вливаться в: **develop**  
Правило именования: любое имя, кроме **main**, **develop**, **release-***, **hotfix-***.  
  
Ветки функциональности используются для разработки новых функций, для которых неизвестно: будут ли они добавлены в ближайший релиз или же в какой-то более поздний. Основной смысл такой ветки в том, что живет она ровно столько, сколько продолжается разработка функции, для которой была создана эта ветка. В это время в ветке main могут выходить релизы, не затрагивающие разрабатываемую функцию. По завершении создания функции, такая ветка либо вливается в ветку develop, либо удаляется, если эксперимент с новой функцией не удался.  
  
Feature-ветки существуют в основном только в репозиториях разработчиков, но могут на некоторое время появиться и в центральном репозитории.  
  
Графически взаимодействие разработчика с feature-веткой выглядит примерно так:
![[Pasted image 20230721104316.png]]
Создать **feature-ветку** можно следующим образом:

```Git
# Переключимся на главную ветвь develop 
git checkout develop 
# Создадим feature-ветку 
git checkout -b new-feature
```

После завершения работы над функцией, вы можете выполнить слияние и **Push**:

```Git
# Переключимся на главную ветвь develop
git checkout develop
# Сольем нашу feature-ветку явным образом
git merge --no-ff new-feature
# Удалим нашу feature-ветку
git branch -d new-feature
# Выполним пуш изменений в основной репозиторий
git push origin develop
```

**Release-ветки**  

Могут порождаться от: **develop**  
Могут вливаться в: **develop**, **main**  
Правило именования: **release-***  
  
Ветки релизов необходимы для подготовки к выпуску новых релизов вашего продукта. Их главное назначение – внести финальные штрихи перед выпуском новой версии. В этих ветках можно вносить небольшие изменения и подготавливать файлы с метаданными о версии вашего продукта. **Release-ветку** следует создавать в тот момент, когда ваш проект готов или почти готов к выпуску очередной версии. По крайней мере не раньше, чем вся функциональность, предназначенная к выходу в этом релизе, будет влита в ветку **develop**.  
  
Решение о номере версии релиза принимается только после создания release-ветки и опирается на принятые в компании правила нумерации версий. До тех пор неясно, будет ли новый релиз иметь **версию 4.1.5, 4.2** или **5.0**. Создать **release-ветку** можно следующим образом.

```Git
# Переключимся на главную ветвь develop
git checkout develop
# Создадим release-ветку
git checkout -b release-4.2
```

Заметьте, мы приняли решение, что новая версия будет иметь номер **4.2**, а потому создали ветку с именем **release-4.2**. Работая в этой ветке, мы можем исправить незначительные ошибки и внести метаинформацию о версии проекта в соответствующие файлы. Обратите внимание, что на этой ветви запрещено вносить какие-то крупные изменения или исправлять серьезные ошибки, ее предназначение не в этом.  
  
Как только все файлы вашего проекта будут готовы к выпуску релиза, данную ветвь можно слить в основную ветку **main**, что и будет соответствовать выпуску релиза. После чего нужно пометить релиз соответствующим тегом, чтобы впоследствии к нему было проще обращаться. Важно не забыть слить изменения с **release-ветки** в ветку **develop**, чтобы вернуть наши незначительные изменения в процесс разработки следующего релиза.

```Git
# Переключимся на основную ветвь main
git checkout main
# Сольем в нее нашу release-ветку
git merge --no-ff release-4.2
# Присвоим коммиту тег
git tag -a v4.2
# Переключимся на основную ветку develop
git checkout develop
# Сольем в нее нашу release-ветку, чтобы вернуть внесенные изменения в разработку
git merge --no-ff release-1.2
# Теперь можно удалить release-ветку
git branch -d release-1.2
```

**Hotfix-ветки**  

Могут порождаться от: **main**  
Могут вливаться в: **develop**, **main**  
Правило именования: **hotfix-***  
  
Ветки срочных исправлений или **hotfix-ветки**, нужны для внесения срочных исправлений в уже вышедший релиз. Такую ветку необходимо создать в ситуации, когда в недавно вышедшем релизе был обнаружен серьезный баг. Предназначение этой ветки – исправить ошибку в последнем вышедшем релизе, а затем выпустить новый релиз, слив ветку **hotfix** в **main** и **develop**. Смысл создания отдельной ветки в том, что работа большей части команды может продолжаться над выходом нового стабильного релиза на ветке develop, пока **bugfix-команда** работает над исправлением ошибки в последнем релизе в ветке **hotfix**.  
  
Чтобы создать **hotfix-ветку**, выполните:

```Git
# Переключимся на главную ветвь main
git checkout main
# Создадим hotfix-ветку для последнего релиза
git checkout -b hotfix-4.2.1
```

Последний релиз имеет номер **4.2**, поэтому мы приняли решение, что релиз с исправлением бага в релизе **4.2** будет иметь версию **4.2.1**.  
  
После внесения всех необходимых исправлений, нужно слить **hotfix-ветку** в ветку **main**, чтобы выпустить новый релиз, и в ветку **develop**, чтобы наши изменения сохранились в следующем релизе. Сделаем это.

```Git
# Переключимся на основную ветвь main
git checkout main
# Сольем в нее нашу hotfix-ветку
git merge --no-ff hotfix-4.2.1
# Присвоим коммиту тег
git tag -a v4.2.1
# Переключимся на основную ветку develop
git checkout develop
# Сольем в нее нашу hotfix-ветку, чтобы сохранить исправление бага в следующем релизе 
git merge --no-ff hotfix-4.2.1
# Теперь можно удалить hotfix-ветку
git branch -d hotfix-4.2.1
```


### 1.21 Практика

Дан проект:

```
wild_animals
  ├── index.html
  └── pictures
    ├── elephant.jpg
    ├── giraffe.jpg
    └── paw_print.jpg
```

Инициализируем репозиторий

```Git
git init

Initialized empty Git repository in C:/Users/<path_to_project>/.git/
```

Убеждаемся, что появилась папка `.git`

```Shell
ls .git/ -Flah
total 11K
drwxr-xr-x 1 User 1049089   0 Jul 20 11:14 ./
drwxr-xr-x 1 User 1049089   0 Jul 20 11:11 ../
-rw-r--r-- 1 User 1049089  23 Jul 20 11:11 HEAD
-rw-r--r-- 1 User 1049089 184 Jul 20 11:14 config
-rw-r--r-- 1 User 1049089  73 Jul 20 11:11 description
drwxr-xr-x 1 User 1049089   0 Jul 20 11:11 hooks/
drwxr-xr-x 1 User 1049089   0 Jul 20 11:11 info/
drwxr-xr-x 1 User 1049089   0 Jul 20 11:11 objects/
drwxr-xr-x 1 User 1049089   0 Jul 20 11:11 refs/
```

Настраиваем пользователя Git на **уровне репозитория**:

```Git
git config user.name "Ale88andr"
git config user.email "ale88andr@gmail.com"
```

Убеждаемся, что настройки применились.
Содержимое файла конфигурации Git(`.git/config`) для текущего репозитория:

```Shell
cat .git/config
[core]
        repositoryformatversion = 0
        filemode = false
        bare = false
        logallrefupdates = true
        symlinks = false
        ignorecase = true
[user]
        name = Ale88andr
        email = ale88andr@gmail.com
```

Изучаем содержимое папки `.git/objects`

```Shell
ls -l .git/objects/
total 0
drwxr-xr-x 1 User 1049089 0 Jul 20 11:11 info/
drwxr-xr-x 1 User 1049089 0 Jul 20 11:11 pack/
```

Она, пока, не содержит никаких объектов, так же отсутствует файл индекса `.git/index`. указатель **HEAD** указывает на ветку `master`

```Shell
cat .git/HEAD
ref: refs/heads/master
```

**Делаем 1-й коммит**:

1. Делаем файлы папки **wild_animals** отслеживаемыми

```Git
git add .
```

 Появился файл индекса `.git/index` в который добавилась информация о файлах проекта, так же в папку с объектами `.git/objects` добавились новые объекты

```Shell
ls -l .git/objects/
total 0
drwxr-xr-x 1 User 1049089 0 Jul 20 11:35 9f/
drwxr-xr-x 1 User 1049089 0 Jul 20 11:35 ce/
drwxr-xr-x 1 User 1049089 0 Jul 20 11:35 e9/
drwxr-xr-x 1 User 1049089 0 Jul 20 11:35 eb/
drwxr-xr-x 1 User 1049089 0 Jul 20 11:11 info/
drwxr-xr-x 1 User 1049089 0 Jul 20 11:11 pack/
```

2. **Делаем коммит**

```Git
git commit -m "Initial commit"
[master (root-commit) a4431b0] Initial commit
 4 files changed, 36 insertions(+)
 create mode 100644 index.html
 create mode 100644 pictures/elephant.jpg
 create mode 100644 pictures/giraffe.jpg
 create mode 100644 pictures/paw_print.jpg
```

Создается коммит с хэшем: **a4431b0**, убеждаемся, что это действительно коммит:

```Git
git cat-file -t a4431b0
commit
```

В папке `.git/objects` добавился новые объекты, в т.ч. наш коммит `a4`:

```Shell
ls .git/objects/
58/  75/  9f/  a4/  ce/  e9/  eb/  info/  pack/
```

Смотрим его содержимое:

```Git
git cat-file -p a4431b0
tree 7510e930bcaf31b167f126b6319409671d7585e4
author Ale88andr <ale88andr@gmail.com> 1689842592 +0300
committer Ale88andr <ale88andr@gmail.com> 1689842592 +0300

Initial commit
```

**Делаем второй коммит**

1. Исправляем опечатку в файле `index.html`
2. Добавляем изменения в индекс

```Git
git add index.html
```

3. Делаем коммит

```Git
git commit -m "add changes to index.html"
[master d440f25] add changes to index.html
 1 file changed, 1 insertion(+), 1 deletion(-)
```

### 1.15 Шпаргалка

`HEAD`   - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем.
`^`      - перемещение на один коммит назад
`~[num]` - перемещение на `[num]` коммитов назад

**Команды:**

`git --version` - Узнать версию git
`git config --global user.name "Mark Sicin"` - Устанавить имя пользователя
`git config --global user.email sicin.mark@example.com` - Установить почту пользователя

`git init` - Создать пустой репозиторий
`git init -b [branch]` - Создать пустой репозиторий с начальной веткой [branch]
`git clone https:// | git clone git://` - Клонировать существующий репозиторий

`git add text.txt` - Добавить файл в репозиторий
`git rm text.txt` - Удалить файл
`git status` - Информация о состояние файлов (изменения, неразрешенные конфликты и тд)
`git status -s` - Информация о состоянии файлов в коротком формате

`git log --oneline` - Посмотреть все коммиты в формате одной строки
`git log --graph` - Посмотеть все коммиты в формате графа

`git commit -a -m "Commit text"` - Сделать коммит с комментарием
`git commit --amend` -  Изменить комментарий коммита с помощью текстового редактора.
`git commit --amend -m "an updated commit message"` - Закоммитеть новый комментарий, не открывая текстовый редактор.
`git commit --amend --no-edit` - Внести изменения в коммит без изменения комментария к нему

`git branch [branch]` - Создать новую ветку
`git branch -f [branch] HEAD~[num]` - Переместить ветку `[branch]` на `[num]` коммитов назад, относительно текущего выбранного коммита
`git branch -f [branch] HEAD^` - Переместить ветку `[branch]` на один коммитов назад, относительно текущего выбранного коммита
`git branch -f [branch] [branch1]^` - Переместить ветку `[branch]` на один коммитов назад, относительно ветки `[branch1]`
`git branch -u [remote_branch]` - Указать текущей ветке отслеживать удалённую ветку `[remote_branch]`

`git checkout [branch]` - Переключиться на ветку `[branch]` (HEAD указывает на коммит, на который указывает `[branch]`)
`git checkout [commit]` - Переключиться на определенный коммит (HEAD указывает на выбранный коммит)
`git checkout -b [branch]` - Создать ветку указывающую на текущем коммите и переключиться на нее
`git checkout -b [branch1]` `[branch2]` - Создать ветку `[branch1]` указывающую на ветку `[branch2]` и переключиться на нее
`git checkout [branch]^` - Переключиться на один коммит назад, относительно коммита на который указывает `[branch]`
`git checkout [branch]~[num]` - Переключиться на `[num]` коммитов назад, относительно коммита на который указывает `[branch]`
`git checkout HEAD^` - Переключиться на один коммит назад, относительно текущего выбраного коммита
`git checkout HEAD~[num]` - Переключиться на `[num]` коммитов назад, относительно текущего выбраного коммита

`git merge [branch]` - Смерждить ветку [branch] c текущей
`git rebase [branch]` - Копирует набор коммитов из текущей ветки и переносит их в [branch].
`git rebase [branch] [branch1]` - Копирует коммиты из ветки [branch1] в ветку [branch].
	Отличия rebase и merge в том, что c его помощью можно делать чистые и красивые          линейные последовательности коммитов. История коммитов будет чище
`git rebase -i [branch]` - Интерактивный rebase. Git откроет интерфейс просмотра того,        какие коммиты готовы к копированию. Также показываются хеши коммитов и комментарии      к ним, так что можно легко понять что к чему.
	После открытия окна интерактивного rebase есть три варианта для каждого коммита:
		- Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе
		- Можно "выкинуть" коммит из ребейза.
		- Наконец, можно соединить коммиты. При помощи этой функции можно объединять изменения двух коммитов.
`git cherry-pick [commit1] [commit2] [...]` - Копирование нескольких коммитов на место, где сейчас находишься (HEAD)

`git reset HEAD^` - Отменяет изменения, перенося ссылку на один коммит назад (удаляет все ненужные коммиты)
`git reset [branch]~[num]` - Отменяет изменения, перенося ссылку на `[num]` коммитов назад (удаляет все ненужные коммиты)
`git reset --soft [commit]` - Отменяет изменения, оставляя все измененные файлы (удаляет все ненужные коммиты)
`git reset --hard [commit]` - Отменяет изменения, удаляя все измененные файлы (удаляет все ненужные коммиты)
`git revert [branch] | [commit] | HEAD` - Создается новый коммит. Новый коммит содержит изменения, полностью противоположные тем, что сделаны в коммите (`[branch] | [commit] | HEAD`). Коммит (`[branch] | [commit] | HEAD`), который мы хотим отменить останется в дереве коммитов для истории, но все действия, которые были в нем сделаны, будут отменены новосозданым коммитом.

`git tag [tag] | [branch] | [commit]` - Создать постоянный тег, который ссылается на конкретный коммит. Теги являются прекрасными ориентирами в истории изменений

`git fetch` - Забирает все-все данные из всех веток в ваш локальный репозиторий, но не мерджит их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент
`git fetch origin [remote_branch] `- Забирает данные из ветки` [remote_branch] `удаленного репозитория
`git fetch origin [remote_branch]:[branch]` - Забрать данные из ветки `[remote_branch]` удаленного репозитория и помещает в ветку `[branch]` в вашем локальном репозитории
`git fetch origin :[branch]` - Создает ветку [branch] в локальном репозитории
`git pull` - Забирает данные в ваш локальный репозиторий и мерджит с вашими наработками
`git pull --rebase` - Забирает данные в ваш локальный репозиторий и ребейзит комиты
`git pull origin [remote_branch]` - Забирает данные из ветки [remote_branch] удаленного репозитория и мерджит эти данные с текущей веткой
`git pull origin [remote_branch]:[branch]` - Забирает данные из ветки `[remote_branch]` удаленного репозитория, помещает данные в `[branch]` (если не существует git создает) локального репозитория и мерджит данные с текущей веткой

`git push origin` - Загрузка ваших изменений в указанный удалённый репозиторий
`git push -u origin [branch]` - Загрузка данных, с связыванием текущей ветки с веткой `[branch]` в удаленном репозитории. Если `[branch]` не существует, git ее создаст
`git push origin [branch]:[remote_branch]` - Запушить коммиты из ветки `[branch]` в ветку `[remote_branch]` на удаленном репохитории, если ветка `[remote_branch]` не существует, git ее создаст
`git push origin :[remote_branch]` - Удаляет ветку `[remote_branch]` из удаленного репозитория
`git push origin +[remove_branch]` - Принудительно отправить изменения в ветку `[remote_branch]` удаленного репозитория. Безопаснее использовать +`[remote_branch]`, чем `git push -f`

# 2. Linux

### 2.1 Общие сведения

**Linux** - представители семейства Unix-подобных операционных систем на общем ядре.

История Linux:
1.       1971 - Unix, Bell Labs: Кен Томпсон, Деннис Ритчи
2.       1983 - GNU, Ричард Столлман
3.       1991 - Linux, Линус Торвальдс

Слои Linux:
-        Hardware (железо)
-        Kernel (ядро)
-        Userspace (рабочее окружение)

![[Pasted image 20230711120319.png]]

#### Ядро
Одной из задач ядра является **распределение памяти** на несколько подразделов, после чего ядро должно постоянно содержать в порядке информацию о состоянии этих подразделов. Каждый процесс использует выделенную для него область памяти, и ядро должно гарантировать то, что процессы придерживаются своих областей.

Ядро отвечает за управление задачами в четырех основных областях системы.
- **Процессы**. Ядро отвечает за то, каким процессам разрешен доступ к центральному процессору. Управление процессами описывает запуск, остановку, возобновление и прекращение работы процессов.
- **Память**. Ядру необходимо отслеживать состояние всей памяти: какая часть в данный момент отведена под определенные процессы, что можно выделить для совместного использования процессами и какая часть свободна.
- **Драйверы устройств**. Ядро выступает в качестве интерфейса между аппаратными средствами (например, жестким диском) и процессами. Как правило, управление аппаратными средствами выполняется ядром.
- **Системные вызовы и поддержка**. Обычно процессы используют системные вызовы для взаимодействия с ядром.

Волшебные директории: Filesystem Hierarchy Standard
-        `/bin` - основные утилиты необходимые в работе
-        `/usr` - пользовательские утилиты
-        `/tmp` - временные файлы
-        `/etc` - файлы конфигурации системы
-        `/home` - файлы пользователя

### 2.2. Пользователи и группы

1.       Каждому пользователю и группе можно выделять свои разрешения: что ему можно, что ему нельзя
2.       Каждому пользователю можно выдавать "свои" места в файловой системе, где будут жить его данные
3.       Данная функция является основой системы безопасности и краеугольным камнем всей системы

Создание пользователей и групп
-        `groupadd <newgroup>` - создаст новую группу `newgroup`
-        `useradd -G <newgroup> -p password <newuser>` -создаст нового пользователя `newuser` с паролем password в группе `newgroup`

### 2.3. Режимы файлов и права доступа

Каждый файл системы Unix обладает *набором прав доступа*, которые определяют, можете ли вы читать, записывать или запускать данный файл. Команда `ls -l` отображает эти права доступа. Вот пример такой информации:

```Shell
-rw-r--r-- l juser somegroup 7041 Mar 26 19:34 endnotes.html
```

Режим файла `-rw-r--r--` представляет права доступа и некоторые дополнительные сведения. Режим состоит из четырех частей.

![[Pasted image 20230711125938.png]]

**- rw- r-- r-- = 644**

1.       `-` обозначает файл, `d` обозначал бы папку
2.       `rw-` обозначает, что владелец (_username_) может читать и писать = 6
3.       `r-` обозначает, что группа (_groupname_) может читать = 4
4.       `r-` обозначает, что другие пользователи могут читать = 4

Права доступа пользователя (первый набор символов) относятся к пользователю, который является владельцем файла. В приведенном выше примере это `juser`. Второй набор символов относится к группе (в данном случае `somegroup`). Любой пользователь из этой группы обладает указанными правами доступа. В третьем наборе (другие права доступа) указано, кто еще будет обладать в системе правами доступа. Их часто называют правами доступа для всех.

![[Pasted image 20230711113622.png]]

![[Pasted image 20230711113632.png]]

#### Изменение прав доступа

Чтобы изменить права доступа, используйте команду `chmod`

```Shell
chmod go+r file
```

Чтобы удалить эти права доступа, используйте `go-r` вместо `go+r`

Иногда пользователи меняют права доступа, указывая числа, например, так:

```Shell
chmod 644 file
```

Такой способ называется *абсолютным изменением*, поскольку при нем сразу же устанавливаются все биты прав доступа.

| **Режим** | **Значение** |  **Применение**  |
|--|--|--|
| 644 | пользователь: чтение/запись;группа, другие: чтение | Файлы |
| 600 | пользователь: чтение/запись;группа, другие: нет | Файлы |
| 755 | пользователь: чтение/запись/исполнение;группа, другие: чтение/исполнение | Каталоги, команды |
| 700 | пользователь: чтение/запись/исполнение;группа, другие: нет | Каталоги, команды |
| 711 | пользователь: чтение/запись/исполнение;группа, другие: исполнение | Каталоги |

Назначить владельца файлу\\папке:

```Shell
chown <username>:<groupname> my-name.txt
```

#### Запуск команд с правами пользователя superuser

В большинстве дистрибутивов применяется пакет `sudo`, который позволяет администраторам запускать команды в режиме root, зайдя в систему со своей учетной записью.

```Shell
sudo vipw
```

**Файл /etc/sudoers**

Система не позволит любому пользователю запускать команды в качестве пользователя superuser. Вы должны настроить права таких привилегированных пользователей в файле `/etc/sudoers`.

приведенный ниже фрагмент позволяет пользователям user1 и user2 запускать любую команду в качестве корневого пользователя, не вводя при этом пароль:

```Shell
User_Alias ADMINS = user1, user2
ADMINS ALL = NOPASSWD: ALL
root ALL=(ALL) ALL
```

### 2.3. SH

Формы обращения к переменным
-        `$VAR` - может быть опасным
-        `"$VAR"` - правильный вариант, если ничего нет после VAR
-        `"${VAR}"` - правильный вариант, если VAR внутри другой строки
-        `'$VAR'` - просто строка

If
![[Pasted image 20230711114802.png]]

**Сравнения**
-        `s1 = s2` - идентичны ли два значения?
-        `s1 != s2` - не идентичны?
-        `s1 -eq s2 `- алгебраическое равенство
-        `s1 -ne s2` - алгебраическое неравество

**Специальные условия**
-        `[ -f` - существует ли файл
-        `[ -d` - существует ли директория
-        `[ -n` - не ли пустая строка
-        `[ -z` - пустая ли строка

**Shebang** – это комментарий в начале файла, который означает некую мета-информацию о том как этот файл будет выполняться.

```
#!/usr/bin/env sh
```

**Циклы**

While
![[Pasted image 20230711115022.png]]

For
![[Pasted image 20230711115046.png]]

Функции
![[Pasted image 20230711115100.png]]

Функции c аргументами
![[Pasted image 20230711115114.png]]

### 2.4. Основные команды и структура каталогов

**Оболочка Bourne shell: /bin/sh**

**Оболочка** — это программа, запускающая команды

Многие важные части системы в действительности являются сценариями оболочки — текстовыми файлами, которые содержат последовательность команд оболочки.

Существуют различные варианты оболочки Unix, но все они заимствуют некоторые функции от оболочки Bourne shell (/bin/sh) — стандартной оболочки, разработанной в компании Bell Labs для ранних версий системы Unix.

Команда `cat` - выводит содержимое одного или нескольких файлов. Эта команда названа так, поскольку она выполняет конкатенацию (сцепление) содержимого файлов, если выводится более одного файла.

```Shell
cat file1 file2 ...
```

Команда `ls` - выводит перечень содержимого какого-либо каталога. По умолчанию это текущий каталог. Используйте вариант `ls -l`, чтобы получить детализированный (длинный) список, или `ls –F`, чтобы отобразить информацию о типах файлов.

```Shell
ls -l
```

Команда `cp` - копирует файлы.

```Shell
cp file1 file2
```

Команда `mv` - переименовывает файл

```Shell
mv file1 file2
```

Команда `touch` - создает файл. Если такой файл уже существует, команда touch не изменяет его, но обновляет информацию о времени изменения файла.

```Shell
touch file
```

Команда `rm` - удаляет файл.

```Shell
rm file
```

Команда `echo` - выводит свои аргументы в стандартный вывод. Команда `echo` весьма полезна для раскрытия значений паттернов оболочки, использующих джокерные символы вроде `*`, и переменных, таких как `$HOME`

```Shell
echo Hello again.
Hello again.
```

Команда `cd` - изменяет текущий рабочий каталог оболочки.

```Shell
cd dir
```

Команда `mkdir` создает новый каталог с именем `dir`

```Shell
mkdir dir
```

Команда `rmdir` удаляет каталог с именем `dir`

```Shell
rmdir dir
```

Команда `grep` - выдает строки из файла или входного потока, которые соответствуют какому-либо выражению. Команда grep чрезвычайно удобна, когда приходится работать одновременно с множеством файлов, поскольку она выдает название файла в дополнение к найденной строке. Двумя наиболее важными параметрами команды grep являются `–i` (для соответствий, нечувствительных к регистру символов) и `–v` (который инвертирует условие поиска, то есть выдает все строки, не отвечающие условию).

```Shell
grep root /etc/*
```

Команда `less` - разбивает содержимое файла на части и умещающееся в пределах одного экрана.

```Shell
less /usr/share/dict/words
```

пример отправки результатов команды grep в команду less

```Shell
grep ie /usr/share/dict/words | less
```

Команда `pwd `- выводит название текущего рабочего каталога

```Shell
pwd
```

Команда `diff` - позволяет увидеть различия между двумя текстовыми файлами

```Shell
diff file1 file2
```

Команда `file` - автоматически определяет тип файла

```Shell
file some_file
```

Команды `head` (отобразит первые десять строк файла) и `tail` (заключительные десять строк) - просмотреть фрагмент файла или потока данных

#### Переменные окружения и оболочки

Оболочка может хранить временные переменные, которые называются переменными оболочки и содержат значения текстовых строк. Переменные оболочки весьма полезны для отслеживания значений в сценариях.

Чтобы присвоить значение переменной оболочки, используйте знак равенства (=).

```Shell
STUFF=blah
```

В этом примере переменной с именем `STUFF` присваивается значение `blah`. Чтобы обратиться к этой переменной, применяйте синтаксис `$STUFF`

```Shell
$STUFF
```

Переменная окружения подобна переменной оболочки, но она не является привязанной к оболочке. Все процессы в системах Unix пользуются хранилищем переменных окружения. Основное отличие переменных окружения от переменных оболочки заключается в том, что операционная система передает все переменные окружения вашей оболочки командам, запускаемым оболочкой, в то время как переменные оболочки не могут быть доступны командам, которые вы запускаете.

Если, например, вы желаете сделать переменную оболочки $STUFF переменной окружения, используйте следующий синтаксис:

```Shell
STUFF=blah
export STUFF
```

#### Командный путь

`PATH` является специальной переменной окружения, которая содержит командный путь, или просто путь. **Командный путь** — это перечень системных каталогов, которые просматривает оболочка, пытаясь найти какую-либо команду.

```Shell
echo $PATH
/usr/local/bin:/usr/bin:/bin
```

#### Ввод и вывод с помощью оболочки

Чтобы направить результат команды command в файл, а не в терминал, используйте символ перенаправления `>` :

```Shell
command > file
```

Оболочка создаст файл `file`, если его еще нет. Если такой файл существует, то оболочка сначала сотрет его (затрет данные).

Вы можете добавить выводимые данные к файлу вместо его перезаписи с помощью такого синтаксиса перенаправления `>>` :

```Shell
command >> file
```

#### Структура сообщений об ошибке в Unix

```Shell
ls /dsafsda
ls: cannot access /dsafsda: No such file or directory
```

Это сообщение состоит из трех частей.
- Название команды: ls. Некоторые команды опускают такую идентифицирующую информацию, и это может раздражать при написании сценариев оболочки, хотя, по сути, это не так уж и важно.
- Имя файла, /dsafsda, которое является более конкретной информацией. Указанный путь содержит ошибку.
- Сообщение об ошибке No such file or directory указывает на ошибку в имени файла.

#### Получение списка процессов и управление ими

**Процесс** — это работающая программа. Каждому процессу в системе присвоен числовой идентификатор процесса (**PID**). Чтобы быстро получить перечень работающих процессов, запустите команду `ps`.

```Shell
ps

PID TTY STAT TIME COMMAND
520 p0 S 0:00 -bash
545 ? S 3:59 /usr/X11R6/bin/ctwm -W
548 ? S 0:10 xclock -geometry -0-0
2159 pd SW 0:00 /usr/bin/vi lib/addresses
31956 p3 R 0:00 ps
```

Эти поля означают следующее.
- **PID** — идентификатор процесса.
- **TTY** — оконечное устройство, в котором запущен процесс (об этом подробнее чуть позже).
- **STAT** — статус процесса, а именно: что выполняет данный процесс и где расположена отведенная для него память. Например, символ S обозначает ждущий процесс, а символ R — работающий (описание всех символов можно найти на странице ps(1) в руководстве).
- **TIME** — количество времени центрального процессора в минутах и секундах, которое использовал данный процесс к настоящему моменту. Другими словами, это общее количество времени, потраченное процессом на выполнение инструкций в процессоре.
- **COMMAND** — поле может показаться очевидным, однако имейте в виду, что процесс может изменить исходное значение этого поля.

Команда ps обладает множеством параметров:

- `ps x` - Показать все процессы, запущенные вами
- `ps ax` - Показать все процессы системы, а не только те, владельцем которых являетесь вы
- `ps u` - Включить детализированную информацию о процессах
- `ps w` - Показать полные названия команд, а не только те, что помещаются в одной строке

#### Завершение процессов

Чтобы завершить процесс, отправьте ему сигнал с помощью команды `kill`. **Сигнал** — это сообщение процессу от ядра. Когда вы запускаете команду `kill`, вы просите ядро отправить сигнал другому процессу.

```Shell
kill pid
```

#### Фоновые процессы

Обычно при запуске из оболочки команды в системе Unix вы не увидите строки приглашения, пока команда не завершит работу. Тем не менее можно отделить процесс от оболочки и поместить его в «фон» с помощью символа амперсанда (`&`); после этого строка приглашения вернется.

```Shell
gunzip file.gz &
```

#### Символические ссылки

**Символическая ссылка** — это файл, который указывает на другой файл или каталог, создавая, по сути, псевдоним (подобно ярлыку в Windows). Символические ссылки обеспечивают быстрый доступ к малопонятным путям каталогов.

Чтобы создать символическую ссылку от цели `target` к имени ссылки `linkname`, воспользуйтесь командой `ln -s`:

```Shell
ln -s target linkname
```

Аргумент `linkname` является именем символической ссылки, аргумент `target` задает путь к файлу или каталогу, к которому ведет ссылка, а флаг `-s` определяет символическую ссылку.

#### Архивирование и сжатие файлов

Команда `gzip` (GNU Zip) - одна из стандартных команд сжатия файлов в системе Unix. Файл, имя которого оканчивается на `.gz`, является архивом в формате GNU Zip. Используйте команду `gunzip file.gz` для декомпрессии файла `<file>.gz` и удаления суффикса из названия; для сжатия применяйте команду `gzip file`.

Команда `tar`  - В отличие от программ сжатия в других операционных системах, команда `gzip` не создает архивы файлов, то есть она не упаковывает несколько файлов и каталогов в один файл. Для создания архива используйте команду tar:

```Shell
tar cvf archive.tar file1 file2 ...
```

Архивы, созданные с помощью команды tar, обычно снабжены суффиксом `.tar`
приведенном выше примере команды параметры `file1`, `file2` и т. д. являются именами файлов и каталогов, которые вы желаете упаковать в архив `<archive>.tar`. Флаг `c` активизирует режим создания.

Чтобы распаковать файл `.tar` с помощью команды `tar`, используйте флаг `x`:

```Shell
tar xvf archive.tar
```

**Сжатые архивы (.tar.gz)**

архивы обычно являются сжатыми, а их имена заканчиваются на `.tar.gz`. Чтобы распаковать сжатый архив, действуйте справа налево: сначала избавьтесь от суффикса `.gz`, а затем займитесь суффиксом` .tar`. Например, приведенные ниже команды производят декомпрессию и распаковку архива `<file>.tar.gz`:

```Shell
gunzip file.tar.gz
tar xvf file.tar
```

#### Основные сведения об иерархии каталогов Linux

![[Pasted image 20230711133530.png]]

Наиболее важные подкаталоги в корневом каталоге таковы.
- `/bin`. Содержит готовые к запуску команды (известные также как исполняемые файлы), включая большинство основных команд системы Unix, таких как `ls` и `cp`. Большинство команд в каталоге `/bin` представлено в двоичном формате, поскольку они созданы компилятором языка `C`, однако в современных системах некоторые команды являются сценариями оболочки.
- `/dev`. Содержит файлы устройств.
- `/etc`. Этот центральный каталог системной конфигурации содержит пароль пользователя, файлы загрузки, файлы устройств, сетевые настройки и другие параметры. Многие элементы каталога `/etc` зависят от аппаратного обеспечения. Например, каталог `/etc/X11` содержит конфигурацию видеокарты и «оконного» интерфейса.
- `/home`. Содержит личные каталоги обычных пользователей. В большинстве версий системы Unix соблюдается этот стандарт.
- `/lib`. Этот каталог содержит файлы библиотек, хранящие программный код, который может быть применен исполняемыми файлами. Существуют два типа библиотек: статические и используемые совместно. Каталог `/lib` должен содержать только библиотеки для совместного пользования. Другие каталоги библиотек, например `/usr/lib`, содержат оба типа, а также другие вспомогательные файлы.
- `/proc`. Этот каталог представляет системную статистику в виде интерфейса «каталог-файл». Основная часть структуры подкаталога `/proc` является уникальной для Linux, однако во многих других вариантах системы Unix присутствуют подобные функции. Каталог` /proc` содержит информацию о запущенных в данный момент процессах, а также о некоторых параметрах ядра.
- `/sys`. Данный каталог подобен каталогу `/proc` тем, что он предоставляет интерфейс устройствам и системе.
- `/sbin`. Здесь расположены системные исполняемые файлы. Команды из каталога `/sbin` относятся к управлению системой, поэтому у обычных пользователей, как правило, в командном пути не указаны компоненты каталога `/sbin`. Многие утилиты из этого каталога не будут работать, если вы запустите их не с правами корневого пользователя.
- `/tmp`. Хранилище для небольших временных файлов, о которых вам не стоит особо беспокоиться. Любой пользователь может выполнять чтение и запись в этом каталоге, однако доступ к файлам другого пользователя может быть запрещен.
- `/usr`. Хотя название этого каталога произносится как user, он не хранит никаких пользовательских файлов. Вместо этого содержит обширную иерархию каталогов, включающую основную часть системы Linux. Многие имена каталогов здесь такие же, как и в корневом каталоге (типа `/usr/bin` и `/usr/lib`), и содержат те же типы файлов. Причина, по которой корневой каталог не содержит систему полностью, главным образом историческая — в прошлом это было необходимо, чтобы корневой каталог не занимал много дискового пространства.
- `/var`. Изменяемый подкаталог, в котором команды хранят информацию во время исполнения. Системный журнал, отслеживание активности пользователей, кэш, а также другие файлы, которые создаются системными командами, расположены здесь. Вы увидите здесь каталог `/var/tmp`, но он не очищается при запуске системы.
- `/boot`. Содержит файлы загрузчика ядра. Эти файлы имеют отношение только к самой первой стадии запуска системы Linux.
- `/media`. Основная точка подключения для таких съемных устройств, как флеш-накопители. Присутствует во многих версиях системы.
- `/opt`. Здесь может находиться дополнительное ПО сторонних разработчиков. Многие версии системы не используют каталог `/opt`

![[Pasted image 20240116151220.png]]

#### Местоположение ядра

В системе Linux ядро обычно размещается в каталогах `/vmlinuz` или `/boot/vmlinuz`. Загрузчик системы загружает этот файл в память и приводит его в действие при запуске системы

После того как загрузчик запустит ядро и приведет его в действие, основной файл ядра больше не используется работающей системой. Тем не менее вы обнаружите множество модулей, которые ядро может по запросу загружать и выгружать во время нормального функционирования системы. Такие загружаемые модули ядра расположены в каталоге `/lib/modules`.

### 2.5. Как происходит загрузка ядра Linux

Упрощенная схема процесса загрузки выглядит так.

Процесс начинается, когда вы нажимаете кнопку питания, чтобы включить компьютер.
![[Pasted image 20231220175921.png]]
1. Сначала загружается программа под названием `BIOS` или `UEFI`.  По сути, это программы, которые подготавливают к работе все основные части вашего компьютера(клавиатура, экране, жестких дисках и так далее). `UEFI` — новейшая разработка, предлагающая более быструю загрузку и лучшие функции безопасности, такие как безопасная загрузка, по сравнению с традиционным `BIOS`. Одно из ключевых различий между `BIOS` и `UEFI` заключается в их подходе к дисковому хранилищу. `BIOS` привязан к системе **основной загрузочной записи** (`MBR`), которая ограничивает размер диска до 2 ТБ.  `UEFI`,с другой стороны, использует таблицу разделов `GUID` (`GPT`), устраняя эти ограничения размера и предлагая более гибкое и современное решение. 

| **BIOS** | **UEFI** |
|--|--|
|`BIOS` привязан к системе **основной загрузочной записи** (`MBR`), которая ограничивает размер диска до 2 ТБ| `UEFI`, использует таблицу разделов `GUID` (`GPT`), устраняя ограничения размера и предлагая более гибкое и современное решение. |
| Более медленная загрузка | Быстрая загрузка |
| Менее защищенный | Более защищенный |

![[Pasted image 20231221100222.png]]

2. Затем `BIOS` или `UEFI` запускает проверку ,называемую самотестированием при включении или `POST`. Этот тест позволяет убедиться, что все различные аппаратные компоненты работают правильно, прежде чем полностью все включить. Если `POST` обнаруживает проблему, на экране часто отображается сообщение об ошибке. Наконец, если с помощью `POST` все прошло успешно, `BIOS` или `UEFI` необходимо найти и загрузить программное обеспечение загрузчика. Порядок загрузки обычно настроен так, чтобы сначала проверять жесткий диск, а затем USB-накопители или компакт-диски, если на жестком диске ничего не обнаружено.  При желании вы можете настроить этот порядок в настройках `BIOS`. В системе `BIOS` код загрузчика находится в первом небольшом фрагменте жесткого диска, называемом основной загрузочной записью. Для `UEFI` существует отдельный раздел, в котором хранятся такие файлы, как файл загрузчика `.efi`.
![[Pasted image 20231221101346.png]]
![[Pasted image 20231221101436.png]]
3. Далее начинает работу загрузчик ОС. Ключевые задачи загрузчика: **найти и загрузить ядро ​​операционной в память компьютера**. Некоторые распространенные загрузчики — это `LILO` и `GRUB2`.  `LILO`, довольно устарел и редко используется в современных дистрибутивах. `GRUB2` — наиболее полнофункциональный и широко используемый на сегодняшний день.  Он может поддерживать загрузку нескольких операционных систем, прекрасно выглядит с графическими или текстовыми меню и имеет множество расширенных опций для опытных пользователей. Загрузчик системы отыскивает образ ядра на диске, загружает его в память и запускает.

5. После того, как загрузчик запускает ядро, оно берет на себя ресурсы компьютера и начинает инициировать все фоновые процессы и службы. Сначала он распаковывает себя в память, проверяет оборудование и загружает драйверы устройств и другие модули ядра. Ядро выполняет инициализацию устройств и их драйверов. Ядро монтирует корневую файловую систему.

6. Затем запускается первоначальный процесс под названием `init`, который в современных системах Linux обычно называется `Systemd`. `Systemd` заменил старые системы инициализации, такие как `SysVinit` и `Upstart`, и является родительским для всех других процессов в Linux.  У `Systemd` есть масса обязанностей по загрузке системы и ее готовности к использованию.  Он проверяет наличие оставшегося оборудования, для которого требуется загрузка драйверов. Он монтирует все ваши файловые системы и диски, чтобы они были доступны.  Он начинает запускать все необходимые вам фоновые службы, такие как сеть, звук, управление питанием. Он обрабатывает входы пользователей, как только вы попадаетев графическое приглашение.  И он загружает среду вашего рабочего стола панелями и меню. `Systemd` использует целевые файлы конфигурации, чтобы решить, в каком режиме ему следует загружаться — что-то базовое, например многопользовательский текстовый режим, или графический режим, который большинство из нас использует ежедневно.
![[Pasted image 20231221102113.png]]
![[Pasted image 20231221102212.png]]
#### Сообщения при запуске

Существуют два способа увидеть сообщения ядра о загрузке и оперативной диагностике:
- заглянуть в системный журнал ядра. Обычно он находится в файле `/var/log/kern.log`, но в зависимости от конфигурации вашей системы может также оказаться вместе с другими системными журналами в каталоге `/var/log/messages`
- воспользоваться командой `dmesg`

#### Параметры ядра

При запуске ядра Linux загрузчик передает ему набор текстовых параметров ядра, которые говорят ядру о том, как оно должно быть запущено. Параметры ядра при загрузке вашей системы можно увидеть в файле `/proc/cmdline`

```Shell
cat /proc/cmdline
BOOT_IMAGE=/boot/vmlinuz-3.2.0-67-generic-pae root=UUID=70ccd6e7-6ae6-44f6-
812c-51aab8036d29 ro quiet splash vt.handoff=7
```

Эти параметры являются либо простыми однословными флагами, вроде `ro` и `quiet`, либо парами `key=value`, например `vt.handoff=7`.

#### Как работает загрузчик GRUB

1. Система BIOS или прошивка ПК инициализирует аппаратные средства и выполняет поиск кода загрузки в устройствах хранения в указанной загрузочной последовательности.
2. Обнаружив код загрузки, система BIOS или прошивка загружают и исполняют его. Именно здесь в дело вступает загрузчик GRUB.
3. Загружается ядро загрузчика GRUB.
4. Происходит инициализация ядра. К этому моменту загрузчик GRUB получает доступ к дискам и файловым системам.
5. Загрузчик GRUB идентифицирует свой загрузочный раздел и загружает в него конфигурацию.
6. Загрузчик GRUB дает пользователю возможность изменить конфигурацию.
7. По истечении времени ожидания или после ответных действий пользователя загрузчик GRUB выполняет конфигурирование
8. В процессе конфигурирования загрузчик GRUB может загрузить дополнительный код (модули) в загрузочный раздел.
9. Загрузчик GRUB исполняет команду boot, чтобы загрузить и исполнить ядро, как определено командой linux в конфигурации.

#### Как запускается пространство пользователя

В общих чертах, пространство пользователя запускается следующим образом.
1. Команда `init`.
2. Важнейшие низкоуровневые службы, такие как `udevd` и `syslogd`.
3. Сетевая конфигурация.
4. Службы среднего и высокого уровня (крон, печать и т. д.).
5. Приглашение ко входу в систему, пользовательский интерфейс и другие приложения высокого уровня.

Команда `init` — это команда из пространства пользователя, подобная любой другой команде системы Linux. Ее можно найти в каталоге `/sbin` вместе с другими системными исполняемыми файлами. Основное назначение этой команды — запуск и останов важнейших служебных процессов системы, хотя новые версии обладают дополнительными возможностями.
В дистрибутивах Linux существует три основные реализации команды init.
- **System V init**. Обычная последовательная команда init (Sys V, обычно произносится sys-five). Версия Red Hat Enterprise Linux и некоторые другие используют этот вариант.
- **systemd**. Набирающий силу стандарт команды init. Во многих дистрибутивах осуществлен переход на команду systemd, а в тех, где это еще не сделано, такой переход планируется.
- **Upstart**. Команда init для версий Ubuntu. Тем не менее к моменту написания книги в Ubuntu также запланирован переход на команду systemd.

### 2.6. Представление о сети и ее конфигурации

![[Pasted image 20230712141829.png]]

Компьютер передает данные по сети в виде небольших порций, называемых **пакетами**. Они состоят из двух частей: **заголовка** и **полезной нагрузки**. Заголовок содержит такую идентифицирующую информацию, как хосты источника/назначения и основной протокол. С другой стороны, полезная нагрузка — это реальные данные, которые компьютер собирается передать (например, код HTML или изображение).

Топология *Интернета* децентрализована; эта сеть составлена из более мелких сетей, называемых *подсетями*. Идея заключается в том, что все подсети каким-либо образом соединены между собой.

У одного хоста может быть несколько IP-адресов. Чтобы увидеть адреса, которые активны на вашем компьютере с Linux, запустите такую команду

```Shell
ifconfig
```

Условно работа сетевого стека разделяют на четыре отдельных уровня:
![[Pasted image 20230808122000.png]]
- **Канальный/физический** уровень отвечает за всю сложную инженерную работу, благодаря которой данные могут осуществить переход с помощью различных технологий, таких как беспроводная сеть Wi-Fi, проводной Ethernet, оптоволоконные или спутниковые соединения.
- **Сетевой (IP) уровень** отвечает за маршрутизацию данных в условиях серии переходов. Он обеспечивает быструю и эффективную транспортировку данных от одного из миллиарда исходных устройств к любому из миллиардов конечных устройств. Сетевой уровень динамически корректирует и перенаправляет данные в зависимости от сетевой нагрузки, производительности канала или возникающих сбоев. Несмотря на эффективность этого уровня, иногда он может терять или даже отбрасывать данные. Сетевой уровень отвечает не за обеспечение общей надежности сети, а за обеспечение оптимальной маршрутизации и транспортировки данных.
- Задача **транспортного уровня** – компенсировать недостатки сетевого и канального уровней. Он обеспечивает повторную передачу потерянных пакетов, а также упорядочение пакетов, пришедших не по порядку, перед их передачей в принимающее приложение. Также транспортный уровень отвечает за управление потоками между отправляющим и принимающим приложениями. Таким образом, он гарантирует, что при высокоскоростном и неперегруженном соединении данные будут перемещаться быстро, а при соединении с низкой скоростью или загруженном соединении – медленно. Посредством регулирования потока данных и скорости передачи данных транспортный уровень обеспечивает бесперебойную работу интернета даже при больших нагрузках.
- Три перечисленных уровня призваны облегчать работу **прикладного уровня**. Благодаря этому приложения могут устанавливать сетевое соединение и отправлять/получать данные по этому соединению с помощью всего нескольких строк кода. Таким образом, приложения могут сосредоточиться на решении пользовательских задач. Стоит отметить, что благодаря вышеописанному подходу на сегодняшний день мы можем наблюдать широкий спектр самых разных приложений, для внедрения которых не требуются изменение основных интернет-протоколов.
#### Коммутация пакетов

Суть технологии коммутации пакетов заключается в том, что данные, которые необходимо передать от источника к приемнику, **разделяются на части** (фрагменты, фреймы, пакеты, блоки и т.п.), **передаваемые независимо друг от друга**. При этом части данных могу передаваться не непосредственно от источника к приемнику, а через **промежуточные сетевые устройства**. И **пути** (перечень узлов, через которые передавалась часть данных) **следования частей могут быть различными**.
#### Подсети

**Подсеть** — это соединенная группа хостов, IP-адреса которых каким-либо образом упорядочены. Обычно такие хосты расположены в одной физической сети. Подсеть определяется с помощью двух фрагментов: **сетевого префикса** и **маски подсети**.

Предположим, необходимо создать подсеть, содержащую IP-адреса от `10.23.2.1` до `10.23.2.254`. **Сетевой префикс** — та часть, которая является общей для всех адресов данной подсети; в приведенном примере это `10.23.2.0`, а **маской подсети** будет `255.255.255.0`. Маска отмечает положения битов в IP-адресе, которые являются общими для подсети.
Вот, например, двоичная запись адресов `10.23.2.0` и `255.255.255.0`:
```
	10.23.2.0: 00001010 00010111 00000010 00000000
255.255.255.0: 11111111 11111111 11111111 00000000
```

Теперь выделим жирным шрифтом те положения битов в адресе 10.23.2.0, которые являются единицами в адресе 255.255.255.0

10.23.2.0: **00001010 00010111 00000010** 00000000

Посмотрите на биты, которые не выделены жирным шрифтом. Для любого из них можно установить значение 1, чтобы получить правильный IP-адрес для данной подсети, за исключением случая, когда все биты являются нулями или единицами.

| **Десятичный формат** | **CIDR** | **Доступные адреса** |
|---|---|---|
|255.255.255.0|/24|256|
|255.255.255.128|/25|128|
|255.255.255.192|/26|64|
|255.255.255.224|/27|32|
|255.255.255.240|/28|16|
|255.255.255.248|/29|8|
|255.255.255.252|/30|4|
|255.255.255.254|/31|2|
|255.255.255.255|/32|1|

#### Заголовки пакетов

Как правило, пакеты состоят из **заголовка канала**, **IP-заголовка**, **заголовка протокола управления передачи данных (TCP)**, а также определенного **набора данных**.
![[Pasted image 20230807143142.png]]

По завершении перехода пакета по определенному каналу заголовок старого канала отбрасывается, и на смену ему приходит заголовок нового, по которому пакету предстоит перейти. IP- и TCP-заголовки остаются неизменными.

- **IP-заголовок** содержит адреса исходного и конечного устройств, а также время жизни (TTL) пакета. IP-заголовок устанавливается на исходном устройстве и не изменяется (кроме TTL), по мере того как пакет перемещается через различные маршрутизаторы.
- **TCP-заголовки** указывают порядок данных в каждом пакете. Когда исходное устройство разбивает сообщение или файл на пакеты, оно отслеживает положение каждого пакета относительно начала сообщения или файла, а затем добавляет в каждый созданный и отправленный пакет его относительный адрес. (Для того чтобы правильно восстановить исходное сообщение, конечное устройство руководствуется относительными адресами пакетов. Благодаря такому подходу технологии транспортного уровня легко могут обрабатывать пакеты, приходящие не по порядку. Такие пакеты помещаются в буфер обмена, а устройство отмечает, что в восстанавливаемом сообщении наблюдается пробел. Затем, по прибытии, нужный пакет идеально вписывается в повторно собранное сообщение.)

> **Управление потоками** – подход, при котором исходное устройство
> периодически замедляется с целью контроля перегрузки сети или
> конечного устройства. Также такой подход позволяет исходному
> устройству увеличивать скорость передачи данных в тех случаях,
> когда сеть и конечное устройство способны обрабатывать более
> высокие скорости передачи данных.

> **Сокет** – программная библиотека, доступная на многих языках программирования, которая делает создание сетевого подключения и обмен данными почти таким же простым, как открытие и чтение файла на любом вашем устройстве.

#### Безопасность транспортного уровня

На сегодняшний день существует два основных подхода к защите сетевой активности. 
- Суть **первого подхода** состоит в том, что все сетевое оборудование (маршрутизаторы и каналы связи) физически находятся в безопасных местах, иными словами, никто не сможет контролировать трафик во время его прохождения по сети. Такой подход не представляется целесообразным при наличии большого количество маршрутизаторов, принадлежащих различным организациям. Несмотря на то что операторы маршрутизаторов придерживаются строгих алгоритмов выполнения процедур и следуют политике безопасности, рано или поздно проблемы все же возникнут. Например, как только вы решите подключиться к Wi-Fi, перехватить данные сможет любой злоумышленник.
- Сущность **второго подхода** заключается в шифровании данных. Так, данные зашифровываются на исходном устройстве, передаются по физическому каналу и затем расшифровываются на конечном устройстве. При таком подходе злоумышленники, конечно, могут увидеть ваши данные, но расшифровать их – нет. Также шифрование гарантирует невозможность внести изменения в передаваемые данные. 

Традиционный способ шифрования передаваемых данных – использование общего секретного ключа (пароля, словесного выражения, числа), который знали бы только отправляющая и получающая стороны. Дешифровать сообщение без такого ключа не представляется возможным.

Передавать общие ключи шифрования через интернет также небезопасно, поскольку злоумышленники могут отследить и перехватить незашифрованное сообщение, содержащее ключ. Также злоумышленники могут перехватить сообщение, дешифровать его, изменить содержимое и зашифровать повторно, а после чего отправить его на конечное устройство. Оно в свою очередь дешифрует сообщение и не узнает, какие именно изменения внесли злоумышленники. Таким образом, общие ключи шифрования не подходят для защиты трафика в условиях существования триллионов пар устройств, взаимодействующих по сети.

В 1970-х годах была разработана концепция **асимметричного ключа шифрования**. Ее сущность заключается в том, что **один ключ используется для шифрования** сообщения, а **другой – для его дешифрования**. Устройство, которое будет получать зашифрованные данные, выбирает ключ шифрования и ключ дешифрования. Затем ключ шифрования отправляется на устройство, которое будет отправлять данные. Оно в свою очередь зашифровывает данные и отправляет их. Далее принимающее устройство восстанавливает исходное сообщение с помощью ключа дешифрования.
Так, согласно этой концепции, **ключ шифрования называют открытым**, так как он может передаваться другим устройствам, а ключ **дешифрования – закрытым**, поскольку он не может быть передан другому устройству. Очень часто такой тип называют шифрованием с **открытыми/закрытыми ключами**. Благодаря разработке такой технологии злоумышленники могут получить только открытый ключ (как правило, в незашифрованном виде) и зашифрованный текст, который невозможно дешифровать без закрытого ключа. Угадать закрытый ключ также практически не-
возможно, поскольку он зашифровывается с помощью математических
операций с большими простыми числами.
![[Pasted image 20230808104040.png]]
#### Слой защищенных сокетов (SSL)

«**слой защищенных сокетов**» (Secure Sockets Layer – **SSL**), или «**протокол за-
щиты транспортного уровня**» (Transport Layer Security – **TLS**) - дополнительный
уровень между **транспортным** и **прикладным**. Когда приложение запрашивает транспортный уровень установить соединение с удаленным хостом, оно также
может запросить, чтобы соединение было зашифрованным или незашифрованным. Если было запрошено зашифрованное соединение, транспортный уровень зашифровывает данные перед разбивкой потока на пакеты. Таким образом, этот процесс не влияет на работу транспортного, сетевого и физических (канальных) и прикладного уровней.
![[Pasted image 20230808105120.png]]
Шифрование представляло собой простое и прозрачное дополнение к транспортному уровню, благодаря чему не возникало необходимости в замене маршрутизаторов сетевого и канального уровней.

> **Secure Sockets Layer (SSL)** – слой защищенных сокетов. Протокол, который позволяет приложению запрашивать шифрование соединения транспортного уровня при прохождении через сеть. Является предшественником протокола транспортного уровня (TLS).

> **Transport Layer Security (TLS)** – протокол, который позволяет приложению запрашивать шифрование соединения транспортного уровня при прохождении через сеть. Является последователем слоя защищенных сокетов (SSL).
#### Сертификаты безопасности и центры сертификации

Несмотря на то что асимметричное шифрование позволяет передавать ключи шифрования по небезопасным сетям и использовать эти ключи для шифрования передаваемых данных, существует еще одна проблема безопасности. Она заключается в **достоверности открытых ключей шифрования**.

К примеру, пользователь может быть уверен, что заходит на сайт
www.amazon.com, но злоумышленники могут перехватить трафик и выдать за нужный вам сайт любой другой, предоставив при этом вашему устройству открытый ключ шифрования. Так, ваш веб-браузер будет шифровать информацию о ваших банковских счетах с помощью ложного открытого ключа и отправит информацию прямо в руки мошенникам. И, поскольку злоумышленники предоставили открытый ключ, они также имеют и закрытый, что позволит им расшифровать вашу
конфиденциальную информацию. Так, вашему устройству необходимы гарантии того, что ключи являются достоверными. Достоверные ключи всегда подписываются цифровой подписью центра сертификации (Certificate Authority – CA). 

![[Pasted image 20230808114319.png]]
#### Маршруты и таблица маршрутизации ядра

Соединение подсетей Интернет заключается в основом в идентификации хостов, подключенных к более чем одной подсети. Ядро Linux использует конфигурацию назначений, которая называется таблицей маршрутизации. Чтобы отобразить таблицу маршрутизации, применяйте команду `route -n`.

```Shell
route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
0.0.0.0 10.23.2.1 0.0.0.0 UG 0 0 0 eth0
10.23.2.0 0.0.0.0 255.255.255.0 U 1 0 0 eth0
```

Две последние строки здесь содержат информацию о маршрутизации. Столбец **Destination** сообщает префикс сети, а столбец **Genmask** — маску, которая соответствует данной сети. В этом выводе определены две сети: `0.0.0.0/0` (которая соответствует каждому адресу в Интернете) и `10.23.2.0/24`. У каждой из этих сетей в столбце **Flags** стоит символ `U`, который говорит о том, что данный маршрут активен («up»).

Различие между назначениями заложено в комбинации значений столбцов **Gateway** и **Flags**. Для адреса `0.0.0.0/0` в столбце **Flags** указан флаг `G`, который означает, что для данной сети связь должна проходить **через шлюз**, указанный в столбце **Gateway** (в данном случае `10.23.2.1`). Однако для сети `10.23.2.0/24` в столбце **Flags** нет символа `G`, это говорит о том, что данная сеть подключена напрямую. Здесь `0.0.0.0` используется в качестве заместителя значения в столбце **Gateway**.

Есть некоторая хитрость: допустим, хост собирается отправить что-либо по адресу `10.23.2.132`, который соответствует обоим правилам таблицы маршрутизации, `0.0.0.0/0` и `10.23.2.0/24`. Как ядро узнает о том, что необходимо применить второй адрес? Оно выбирает самый длинный совпадающий **префикс назначения**. Именно здесь нотация CIDR становится чрезвычайно удобной: адрес `10.23.2.0/24` годится, и длина его префикса равна 24 битам; адрес `0.0.0.0/0` тоже подходит, но его префикс — нулевой длины (то есть у него нет префикса), поэтому берет верх правило для адреса `10.23.2.0/24`.

#### Команда ping

Команда ping (см. http://ftp.arl.mil/~mike/ping.html) является одним из главнейших инструментов для сетевой отладки. Она отправляет пакеты эхо-запроса по протоколу ICMP какому-либо хосту-адресату и просит вернуть его отправителю. Если принимающий хост получает пакет и настроен на ответ, он отправляет эхо-ответ по протоколу ICMP.

```Shell
ping 10.23.2.1
PING 10.23.2.1 (10.23.2.1) 56(84) bytes of data.
64 bytes from 10.23.2.1: icmp_req=1 ttl=64 time=1.76 ms
64 bytes from 10.23.2.1: icmp_req=2 ttl=64 time=2.35 ms
64 bytes from 10.23.2.1: icmp_req=4 ttl=64 time=1.69 ms
64 bytes from 10.23.2.1: icmp_req=5 ttl=64 time=1.61 ms
```

*Первая строка* говорит о том, что вы отправляете пакеты из 56 байт (если учитывать заголовки, то из 84 байтов) по адресу `10.23.2.1` (по умолчанию один пакет в секунду);

*Остальные строки* показывают отклик от хоста с адресом `10.23.2.1`. Самыми важными частями вывода являются **порядковый номер** (**icmp_req**) и **время прохождения** в прямом и обратном направлениях (**time**). Количество возвращенных байтов равно размеру отправленного пакета плюс 8. Содержимое пакетов не имеет значения.

Разрывы в порядковых номерах (такие как между 2 и 4) обычно свидетельствуют о каких-либо неполадках с подключением. Возможно также, что пакеты будут приходить в неправильном порядке. Если на доставку ответа требуется больше секунды (1000 мс), то подключение является крайне медленным.

**Время прохождения** — это интервал времени с момента отправки пакета-запроса до момента прибытия пакета-ответа. Если достичь назначения не представляется возможным, конечный маршрутизатор, который видит данный пакет, возвращает команде ping ICMP-пакет `host unreachable` («хост недоступен»).
#### Конфигурирование сетевого интерфейса

Чтобы вручную указать IP-адрес и маску сети для сетевого интерфейса ядра, нужно было выполнить следующее:

```Shell
ifconfig <interface> <address> netmask <mask>
```

Здесь параметр `interface` является именем интерфейса, таким как `eth0`. Когда интерфейс заработает, вам следует быть готовыми к добавлению маршрутов, что, как правило, сводится к указанию шлюза по умолчанию, например, так:

```Shell
route add default gw <gw-address>
```

Параметр `gw-address` является IP-адресом вашего шлюза по умолчанию; он должен быть адресом в локально подключенной подсети, определенной адресом и маской одного из сетевых интерфейсов. Чтобы удалить шлюз по умолчанию, запустите команду:

```Shell
route del -net default
```

Можно легко переопределить шлюз по умолчанию с помощью других маршрутов. Допустим, ваш компьютер находится в подсети `10.23.2.0/24`, вы желаете попасть в подсеть `192.168.45.0/24` и знаете о том, что адрес `10.23.2.44` может выступать в роли маршрутизатора для этой подсети. Запустите такую команду, чтобы отправить трафик, связанный с адресом `192.168.45.0` на этот маршрутизатор:

```Shell
route add -net 192.168.45.0/24 gw 10.23.2.44
```

#### Файл /etc/hosts

В большинстве систем можно переопределить параметры поиска имен хоста с помощью файла /etc/hosts. Обычно это выглядит так:

```
127.0.0.1 localhost
10.23.2.3 atlantic.aem7.net atlantic
10.23.2.4 pacific.aem7.net pacific
```

#### Файл resolv.conf

Традиционным файлом конфигурации для серверов DNS является файл /etc/resolv.conf.

```
search mydomain.example.com example.com
nameserver 10.32.45.23
nameserver 10.3.2.3
```

#### Локальный хост

Если запустить команду `ifconfig`, можно заметить интерфейс `lo`:

```Shell
lo Link encap:Local Loopback
inet addr:127.0.0.1 Mask:255.0.0.0
inet6 addr: ::1/128 Scope:Host
UP LOOPBACK RUNNING MTU:16436 Metric:1
```

Интерфейс `lo` является **виртуальным сетевым интерфейсом**, который называется возвратной петлей, поскольку он «закольцован» сам на себя. Результат таков, что при подключении к адресу `127.0.0.1` происходит подключение к компьютеру, которым вы пользуетесь в данный момент. Когда исходящие данные для локального хоста доходят до сетевого интерфейса `lo` в ядре, ядро просто заново упаковывает их как входящие данные и отправляет обратно через интерфейс `lo`.

#### Порты TCP и соединения

Протокол TCP предоставляется нескольким сетевым приложениям на одном компьютере с помощью сетевых **портов**. **Порт** — это просто число. Если IP-адрес можно уподобить почтовому индексу какого-либо жилого дома, то порт похож на номер почтового ящика: это дальнейшее деление на более мелкие части. При использовании протокола TCP приложение открывает соединение между одним из портов данного компьютера и каким-либо портом удаленного хоста. Можно идентифицировать соединение с помощью пары, составленной из IP-адреса и номера порта. Чтобы увидеть соединения, которые в данный момент открыты на компьютере, воспользуйтесь командой `netstat`

```Shell
netstat -nt
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address Foreign Address State
tcp 0 0 10.23.2.4:47626 10.194.79.125:5222 ESTABLISHED
tcp 0 0 10.23.2.4:41475 172.19.52.144:6667 ESTABLISHED
tcp 0 0 10.23.2.4:57132 192.168.231.135:22 ESTABLISHED
```

Поля **Local Address** и **Foreign Address** показывают соединения с точки зрения компьютера. Следовательно, для этого компьютера интерфейс настроен на IP-адрес `10.23.2.4`, а локальные порты `47626`, `41475` и `57132` подключены. Здесь первое соединение установлено между портом `47626` и портом `5222` по адресу `10.194.79.125`

#### Установление TCP-соединений

Чтобы установить соединение с помощью транспортного уровня, процесс на каком-либо хосте инициирует подключение одного из своих локальных портов ко второму хосту с помощью специальной *серии пакетов*. Чтобы распознать входящее соединение и ответить на него, второй хост должен обладать процессом, который *прослушивает правильный порт*. Как правило, подключающийся процесс называется *клиентом*, а прослушивающий — *сервером*. О портах важно знать следующее: клиент выбирает такой порт со своей стороны, который в настоящее время не используется, но он практически всегда соединяется с каким-либо хорошо известным портом на стороне сервера. Удаленный хост, подключающийся к хорошо известному порту вашего компьютера, подразумевает, что сервер локального компьютера прослушивает данный порт. Чтобы убедиться в этом, выведите список всех TCP-портов, которые прослушивает ваш компьютер, с помощью команды `netstat`:

```Shell
netstat -ntl
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State
tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN
tcp 0 0 127.0.0.1:53 0.0.0.0:* LISTEN
```

Строка, которая содержит значение `0.0.0.0:80` как локальный адрес, говорит о том, что локальный компьютер прослушивает подключения к порту `80` от удаленных компьютеров.

#### Настройка Linux в качестве маршрутизатора

По существу, маршрутизаторы являются всего лишь компьютерами, которые обладают несколькими интерфейсами физической сети. Можно с легкостью настроить компьютер с Linux как маршрутизатор.
Допустим, у вас есть две локальные подсети — `10.23.2.0/24` и `192.168.45.0/24`. Чтобы их соединить, у вас имеется компьютер-маршрутизатор с Linux, в котором присутствуют три сетевых интерфейса: два для локальных подсетей и один — для связи с Интернетом. IP-адреса маршрутизатора для локальных подсетей таковы: `10.23.2.1` и `192.168.45.1`. При настройке этих адресов таблица маршрутизации выглядит подобным образом

```Shell
Destination  Gateway Genmask       Flags Metric Ref Use Iface
10.23.2.0    0.0.0.0 255.255.255.0 U     0      0   0   eth0
192.168.45.0 0.0.0.0 255.255.255.0 U     0      0   0   eth1
```

![[Pasted image 20230712105728.png]]

Допустим, что для хостов в каждой из подсетей маршрутизатор указан в качестве шлюза по умолчанию (`10.23.2.1` для сети `10.23.2.0/24` и `192.168.45.1` для сети `192.168.45.0/24`). Если сеть `10.23.2.4` желает отправить пакет куда-либо за пределы сети `10.23.2.0/24`, она передает такой пакет по адресу `10.23.2.1`. Например, чтобы отправить пакет от адреса `10.23.2.4` (хост `A`) по адресу `192.168.45.61` (хост `E`), пакет приходит на адрес `10.23.2.1` (маршрутизатор) через интерфейс `eth0`, а затем уходит с него через интерфейс маршрутизатора `eth1`. Однако по умолчанию ядро Linux не перемещает автоматически пакеты из одной подсети в другую. Чтобы задействовать эту основную функцию маршрутизации, необходимо **включить IP-перенаправление в ядре маршрутизатора** с помощью такой команды:

```Shell
sysctl -w net.ipv4.ip_forward
```

Чтобы это изменение сохранилось после перезагрузки, можно добавить его в файл `/etc/sysctl.conf`.

**Интернет-ссылки верхнего уровня**. Когда в маршрутизаторе присутствует также третий сетевой интерфейс с интернет-ссылкой верхнего уровня, такая же настройка разрешает доступ в Интернет всем хостам, так как они сконфигурированы на использование этого маршрутизатора в качестве шлюза по умолчанию. Однако здесь все сложнее. Проблема в том, что конкретные IP-адреса, такие как `10.23.2.4`, в действительности не видны всему Интернету; они находятся в так называемых частных сетях. Чтобы обеспечить их подключением к Интернету, следует настроить в маршрутизаторе функцию под названием **NAT** (**Network Address Translation**, преобразование сетевых адресов).

#### Динамическая маршрутизация

Одной из самых распространенных проблем функционирования сети является сбой в
исходящей линии. Причин у этой проблемы может быть масса, вплоть
до того, что кто-то споткнулся о кабель и выдернул его из разъема.
В таких случаях маршрутизаторы обычно уже располагают набором
сетевых номеров, которые они хотели отправить по поврежденной
линии. На удивление процесс восстановления при сбоях в исходящих линиях происходит достаточно просто. Сначала маршрутизатор отбрасывает все записи в своей таблице. Затем по мере поступления новых пакетов, предназначенных для этих сетевых номеров, маршрутизатор заново выстраивает маршруты, на этот раз «советуясь» с соседними маршрутизаторами (кроме тех, с кем из-за разрыва связи
он больше не может контактировать).
![[Pasted image 20230807135744.png]]

На какое-то время работа маршрутизаторов замедляется ввиду
перестраивания таблиц маршрутизации, выстраивающих новую конфигурацию сети. Через некоторое время стандартная скорость работы восстанавливается.

Во время пауз маршрутизатор запрашивает у соседа всю или часть его таблицы маршрутизации. Маршрутизатор просматривает таблицы соседей и, если он видит, что другой маршрутизатор построил более оптимальный маршрут к какому-либо сетевому номеру, он обновляет свою таблицу.

#### Преобразование сетевых адресов (маскировка IP-адреса)

Функция **NAT** — широко применяемый способ совместного использования единственного IP-адреса для частной сети. Он почти универсален в домашних сетях и сетях небольших офисов. В Linux вариант функции NAT, который использует большинство людей, известен как маскировка(маскарадинг) IP-адреса.

Суть функции **NAT** заключается в том, что маршрутизатор не просто передает пакеты от одной подсети в другую, но и трансформирует их во время передачи. Интернет-хосты знают, как подключиться к маршрутизатору, однако ничего не знают о расположенной за ним частной сети. Хостам частной сети не требуется специальная конфигурация; маршрутизатор является для них шлюзом по умолчанию.
Эта система в общих чертах работает так.
1. Хост внутренней частной сети намерен установить соединение с внешним миром, поэтому он отправляет пакеты своего запроса на соединение через маршрутизатор.
2. Маршрутизатор перехватывает эти пакеты, вместо того чтобы отправить их в Интернет (в котором они пропали бы, поскольку общественный Интернет ничего не знает о частных сетях).
3. Маршрутизатор **определяет пункт назначения для пакета-запроса и открывает собственное соединение с этим пунктом назначения**.
4. Когда маршрутизатор установит соединение, он отправляет **фальсифицированное сообщение «соединение установлено» обратно, исходному внутреннему хосту**.
5. Теперь маршрутизатор становится **посредником** между внутренним хостом и пунктом назначения. Пункт назначения ничего не знает о внутреннем хосте; для удаленного хоста соединение выглядит как исходящее от маршрутизатора.

Чтобы компьютер с Linux играл роль **NAT-маршрутизатора**, в конфигурации ядра должны быть активизированы следующие составляющие: фильтрация сетевых пакетов («поддержка брандмауэра»), отслеживание подключений, поддержка IP-таблиц, полная функция NAT и поддержка маскировки (**MASQUERADE**). В большинстве версий ядра эта поддержка присутствует.

Далее необходимо запустить несколько команд `iptables`, чтобы маршрутизатор использовал функцию **NAT** для частной подсети. Вот пример, который применяется к внутренней сети Ethernet с интерфейсом `eth1`, совместно использующей внешнее подключение к интерфейсу `eth0`

```Shell
sysctl -w net.ipv4.ip_forward
iptables -P FORWARD DROP
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
iptables -A FORWARD -i eth0 -o eth1 -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT
```

#### Брандмауэры

Маршрутизаторы должны всегда содержать какой-либо **брандмауэр** для защиты от нежелательного трафика в сети. **Брандмауэр** — это программное обеспечение и/или конфигурация аппаратных средств, которые обычно размещаются в маршрутизаторе между Интернетом и малой сетью, пытаясь не допустить того, чтобы что-либо «плохое» навредило малой сети.

Система может фильтровать пакеты, когда она:
1. получает пакет;
2. отправляет пакет;
3. перенаправляет пакет другому хосту или шлюзу.

Если брандмауэра нет, система просто обрабатывает пакеты и отправляет их по назначению. Брандмауэры помещают проверочные пункты для пакетов в указанных
выше точках передачи данных. На этих проверочных пунктах пакеты удаляются, отклоняются или принимаются, как правило, на основе таких критериев:
- IP-адрес или подсеть источника или пункта назначения;
- порт источника или пункта назначения (в сведениях транспортного уровня);
- сетевой интерфейс брандмауэра.

Брандмауэры обеспечивают возможность работы с подсистемой ядра Linux, которая обрабатывает IP-пакеты.

В Linux правила для брандмауэра создаются в виде последовательности, известной как **цепочка**. Набор цепочек формирует **таблицу**. Когда пакет проходит через различные части сетевой подсистемы Linux, ядро применяет правила из определенных цепочек к пакетам. Например, после получения нового пакета от физического уровня ядро активизирует правила в цепочках, соответствующих вводу.
Все эти структуры данных обслуживаются ядром. Такая система в целом называется таблицами **iptables**, а команда из пространства пользователя `iptables` создает правила и управляет ими.

Поскольку таблиц может быть несколько — каждая со своим набором цепочек, содержащих множество правил, — то перемещение пакетов становится довольно сложным. Тем не менее обычно работают с единственной таблицей, которая называется «фильтр» и контролирует основной поток пакетов. В таблице фильтра есть три главные цепочки: **INPUT** для входящих пакетов, **OUTPUT** для исходящих пакетов и **FORWARD** для перенаправляемых пакетов.

![[Pasted image 20230712111732.png]]
Просмотреть текущую конфигурацию `iptables`, использовав команду:

```Shell
iptables -L

Chain INPUT (policy ACCEPT)
target prot opt source destination
Chain FORWARD (policy ACCEPT)
target prot opt source destination
Chain OUTPUT (policy ACCEPT)
target prot opt source destination
```

У каждой цепочки брандмауэра есть политика по умолчанию, которая определяет, что делать с пакетом, если он не удовлетворяет ни одному из правил. Для всех трех цепочек в данном примере установлена политика **ACCEPT**. Это означает, что ядро разрешает пакету пройти через систему фильтрации. Политика **DROP** говорит ядру о том, что пакет надо отбросить. Чтобы указать политику цепочки, используйте команду `iptables -P`, например, так:

```Shell
iptables -P FORWARD DROP
```

Допустим, кто-либо с IP-адресом `192.168.34.63` надоедает вам. Чтобы избавиться от его запросов к вашему компьютеру, запустите следующую команду:

```Shell
iptables -A INPUT -s 192.168.34.63 -j DROP
```

Здесь параметр `-A INPUT` присоединяет правило к цепочке **INPUT**. Фрагмент `–s 192.168.34.63` указывает IP-адрес источника в этом правиле, а часть `-j DROP` говорит ядру о том, чтобы оно отбрасывало любые пакеты, удовлетворяющие этому правилу. Следовательно, ваш компьютер будет отвергать любые пакеты, приходящие с адреса `192.168.34.63`.

Чтобы увидеть это правило, запустите команду `iptables -L`:

```Shell
iptables -L

Chain INPUT (policy ACCEPT)
target prot opt source destination
DROP all -- 192.168.34.63 anywhere
```

Но вот беда: ваш приятель с адресом 192.168.34.63 сообщил всем в своей подсети, чтобы к вашему компьютеру подключались через порт SMTP (TCP-порт 25). Чтобы избавиться также и от этого трафика, запустите такую команду

```
iptables -A INPUT -s 192.168.34.0/24 -p tcp --destination-port 25 -j DROP
```

В этом примере добавлен спецификатор маски сети для адреса источника, а также флаг `–p tcp`, чтобы учитывать только пакеты TCP. Следующее ограничение, `--destination-port 25`, говорит о том, что данное правило должно применяться только к трафику порта `25`. IP-таблица для цепочки **INPUT** теперь выглядит так

```Shell
Chain INPUT (policy ACCEPT)
target prot opt source destination
DROP all -- 192.168.34.63 anywhere
DROP tcp -- 192.168.34.0/24 anywhere tcp dpt:smtp
```

Все идет замечательно, пока кто-то из ваших знакомых с адресом `192.168.34.37` не говорит вам, что он не может отправить вам почту, поскольку вы заблокировали его компьютер. Думая о том, что это легко исправить, вы запускаете следующую команду:

```Shell
iptables -A INPUT -s 192.168.34.37 -j ACCEPT
```

Однако это не срабатывает. Чтобы понять почему, взгляните на новую цепочку

```Shell
Chain INPUT (policy ACCEPT)
target prot opt source destination
DROP   all -- 192.168.34.63 anywhere
DROP   tcp -- 192.168.34.0/24 anywhere tcp dpt:smtp
ACCEPT all -- 192.168.34.37 anywhere
```

Ядро считывает цепочки **сверху вниз**, применяя **первое правило, которое подходит**.
Первое правило не подходит для адреса `192.168.34.37`, а второе подходит, так как оно применяется ко всем хостам в диапазоне адресов от `192.168.34.1` до `192.168.34.254` и говорит о том, что пакеты должны отвергаться. Когда правило подходит, ядро приступает к действиям и уже не смотрит остальные цепочки

Решение заключается в перемещении третьего правила вверх. Сначала удалите третье правило с помощью такой команды

```Shell
iptables -D INPUT 3
```

Затем вставьте это правило в верхней части цепочки с помощью команды `iptables -I`

```Shell
iptables -I INPUT -s 192.168.34.37 -j ACCEPT
```

Чтобы вставить правило где-либо внутри цепочки, укажите номер правила после имени цепочки (например, `iptables –I INPUT 4 ...`).

#### Стратегии для брандмауэров

Существуют два основных типа сценариев для брандмауэров: **один для защиты отдельных компьютеров** (здесь можно указывать правила в цепочке INPUT каждого компьютера), а второй — **для защиты компьютеров в составе сети** (здесь правила указываются в цепочке FORWARD маршрутизатора). В обоих случаях вы не можете достичь серьезной защиты, если вы применяете по умолчанию политику ACCEPT, а затем постоянно добавляете правила, которые отбрасывают пакеты от источников, начинающих рассылать нежелательный контент. Вы должны **разрешать только те пакеты, которым доверяете, и отвергать все остальные**.

Допустим, что у вашего компьютера имеется SSH-сервер, обслуживающий TCP-порт `22`. Нет никаких оснований для того, чтобы какой-либо хост инициировал соединение с другими портами вашего компьютера, и вы не должны давать такой возможности никаким хостам. Чтобы это организовать, сначала установите для цепочки **INPUT** политику **DROP**:

```Shell
iptables -P INPUT DROP
```

Чтобы включить ICMP-трафик (для команды ping и других утилит), используйте такую команду:

```Shell
iptables -A INPUT -p icmp -j ACCEPT
```

Убедитесь в том, что вы можете получать пакеты, которые вы отправляете как на IP-адреса внутри собственной сети, так и на адрес `127.0.0.1` (локальный хост). При условии, что `my_addr` — это IP-адрес вашего хоста (Если вы управляете подсетью в целом и доверяете в ней всему, можно заменить адрес `my_addr` на адрес вашей подсети и ее маску, например, на `10.23.2.0/24`.), выполните следующее:

```Shell
iptables -A INPUT -s 127.0.0.1 -j ACCEPT
iptables -A INPUT -s my_addr -j ACCEPT
```

Далее, если вы используете удаленный сервер DNS с протоколом UDP, вы должны принимать трафик от вашего сервера имен, чтобы компьютер мог отыскивать имена с помощью службы DNS. Выполните это для всех серверов DNS, указанных в файле `/etc/resolv.conf`, используя следующую команду (здесь `ns_addr` означает адрес сервера имен)

```Shell
iptables -A INPUT -p udp --source-port 53 -s ns_addr -j ACCEPT
```

И наконец, разрешите SSH-соединения от кого угодно:

```Shell
iptables -A INPUT -p tcp --destination-port 22 -j ACCEPT
```

#### Защищенная оболочка (SSH)

Одним из самых распространенных сетевых сервисных приложений является защищенная оболочка (SSH) — стандарт де-факто для удаленного доступа к компьютерам с Unix. Настроенная оболочка SSH дает возможность защищенного входа в оболочку, удаленного исполнения команд, простого совместного использования файлов. Из многих полезных возможностей и функций оболочки SSH можно упомянуть следующие:
- шифрование пароля и других сеансовых данных для защиты от шпионов;
- туннелирование других сетевых соединений;
- наличие клиентов почти для любой операционной системы;
- использование ключей для аутентификации хоста.

Для запуска сервера sshd необходим файл конфигурации, а также ключи хоста. В большинстве версий ОС файл конфигурации находится в каталоге `/etc/ssh/sshd_config` Этот файл состоит из пар «ключевое слово — значение».

**Ключи хоста**

У оболочки OpenSSH есть три набора ключей хоста: один для протокола версии 1 и два для протокола 2-й версии (RSA и DSA). В каждом наборе присутствует открытый ключ (файл с расширением `.pub`) и секретный ключ (файл без расширения). 

```
ssh_host_rsa_key - Секретный ключ RSA (версия 2)
ssh_host_rsa_key.pub - Открытый ключ RSA (версия 2)
ssh_host_dsa_key - Секретный ключ DSA (версия 2)
ssh_host_dsa_key.pub - Открытый ключ DSA (версия 2)
```

Чтобы создать ключи для протокола SSH версии 2, используйте команду ssh-keygen, которая включена в оболочку OpenSSH:

```Shell
ssh-keygen -t rsa -N '' -f /etc/ssh/ssh_host_rsa_key
или
ssh-keygen -t dsa -N '' -f /etc/ssh/ssh_host_dsa_key
```

#### Инструменты диагностики

- команда `netstat` является базовой сетевой службой отладки, которая может отобразить разнообразную статистику о транспортном и сетевом уровнях

```
-t Вывести информацию о порте TCP
-u Вывести информацию о порте UDP
-l Вывести прослушивающие порты
-a Вывести все активные порты
-n Отключить поиск имен (для ускорения работы; полезно также, если не работает служба DNS)
```

- команда `traceroute` - работает на основе `TTL` (Когда значение `TTL` достигает нуля, маршрутизатор отбрасывает пакет.) Сначала `traceroute` отправляет пакет с `TTL`, равным `1`. Пакет попадает на первый маршрутизатор и сразу отбрасывается, а ваше устройство получает соответствующее уведомление. Затем `traceroute` отправляет пакет с `TTL`, равным `2`. Пакет проходит через первый маршрутизатор и отбрасывается вторым, который снова отправляет вам уведомление. Затем `traceroute` отправляет пакет с `TTL`, равным `3`. Так, с каждым разом утилита увеличивает значение `TTL`, пока пакет не дойдет до места назначения.

```Shell
traceroute www.stanford.edu
traceroute to www5.stanford.edu (171.67.20.37), 64 hops max, 40 byte packets
1 141.211.203.252 (141.211.203.252) 1.390 ms 0.534 ms 0.490 ms
2 v-bin-seb.r-bin-seb.umnet.umich.edu (192.122.183.61) 0.591 ms 0.558 ms 0.570 ms
3 v-bin-seb-i2-aa.merit-aa2.umnet.umich.edu (192.12.80.33) 6.610 ms 6.545 ms 6.654 ms
4 192.122.183.30 (192.122.183.30) 7.919 ms 7.209 ms 7.122 ms
5 so-4-3-0.0.rtr.kans.net.internet2.edu (64.57.28.36) 17.672 ms 17.836 ms 17.673 ms
6 so-0-1-0.0.rtr.hous.net.internet2.edu (64.57.28.57) 31.800 ms 41.967 ms 31.787 ms
7 so-3-0-0.0.rtr.losa.net.internet2.edu (64.57.28.44) 63.478 ms 63.704 ms 63.710 ms
8 hpr-lax-hpr--i2-newnet.cenic.net (137.164.26.132) 63.093 ms 63.026 ms 63.384 ms
9 svl-hpr--lax-hpr-10ge.cenic.net (137.164.25.13) 71.242 ms 71.542 ms 76.282 ms
10 oak-hpr--svl-hpr-10ge.cenic.net (137.164.25.9) 72.744 ms 72.243 ms 72.556 ms
11 hpr-stan-ge--oak-hpr.cenic.net (137.164.27.158) 73.763 ms 73.396 ms 73.665 ms
12 bbra-rtr.Stanford.EDU (171.64.1.134) 73.577 ms 73.682 ms 73.492 ms
13 * * *
14 www5.Stanford.EDU (171.67.20.37) 77.317 ms 77.128 ms 77.648 ms
```

Иногда отслеживание маршрутов пакетов может занимать больше времени – до двух минут. Не все маршрутизаторы отправляют уведомление об отбрасывании пакета. В приведенном выше примере маршрутизатор на `13` этапе отбросил наш пакет.
#### Угрозы безопасности приложений (OWASP)

1. **А1:2017- Внедрение** - Уязвимости, связанные, например, с внедрением SQL, NoSQL, OS и LDAP, возникают, когда непроверенные данные отправляются интерпретатору в составе команды или запроса. Вредоносные данные могут заставить интерпретатор выполнить непредусмотренные команды или обратиться к данным без прохождения соответствующей авторизации.
2. **А2:2017- Недостатки аутентификации** - Функции приложений, связанные с аутентификацией и управлением сессиями, часто некорректно реализуются, позволяя злоумышленникам скомпрометировать пароли, ключи или сессионные токены, а также эксплуатировать другие ошибки реализации для временного или постоянного перехвата учетных записей пользователей.
3. **А3:2017- Разглашение конфиденциальных данных** - Многие веб-приложения и API имеют плохую защиту критичных финансовых, медицинских или персональных данных. Злоумышленники могут похитить или изменить эти данные, а затем осуществить мошеннические действия с кредитными картами или персональными данными. Конфиденциальные данные требуют дополнительных мер защиты, например их шифрования при хранении или передаче, а также специальных мер предосторожности при работе с браузером.
4. **А4:2017-Внешние сущности XML (ХХЕ)** - Старые или плохо настроенные XML-процессоры обрабатывают ссылки на внешние сущности внутри документов. Эти сущности могут быть использованы для доступа к внутренним файлам через обработчики URI файлов, общие папки, сканирование портов, удаленное выполнения кода и отказ в обслуживании.
5. **А5:2017-Недостатки контроля доступа** - Действия, разрешенные аутентифицированным пользователям, зачастую некорректно контролируются. Злоумышленники могут воспользоваться этими недостатками и получить несанкционированный доступ к учетным записям других пользователей или конфиденциальной информации, а также изменить пользовательские данные или права доступа.
6. **А6:2017-Некорректная настройка параметров безопасности** - Некорректная настройка безопасности является распространенной ошибкой. Это происходит из-за использования стандартных параметров безопасности, неполной или специфичной настройки, открытого облачного хранения, некорректных HTTP-заголовков и подробных сообщений об ошибках, содержащих критичные данные. Все ОС, фреймворки, библиотеки и приложения должны быть не только настроены должным образом, но и своевременно корректироваться и обновляться.
7. **А7:2017-Межсайтовое выполнение сценариев (XSS)** - XSS имеет место, когда приложение добавляет непроверенные данные на новую вебстраницу без их соответствующей проверки или преобразования, или когда обновляет открытую страницу через API браузера, используя предоставленные пользователем данные, содержащие HTML- или JavaScript-код. С помощью XSS злоумышленники могут выполнять сценарии в браузере жертвы, позволяющие им перехватывать пользовательские сессии, подменять страницы сайта или перенаправлять пользователей на вредоносные сайты.
8. **А8:2017- Небезопасная десериализация** - Небезопасная десериализация часто приводит к удаленному выполнению кода. Ошибки десериализации, не приводящие к удаленному выполнению кода, могут быть использованы для атак с повторным воспроизведением, внедрением и повышением привилегий.
9. **А9:2017-Использование компонентов с известными уязвимостями** - Компоненты, такие как библиотеки, фреймворки и программные модули, запускаются с привилегиями приложения. Эксплуатация уязвимого компонента может привести к потере данных или перехвату контроля над сервером. Использование приложениями и API компонентов с известными уязвимостями может нарушить защиту приложения и привести к серьезным последствиям.
10. **А10:2017-Недостатки журналирования и мониторинга** - Недостатки журналирования и мониторинга, а также отсутствие или неэффективное использование системы реагирования на инциденты, позволяет злоумышленникам развить атаку, скрыть свое присутствие и проникнуть в другие системы, а также изменить, извлечь или уничтожить данные. Проникновение в систему обычно обнаруживают только через 200 дней и, как правило, сторонние исследователи, а не в рамках внутренних проверок или мониторинга.
# 3. Development lifecycle

### 3.1 Git-Flow

![[Pasted image 20230712122855.png]]

В целом, в настоящее время модель git-flow используется сравнительно редко. Эта модель ветвления основана на предсказуемом, долгосрочном цикле релиза новых версий, а не на выпуске нового кода каждые несколько часов. Git-flow сильно усложняет continuous delivery, когда разработчики выпускают частые обновления путем слияния с мастером (фактически, непосредственно в production) и плохо подходит для проектов, разбитых на сервисы.  
Единственный вариант, неплохо подходящий под git-flow — большая команда (20+ человек), планомерно выпускающая несколько параллельных релизов или занимающаяся поддержкой нескольких версий приложения параллельно. В таком случае git-flow действительно может помочь навести порядок.

### 3.2 Trunk-based development

Магистральная разработка (trunk-based development) фактически является обязательной практикой CI/CD и предполагает небольшие частые обновления главной ветки. Подразумевает ежедневные коммиты, многоуровневое автоматическое тестирование и быструю кеширующую сборку.

# 4. CI/CD

## 4.1 Непрерывная интеграция и непрерывная доставка

Непрерывная интеграция и непрерывная доставка (Continuous integration/
Continuous delivery, CI/CD) - создаёт среду `DevOps` (Development-Operations), устраняя разрыв между разработкой и эксплуатацией программного обеспечения.

**CI** - это непрерывная интеграция, сборка и тестирование разных модулей кода по
мере их обновления. Это означает, что код, разработанный индивидуально каждым
членом команды, интегрируется, создается и тестируется, как правило, много раз в
день. После этого репозиторий в системе контроля версий обновляется.

Главное преимущество `CI` - проблемы и ошибки обнаруживаются в самом начале,
обычно в тот же день. Их можно поправить сразу, а не через несколько дней, недель
или даже месяцев, когда они просочились в другие модули, а те, в свою очередь,
создали множество зависимостей.

Когда новый код создан и протестирован, его можно обновить с помощью непрерывной доставки - **CD**. В полном конвейере CI/CD каждое изменение собирается и тестируется, а после отображается в развернутом коде. При правильном подходе конечное решение будет постоянно улучшаться.

# 5.  Containers

## 5.1 Основы виртуализации

#### Если бы не было виртуализации:

-        Покупка нового сервера под каждый новый сервис;
-        Повышенное энергопотребление;
-        Сложная сетевая инфраструктура;
-        Сложная и дорогая система резервного копирования;
-        Выше вероятность отказа оборудования.

**Виртуализация** - это выделение ресурсов в изолированную среду.

![[Pasted image 20231025125206.png]]

**Гипервизор** – занимается изоляцией и выделением изолированных ресурсов для виртуальных систем

**Ключевые задачи гипервизора**:
-        Эмуляция аппаратных ресурсов
-        Изоляция среды
-        Распределение ресурсов

Преимущества гипервизора 2-го типа:
1. Доступность
2. Удобство
3. Наличие бесплатного софта

Недостатки:
1. Зависимость от работы своего ПК
2. Низкая плотность виртуальных машин

## VMWare

У VMWare есть три основных типа адаптеров:
1. **Bridged** – виртуальная машина прокидывается в виртуальную сеть напрямую
2. **NAT** – виртуальная машина получает доступ к сети через хостовую машину
3. **Виртуальные сетевые адаптеры (VMNet)** - виртуальные машины в одном vmnet могут видеть друг друга

Преимущества гипервизора 1-го типа
1. Высокая плотность ВМ
2. Возможность миграции между серверам
3. Наличие бесплатного софта

Недостатки
1. Высокая стоимость серверов
2. Высокая квалификация инженеров

**Аппаратная виртуализация** – разделение (изоляция) физических ресурсов сервера, которое осуществляет специальное ПО - **гипервизор**

**Программная виртуализация (контейнеризация)** - разделение (изоляция) программных ресурсов хостовой ОС.

![[Pasted image 20231025125434.png]]

|**Виртуальные машины**|**Контейнеры**|
|---|---|
|Изоляция на уровне "железа”|Изоляция на уровне ОС|
|Каждая ВМ имеет собственную ОС|Каждый контейнер разделяет единую ОС|
|Загружается минуты|Загружается секунды|
|VM "весят" гигабайты|Контейнеры "весят” мегабайты|
|VM долго создаются|Контейнеры создаются за секунды|
|Использует много ресурсов|Использует мало ресурсов|
|VM легко мигрируют на другие хосты виртуализации|Контейнеры проще пересоздать|

**Контейнеризация** – у исходной ОС берутся все необходимые библиотеки, процессы и дублируются в некое изолированное пространство – **контейнер.**

## 5.2 Технологии виртуализации

Существует несколько подходов по организации виртуализации.

1. **Трансляция вызовов** - В данном случае код гостевой операционной системы выполняется процессором так же, как и код операционной системы-хоста, но при этом происходит определенное управление исполняемым кодом. Одни операции (например арифметика) отправляются процессору на выполнение непосредственно, другие (трансляция системных вызовов или обращение к оборудованию) подменяются гипервизором на иные инструкции.
2. **Аппаратная виртуализация** - В данном случае процессор позволяет гипервизору задавать контекст виртуальных машин, что упрощает переключение кода между гостевым кодом и кодом хоста. Существует несколько неродственных систем виртуализации — Intel VT и AMD-V.
3. **Паравиртуализация** - Тот случай, когда для упрощения работы в виртуальной машине запускается не оригинальная операционная система, а слегка измененная. Как правило, речь идет о модификации ядра. Таким образом, операционная система «знает», что она выполняется не на аппаратной платформе, а в условиях виртуальной машины, что позволяет добиться еще лучшей производительности и интеграции с операционной системой-хостом. Не всегда такое представляется возможным, например, для виртуализации Windows. Тем не менее, и при запуске неизмененного ядра операционной системы доступна частичная виртуализация за счет установки специальных утилит, демонов и драйверов, которые рассчитаны на работу с виртуальным оборудованием.
4. **Контейнерная виртуализация** - Очень сильно отличающаяся от всего вышесказанного технология. Если используется одна и та же операционная система для виртуализации (либо родственные системы), можно изолировать процессы, пользователей, создать изолированные разделы на дисках, отдельные виртуальные сетевые интерфейсы. В этом случае каждая из таких «групп» представляет своего рода изолированный клон виртуальной системы. Такой механизм называется контейнерной виртуализацией. Все экземпляры виртуальных машин используют одно и то же ядро операционной системы хоста, но операционное окружение каждой из них изолированно, обладает своими  пользователями, настройками, IP-адресами, операционными системами. Такой подход позволяет, например, на одном ядре Linux запускать разные операционные системы (Debian и Red Hat например). Таким образом достигается наилучшая производительность, но, с другой стороны, виртуальные машины могут в большей степени конкурировать за аппаратные ресурсы (которые при контейнерной виртуализации превращаются в своего рода коммунальные ресурсы, а не сразу выделяются, как у вышестоящих способов).

**Примеры виртуализирующих технологий**

Популярные и часто упоминаемые системы виртуализации:

- KVM — механизм, реализованный в ядре Linux, позволяющий запускать немодифицированные ядра ОС Linux, Windows, FreeBSD и т.д. Используется аппаратная виртуализация, Intel VT или AMD-V. Так как KVM — механизм ядра, для удобной работы требуется менеджер виртуальных машин, например, Virtual Machine Manager или ProxMox. KVM-виртуализация часто применяется хостинг-провайдерами для организации услуги VDS/VPS (Virtual Dedicated Server/Virtual Private Server).

- XEN  позволяет запускать операционные системы с немодифицированным ядром (требуется аппаратная виртуализация Intel VT или AMD-V) либо с модифицированным ядром (паравиртуализация). Что интересно, возможен запуск виртуальной машины в режиме паравиртуализации внутри виртуальной машины, использующей аппаратную виртуализацию.

- OpenVZ — технология контейнерной виртуализации, по которой могут виртуализироваться только Linux-операционные системы. Как и KVM, также часто используется хостинг-провайдерами для организации услуги VDS/VPS. Стоит отметить, что в отличие от KVM или XEN, как и в другой контейнерной виртуализации, пользователь VDS не имеет возможности установить нестандартные модули ядра.

- LXC (Linux container) — технология контейнерной виртуализации, сходная с OpenVZ. ProxMox позволял работать с OpenVZ. C 4-й версии поддерживает LXC.

- Docker — также технология контейнерной виртуализации. Изначально использовалась LXC, теперь применяет собственную библиотеку виртуализации.