![[Pasted image 20230607103901.png]]

## 5.1 Как работает виртуальная машина Python
![[Pasted image 20230814113622.png]]
-        Код Python программы компилируется в **байткод** виртуальной машины;
-        Виртуальная машина по одной выполняет инструкции байткода (виртуальная машина использует байткод написанный только для неё и реализует удобную семантику Python (синтаксис), удобную модель управления памятью (автоматическое управление памятью));

# 1. Управление памятью

### 1.1.1 Как устроена память компьютера

Память в вычислительных устройствах имеет иерархическую структуру и обычно предполагает использование нескольких запоминающих устройств, имеющих различные характеристики. Выделяют два основных типа памяти:
- внутренняя память
- внешняя память
![[Pasted image 20230814124824.png]]

**Внутренняя память**

Характерными особенностями внутренней памяти по сравнению с внешней являются высокое быстродействие и ограниченный объем. Физически внутренняя память компьютера представляет собой интегральные микросхемы, которые размещаются в специальных гнездах на материнской плате. Чем больше размер внутренней памяти, тем более сложную задачу и с большей скоростью может решить компьютер.

Внутренняя память подразделяется на:
-        **постоянную память** (хранит очень важную для нормальной работы компьютера информацию Read Only Memory (ROM) — память только для чтения)
-        **оперативную память** (ранит информацию, необходимую для выполнения программ в текущем сеансе работы RAM (англ. Random Access Memory — память с произвольным доступом))
-        **кэш-память** (служит для увеличения производительности компьютера. Кэш-память используется при обмене данными между процессором и оперативной памятью. Алгоритм ее работы позволяет сократить частоту обращений процессора к оперативной памяти и, следовательно, повысить производительность компьютера)

**Кэш-память**
![[Pasted image 20230814124938.png]]

Современные процессоры оснащены кэшем, который состоит зачастую из трех уровней: **L1** (первый уровень), **L2** (второй уровень), **L3** (третий уровень).

1. **Кэш первого уровня (L1)** – наиболее быстрый уровень кэш-памяти, который работает напрямую с ядром процессора, благодаря этому плотному взаимодействию, данный уровень обладает наименьшим временем доступа и работает на частотах, близких процессору. Размер данного кэша обычно не велик (~на каждое ядро по 32Кб)
2. **Кэш второго уровня (L2)** – второй уровень более масштабный, нежели первый, но в результате, обладает меньшими скоростными характеристиками (~на каждое ядро по 256Кб)
3. **Кэш третьего уровня (L3)** – третий уровень, более медленный, нежели два предыдущих. Но всё равно он гораздо быстрее, чем оперативная память. Если два предыдущих уровня разделяются на каждое ядро, то данный уровень является общим для всего процессора.

**Внешняя память**

Назначение внешней памяти компьютера заключается в долговременном хранении информации любого вида. Выключение питания компьютера не приводит к очистке внешней памяти. Но обращение к внешней памяти требует гораздо большего времени. Как человек затрачивает на поиск информации в справочной литературе гораздо больше времени, чем на ее поиск в собственной памяти, так и время обращения (доступа) к внешней памяти существенно больше, чем к оперативной.

Все современные компьютеры используют архитектуру фон Неймана.
![[Pasted image 20230814125042.png]]

[Что каждый программист должен знать о памяти](http://rus-linux.net/lib.php?name=/MyLDP/hard/memory/memory.html)
### 1.1.2 Управление памятью в ЯП

Управление памятью — это процесс выделения, распределения и координации памяти таким образом, чтобы все программы работали правильно и могли оптимально получать доступ к различным системным ресурсам. Управление памятью также включает в себя и очистку памяти от объектов, которые больше не нужны.

Существует два типа управления памятью:
-        **ручное управление памятью**
-        **автоматическое управление памятью**

**Ручное управление памятью** включает в себя, как правило, три этапа:
1.      запрос памяти у операционной системы
2.      работа с ней
3.      возвращение памяти обратно в операционную систему

Ручной подход управления позволяет работать с памятью максимально эффективно. Мы точно знаем, сколько памяти нам выделено, зачем мы ее используем, и т.д. Однако помимо преимуществ такой подход имеет и ряд недостатков. Ключевой из них — сложность. Управлять памятью вручную — сложно и тяжело, поскольку легко забыть вернуть память обратно операционной системе, в результате чего возникает утечка: программа держит неиспользуемую память просто так, не давая применять ее для решения других задач.

**Автоматическое управление памятью** берет на себя самый сложный этап — возвращение памяти обратно операционной системе, когда она уже не требуется. Восстановленная память может использоваться другими объектами. Это пусть и немного менее эффективно, но позволяет сильно сократить трудозатраты на управление памятью и повысить надежность этого процесса.

К языкам с **ручным** управлением памяти относятся: C, C++, Pascal и многие другие.

К языкам с **автоматическим** управлением памяти относятся: **Python**, C#, Java, Ruby, JavaScript и многие другие.
### 1.1.3 Механизм работы памяти в Python

Python — это язык **с автоматическим управлением памятью**. Причем для управления ею он использует несколько механизмов. При запуске Python программы создается **новый процесс**, в рамках которого операционная система выделяет **пул ресурсов**, включая виртуальное адресное пространство. В эту память загружается **интерпретатор Python** вместе со всеми необходимыми ему для работы данными, **включая код программы**.

Оставшаяся свободная виртуальная память используется для хранения Python объектов. Для управления этой памятью в Python используется специальный механизм, который называется **аллокатор**. Он используется каждый раз, когда нам нужно создать новый объект.

Обычно мы в своих программах не оперируем большими объектами. Большая часть наших данных — это числа, строки и т.д., они занимают не такой уж большой объем в расчёте на одно значение. Но зато мы создаем их достаточно часто. И это приводило бы к проблемам, если бы Python абсолютно все такие вызовы транслировал в операционную систему. Системный вызов на выделение памяти — трудозатратная операция, зачастую связанная с переходом в контекст ядра операционной системы. Поэтому одна из главных задач аллокатора Python — **оптимизация количества системных вызовов**.

Для больших объектов (больше 512 байт) Python выделяет память **напрямую у ОС**. Обычно таких объектов не очень много в рамках программы, и создаются они нечасто. Поэтому накладные расходы на создание таких объектов напрямую в оперативную память не так высоки.

Аллокатор для малых объектов (не больше 512 байт) использует три уровня абстракции:
-        **блок** — кусок памяти, используемый для хранения одного объекта
-        **пул** — кусок памяти, содержащий блоки (обычно одна **страница** виртуальной памяти размером **4** килобайта)
-        **арена** — большой непрерывный кусок памяти, содержащий пулы (обычно содержит несколько страниц виртуальной памяти и имеет размер **256** килобайт)
![[Pasted image 20230814125908.png]]

**Блок**

Блок — это кусок памяти, который может содержать только один Python объект фиксированного размера. Размер блока может варьироваться от 8 до 512 байт и должен быть кратен восьми. Все блоки в конкретном пуле имеют одинаковый размер и находятся в одном классе размера, который и определяет размер блока. Градация в приведенной ниже таблице взята прямо из комментариев в исходном коде:

|**Запрос памяти в байтах**|**Размер блока в байтах**|**Индекс класса размера**|
|---|---|---|
|1-8|8|0|
|9-16|16|1|
|17-24|24|2|
|25-32|32|3|
|33-40|40|4|
|41-48|48|5|
|...|...|...|
|505-512|512|63|

Таким образом, если необходимы:
-        6 байт, то данные будут помещены в блок размером 8 байт
-        42 байта, то данные будут помещены в блок размером 48 байт
-        505 байтов, то данные будут помещены в блок размером 512 байт
-        и т.д.

**Пул**

Пулы состоят из **блоков одного размера**. Каждый пул работает по принципу двухсвязного списка с другими пулами **того же размера**. Поэтому алгоритм может с легкостью найти необходимое место для требуемого размера блока даже среди множества пулов. Размер пула равен **4** килобайта. **Ограничение пула** фиксированным размером блоков помогает с **фрагментацией**: Если объект уничтожается, аллокатор может заполнить это пространство **новым объектом того же размера**.

Для эффективного управления пулами Python использует дополнительный список, который называется **usedpools**. Он хранит **указатели на пулы, сгруппированные по классам**. Как мы уже знаем, все пулы с одинаковым размером блока связаны между собой с помощью двухсвязного списка. Чтобы перебрать их, нам просто нужно знать начало списка. Если пулов такого размера нет, то при первом запросе памяти будет создан новый пул.
![[Pasted image 20230814130000.png]]

Пулы находятся в трех состояниях:
1. **используемый (used)** — частично заполненный, какие-то блоки заняты, какие-то свободны
2. **полный (full)** — полностью заполненный, все блоки заняты
3. **пустой (empty)** — все блоки свободны и доступны для записи (хранятся в списке пустых пулов freepools)
![[Pasted image 20230814130105.png]]

Используемый пул содержит блоки, в которые можно записать какую-то информацию. Блоки полного пула все распределены и уже содержат данные. Пустые пулы не содержат данных и могут быть разбиты на какие угодны классы размера при необходимости.

_Допустим, нашему коду необходимо 8 байт. Если в списке используемых пулов нет пулов с классом размера в 8 байт, то новый пустой пул инициализируется, как хранящий блоки по 8 байт. Затем пустой пул добавляется в список используемых пулов и может быть использован при следующих запросах._

Заполненный пул освобождает некоторые блоки, когда эта информация в них уже не нужна. Этот пул добавится в список используемых в соответствии со своим классом размера.

**Пулы и блоки не выделяют память напрямую**, вместо этого они используют уже выделенное пространство в **аренах.**

**Арена**

Арена – это кусок памяти размером в 256 килобайт, который обеспечивает память для 64 пулов.
![[Pasted image 20230814130159.png]]

Арены, в отличие от пулов, **не имеют явных разделений на состояния**. Они сами по себе организованы в двухсвязный список **usable_arenas**. Этот список отсортирован по количеству свободных пулов. **Чем меньше свободных пулов, тем ближе арена к началу списка**.
![[Pasted image 20230814130216.png]]

Это означает, что **наиболее полная арена** будет выбрана для записи еще большего количества данных. Такое расположение арен позволяет снизить объем потребляемой программой памяти. Дело в том, что в некоторых случаях, когда память освобождается, она все еще остается недоступной операционной системе. Процесс Python держит ее распределенной и использует ее позже для новых данных. Полное освобождение памяти возвращает память в пользование операционной системе.

Арены — **единственные области, которые могут быть полностью освобождены**. Таким образом те арены, которые находятся в списке ближе к пустому состоянию, должны быть освобождены. В таком случае, область памяти может быть действительно полностью освобождена, и соответственно общий объем памяти Python программы будет уменьшен.
## 1.1 Как устроен сборщик мусора?

Стандартный интерпретатор Python (CPython) использует для сборки мусора два алгоритма: **подсчет ссылок (reference counting, неотключаемый механизм)** и **garbage collector (стандартный модуль gc из Python, отключаемый)**. Алгоритм подсчета ссылок не умеет определять циклические ссылки.

**Счетчик ссылок**

- Каждый созданный объект имеет специальное поле - счетчик ссылок. Он хранит в себе кол-во ссылающихся на него объектов. Увеличивает свое значение, например, когда используется операция присваивания, или когда объект становится частью списка. При удалении переменной счетчик ссылок уменьшается на 1(например, при завершении функции, где эта переменная была объявлена.)

```Python
import sys


a = '876543210'
b = a

print(sys.getrefcount('876543210')) #5

del a

print(sys.getrefcount('876543210')) #4

```

**Сборщик** **мусора**

У счетчика ссылок есть большой недостаток - **невозможность отловить циклические ссылки**. Если объект или несколько объектов ссылаются друг на друга, счетчик никогда не опустится ниже 1. Специально для обработки таких случаев и создан модуль `gс`. Его работа заключается в том, чтобы периодически сканировать объекты контейнерного типа и определять наличие циклических ссылок. Говоря о сборщике мусора, важным понятием является поколение объектов - это набор объектов, за которыми следит сборщик. Есть три поколения, каждое из которых сканируется с разной частотой. Чаще сканируются объекты первого поколения, т.к. туда попадают новые объекты. Как правило, такие объекты имеют маленький срок жизни и являются временными, поэтому целесообразно проверять их чаще. Если объекты прошли сканирование и не были удалены, то они переходят в следующее поколение. Сканирование инициируется по достижению заданных порогов (`700`,`10`,`10`) посмотреть их можно через` gc.get_threshold()`

В каждом поколении есть специальный счетчик и порог срабатывания, при достижении которого начинается процесс сборки мусора. Как только в Python создается какой-либо контейнерный объект, он проверяет эти пороги. Если условия срабатывают, то начинается процесс сборки мусора.

Стандартные пороги срабатывания для поколений установлены на `700`, `10` и `10` соответственно, но всегда можно изменить их с помощью функций `gc.get_threshold` и `gc.set_threshold`.

Циклические ссылки могут находиться только в “контейнерных” объектах, т.е. в объектах, которые могут хранить другие объекты, например в списках, словарях, классах и кортежах. GC не следит за простыми и неизменяемыми типами, за исключением кортежей. Некоторые кортежи и словари также исключаются из списка слежки при выполнении определенных условий. Со всеми остальными объектами гарантированно справляется алгоритм подсчета ссылок.

В отличие от алгоритма подсчета ссылок, циклический GC не работает постоянно, а запускается **периодически**.

Алгоритм поиска циклических ссылок: говоря кратко, GC проходит по всем объектам из выбранного поколения и временно удаляет все ссылки от каждого объекта. Все объекты, у которых после этого счетчик ссылок меньше двух, считаются недоступными и могут быть удалены.

Ручной отлов циклических ссылок возможен благодаря наличию у GC отладочному флагу `DEBUG_SAVEALL`, с которым все недоступные объекты будут добавлены в список `gc.garbage`:

```Python
gc.set_debug(gc.DEBUG_SAVEALL)
```

## 1.2 Как происходит выделение памяти?

Напрямую из кода память **не выделяется**. Вся работа по выделению памяти перекладывается на **менеджеров памяти**. Есть один общий менеджер "верхнего" уровня, который отвечает за выделение большого блока из выделенной программе памяти - "**арена**"(занимает `256Кб.`). Арена делится на пулы по `4Кб`. Каждый пул может содержать в себе только блоки заранее определенного размера - от `8` до `512` байт. Когда менеджер определенного типа запрашивает память для объекта, он заранее знает размер и может сразу обратиться к пулу за нужным размером блока. Когда переменной присваивается значение, на самом деле сначала создается объект в подходящем свободном блоке и потом уже в переменную кладется ссылка на этот объект.
## 1.3 Как происходит освобождение памяти?

В Python **нет необходимости в ручной очистке памяти**. Если объект больше не используется, все это перекладывается на сам интерпретатор и два механизма: **счетчик ссылок и сборщик мусора**.
## 1.4 Как CPython управляет памятью?

В CPython память управляется **в основном с помощью подсчета ссылок**. Т.е. для каждого объекта Python (числа, словаря или списка) подсчитывается, сколько экземпляров в данный момент использует его. Когда экземпляр перестает быть нужным кому-то, счетчик ссылок на него уменьшается, когда создается ещё один экземпляр - увеличивается. Если счетчик ссылок обратится в нуль, значит, на объект никто не ссылается и его можно удалить.
## 1.5 Механизмы очистки памяти

Python является языком с автоматически управляемой памятью, то есть программисту, пишущему код на Python, не нужно беспокоиться о работе с памятью, в частности заниматься ее освобождением. Как только данные программы (объекты в Python) больше не нужны, Python автоматически освобождает память, которую они занимали.

Стандартный интерпретатор Python использует сразу два механизма очистки памяти:
- подсчет ссылок
- сборщик мусора (Garbage Collector, GC)

#### Подсчет ссылок

Алгоритм подсчета ссылок — это один из самых простых механизмов очистки памяти. Объекты удаляются как только на них больше нет ссылок.

Каждый объект в Python унаследован от базового класса `PyObject`, который содержит специальное поле `Reference Count (ob_refcnt)`, в котором хранится количество ссылок на данный объект. Как только кто-то начинает ссылаться на объект, значение этого поля увеличивается на единицу. Если по какой-то причине ссылка пропадает, то это поле уменьшается на один. При этом если счетчик ссылок для определенного объекта достигает нуля, то интерпретатор запускает процесс уничтожения объекта. Если удаленный объект содержал ссылки на другие объекты, то эти ссылки также удаляются. Таким образом, удаление одного объекта может повлечь за собой удаление других.

> Механизм подсчета ссылок работает в режиме реального времени.

Приведенный ниже код:

```python
nums = [1, 2, 3]
```

создает объект, у которого поле `Reference Count (ob_refcnt)` равно 1

![[Pasted image 20230714101643.png]]

Приведенный ниже код:

```python
nums = [1, 2, 3]
nums1 = nums
```

создает объект, у которого поле `Reference Count (ob_refcnt)` равно 2.

![[Pasted image 20230714101711.png]]

Четыре основных сценария, **увеличивающих** количество ссылок на объект:

- создание нового объекта и присвоение его переменной
- присвоение уже существующего объекта переменной
- передача объекта в функцию в качестве аргумента
- добавление объекта в список, множество, словарь и т.д.

Четыре основных сценария, **уменьшающих** количество ссылок на объект:

1. удаление объекта из области видимости функции после ее завершения
2. удаление переменной с помощью оператора `del`
3. переприсваивание переменной нового значения
4. удаление объекта из списка, множества, словаря и т.д.

Для получения количества ссылок на заданный объект используется функция `getrefcount()` из модуля `sys`.

Приведенный ниже код:

```python
import sys


nums = [1, 2, 3] 
print(sys.getrefcount(nums))
```

выводит:

```no-highlight
2
```

Когда мы вызываем функцию `getrefcount()` для получение количества ссылок на объект, мы увеличиваем количество ссылок на объект на один, так как передаем `nums` в качестве аргумента в функцию. Поэтому счетчик ссылок равен 22. Это означает, что и переменная `nums`, и функция `getrefcount()` ссылаются на один и тот же список `[1, 2, 3]`.

Алгоритм подсчета ссылок очень простой и эффективный, но у него есть один большой недостаток. Он не умеет определять **циклические ссылки**.

Приведенный ниже код:

```no-highlight
nums1 = [1, 2, 3]
nums2 = [4, 5]

nums1.append(nums2)
nums2.append(nums1) 
```

создает циклические ссылки, так как `nums1` содержит ссылку на `nums2`, в то время как `nums2` содержит ссылку на `nums1`. Таким образом, счетчики ссылок у `nums1` и `nums2` никогда не будут равны нулю.

Приведенный ниже код:

```no-highlight
nums = [1, 2, 3]
nums.append(nums)
```

также создает циклическую ссылку, так как `nums` содержит ссылку на себя самого.

Именно из-за этого в Python существует дополнительный механизм очистки памяти — **сборщик мусора** (Garbage Collector, GC), который следит за объектами с потенциальными циклическими ссылками.

> В Python алгоритм подсчета ссылок является фундаментальным и не может быть отключен, тогда как сборщик мусора (GC) опционален и может быть отключен.

#### Сборщик мусора

В отличие от алгоритма подсчета ссылок, сборщик мусора не работает в режиме реального времени и запускается периодически. Каждый запуск сборщика создаёт микропаузы в работе программы, поэтому Python использует различные [эвристики](https://ru.wikipedia.org/wiki/%D0%AD%D0%B2%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0) для определения частоты запуска сборщика мусора.

Сборщик мусора разделяет все объекты на **3 поколения** (нулевое, первое и второе). **Новые объекты** попадают в **нулевое поколение**. Если новый **объект выживает** в процессе сборки мусора, то **он перемещается в следующее поколение**. Чем старше поколение, тем реже оно сканируется на сборку мусора. Так как новые объекты зачастую имеют очень маленький срок жизни (являются временными), то имеет смысл проверять их чаще, чем те, которые уже прошли через несколько этапов сборки мусора.

В каждом поколении есть специальный порог срабатывания, при достижении которого срабатывает процесс сборки мусора. Если сразу несколько поколений преодолели порог, то выбирается наиболее старшее поколение, так как сборка мусора в старших поколениях включает в себя также сборку мусора и в младших поколениях.

Для взаимодействия со сборщиком мусора используется модуль `gc`.

Наиболее полезные функции модуля:
- `gc.enable()`: включает сборщика мусора (по умолчанию он включен)
- `gc.disable()`: отключает сборщика мусора
- `gc.isenabled()`: возвращает `True`, если сборщик мусора включен, или `False` в противном случае
- `gc.collect()`: запускает сборщика мусора на всех трех поколениях. Функция имеет необязательный аргумент `generation` (целое число от 00 до 22), указывающий номер поколения, в котором нужно запустить сборщика мусора

> Счетчик ссылок подвержен проблемам в многопоточной среде, которые могут приводить к некорректности обновления этого счетчика из разных потоков и, следовательно, к удалению объектов, на которые еще существуют ссылки. Чтобы этого избежать, CPython использует [GIL — Global Interpreter Lock](https://ru.wikipedia.org/wiki/%D0%93%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80%D0%B0). Каждый раз, когда происходит работа с памятью, GIL — как глобальная блокировка — препятствует выполнению этих действий одновременно из двух потоков. Он гарантирует, что сначала отработает один, потом другой.

# 2. Обработка исключений

## 2.1 Типы ошибок

Разработка программы на любом языке программирования практически всегда бывает связана с возникновением различного рода ошибок, препятствующих получению желаемого результата.

Обычно выделяют следующие три категории ошибок:
-       **синтаксические** – возникают из-за синтаксических погрешностей кода (Синтаксические ошибки легко отлавливаются интерпретатором, который сразу же сообщает программисту о проблеме в написанном коде.)
-       **логические** – проявляются вследствие логических неточностей в алгоритме (Логические ошибки считаются более сложными в выявлении, поскольку не отлавливаются интерпретатором. Обычно они вызваны определенным недостатком в логике программы, из-за чего результат работы программы отличается от желаемого результата. Возможным решением проблемы является тестирование программы на разных примерах входных данных, для которых известен правильный результат.)
-       **ошибки времени выполнения, исключения** – вызваны некорректными действиями пользователя или системы (Исключения представляют собой еще один вид ошибок, которые проявляются в зависимости от наличия обстоятельств, меняющих ход выполнения программы. Исключения являются ошибками времени выполнения, возникающие в процессе выполнения программы и связанные с некорректностью переданных в программу данных, недоступностью ресурсов и т.д.)

## 2.2 Обработка исключений

Общая идея, заложенная в основу метода обработки исключений, такая: программный код, в котором **потенциально** может возникнуть ошибка, **выделяется специальным образом** – "берется на контроль". Если при выполнении этого программного кода ошибка не возникает, то ничего не происходит. Если при выполнении "контролируемого" кода **возникает ошибка**, то **выполнение кода останавливается** и автоматически **создается объект-исключение**, содержащий описание возникшей ошибки.

Для обработки исключительных ситуаций в языке Python используется конструкция **try-except**.

После **ключевого слова try** и двоеточия **размещается блок программного кода**, который мы подозреваем на предмет возможного возникновения ошибки. Этот код будем называть **контролируемым**. По завершении этого блока указывается **ключевое слово except**, после которого идет еще один блок программного кода. Этот код будем называть **кодом обработки ошибки (исключения)**.

```Python
try:
    # контролируемый код
except:
    # код обработки ошибки (исключения)
```

Если при выполнении кода в блоке **try** ошибка не возникла, то **код обработки ошибки (исключения)** в блоке **except** выполняться **не будет**. Если при выполнении кода в блоке **try** возникла ошибка, то выполнение кода **trу блока прекращается**, и **выполняется код обработки ошибки (исключения) в блоке except**. После этого **управление передается следующей команде** после конструкции **try-except**.

Пример использования инструкции try-except. Контролируемый код содержит считывание данных от пользователя с последующей конвертацией к числовому типу int и выводом частного введенных чисел.

```Python
try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except:
    print('Вы ввели некорректные данные!')

print('Работа программы завершена!')
```

Последняя строка программного кода, находится вне конструкции **try-except** и будет выполняться всегда независимо от того, произошла ошибка или нет.

## 2.3 Обработка нескольких исключений

Более утонченная обработка ошибок (исключительных ситуаций) подразумевает более индивидуальный подход.

Идея в том, чтобы обработка ошибок базировалась **на типе или характере ошибки**. Описанная схема обработки исключений претерпевает минимальные изменения. В конструкции **try-except** после блока **try** указывается **несколько** **ехсерt блоков**, причем **для каждого блока явно указывается тип ошибки (исключения)**, который обрабатывается в этом блоке. **Ключевое слово**, определяющее **тип ошибки**, указывается после ключевого слова **except** соответствующего блока.

```Python
try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
```

Выполняются команды **trу** блока. Если возникла ошибка, то выполнение команд **trу** блока **прекращается** и начинается **последовательный просмотр ехсерt блоков** на предмет **совпадения типа ошибки**, которая возникла, и типа ошибки, указанного после ключевого слова в **ехсерt** блоке. Как только совпадение найдено, выполняются команды соответствующего **ехсерt** блока, после чего **управление переходит к команде после** конструкции **try-except**. Если при переборе **ехсерt блоков** совпадение по типу ошибки **не найдено**, **выполнение кода прекращается** и появляется сообщение об ошибке. Если при выполнении **trу** блока ошибок не было, коды в **ехсерt** блоках не выполняются.

```Python
try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except (ValueError, IndexError, KeyError):
    print('Тут обрабатываются сразу три типа ошибок!')
except ZeroDivisionError:
    print('На ноль делить нельзя!')
except:
    print('Если не сработал ни один из предыдущих блоков except.')

print('Работа программы завершена!')
```

## 2.4 Основные типы исключений

Таблица основных типов исключений:

|**Тип исключения**|**Описание**|
|---|---|
|BaseException|является классом самого верхнего уровня и базовым для всех прочих классов исключений|
|Exception|базовый класс для большинства встроенных в Python исключений. Именно его, а не BaseException, необходимо наследовать при создании пользовательского класса исключения|
|AssertionError|возбуждается инструкцией assert|
|AttributeError|возбуждается при попытке обращения к несуществующему атрибуту объекта|
|EOFError|возбуждается функцией input() при достижении конца файла с вводными данными|
|ImportError|возбуждается, если невозможно импортировать модуль или пакет|
|IndexError|возбуждается при попытке получить элемент коллекции по несуществующему индексу|
|KeyError|возбуждается при попытке получить элемент коллекции по несуществующему ключу|
|MemoryError|возбуждается, если интерпретатору существенно не хватает оперативной памяти|
|NameError|возбуждается при попытке обратиться к необъявленной переменной|
|TypeError|возбуждается при несоответствии типов|
|ValueError|возбуждается при передаче в функцию аргумента с неподдерживаемым значением|
|ZeroDivisionError|возбуждается при попытке выполнить деление на ноль|
|NotImplementedError|возбуждается, если наследник класса не переопределил метод, который должен был переопределить|

![[Pasted image 20230609214602.png]]

## 2.5 Необязательный блок else

Помимо блоков **try** и **except**, в инструкции **try-except** может также использоваться необязательный блок **else**.

Блок **else** размещается после последнего **ехсерt** блока и содержит программный код, который выполняется **только в случае, если при выполнении кода в trу блоке ошибок (исключений) не было.**

Шаблон инструкции **try-except** в этом случае такой:

```Python
try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
else:
    # код для случая, если ошибки (исключения) не было
```

```Python
try:
    num = int(input())
    print('Квадрат числа равен:', num ** 2)
except ValueError:
    print('Вы ввели некорректные данные!')
else:
    print('Ошибки не произошло!')

print('Работа программы завершена!')
```

Блок **else** в конструкции **try-except** подобен блоку else в конструкциях for/while. Он срабатывает **если в контролируемом коде не произошло ошибок** (если тело цикла завершилось штатным способом, без break).

## 2.6 Необязательный блок finally

Блок **finally** размещается после последнего **ехсерt** блока, либо после блока **else**, если он присутствует, и **содержит программный код, который выполняется в любом случае, независимо от того, возникла ошибка (исключение) при выполнении кода trу блока или нет.**

Шаблон инструкции try-except в этом случае такой:

```Python
try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
finally:
    # код, который выполняется всегда
```

Блок finally располагается **после** блока **else**, в случае **присутствия** последнего.

Инструкции внутри блока **finally** будут выполнены, даже если блок **try** содержит **break, continue, return**. Следующая особенность работы блока **finally** связана с обработкой ошибок (исключений) **внутри функций**. Нужно знать, что блок **finally выполняется до return**.

## 2.7 Иерархия исключений

В Python присутствует строгая иерархия исключений, вершиной которой является тип **BaseException**. Тип **BaseException** является классом самого верхнего уровня и базовым для всех прочих классов исключений.

Дерево встроенных исключений выглядит так:

BaseException

 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
      |    +-- DeprecationWarning
      |    +-- PendingDeprecationWarning
      |    +-- RuntimeWarning
      |    +-- SyntaxWarning
      |    +-- UserWarning
      |    +-- FutureWarning
      |    +-- ImportWarning
      |    +-- UnicodeWarning
      |    +-- BytesWarning
      |    +-- ResourceWarning

Тип **Exception** – базовый класс для большинства встроенных в Python исключений. Именно его, а не BaseException, необходимо наследовать при создании пользовательского класса исключения.

Для проверки родства классов исключений можно использовать встроенную функцию `issubclass()`, которая указывает на то, является ли некоторый класс потомком указанного класса или нет.

Важно помнить, что если у нас используется **несколько** блоков **except**, то **первыми нужно указывать наиболее конкретные**.

## 2.8 Работа с объектом возбужденного исключения

Если нужен доступ к сгенерированному исключению как к объекту, то используется специальный синтаксис.

```Python
try:
    nums = [10, 5, 20, 25]
    print(nums[100])
except (KeyError, IndexError) as err:  # записываем сгенерированное исключение в err
    print(err)  # list index out of range
    print(type(err))  # <class 'IndexError'>
    print(dir(err))  # ['__cause__', '__class__', ... 'with_traceback']
```

Посмотреть все атрибуты объекта сгенерированного исключения можно с помощью встроенной функции `dir()`. Наибольший интерес представляет из себя атрибут `args`

Для получения информации об исключении можно воспользоваться функцией `exc_infо()` из модуля `sys`. Данная функция возвращает кортеж из трех значений: типа исключения, значения и объекта с трассировочной информацией об исключении, которое в данный момент обрабатывается.

## 2.9 Возбуждение исключений

Для возбуждения исключения используется оператор `raise`. В качестве аргумента оператор `raise` использует **экземпляр класса, унаследованного от Exception**. Класс указывает на тип исключения, а аргумент, передаваемый конструктору этого исключения, обычно описывает подробности возникновения исключительной ситуации.

Если возбуждаемые пользователем исключения **не перехватываются**, то они **распространяются** вплоть до **стандартного обработчика исключений и прекращают работу программы** с выводом стандартного сообщения об ошибке.

```Python
try:
    x, y = 10, 0
    if y == 0:
        raise ZeroDivisionError('Деление на ноль.')  # Возбуждение исключения
except ZeroDivisionError as err:
    print(err)             # Деление на ноль.
    print(err.args)        # ('Деление на ноль.',)
    print(type(err.args))  # <class 'tuple'>
```

При создании объекта исключения мы можем указать в конструкторе подробности возникновения исключительной ситуации. Конструктор любого исключения принимает переменное количество аргументов. Для того чтобы получить указанные значения, мы используем атрибут **args**, который является **кортежем**.

Оператор возбуждения исключений raise имеет несколько вариантов формата:

1.     **raise** _<экземпляр класса_> (указывается экземпляр класса возбуждаемого исключения с аргументами при необходимости.)

```Python
raise ValueError('Oпиcaниe исключения')
```

2.     **raise** _<название класса>_ (указывается только название класса исключения.)

```Python
raise ValueError  # эквивалентно: raise ValueError()
```

3.     **raise** _<экземпляр или название класса>_ from _<объект исключения>_ (сначала указывается экземпляр класса или просто название класса, а потом объект исключения, на основании которого создается новое исключение. В этом случае объект исходного исключения сохраняется в атрибуте __cause__. При обработке вложенных исключений эти данные используются для вывода информации не только о последнем исключении, но и о первоначальном исключении.)

```Python
try:
    х = 1 / 0
except Exception as err:
   raise ZeroDivisionError('Описание исключения') from err
```

4.     **raise** (повторно возбуждаем и пробрасываем выше последнее перехваченное исключение.)

```Python
try:
	х = 1 / 0
except Exception as err:
    print(err)  # каким-то образом обработали перехваченное исключение
    raise       # пробрасываем исключение выше
```

Возбуждение исключения в коде похоже на `return`, только на его глобальную версию, завершающую все функции в порядке, обратном тому, в котором они вызывались.

Сам механизм исключений **достаточно медленный**, поэтому, например, не очень хорошей идеей будет возбуждать исключение внутри цикла, когда мы точно знаем, что их будет достаточно большое количество.

## 2.9 Пользовательские исключения

В Python можно создавать **собственные типы** исключений. Такая практика позволяет увеличить гибкость процесса обработки ошибок в рамках той предметной области, для которой написана программа.

Для создания собственного типа исключения необходимо **создать класс**, **являющийся потомком** (наследником) одного из уже существующего **типа исключения**.

```Python
class NegativeAgeError(Exception):
    pass
```

Новый тип исключения с именем NegativeAgeError, который является **потомком класса Exception**. Класс **Exception** содержит весь необходимый функционал, позволяющий работать с исключениями, поэтому в большинстве случаев достаточно создать пустой класс, который является потомком класса Exception. Теперь мы можем работать с типом исключения NegativeAgeError, как с любым встроенным.

```Python
try:
    print('Введите свой возраст')
    age = int(input())
    if age < 0:
        raise NegativeAgeError('Возраст не может быть отрицательным')
    print('Ваш возраст равен', age)
except ValueError:
    print('Возраст должен быть числом')
except NegativeAgeError as e:
    print(e)
```

## 2.10 Методики LBYL и EAFP

При написании программного кода, который может потенциально возбуждать исключения, существуют два основных подхода:
1.     **LBYL** (Look Before You Leap) — посмотри перед прыжком
2.     **EAFP** (Easier to Ask Forgiveness than Permission) — проще извиниться, чем спрашивать разрешение

Приведенный ниже код
```Python
data = {'Tim': 33, 'Eva': 50}

data['Alex'] += 1
```

приводит к возникновению исключения **KeyError**, поскольку ключ Anri отсутствует в словаре.

Мы можем исправить такой код двумя способами.

**Способ 1.** Перестраховаться и заранее проверить, что все получится. Это идеология **LBYL**-подхода. Сначала посмотрели, убедились, что все в порядке, только потом сделали.

```Python
data = {'Tim': 33, 'Eva': 50}

if 'Alex' in data:
    data['Alex'] += 1
else:
    print('Ключ Alex отсутсвует в словаре.')
```

**Способ 2.** Мы можем описывать только главный алгоритм, рассчитывая, что все будет хорошо. Но при таком подходе необходимо прописать действия с исключениями (иногда разных типов). Это суть подхода **EAFP**.

```Python
data = {'Tim': 33, 'Eva': 50}

try:
    data['Alex'] += 1
except KeyError:
    print('Ключ Alex отсутсвует в словаре.')
```

В Python, скорее, преобладает подход **EAFP**, поэтому Python полагается на то, что **исключения будут обработаны после их возникновения.** И хотя такой подход может показаться рискованным, при разумном использовании исключений **код получается менее громоздким и лучше читается**, а **ошибки обрабатываются** только в случае их **возникновения**.

# 3. Typing

## 3.1 **Типизация** языков программирования

**Типизация** языков программирования ‌—‌ ‌это‌ ‌то, ‌ ‌как‌ ‌различные‌ ‌языки‌ ‌распознают‌ ‌типы‌ ‌переменных. ‌

Языки‌ ‌программирования‌ ‌бывают‌:
-        Нетипизированными‌ ‌(бестиповыми)
-        Типизированными‌

**Нетипизированные языки программирования**

Бестиповая‌ ‌типизация‌ ‌в‌ ‌основном‌ ‌присуща‌ ‌старым‌ ‌и‌ ‌низкоуровневым‌ ‌языкам‌ ‌программирования. ‌‌Все‌ ‌данные‌ ‌в‌ ‌таких‌ ‌языках‌ ‌считаются‌ ‌цепочками‌ ‌бит‌ ‌произвольной‌ ‌длины‌ ‌и, ‌ ‌как‌ ‌следует‌ ‌из‌ ‌названия, ‌ ‌не‌ ‌делятся‌ ‌на‌ ‌типы. ‌ ‌Работа‌ ‌с‌ ‌ними‌ ‌труднее, ‌ ‌и‌ ‌при‌ ‌чтении‌ ‌кода‌ ‌не‌ ‌всегда‌ ‌ясно, ‌ ‌о‌ ‌каком‌ ‌типе‌ ‌переменной‌ ‌идет‌ ‌речь. ‌ При‌ ‌этом‌ ‌у‌ ‌нетипизированных‌ ‌языков‌ ‌есть и плюсы: в ‌них‌ ‌можно‌ ‌совершать‌ ‌операции‌ ‌с‌ ‌любыми‌ ‌данными, ‌ ‌и‌ ‌код‌ ‌получается‌ ‌более‌ ‌эффективным. ‌

Примеры:

**Типизированные языки**: C, **Python**, Scala, PHP, Lua, C#, Java и т.д.
**Нетипизированные языки**: Assembler, Forth, Brainfuck и т.д.‌

Бестиповая типизация по своей сути очень проста и дальше она ни на какие другие виды не делится. А вот типизированные языки разделяются еще на несколько категорий:
-        **Статическая** и **динамическая** типизация
-        **Сильная** (**строгая**) и **слабая** (**нестрогая**) типизация
-        **Явная** и **неявная** типизация

**Статическая и динамическая типизация**

В языках ‌программирования‌ ‌со‌ **‌статической**‌ ‌типизацией‌ **‌проверка‌ типов‌ ‌начинается‌ ‌на‌ ‌стадии‌ ‌компиляции**. ‌ ‌Компиляторы‌ ‌ищут‌ ‌ошибки‌ ‌ещё‌ ‌до‌ ‌запуска‌ программы, то есть компилятор на 100% уверен, какой тип где находится. ‌Благодаря‌ ‌этому‌ ‌статически‌ ‌типизированные языки программирования ‌зачастую‌ ‌быстрее. ‌ ‌Кроме‌ ‌того, ‌ ‌тип‌ ‌для‌ ‌переменной‌ ‌можно‌ ‌назначить‌ ‌только‌ ‌один‌ ‌раз.

``` C#
int‌ ‌data = 17;‌

data‌ ‌=‌ ‌"Hello";‌  # в С# будет ошибка
```

В‌ ‌свою‌ ‌очередь, ‌ ‌языки‌ ‌с‌ **‌динамической**‌ ‌типизацией‌ **‌ищут‌ ‌ошибки‌ ‌на‌ ‌стадии‌ ‌выполнения**. ‌ ‌В‌ ‌них‌ ‌можно‌ ‌задать‌ ‌разные‌ ‌типы‌ ‌для‌ ‌одной‌ ‌и‌ ‌той‌ ‌же‌ ‌переменной, ‌ ‌и‌ ‌они‌ ‌более‌ ‌гибкие. ‌

```Python
data‌ ‌=‌ ‌17

data‌ ‌=‌ ‌'Hello' # в Python ошибки не будет
```

Примеры:

**Статическая типизация**: C, Java, C#, Kotlin, Scala, GO и т.д.
**Динамическая типизация**: **Python**, JavaScript, Ruby, Julia и т.д.

Преимущества статической типизации:
-        Проверки типов происходят только один раз — на этапе компиляции
-        Скорость выполнения
-        Ускорение разработки при поддержке IDE (отсеивание вариантов, заведомо не подходящих по типу)

Преимущества динамической типизации:
-        Простота создания универсальных коллекций
-        Удобство описания обобщенных алгоритмов (например сортировка списка, которая будет работать не только со списком целых чисел, но и со списком вещественных и даже списком строк)
-        Легкость в освоении — языки с динамической типизацией обычно очень хороши для того, чтобы начать программировать

**Сильная и слабая типизация**

В‌ ‌**слабо**‌ ‌типизированных‌ ‌языках‌ ‌программирования‌ **‌можно‌ ‌смешивать‌ ‌разные‌ ‌типы‌ ‌данных**. Так‌ ‌код‌ ‌получается‌ ‌короче‌ ‌—‌ ‌язык‌ ‌«старается‌»‌ ‌сам‌ ‌выполнять‌ ‌операции‌ ‌преобразования‌ ‌с‌ ‌разными‌ ‌типами.‌ ‌Впрочем,‌ ‌в‌ ‌таком‌ ‌случае‌ ‌не‌ ‌всегда‌ ‌ясно,‌ ‌как‌ ‌поведёт‌ ‌себя‌ ‌программа.‌ ‌Например,‌ ‌в‌ ‌JavaScript‌ ‌возможна‌ ‌такая‌ ‌запись:‌ ‌

``` Javascript
5‌‌ ‌‌+‌‌ ‌‌'6'‌;‌ ‌‌            //‌ ‌'56'‌ ‌
4‌‌ ‌‌*‌‌ ‌‌'3'‌;‌ ‌‌            //‌ ‌12‌ ‌
2‌‌ ‌‌+‌‌ ‌‌true‌;‌‌            //‌ ‌3‌ ‌
false‌‌ ‌-‌ ‌‌4‌;‌‌           //‌ ‌-4
```

При‌ **‌сильной‌ ‌(строгой‌)** ‌типизации, ‌ ‌как‌ ‌в‌ ‌Python, ‌ ‌язык‌ **‌не‌ ‌позволяет‌ ‌смешивать‌ ‌разные‌ ‌типы‌** ‌—‌ ‌то‌ ‌есть ‌если‌ ‌вы‌ ‌обозначили‌ ‌переменную‌ ‌как‌ ‌число, ‌ ‌то‌ ‌добавить‌ ‌к‌ ‌ней‌ ‌строку‌ ‌уже‌ ‌не‌ ‌получится.

```Python
data = 'python'
new_data = data + 2022   # TypeError: can only concatenate str (not "int") to str
```

Языки‌ ‌с‌ ‌сильной‌ ‌типизацией‌ ‌надёжнее. ‌ ‌Да и‌ ‌программист, ‌ ‌прописывая‌ ‌все‌ ‌преобразования‌ ‌вручную, ‌ ‌лучше‌ ‌понимает, ‌ ‌как‌ ‌работает‌ ‌его‌ ‌код. ‌

Примеры:
**Сильная типизация**: Java, **Python**, Haskell, Lisp и т.д.
**Слабая типизация**: C, JavaScript, Visual Basic, PHP и т.д.

Преимущества сильной типизации:
-        Надежность: мы получаем ошибки компиляции, взамен неправильного поведения
-        Скорость: вместо скрытых преобразований, которые могут быть довольно затратными, с сильной типизацией необходимо писать их явно, что заставляет программиста как минимум знать, что этот участок кода может быть медленным
-        Понимание работы программы: вместо неявного приведения типов, программист пишет все сам
-        Определенность: когда мы пишем преобразования вручную мы точно знаем, что мы преобразуем и во что

Преимущества слабой типизации:
-        Удобство использования смешанных выражений
-        Абстрагирование от типизации и сосредоточение на задаче
-        Краткость записи

**Явная и неявная типизация**

В‌ ‌языках‌ ‌программирования‌ ‌с‌ **‌явной‌ ‌типизацией‌ ‌типы‌ ‌переменных‌ ‌и‌ ‌возвращаемых‌ ‌значений‌ ‌функций‌ ‌нужно‌ ‌задавать явно**. ‌ ‌Это‌ ‌дольше, ‌ ‌но‌ ‌так‌ ‌проще‌ ‌определять, ‌ ‌что‌ ‌значат‌ ‌все‌ ‌данные, ‌ ‌а‌ ‌программисту‌ ‌не‌ ‌придётся‌ ‌запоминать‌ ‌отдельно‌ тип каждой переменной. ‌ ‌В‌ ‌языке‌ ‌C# ‌переменную‌ ‌целого типа int нужно объявить так: ‌

```C#
int‌ ‌data = 17
```

При‌ **‌неявной‌ ‌типизации‌ ‌тип‌ ‌переменной‌ ‌определяется‌ ‌интерпретатором‌ ‌или‌ ‌компилятором**, ‌ ‌поэтому‌ ‌записи‌ ‌в‌ ‌таких‌ ‌языках‌ ‌короче. ‌ В‌ ‌языке‌ ‌Python ‌переменную‌, содержащее ‌целое число можно ‌объявить так (язык‌ ‌сам‌ ‌определит, ‌ ‌что‌ ‌это‌ ‌целое‌ ‌число): ‌

```Python
data = 17
```

Примеры:

**Явная типизация**: C++, D, C#, Java и т.д.
**Неявная типизация**: **Python**, PHP, Lua, JavaScript и т.д.

Преимущества явной типизации:
-        Наличие у каждой функции сигнатуры (например **int add(int, int)**) позволяет без проблем определить, что функция делает
-        Программист сразу записывает, какого типа значения могут храниться в конкретной переменной, что снимает необходимость запоминать это

Преимущества неявной типизации:
-        Сокращение записи: запись **def add(x, y)** короче, чем **int add(int x, int y)**
-        Устойчивость к изменениям: если в функции временная переменная была того же типа, что и входной аргумент, то в явно типизированном языке при изменении типа входного аргумента нужно будет изменить еще и тип временной переменной

Python — это язык с **динамической, сильной и неявной типизацией**. Такая система типов — это очень удачный компромисс между простотой разработки и надежностью написанных программ.

## 3.2. Аннотации типов

В достаточно крупной кодовой базе при отсутствии информации о типах очень сложно угадать, какие именно объекты используются в программе.

По этим соображениям, в Python 3.5 появились **аннотации типов**, которые представляют собой **специальный синтаксис для объявления типов параметров функций и их возвращаемых значений** (PEP 484). В Python 3.6 эта возможность была расширена — стало можно объявлять **типы переменных вообще в любом месте программы** (PEP 526). С каждой новой версией языка эта функциональность улучшается, и писать аннотации типов становится всё проще, удобнее и естественнее.

Нужно отметить, что аннотации типов — это **именно возможность**, а не обязанность. У программиста есть выбор — добавлять информацию о типах или нет. Таким образом Python пытается усидеть на двух стульях — остаться языком с динамической типизацией и дать возможность для статического анализа написанных программ.

Программист при написании кода расставляет **информацию о типах переменных, параметров и возвращаемых значений функций**. Это **никак не влияет на выполнение программы**. Python сам по себе никак **не использует** эту информацию, он лишь **перекладывает её в специальные атрибуты функций или переменных**, делая доступной для сторонних утилит. То есть, если указано, что функция принимает строковый аргумент, то это никак не помешает вызвать её с целым числом или списком — в зависимости от тела функции, она может отработать, а может завершиться ошибкой, но сама возможность вызова с любыми типами аргументов никак не ограничивается.

**Простые типы**

Рассмотрим определение функции **greet()**, которая по задумке принимает строковый аргумент name и возвращает строковое значение приветствия:

```Python
def greet(name):
    return f'Hello {name}!'
```

С помощью аннотаций типов можем переписать функцию в виде:

```Python
def greet(name: str) -> str:
    return f'Hello {name}!'
```

**Типы параметров**, записываются **после имени параметра через знак двоеточия**, а **тип возвращаемого значения** функции записывается **после знака "стрелки"**. Теперь программист просто взглянув на сигнатуру функции может понять, что функция принимает строку и возвращает строку. При этом можно понять, что если передать в неё другой тип, то она не сможет корректно отработать.

Если некоторый аргумент имеет **значение по умолчанию**, то его тип должен **предшествовать значению по умолчанию**:

```Python
def greet(name: str = 'world') -> str:
    return f'Hello, {name}!'
```

Точно так же можно использовать аннотации типов и любые другие базовые (не являющиеся коллекциями) типы в Python: **int**, **float**, **bool**, **str**, **NoneType**.

**Пример 1**. Функция print_hello() принимает два аргумента типа str и bool и возвращает значение None.

```Python
def print_hello(name: str, upper: bool = False) -> None:
    if upper:
        name = name.upper()
    print(f'Hello, {name}')
```

Пример 2. Функция avg() принимает три аргумента типа int и возвращает значение float:

```Python
def avg(num1: int, num2: int, num3: int) -> float:
    return (num1 + num2 + num3) / 3
```

Вот так можно добавить аннотации типов к переменным в любом месте кода (Python 3.6+):

```Python
name: str = 'Name'
age: int = 29
height: float = 171.5
is_married: bool = False
```

Можно также аннотировать переменные, не назначая им сразу значения:

```Python
surname: str
gender: bool
```

**Типы** **коллекции**

Перейдем к более сложным типам, таким как списки, кортежи, словари и множества. Можно добавлять аннотации типов, используя сами имена классов **list**, **tuple**, **set**, **dict**:

```Python
def sum_square(nums: list) -> float:
    total = 0
    for i in nums:
        total += i ** 2
    return total
```

Это не слишком информативно, потому что кроме самого типа list было бы ещё полезно знать, какие данные он в себе содержит. В нашем примере непонятно списком каких типов является параметр nums.

В Python до версии 3.9 для этого придётся использовать отдельные типы из модуля **typing**. Делается это при помощи квадратных скобок:

```Python
from typing import List


def sum_square(nums: List[int]) -> float:
    total = 0
    for i in nums:
        total += i ** 2
    return total
```

```Python
from typing import List, Tuple, Dict, Set


numbers: List[int]                # тип всех элементов списка
person:  Tuple[str, int, bool]    # тип каждого элемента кортежа
prices:  Dict[str, int]           # тип ключей, тип значений
answers: Set[float]               # тип всех элементов множества
```

Начиная с Python 3.9 можно использовать **стандартные классы** в точно таких же целях, ничего ниоткуда **не импортируя**:

**Атрибут __annotations__**

Доступ к **использованным в функции аннотациям** можно получить через атрибут **__annotations__**, в котором аннотации представлены в виде словаря, где **ключами** являются **названия параметров**, а **значениями** – их **типы**. При этом, возвращаемое функцией значение хранится в записи с ключом return.

```Python
def print_hello(num1: int, num2: int, num3: int) -> float:
    return (num1 + num2 + num3) / 3


print(print_hello.__annotations__)  # {'num1': <class 'int'>, 'num2': <class 'int'>, 'num3': <class 'int'>, 'return': <class 'float'>}
```

**Полезные типы модуля** **typing**

Многие типы из модуля typing позволяют работать с несколькими типами одновременно. К наиболее часто используемым типам модуля typing относятся:

-        Union
-        Optional
-        Any
-        NoReturn

Тип **Union**

Часто возникает ситуация, когда нужно **объединить несколько типов**, например, для того, чтобы указать, что функция может принимать и целые и вещественные числа. Этого можно достичь при помощи специального типа **Union** из модуля **typing**.

Функция add_or_concatenate() должна принимать аргументы типов int, float, str и возвращает один из трех типов int, float, str:

```Python
from typing import Union


def add_or_concatenate(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str]:
    return a + b
```

```Python
from typing import Union


NumberOrStr = Union[int, float, str]

def add_or_concatenate(a: NumberOrStr, b: NumberOrStr) -> NumberOrStr:
    return a + b
```

Особенности типа Union:
-        Аргументы указываемые в квадратных скобках должны быть типами, причем необходимо указать хотя бы один тип
-        Запись Union[Union[int, str], float] эквивалентна записи Union[int, str, float]
-        Запись Union[int] эквивалентна записи int
-        Запись Union[int, str, int] эквивалентна записи Union[int, str]
-        Запись Union[int, str] эквивалентна записи Union[str, int]

Тип **Optional**

Также очень часто возникает ситуация, когда возможно **либо значение определенного типа, либо None**. Мы можем использовать тип **Optional** следующим образом:

```Python
from typing import Optional


name: Optional[str]
```

По сути name: **Union[str, None]** и name: **Optional[str]** это одно и то же, но второй вариант читается проще.

Тип **Any**

Может возникнуть ситуация, когда не получается указать **какой-либо конкретный тип**, потому что, функция может принимать на вход **абсолютно что угодно**. Для этих случаев тоже есть специальный тип **Any**:

```Python
from typing import Any


def func(arg: Any) -> Any:
    return arg
```

Таким образом любой тип совместим с типом **Any**, как и **Any** совместим с любым типом.

Тип **NoReturn**

Специальный тип **NoReturn** указывает, что функция **никогда не возвращает значение**:

```Python
from typing import NoReturn


def stop() -> NoReturn:
    raise RuntimeError('no way')
```

В экосистеме Python есть несколько конкурирующих между собой тайп-чекеров, например, **mypy**, **pyre**, **pytype**, **pyright**. Данные тайп-чекеры **позволяют находить ошибки связанные с несоответствием типов еще на этапе написания программы**. Самым популярным среди них является **mypy**, автором которого является Гвидо ван Россум.

# 4. Introspection

## 4.1. Интроспекция

Интроспекция — способность объекта во время выполнения получить тип, доступные атрибуты и методы, а также другую информацию, необходимую для выполнения дополнительных операций с объектом

#### Встроенные функции

|Функция|Возвращаемое значение|
|---|---|
|`type(obj)`|тип объекта|
|`dir(obj)`|пространство имен объекта|
|`dir()`|текущее пространство имен|
|`id(obj)`|адрес объекта в памяти|
|`help(obj)`|подсказка к объекту|
|`hasattr(obj, 'attr')`|наличие атрибута у объекта|
|`getattr(obj, 'attr'[, default])`|возвращает атрибут объекта|
|`locals()`|словарь локальных переменных|
|`globals()`|словарь глобальных переменных|

#### Переменные

|Переменная|Значение|
|---|---|
|`__annotations__`|словарь аннотаций типов|
|`__name__`|имя модуля, если он импортирован, или `'__main__'`, если запущен непосредственно.|
|`__file__`|путь к файлу, содержащему объект в системе|

#### Модуль sys

|Функция|Возвращаемое значение|
|---|---|
|`sys.argv`|список аргументов, с которыми запущен интерпретатор|
|`sys.executable`|адрес интерпретатора в системе|
|`sys.flags`|флаги командной строки|
|`sys.getrecursionlimit()`|лимит рекурсии|
|`sys.getsizeof(obj[, default])`|размер объекта|
|`sys.hash_info`|параметры хеширования|
|`sys.modules`|словарь загруженных модулей|
|`sys.path`|список путей для поиска модулей|
|`sys.platform`|операционная система|
|`sys.version`|версия Python|
|`sys.version_info`|версия Python в форме кортежа|

## 4.2 Переменные (Variables)

#TODO 

### 4.2.1 Локальные и глобальные переменные

**Локальными** называются переменные, объявленные внутри функции и доступные только ей самой. Программный код за пределами функции к ним доступа не имеет.

**Глобальными** называются переменные, объявленные в основной программе и доступные как программе, так и всем ее функциям.

Глобальные переменные – **зло**
-        Глобальные переменные затрудняют отладку программы. Значение глобальной переменной может быть изменено любой инструкцией в программном файле. Если обнаружится, что в глобальной переменной хранится неверное значение, то придется отыскать все инструкции, которые к ней обращаются, чтобы определить, откуда поступает плохое значение. В программе с тысячами строк кода сделать это непросто.
-        Функции, использующие глобальные переменные, обычно зависят от этих переменных. Если возникнет необходимость применить такую функцию в другой программе, скорее всего придется эту функцию перепроектировать, чтобы она не опиралась на глобальную переменную.
-        Глобальные переменные затрудняют понимание программы. Глобальная переменная может быть модифицирована любой инструкцией в программе. При необходимости разобраться в какой-то части программы, использующей глобальную переменную, придется узнать обо всех других частях программы, обращающихся к этой глобальной переменной.

### 4.2.2 Работа переменных в Python

Переменные в Python в корне отличаются от переменных в языках C и C++. По сути, их просто нет в Python. Вместо переменных здесь имена. Чаще всего можно воспринимать имена в Python в качестве переменных, но необходимо понимать разницу.

```Python
num = 101
```

В Python исполнение этой строки кода проходит через несколько этапов:
1.      создаётся специальный объект **PyObject**
2.      заполняется его поле **Type**, которое указывает на тип
3.      заполняется его поле **Value**, которое указывает на значение
4.      создаётся имя num
5.      имя num начинает указывать на созданный **PyObject**
6.      счётчик ссылок (поле **Reference Count**) объекта **PyObject** увеличивается на 1
![[Pasted image 20230724153923.png]]
Вместо того чтобы num владел блоком памяти, в котором хранится значение 101, этой памятью владеет PyObject объект. Таким образом, в Python имя переменной **не владеет** напрямую каким-либо **адресом в памяти**.

Для присвоения нового значения имени num мы используем следующий код:

```Python
num = 101
num = 102
```

Исполнение этой строки кода проходит через несколько этапов:
1.      создаётся **новый PyObject**
2.      заполняется его поле **Type**, которое указывает на тип
3.      заполняется его поле **Value**, которое указывает на значение
4.      имя num указывает на **новый PyObject**
5.      счётчик ссылок (поле **Reference Count**) нового PyObject **увеличивается на 1**
6.      счётчик ссылок (поле **Reference Count**) старого PyObject **уменьшается на 1**
![[Pasted image 20230724154042.png]]
Предыдущий объект (содержавший значение 101) теперь находится в памяти со счётчиком ссылок, равным 0, и подлежит удалению с помощью сборщика мусора

Имя переменной в Python указывает на объект и **не владеет областью памяти напрямую**. Также мы видим, что строка кода `num = 101` является **не присваиванием**, а, скорее, **привязкой (binding)** имени `num` к объекту.

Мы можем ввести новое имя `num1`:

```Python
num = 101
num = 102
num1 = num
```
![[Pasted image 20230724154148.png]]
Мы видим, что новый Python объект *не создан*, создано только *новое имя*, которое указывает **на тот же объект**. Кроме того, **счётчик ссылок объекта увеличился на 1.**

**Присваивание**

Помимо простого знака равенства в Python есть и другие виды присваивания. Например, и для чисел, и для списков можно использовать `+=`. Работа `+=` в Python реализована через значение x. Эти две строки эквивалентны:

```Python
x += y
x = x.__iadd__(y)
```

Значение `+=` зависит от типа x, потому что это значение определяет реализацию `__iadd__`, который будет использоваться. С числами `+=` будет работать точно так, как вы и ожидаете. Но со списками `nums = nums + more` свяжет имя `nums` с **новым списком**, сформированным **путем конкатенации** `nums` и `more`. А `nums += more` **модифицирует** сам список `nums` (**мутация**).

Причина этого в том, что список реализует `__iadd__` следующим образом:

```Python
class List:
   def __iadd__(self, other):
      self.extend(other)
      return self
```

Когда вы выполняете `nums += more`, вы получаете то же, что и при следующем присваивании:

```Python
nums = nums.__iadd__(more)
```

которое, в силу реализации `__iadd__`, работает так:

```Python
nums.extend(more)
nums = nums
```

Так что здесь есть операция повторного связывания, но сначала происходит операция **мутации**.

**Аргументы функций**

```Python
def func(x):
    print(x)

num = 17
func(num)
print(num)
```

Здесь `num` — это значение, замещающее параметр `x`. При вызове этой функции мы получаем точно такое же поведение, как если бы выполнили `x = num`. Параметру присваивается настоящее значение.

Каждый вызов функции создает **фрейм стека** — контейнер для имен, **локальных для этой функции**. Имя `x` — **локально** для функции, но суть присваивания остается прежней.

Когда мы находимся внутри функции, у нас есть значение (`17`) с двумя именами: `num` в вызывающем фрейме и `x` — во фрейме функции. Когда функция делает возврат значения, фрейм стека функции уничтожается, а вместе с ним — содержащиеся в нем имена.

[https://techrocks.ru/2021/06/07/names-and-values-in-python/](https://techrocks.ru/2021/06/07/names-and-values-in-python/)

### 4.2.3 Типизация

Языки высокого уровня работают не с битами и байтами, а с более абстрактными структурами данных - **типами**, поэтому эти языки принято считать **типизированными**.

Выделяют несколько видов типизации:  
1. Явная / неявная
2. Статическая / динамическая

|Типизация|Определение|Пример|
|---|---|---|
|Явная|Тип новых переменных, функций и их аргументов необходимо задавать явно.|C++, Pascal, C#|
|Неявная|Языки с неявной типизацией перекладывают эту задачу на компилятор / интерпретатор.|PHP, Python, JavaScript|
|Статическая|Конечные типы переменных и функций устанавливаются на этапе компиляции.|C, Java, C#|
|Динамическая|Все типы выясняются во время выполнения программы.|Python, JavaScript|

В Python типы данных можно разделить на:  
1. **Встроенные** в интерпретатор _(built-in_) и
2. **Не встроенные**, которые можно использовать после импорта соответствующих модулей.

К основным **встроенным** типам относятся:
1. **None** (неопределенное значение переменной)

2. Логические переменные (**Boolean** Type)

3. Числа (**Numeric** Type)
	1. **int**– целое число
	2. **float** – число с плавающей точкой
	3. **complex** – комплексное число

4. Списки (Sequence Type)
	1. **list** – список
	2. **tuple** – кортеж

5. Строки (Text Sequence Type )
	1. **str**

6. Бинарные списки (Binary Sequence Types)
	1. **bytes** – байты
	2. **bytearray** – массивы байт
	3. **memoryview** – специальные объекты для доступа к внутренним данным объекта через protocol buffer

7. Множества (Set Types)
	1. **set** – множество
	2. **frozenset** – неизменяемое множество

8. Словари (Mapping Types)
	1. **dict** – словарь

### 4.2.4 Изменяемые и неизменяемые типы данных

Типы данных в Python делятся на две категории:
-        изменяемые (list, set, dict, bytearray)
-        неизменяемые (int, float, bool, tuple, str, None, function, range, bytes, frozenset)

Все строковые методы возвращают новые объекты, а не изменяют исходные. Аналогичным образом работают методы других неизменяемых типов данных.

В Python существует два типа изменения:
-        присвоение переменной нового значения
-        непосредственное изменение объекта

```Python
nums = [1, 2, 3]
print(nums, id(nums))  # [1, 2, 3] 93086720

nums = [1, 2, 3] + [4]
print(nums, id(nums))  # [1, 2, 3, 4] 93350080
```

Приведенный выше код всегда выводит различные идентификаторы, так как мы не изменяем исходный список, а создаем новый и присваиваем его прежней переменной.

```Python
nums = [1, 2, 3]
print(nums, id(nums))  # [1, 2, 3] 120674368

nums.append(4)
print(nums, id(nums))  # [1, 2, 3, 4] 120674368
```

Приведенный выше код всегда выводит одинаковые идентификаторы, так как мы единожды создаем список, а после изменяем его, добавляя в него новый элемент.

Таким образом, в **первом случае мы изменяем переменную**, то есть изменяем то, на какой объект она ссылается. Во **втором случае мы изменяем сам объект**, на который может ссылаться любое количество переменных.

Важно понимать, что во время изменения объекта, мы изменяем именно **объект, а не переменные**. Другими словами, если какая-либо другая переменная указывает на объект, который мы изменили, эта переменная также отразит это изменение, но не потому что изменилась переменная, а потому что изменился объект, на который она ссылается.

Оператор присваивания в Python **не создает копию объекта**, он лишь **связывает** имя переменной с объектом.

Python **по-разному** обрабатывает сложение списков с помощью операторов `+` и `+=`.

```Python
nums1 = [1, 2, 3]
nums2 = nums1
nums1 = nums1 + [4, 5]
print(nums1, nums2)  # [1, 2, 3, 4, 5] [1, 2, 3]
```

В данном случае оператор **+ создал новый список** `[1, 2, 3, 4, 5]`, который был присвоен переменной `nums1`, при этом `nums2` по-прежнему указывает на старый список `[1, 2, 3]`.

```Python
nums1 = [1, 2, 3]
nums2 = nums1
nums1 += [4, 5]
print(nums1, nums2)
```

В данном случае **оператор `+=`** **изменил** текущий список, и эти изменения также видны в `nums2`. **По сути, оператор `+=` для списков работает как списочный метод** `extend()`.

Считается плохой практикой использование **изменяемых типов данных в качестве значений параметров по умолчанию**, так как значение по умолчанию для параметра **создается единожды при определении функции** (обычно при загрузке модуля) и становится атрибутом (свойством) функции. Поэтому если значением по умолчанию является изменяемый объект, то его изменение повлияет на каждый следующий вызов функции.

```Python
def append(element, seq=[]):
    seq.append(element)
    return seq

print(append(10)) # [10]
print(append(5))  # [10, 5]
print(append(1))  # [10, 5, 1]
print(append(3))  # [10, 5, 1, 3]
```

Для решения проблемы можно использовать константу `None` в качестве значения параметра по умолчанию, а в теле функции устанавливать нужное значение:

```Python
def append(element, seq=None):
    if seq is None:
        seq = []
    seq.append(element)
    return seq

print(append(10))  # [10]
print(append(5))  # [5]
print(append(1))  # [1]
```



# 5. Иное

## 5.1 GIL

### 5.1.1. Global Interpreter Lock

**Global Interpreter Lock** - особенность интерпретатора, когда одновременно может исполняться только один поток, остальные потоки в это время простаивают.

GIL:
-       Не дает Python-процессу исполнять более одной команды байт-кода в каждый момент времени. Это означает, что, даже если имеется несколько потоков на многоядерной машине, интерпретатор сможет в каждый момент времени исполнять только один поток.
-       Многопроцессорные приложения могут конкурентно выполнять несколько команд байт-кода, т.к. у каждого Python-процесса своя собственная GIL.

GIL работает так: на каждый поток выделяется некоторый **квант** времени. Он измеряется в машинных единицах “тиках” и по умолчанию равен 100. Как только на поток было потрачено 100 тиков, интерпретатор бросает этот поток и переключается на второй, тратит 100 тактов на него, затем третий, и так по кругу. Этот алгоритм гарантирует, что всем потокам будет выделено ресурсов поровну.

### 5.1.2 Для чего нужна GIL?

GIL нужен для **предотвращения конфликта потоков**, возникающий из-за того, что интерпретатор CPython не является потокобезопасным. Это означает, что если два или более потоков модифицируют разделяемую переменную, то её конечное состояние может оказаться неожиданным из-за состояния гонки потоков, которое возникает, когда два потока одновременно обращаются к одному объекту Python.

### 5.1.3 Когда освобождается GIL?

GIL освобождается при операциях **ввода-вывода**, но не освобождается для счетных задач

### 5.1.4 Как обойти ограничения, накладываемые GIL?

-       Использовать альтернативные интерпретаторы Python, например PyPy.
-       Уход от многопоточности в сторону мультипроцессорности, используя модуль multiprocessing.

### 5.1.5 GIL, какие проблемы он решает, плюсы и минусы.

GIL – Global Interpreter Lock, есть не только в python, блокирует интерпретатор python на то, что в один момент времени может исполняться только один поток. Python не многопоточный язык по своему дизайну!

-       Борется с конфликтами при обращении к разделяемых объектам
-       Занимается синхронизацией общей памяти при многопоточности
-       Не дает просыпаться лишним потокам невовремя
-       Переключение между потоками: по тикам, по событиям, по таймеру
-       GIL делает любую программу однопоточной

**Плюсы:**

GIL привносит с собой то, что мы можем безболезненно интегрировать в python «с» расширения и безопасно управлять памятью (async – опасно) и программы в однопотоке быстрые!

GIL – это механизм, обеспечивающий при использовании интерпретатора Cpython, безопасную работу с потоками. Но из-за GIL в конкретный момент времени выполнять байт-код Python может лишь один поток операционной системы.

**Минусы:**

В результате с GIL нельзя ускорить Python код интенсивно использующий ресурсы процессора, распределив вычислительную нагрузку по нескольким потокам.

GIL создает дополнительную нагрузку на систему – это замедляет многопоточные программы.

### 5.2 Что такое args, kwargs?

Выражения `*args` и `**kwargs` объявляют в сигнатуре функции. Они означают, что внутри функции будут доступны переменные с именами **args** и **kwargs** (без звездочек). Можно использовать другие имена, но это считается дурным тоном.

**args** - принимает неограниченное количество позиционных (неименнованых) аргументов функции, представлен в виде **tuple**

**kwargs** – принимает неограниченное количество аргументов функции переданных с помощью ключевых слов, представлен в виде **dict**

> Важно: если в функцию не передано никаких параметров, переменные будут соответственно равны пустому кортежу и пустому словарю, а не `None`.

### 5.3 Анонимные функции

### 5.3.1 lambda

Помимо стандартного определения функции, состоящего из ее заголовка с ключевым словом def и блока кода – тела функции, в Python можно создавать короткие однострочные функции с использованием оператора lambda. Это анонимные функции или лямбда-функции.

Анонимные функции – **функции с телом, но без имени**.

Общий формат определения анонимной функции: `lambda список_параметров: выражение`.

Тут _список_параметров_ – список параметров через запятую, _выражение_ – значение, либо код, дающий значение.

```Python
def standard_function(x):          #  стандартное объявление функции
    return x*2

lambda_function = lambda x: x*2    #  объявление анонимной функции

f1 = lambda: 10 + 20               # функция без параметров
f2 = lambda х, у: х + у            # функция с двумя параметрами
f3 = lambda х, у, z: х + у + z     # функция с тремя параметрами
```

Когда применение анонимных функций оправдано:
-       Однократное использование функции;

```Python
points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)]

print(sorted(points, key=lambda point: point[1]))  # сортируем по второму значению кортежа
print(sorted(points, key=lambda point: point[0] + point[1])) # по сумме элементов
```

-       Передача функций в качестве аргументов другим функциям;

```Python
numbers = [1, 2, 3, 4, 5, 6]

new_numbers1 = list(map(lambda x: x+1, numbers))      #  увеличиваем на 1
new_numbers2 = list(map(lambda x: x*2, numbers))      #  удваиваем
new_numbers3 = list(map(lambda x: x**2, numbers))     #  возводим в квадрат

numbers = [-1, 2, -3, 4, 0, -20, 10, 30, -40, 50, 100, 90]

positive_numbers = list(filter(lambda x: x > 0, numbers))      #  положительные числа
large_numbers = list(filter(lambda x: x > 50, numbers))        #  числа, большие 50
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))     #  четные числа
```

-       Возвращение функции в качестве результата другой функции.

```Python
def generator_square_polynom(a, b, c):
    return lambda x: a*x**2 + b*x + c
```

### 5.3.2 Условный оператор в теле анонимной функции

В теле анонимной функции не получится выполнить несколько действий и не получится использовать многострочные конструкции вроде циклов `for` и `while`. Однако можно использовать тернарный условный оператор.

```Python
numbers = [-2, 0, 1, 2, 17, 4, 5, 6]
result = list(map(lambda x: 'even' if x % 2 == 0 else 'odd', numbers))
print(result)
```

### 5.3.3 Передача аргументов в анонимную функцию

Как и обычные функции, определенные с помощью ключевого слова def , анонимные функции поддерживают все способы передачи аргументов:
-       Позиционные аргументы;
-       Именованные аргументы;
-       Переменный список позиционных аргументов (\*args);
-       Переменный список именованных аргументов (\*\*kwargs);
-       Обязательные аргументы (\*).

```Python
f1 = lambda x, y, z: x + y + z
f2 = lambda x, y, z=3: x + y + z
f3 = lambda *args: sum(args)
f4 = lambda **kwargs: sum(kwargs.values())
f5 = lambda x, *, y=0, z=0: x + y + z
```

### 5.3.4 Особенности и ограничения анонимных функций в Python

-       Анонимная функция может содержать только выражение, и не может включать в свое тело операторы;
-       В теле анонимной функции такие операторы, как return, pass, assert или raise, вызовут исключение SyntaxError;
-       Анонимная функция пишется как одна строка исполнения;
-       Анонимная функция может быть немедленно вызвана.

Анонимные функции очень часто используются вместе со встроенными функциями `map()`, `filter()`, `reduce()`, `sorted()`, `max()`, `min()` и т.д.

Анонимные функции являются выражениями, то есть их можно сразу вызывать в момент определения.

```Python
print((lambda x, y: x + y)(10, 7))          # 17
print(eval('(lambda num: num ** 2)(7)'))    # 49
```

В анонимных функциях может быть использована рекурсия.

```Python
fact = lambda n: 1 if n == 0 else n*fact(n - 1)

for i in range(10):
    print(fact(i))
```

### 5.4. Вложенные функции, замыкания

### 5.4.1 Вложенные функции

Python позволяет определять функции внутри других функций. Их называют вложенными функциями или внутренними функциями.

```Python
def speak(text):
    def whisper(t):              # объявляем вложенную функцию
        return t.lower() + '...'
    return whisper(text)         # вызываем вложенную функцию и возвращаем ее результат

print(speak('Hello, World')) 
```

Каждый раз, когда мы вызываем функцию `speak()`, она определяет новую внутреннюю функцию `whisper()`, а затем вызывает ее. При этом функция `whisper()` не существует вне родительской функции `speak()`.

Если нам нужно получить доступ к вложенной функции `whisper()` извне, то мы можем вернуть ее (вложенную функцию) вызывающей стороне родительской функции.

### 5.4.2 Замыкания

Вложенные функции могут захватывать и переносить с собой часть состояния родительской функции.

```Python
def get_speak_func(text, volume):
    def whisper():
        return text.lower() + '...'
    def yell():
        return text.upper() + '!'
    
    if volume > 0.5:
        return yell
    else:
        return whisper

yell = get_speak_func('Hello, World', 0.7)
print(yell())
```

Теперь вложенные функции `whisper()` и `yell()` **не имеют параметра text**. Они его получают и используют через **родительскую функцию** `get_speak_func()`. Функции, которые делают это, называются **замыканиями**. **Замыкание запоминает значения из включающей его области**, даже если поток программы больше не находится в этой области.

**Замыкание** — это особый вид функции. Она определена в теле другой функции и создаётся каждый раз во время её выполнения. Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней функции.

```Python
def closure():
    count = 0
    def inner():
        nonlocal count
        count += 1
        print(count)
    return inner

start = closure()
another = closure()             # другое замыкание, со своими локальными значениями
start()                         # выводит 1
start()                         # выводит 2
another()                       # выводит 1
start()                         # выводит 3
```

Замыкания очень полезны при решении многих задач. С их помощью функции могут не только возвращать поведение, но и предварительно настраивать это поведение.

### 5.4.3 Нелокальные переменные

При поиске переменной с указанным именем приоритет (правило разрешения имен) следующий:
-       сначала ищем локальную переменную
-       если не нашли локальную, ищем нелокальную
-       если не нашли нелокальную, ищем глобальную
-       и в самом конце — встроенную в язык

**Промежуточная область видимости, которая доступна вложенным функциям, называется нелокальной**. Если вложенность функций больше двух уровней, нелокальная переменная ищет в «ближайшей» области видимости, т. е. в функции вложенностью на один меньше. Если не находит, поиск переходит в самую ближнюю из внешних областей видимости, затем в чуть более далекую — и так далее, пока не найдется нужное имя. **Фактически интерпретатор ищет там, «где поближе»**.

Ключевое слово `nonlocal`

Вложенная функция видит переменные в родительской функции, которые называются **нелокальными** или **свободными** переменными.

```Python
def outer_function():
    num = 5
    def inner_function():      # определяем вложенную функцию
        num += 10
        print(num)
    inner_function()           # вызываем вложенную функцию
        
outer_function()
```

Такой код приводит к возникновению ошибки:

```UnboundLocalError: local variable 'num' referenced before assignment```

Дело в том, что вложенная функция не просто обращается (получает значение) к переменной num, но и **пытается его изменить**! **Внутренняя функция видит переменные в объемлющей функции**, но, если она хочет такую переменную изменить, должна объявить ее **nonlocal**.

```Python
def outer_function():
    num = 5
    def inner_function():      # определяем вложенную функцию
        nonlocal num
        num += 10
        print(num)
    inner_function()           # вызываем вложенную функцию
        
outer_function()  # 15
```

Атрибут `__closure__`

Все функции содержат специальный атрибут `__closure__`, который представляет из себя кортеж, содержащий данные, связанные с вложенными областями видимости, то есть с нелокальными переменными.

```Python
def outer_function(arg):
    num = 5
    name = 'Timur'
    numbers = [1, 2, 3]
    def inner_function():      # определяем вложенную функцию
        print(arg)
        print(num)
        print(numbers)
    return inner_function      # возвращаем вложенную функцию
        
inner = outer_function('python')

for var in inner.__closure__:
    print(var.cell_contents)

# python
# 5
# [1, 2, 3]
```

кортеж `__closure__` содержит внутри себя **специальный тип данных**. Для получение самого значения захваченной переменной нужно использовать атрибут **cell_contents**.

### 5.4.4 Когда использовать замыкания

Концепция замыканий, то есть функций, захватывающих нелокальные переменные, находят много применений при написании кода. Замыкания хороши для:

-       **воздержания от жестко закодированных констант**
-       **воздержания от использования глобальных переменных**
-       **воздержания от создания ненужных типов данных (классов)**
-       **замыкания нужны для реализации декораторов**

**Сокрытие данных** основное преимущество замыканий.

Вложенные (внутренние) функции позволяют избавиться от глобальных переменных. Такая техника позволяет сделать внешнюю для функции переменную, но при этом спрятанную от посторонних глаз, в отличие от глобальной. Такие переменные нужны в первую очередь для того, чтобы хранить какие-то данные, относящиеся к функции, между вызовами функции. Локальные переменные стираются при выходе из функции, глобальные — сохраняются, но видны всему свету, а нелокальные — идеальное сочетание закрытости и «сохраняемости».

Если функция использует глобальные переменные, это тоже замыкание. Но чаще всего замыканием называют все-таки функцию, которая использует нелокальные переменные. Такая функция как бы «таскает за собой» свои внешние переменные, но никому их не показывает.

### 5.5 Модули (Module) и Пакеты (Package) в Python

### 5.5.1 Модуль

**модуль(module)** в Python - это просто файл, содержащий код на Python. Каждый модуль может содержать переменные, классы и функции. Кроме того, в модуле может находиться исполняемый код. Имя модуля соответствует имени файла. Например:

```
# Имя файла
math.py

# Имя модуля
math
```

Каждая программа может импортировать модуль и получить доступ к его классам, функциям и объектам.

> Модуль - это отдельный файл с кодом на Python, который:  
> 1. Имеет расширение ***.py** (имя файла без расширения является именем модуля).
> 2. Может быть импортирован.
> 3. Может быть многократно использован.
> 4. Позволяет вам логически организовать ваш код на Python.

### 5.5.2. Пакет

Если начать делить код достаточно большого проекта на модули, то довольно быстро может возникнуть желание сгруппировать несколько близких по тематике модулей. Или же мы захотим вынести часть модулей из проекта, чтобы их можно было использовать в других проектах. И тут нам на помощь приходят **пакеты(packages)** в Python, которые служат для объединения модулей в группы.
![[Pasted image 20230724114841.png]]
**Пакет** - это набор взаимосвязанных модулей(при этом стоит уточнить, что сам пакет тоже является модулем), предназначенных для решения задач определенного класса некоторой предметной области. Это такой способ структуризации модулей. Пакет представляет собой папку, в которой содержатся модули и другие пакеты и обязательный файл **__init__.py**, отвечающий за инициализацию пакета.

Пример содержимого каталога стандартного пакета **json**, который, как можно заметить, состоит из 4 модулей и файла **__init__.py**:

```
json/
├── __init__.py
├── decoder.py
├── encoder.py
├── scanner.py
└── tool.py
```

> Пакет - это каталог с модулями, другими пакетами и файлом **__init__.py**. При этом:  
> 1. Именем пакета является название данного каталога.
> 2. С версии Python 3.3 любая папка (даже без **__init__.py**) считается пакетом.
> 3. Пакет может быть импортирован(так же как и модуль).
> 4. Пакет может быть многократно использован(так же как и модуль).

### 5.5.3 Классификация модулей

Для удобной и эффективной разработки на Python создано огромное количество модулей и пакетов. Их все можно разделить на 3 группы в зависимости от того, кем создается и где хранится код конкретного модуля:  

1. Стандартная библиотека Python (_англ._ Standard Library).
2. Сторонние модули (_англ._ 3rd Party Modules)
3. Пользовательские модули
![[Pasted image 20230724115158.png]]
### 5.5.4 Инструкция импорта import
![[Pasted image 20230724115421.png]]

Чтобы воспользоваться функционалом модуля или пакета, необходимо его импортировать внутрь вашей программы. При импорте интерпретатор сначала ищет **встроенный** модуль с заданным именем. Если такого модуля нет, то идёт поиск файла **<имя_модуля>.py** в списке директорий, определённых в переменной **sys.path**.  
  
Переменная **sys.path** (атрибут **path** модуля **sys**) – это список строк, которые указывают пути поиска для модулей. При инициализации данный список включает:  

1. рабочую директорию скрипта (основного модуля);
2. переменную окружения **PYTHONPATH** и пути инсталляции Python

Если модуль не удается найти, возбуждается исключение **ImportError**.

При импорте модуля Python выполняет весь код в нём, а при импорте пакета Python выполняет код в файле пакета **__init__.py**, если такой имеется. Все объекты, определённые в модуле или **__init__.py**, становятся доступны импортирующему.

### 5.5.5 Инструкция импорта from ... import

Инструкция **from...import** чаще всего используется для частичного импорта.

```
from <модуль/пакет> import <атрибут/модуль_1> [ as <псевдоним_1> ], [<атрибут/модуль_2> [ as <псевдоним_2> ] ...]
```

В каких ситуациях необходим частичный импорт?  

1. Нужно импортировать только один или несколько модулей из пакета.
2. Нужно импортировать только один или несколько атрибутов(функций или классов) из модуля.

### 5.5.6 Относительный и абсолютный импорт

При работе с пакетами может возникнуть ситуация, когда необходимо импортировать подпакет или модуль из другого каталога - соседнего или на уровень выше/ниже. Чтобы интерпретатор Python понял, где искать, ему нужно указать правильный путь в дереве каталогов к модулю/пакету, который вы собираетесь импортировать. В Python данный путь(как и сам импорт) может быть двух видов:  

1. Абсолютный
2. Относительный

**Абсолютный импорт**

При абсолютном импорте используется полный путь к желаемому(импортируемому) модулю. Полный путь к модулю - это путь от **корневой папки** проекта. Формат абсолютного пути:  

**<пакет_1>.<пакет_2>.<пакет_n>.<модуль/пакет>**  
  
Например, если рассмотреть проект со следующей структурой:

```
projectfruits
    ├── citrus
          ├── __init__.py
          ├── grapefruit.py
          ├── lemon.py
          └── orange.py
    ├── apple.py
    └── banana.py
```

То абсолютные пути модулей проекта будут выглядеть следующим образом:

```
citrus.grapefruit
citrus.lemon
citrus.orange
apple
banana
```

При абсолютном импорте одинаково могут использоваться обе выше рассмотренные инструкции:

- `import <полный_путь>`
- `from <полный_путь> import <объект_импорта>`

```Python
# Импортируем модуль apple в модуль lemon
import apple

# Импортируем функцию baz из модуля apple в модуль lemon
from apple import baz

# Импортируем модуль lemon в модуль apple двумя равнозначными способами
import citrus.lemon
from citrus import lemon

# Импортируем функцию foo из модуля lemon в модуль apple
from citrus.lemon import foo
```

**Относительный импорт**  
Как несложно будет догадаться, при относительном виде импорта используются относительные пути к импортируемому файлу. Относительный путь показывает, на **сколько директорий вверх** необходимо подняться. Формат относительного пути:  

**.<модуль/пакет>**

Количество точек в начале указывает, как необходимо перемещаться по директориям пакета.  Одна точка `.` означает, что пакет/модуль лежит в текущей директории. Две точки `..` говорят о том, что необходимо подняться на уровень выше и так далее.

При относительном импорте(в отличие от абсолютного) может использоваться только вторая инструкция:

```
from <относительный путь> import <объект_импорта>
```

```Python
# Импортируем модуль lemon в модуль orange(находятся в одном пакете citrus)
from . import lemon

# Импортируем функцию foo из модуля lemon в модуль orange(находятся в одном пакете citrus)
from .lemon import foo
```

> Как правило, абсолютные импорты предпочтительнее относительных. [PEP 8](https://www.python.org/dev/peps/pep-0008) рекомендует использовать абсолютный импорт, но утверждает, что в некоторых сценариях допустим и относительный импорт.

### 5.5.7 Виртуальные окружения Python. Модуль venv.

При создании приложений на Python могут возникнуть несколько проблем, которые связаны с использованием библиотек разных версий. Например:  

1. Разные проекты используют одни и те же библиотеки, но при этом версии библиотек отличаются.
2. Возможна ситуация, когда для корректной работы приложения необходимо зафиксировать версию одной из библиотек-зависимостей. Очевидно, что в данной ситуации пользоваться глобальным хранилищем библиотек будет неуместным, так как это может повлечь за собой цепочку проблем.
3. У приложения может не быть доступа к каталогу глобального хранилища пакетов.

Для решения вышеперечисленных задач используется подход, основанный на построении **виртуальных окружений Python** – своего рода песочниц, внутри которых изолированно запускается приложение со своими библиотеками. При этом если данное приложение обновляет и изменяет данные библиотеки, это никак не затрагивает другие приложения с такими же библиотеками-зависимостями. Таким образом, виртуальное окружение в Python — способ изолировать зависимости (пакеты) для определённого проекта.
![[Pasted image 20230724120548.png]]
**Как создать виртуальное окружение?**  
Существует достаточно много модулей, которые позволяют создавать виртуальные окружения в Python. Некоторые уже входят в стандартную библиотеку(**venv**), другие необходимо установить из каталога PyPI(**virtualenv**, **pyenv**).  
  
Создать виртуальную среду с помощью выбранной утилиты можно по-разному, в зависимости от того, где вы работаете с кодом:  

1. Можно создать виртуальное окружение в консоли. Например, в случае стандартного модуля **venv** это будет выглядеть следующим образом: **python3 -m venv /path/to/new/virtual/****environment**
2. Если вы работаете с IDE(например, PyCharm) при создании проекта необходимо выбрать соответствующую опцию по созданию виртуального пространства. Обратите внимание, что в зависимости от уже установленных библиотек, в выпадающем списке могут быть доступны несколько вариантов модулей, создающих виртуальные среды:
![[Pasted image 20230724120621.png]]

В результате создается директория с говорящим названием **venv**, которая содержит все файлы, необходимые для поддержания и корректного функционирования свежесозданной виртуальной среды. Содержимое данного каталога на Linux выглядит приблизительно так:

```
├── bin
│   ├── activate
│   ├── activate.csh
│   ├── activate.fish
│   ├── easy_install
│   ├── easy_install-3.5
│   ├── pip
│   ├── pip3
│   ├── pip3.8
│   ├── python -> python3.8
│   ├── python3 -> python3.8
│   └── python3.8 -> /Library/Frameworks/Python.framework/Versions/3.8/bin/python3.8
├── include
├── lib
│   └── python3.8
│       └── site-packages
└── pyvenv.cfg
```

**Как активировать виртуальную среду?**  
Итак, вы создали виртуальное пространство для вашего проекта и хотите им воспользоваться. Для этого необходимо его активировать. Процесс активации среды немного различается в зависимости от типа операционной системы:

```Shell
# Для Linux
# Используем команду source и передаем ей скрипт activate из папки bin
$ source my_project/venv/bin/activate

# Для Windows
# Запускаем bat-файл activate.bat
> D:\home\python\project\env\Scripts\activate.bat
```

**Работа внутри виртуальной среды**  
Теперь с помощью одного из менеджеров пакетов(**pip** или **easy_install**) можно просматривать/устанавливать/изменять/удалять пакеты. Несколько примеров с использованием менеджера **pip**:

```
# Список установленных библиотек
$ pip3 list
Package            Version 
------------------ -------- 
certifi            2019.3.9     
pip                19.3.1   
pytest             5.4.2   
requests           2.22.0  
selenium           3.141.0 
setuptools         41.6.0  
six                1.12.0  
urllib3            1.25.2  

# Установка библиотеки requests
$ pip3 install requests

# Удаление библиотеки six
$ pip3 uninstall six
```

**Как деактивировать виртуальную среду?**  
После того, как вы завершили работу с текущей средой, необходимо ее деактивировать. Процесс так же немного отличается на разных типах ОС:

```Shell
# Для Linux
# В рамках текущей сессии вызываем команду deactivate
(venv) $ deactivate

# Для Windows
# Запускаем bat-файл deactivate.bat
> D:\home\python\project\env\Scripts\deactivate.bat
```

### 5.5.8 Исполняемая часть модуля. Переменная **__name__**.

Модуль в Python можно использовать следующим образом:  

1. Запустить автономно. Модуль - это скрипт на Python, а значит, его можно запустить в терминале/консоли или через IDE.
2. Импортировать. При этом, как мы уже рассмотрели выше, используется инструкция **import**.

При написании модуля необходимо заранее продумать, будет он запускаться самостоятельно, или он предназначен для импорта в другие модули. Почему это важно? Потому что, при импорте исполняемая часть кода будет выполнена интерпретатором.  
  
Рассмотрим пример. Перед нами модуль **calculator**, который содержит две функции(**sum_up()** для сложения и **sub()** для вычитания) и исполняемую часть(тесты функций модуля):

```Python
# Функции
def sum_up(a, b):
    return a + b


def sub(a, b):
    return a - b


# Исполняемый код
print('Сумма: ', sum_up(2, 3))
print('Разность: ', sub(5, 1))
```

Если мы запустим модуль `calculator` самостоятельно, то будет выполнена исполняемая часть. Вывод в консоль:

```Shell
$ python3 calculator.py 
Сумма:  5
Разность:  4
```

А что произойдет с исполняемой частью, если мы импортируем модуль **calculator** внутрь другого модуля? Ответ - то же самое! Она также будет выполнена интерпретатором. Нужно ли это во время импорта? В подавляющем большинстве случаев - **нет**.

Как этого избежать? Как сделать так, чтобы при автономном запуске скрипта исполняемая часть выполнялась, а при импорте - нет? Ответ следующий: достаточно использовать **специальный атрибут модуля** **__name__**, который меняет свое значение в зависимости от того, запущен модуль или импортирован:  

1. Атрибут **__name__** содержит имя модуля, если он был импортирован (например, "**calculator**" или "**math**")
2. Атрибут **__name__** принимает значение "**__main__**", если модуль был запущен автономно.

Соответственно для решения проблемы поступают следующим образом:  

1. Вспомогательные модули(т. е. те модули, которые планируется **импортировать**) избавляются от кода вне функций и/или классов.
2. В основном файле программы(тот модуль, который планируется **запускать**) вставляется проверка атрибута **__name__**. Выглядит эта проверка следующим образом:

```Python
# Классы/ функции модуля
# <..>

if __name__ == '__main__':
    # Исполняемая часть
    # <..>
```

При наличии такой проверки если этот файл будет импортирован, его исполняемый код не будет выполняться интерпретатором Python.
