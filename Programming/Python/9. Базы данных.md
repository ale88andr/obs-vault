![[Pasted image 20230710094652.png]]

## 9.1 Основы баз данных
---
### 9.1.1 Реляционная модель

**Реляционная модель** баз данных - это способ организации данных в базе данных с использованием таблиц, где информация представлена в виде строк и столбцов. Основная идея заключается в том, что данные представляются в виде "отношений" между таблицами.

Вот простое объяснение ключевых понятий реляционной модели:

1. **Таблицы**: Основные сущности в реляционной модели. Каждая таблица представляет собой набор данных, организованных в строки и столбцы. Например, таблица с информацией о пользователях со столбцами "Имя", "Возраст", "Email" и т.д.
2. **Строки**: Каждая строка в таблице представляет собой отдельную запись или кортеж, содержащий конкретные данные. Например, одна строка может содержать информацию о конкретном пользователе.
3. **Столбцы**: Каждый столбец представляет собой конкретный атрибут данных. Например, в таблице с информацией о пользователях, столбец "Имя" содержит имена пользователей.
4. **Ключи**: Ключи используются для идентификации уникальных записей в таблице. Основные типы ключей - это первичный ключ (Primary Key), который уникально идентифицирует каждую запись, и внешний ключ (Foreign Key), который связывает две таблицы между собой.
5. **Отношения**: Отношения между таблицами могут быть установлены с использованием ключей. Например, внешний ключ в одной таблице может ссылаться на первичный ключ в другой таблице, устанавливая связь между ними.
6. **Целостность данных**: Реляционная модель поддерживает различные ограничения, такие как уникальность значений, ссылочная целостность (foreign key constraints) и другие, которые гарантируют корректность и согласованность данных.
7. **Язык SQL**: Для работы с реляционными базами данных используется язык SQL (Structured Query Language). SQL предоставляет средства для выполнения запросов, добавления, обновления и удаления данных.

Реляционная модель баз данных является популярным и мощным способом организации данных, который позволяет эффективно хранить, извлекать и управлять информацией.

### 9.1.2 Транзакции

**Транзакция** - набор операций(блок операций, в котором будут выполнены все операции, либо не пройдет ни одна) над базой данных, рассматриваемых как единая и неделимая единица работы.

**Транзакция** - это логическая операция или последовательность операций в системе управления базами данных (СУБД), которая рассматривается как единое целое. Транзакция представляет собой способ гарантировать целостность, согласованность и надежность взаимодействия с данными в базе данных. Она обычно представляет собой одну или несколько операций чтения или записи данных в базе данных.

Основные свойства транзакций включают в себя:

1. **Атомарность (Atomicity)**: Транзакция считается атомарной, что означает, что либо все операции внутри транзакции успешно выполняются, либо ни одна из них не выполняется. Если хотя бы одна операция в транзакции завершается с ошибкой, то все изменения, сделанные этой транзакцией, отменяются (откат), и база данных остается в исходном состоянии.
    
2. **Согласованность (Consistency)**: Транзакция должна приводить базу данных из одного согласованного состояния в другое согласованное состояние. Это означает, что транзакция должна уважать все ограничения целостности и правила базы данных.
    
3. **Изолированность (Isolation)**: Транзакции выполняются параллельно, но их изменения не должны видеть друг друга до завершения. Это предотвращает конфликты и гарантирует, что транзакции не влияют друг на друга в процессе выполнения.
    
4. **Надежность (Durability)**: Когда транзакция завершается успешно, ее результаты должны сохраняться даже в случае сбоя системы. Это означает, что данные, записанные в базу данных, должны быть надежно сохранены и восстановлены после сбоя, чтобы обеспечить устойчивость данных.

Примером транзакции может быть перевод денег с одного банковского счета на другой. В этом случае транзакция может включать операции снятия денег с одного счета и зачисления их на другой. Если любая из этих операций не удастся (например, из-за недостатка средств), то транзакция будет отменена, и ни одна из операций не будет выполнена.

Транзакции играют важную роль в обеспечении целостности данных и управлении параллельным доступом к базе данных в многопользовательских системах.

**Уровни изоляции транзакций** - это концепция в системах управления реляционными базами данных (СУБД), которая определяет, как одна транзакция взаимодействует с данными во время выполнения и какие виды блокировок применяются для предотвращения конфликтов между транзакциями. Уровни изоляции определяют уровень видимости изменений, внесенных одной транзакцией, для других транзакций во время их выполнения.

Существует несколько уровней изоляции транзакций, каждый из которых предоставляет разные гарантии по отношению к согласованности данных и производительности. Вот основные уровни изоляции:

1. **READ UNCOMMITTED (Чтение незафиксированных данных)** - чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, изменённые другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок. Невозможны потерянные изменения, возможны неповторяемое чтение и фантомы:
    - Позволяет транзакциям видеть нефиксированные изменения других транзакций.
    - Не обеспечивает изоляцию транзакций и может приводить к чтению "грязных данных" (незафиксированных изменений).
2. **READ COMMITTED (Чтение фиксированных данных)** - чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций. Потерянные изменения и грязное чтение не допускается, возможны неповторяемое чтение и фантомы:
    - Гарантирует, что транзакции видят только фиксированные изменения других транзакций.
    - Избегает грязного чтения, но может допустить чтение неконсистентных данных из-за "фантомных строк".
3. **REPEATABLE READ (Повторяемое чтение)** - чтение всех изменений своей транзакции, любые изменения, внесённые параллельными транзакциями после начала своей, недоступны. Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы:
    - Гарантирует, что транзакции видят только данные, считанные на момент начала транзакции.
    - Предотвращает грязное чтение и фантомные строки, но допускает чтение неконсистентных данных из-за конфликтов с блокировками.
4. **SERIALIZABLE (Сериализуемость)** - результат параллельного выполнения сериализуемой транзакции с другими транзакциями должен быть логически эквивалентен результату их какого-либо последовательного выполнения. Проблемы синхронизации не возникают:
    - Обеспечивает наивысший уровень изоляции, предотвращая все виды аномалий, такие как грязное чтение, фантомные строки и конфликты.
    - Гарантирует, что транзакции выполняются так, как если бы они были выполнены одна за другой, не параллельно.

Каждый уровень изоляции имеет свои преимущества и недостатки, и выбор уровня зависит от требований приложения. Более строгие уровни изоляции обеспечивают большую надежность и согласованность данных, но могут снижать производительность из-за большего количества блокировок. Более низкие уровни изоляции могут улучшить производительность, но могут вносить риск аномалий данных.

Уровни изоляции транзакций важны для обеспечения правильного функционирования многопользовательских приложений, работающих с базами данных, и для предотвращения конфликтов и аномалий при одновременном доступе к данным.

### 9.1.3 ACID

#TODO 

### 9.1.4 N+1 Problem

Проблема **n+1** в контексте баз данных относится к эффективности запросов данных. Эта проблема возникает, когда вы выполняете один запрос для получения списка сущностей (например, пользователей) и затем для каждой сущности делаете дополнительный запрос, чтобы получить связанные с ней данные (например, посты каждого пользователя).

Давайте рассмотрим пример с социальной сетью:

1. Вы выполняете запрос для получения списка пользователей.
2. Затем, для каждого пользователя в списке, вы выполняете ещё один запрос, чтобы получить его посты.

Если у вас есть **n** пользователей в списке, это означает, что вы выполняете **n+1** запросов к базе данных (1 запрос для списка пользователей и ещё **n** запросов для постов каждого пользователя).

Это может быть неэффективным, особенно при больших объемах данных, так как каждый дополнительный запрос к базе данных требует времени на обработку и передачу данных, что может сильно замедлить приложение.

Для решения проблемы **n+1** можно использовать методы оптимизации запросов, такие как предварительная загрузка данных (eager loading) или объединение запросов (query batching). Эти методы позволяют сделать всего один запрос к базе данных, чтобы получить все необходимые данные, вместо множества отдельных запросов. Таким образом, можно улучшить производительность и снизить нагрузку на базу данных.

### 9.1.5 **SQL Injection**

**SQL Injection** - это тип атаки на веб-приложения, при которой злоумышленник вводит вредоносный SQL-код в поля ввода веб-формы или параметры URL, с целью выполнения нежелательных операций в базе данных. Эта атака возникает из-за недостаточной или неправильной фильтрации ввода данных, передаваемых пользователем.

Пример SQL Injection:

Предположим, у вас есть веб-приложение, которое принимает имя пользователя и пароль, а затем выполняет SQL-запрос для аутентификации:

```SQL
SELECT * FROM users WHERE username = 'введенное_имя' AND password = 'введенный_пароль'
```

Если злоумышленник введет следующий текст в поле "Имя пользователя":

```SQL
' OR '1'='1
```

SQL-запрос может преобразиться в следующий вид:

```SQL
SELECT * FROM users WHERE username = '' OR '1'='1' AND password = 'введенный_пароль'
```

В результате этого запроса, так как условие '1'='1' всегда истинно, злоумышленник может получить доступ к аккаунту даже без знания правильного пароля.

Для защиты от SQL Injection необходимо использовать параметризованные запросы или правильно фильтровать и экранировать ввод пользователя, чтобы предотвратить внедрение вредоносного SQL-кода. Также важно обновлять и поддерживать вашу систему безопасности, чтобы избежать уязвимостей.

Чтобы предотвратить атаки SQL Injection, рекомендуется следовать нескольким базовым принципам безопасности:

1. **Использование параметризованных запросов (Prepared Statements)**: Используйте библиотеки или ORM (Object-Relational Mapping), которые поддерживают параметризованные запросы. Это позволяет отделить данные пользователя от кода SQL и предотвращает внедрение вредоносного кода.

```Python
import sqlite3

# Подключение к базе данных
conn = sqlite3.connect('my_database.db')
cursor = conn.cursor()

# Безопасный SQL-запрос с использованием параметризованного запроса
username = input("Введите имя пользователя: ")
password = input("Введите пароль: ")

cursor.execute("SELECT * FROM users WHERE username=? AND password=?", (username, password))

# Получение результатов
result = cursor.fetchone()
if result:
    print("Вы успешно вошли в систему.")
else:
    print("Ошибка аутентификации.")

# Закрытие соединения с базой данных
conn.close()
```
    
2. **Экранирование (Escaping)**: Если вы не можете использовать параметризованные запросы, удостоверьтесь, что вы правильно экранируете (экранирование специальных символов) все данные пользователя, прежде чем включать их в SQL-запрос.
    
3. **Принцип наименьших привилегий**: Назначайте пользователям в базе данных только те права, которые им действительно необходимы. Например, если пользователь только читает данные, не давайте ему право изменять или удалять.
    
4. **Ограничение доступа к базе данных**: Ограничьте доступ к базе данных средствами брандмауэра и настройками сетевой безопасности, чтобы только доверенные и необходимые приложения имели доступ к ней.
    
5. **Регулярные обновления и патчи**: Убедитесь, что ваша система и все используемые библиотеки и фреймворки обновляются регулярно, чтобы устранять известные уязвимости.
    
6. **Внимательность к вводу данных пользователя**: Всегда проверяйте и валидируйте данные, поступающие от пользователей. Не доверяйте им и не используйте их напрямую в SQL-запросах без предварительной обработки.
    
7. **Мониторинг и журналирование**: Ведите журнал всех SQL-запросов, выполняемых вашим приложением. Это может помочь в обнаружении подозрительной активности.
    
8. **Обучение и обновление персонала по безопасности**: Обучите членов вашей команды и разработчиков о методах предотвращения SQL Injection и других типах атак.

### 9.1.6 NoSQL

**NoSQL** (*Not Only SQL*) — это подход к хранению и управлению данными, который предоставляет альтернативу реляционным базам данных (SQL-базам данных). Основная идея NoSQL состоит в том, чтобы эффективно хранить и обрабатывать данные, которые не всегда легко представить в табличной форме, как это делается в реляционных базах данных. Вот ключевые характеристики и объяснение NoSQL:

1. **Гибкость в модели данных:** Реляционные базы данных требуют строгой схемы данных, где структура таблицы определяется заранее. В NoSQL базах данных схема данных более гибкая. Вы можете добавлять, изменять и удалять поля из документов (в случае документоориентированных баз данных), коллекций (для баз данных типа ключ-значение) или графов (для графовых баз данных) без необходимости перепроектирования всей базы данных.
    
2. **Горизонтальное масштабирование:** NoSQL базы данных часто легче масштабируются горизонтально, что означает, что вы можете добавлять новые серверы или узлы кластера для обработки больших объемов данных и нагрузки. Это делает их более подходящими для распределенных и высоконагруженных приложений.
    
3. **Разные модели данных:** NoSQL базы данных поддерживают разные модели данных, такие как ключ-значение, документоориентированная, графовая и колоночная. Это позволяет выбирать наиболее подходящую модель для конкретного типа данных и запросов.
    
4. **Высокая производительность:** NoSQL базы данных обычно обеспечивают высокую производительность при чтении и записи данных. Они оптимизированы для определенных типов операций, что делает их эффективными для определенных приложений и нагрузок.
    
5. **Горизонтальное разделение данных:** NoSQL базы данных могут автоматически разделять данные между различными узлами, что способствует равномерному распределению нагрузки и обеспечивает отказоустойчивость.
    
6. **Простая репликация:** Многие NoSQL системы предоставляют встроенную поддержку репликации данных для обеспечения отказоустойчивости и увеличения доступности.
    

Примеры популярных NoSQL баз данных включают MongoDB (документоориентированная), Cassandra (колоночная), Redis (ключ-значение), Neo4j (графовая) и многие другие. Выбор NoSQL или SQL базы данных зависит от конкретных потребностей вашего приложения, типа данных и требований к производительности.

## 9.2 SQL
---
### 9.2.1 DDL

Команды языка SQL делятся на две основные категории: команды языка определения данных (DDL - Data Definition Language) и команды языка манипулирования данными (DML - Data Manipulation Language). Вот некоторые примеры команд DDL:

1. **CREATE TABLE**: Создание новой таблицы в базе данных. Пример:

```sql
CREATE TABLE Employees (EmployeeID INT PRIMARY KEY, FirstName VARCHAR(50), LastName VARCHAR(50), DepartmentID INT);
```

2. **ALTER TABLE**: Изменение структуры существующей таблицы, например, добавление новых столбцов. Пример:

```sql
ALTER TABLE Employees ADD Email VARCHAR(100);
```

3. **DROP TABLE**: Удаление таблицы из базы данных. Пример:

```sql
DROP TABLE Employees;
```

4. **CREATE INDEX**: Создание индекса для ускорения поиска данных в таблице. Пример:

```sql
CREATE INDEX idx_Employee_Department ON Employees (DepartmentID);
```

5. **ALTER TABLE (DROP COLUMN)**: Удаление столбца из существующей таблицы. Пример:

```sql
ALTER TABLE Employees DROP COLUMN Email;
```

6. **CREATE DATABASE**: Создание новой базы данных. Пример:

```sql
CREATE DATABASE CompanyDB;
```

7. **ALTER DATABASE**: Изменение параметров базы данных, таких как установка режима совместимости. Пример:

```sql
ALTER DATABASE CompanyDB SET COMPATIBILITY_LEVEL = 150;
```

8. **DROP DATABASE**: Удаление базы данных. Пример:

```sql
DROP DATABASE CompanyDB;
```

Эти команды DDL используются для определения структуры базы данных, таблиц и индексов, и они не изменяют сами данные в таблицах.
### 9.2.2 DML

Команды языка манипулирования данными (DML - Data Manipulation Language) используются для работы с данными в таблицах базы данных. Вот некоторые примеры DML-команд SQL:

1. **SELECT**: Извлечение данных из таблицы. Пример:

```sql
SELECT FirstName, LastName FROM Employees WHERE DepartmentID = 1;
```

2. **INSERT INTO**: Вставка новых записей в таблицу. Пример:

```sql
INSERT INTO Employees (FirstName, LastName, DepartmentID) VALUES ('John', 'Doe', 2);
```

3. **UPDATE**: Обновление существующих записей в таблице. Пример:

```sql
UPDATE Employees SET DepartmentID = 3 WHERE EmployeeID = 101;
```

4. **DELETE**: Удаление записей из таблицы. Пример:

```sql
DELETE FROM Employees WHERE EmployeeID = 102;
```

5. **INSERT INTO (SELECT)**: Вставка данных из одной таблицы в другую. Пример:
 
 ```sql
INSERT INTO NewEmployees (FirstName, LastName, DepartmentID)
SELECT FirstName, LastName, DepartmentID
FROM OldEmployees
WHERE DepartmentID = 1;
```

6. **MERGE (UPSERT)**: Обновление существующих записей и вставка новых записей в зависимости от условия. Пример:

```sql
MERGE INTO TargetTable AS T
USING SourceTable AS S
ON T.EmployeeID = S.EmployeeID
WHEN MATCHED THEN
    UPDATE SET T.DepartmentID = S.DepartmentID
WHEN NOT MATCHED THEN
    INSERT (EmployeeID, FirstName, LastName, DepartmentID)
    VALUES (S.EmployeeID, S.FirstName, S.LastName, S.DepartmentID);
```

7. **TRUNCATE TABLE**: Удаление всех записей из таблицы без удаления самой таблицы. Пример:

```sql
TRUNCATE TABLE Employees;
```
 
8. **ROLLBACK**: Откат транзакции и отмена внесенных изменений (используется в контексте транзакций). Пример:

```sql
ROLLBACK;
```

Эти команды DML используются для добавления, изменения, извлечения и удаления данных в таблицах базы данных.

### 9.2.3 DCL

Команды управления данными (DCL - Data Control Language) в SQL используются для управления правами доступа к данным и безопасностью базы данных. Вот некоторые примеры команд DCL:

1. **GRANT**: Предоставление прав доступа к объектам базы данных (например, таблицам) пользователям или ролям. Пример:

```sql
GRANT SELECT, INSERT ON Employees TO User1;
```

В этом примере пользователю User1 предоставляются права SELECT и INSERT на таблицу Employees.
    
2. **REVOKE**: Отзыв прав доступа к объектам базы данных у пользователя или роли. Пример:

```sql
REVOKE DELETE ON Employees FROM User2;
```

 В этом примере право DELETE отзывается у пользователя User2 для таблицы Employees.

3. **DENY**: Запрет предоставления определенных прав доступа к объектам базы данных. Пример:

 ```sql
 DENY UPDATE ON Employees TO User3;
 ```

   В этом примере предоставление права UPDATE пользователю User3 для таблицы Employees запрещается.

4. **GRANT EXECUTE**: Предоставление прав на выполнение хранимой процедуры или функции. Пример:

```sql
GRANT EXECUTE ON sp_InsertEmployee TO Role1;
```

В этом примере роли Role1 предоставляется право на выполнение хранимой процедуры `sp_InsertEmployee`.

5. **GRANT ALL**: Предоставление всех доступных прав на объект базы данных. Пример:

```sql
GRANT ALL ON Employees TO User4;
```

В этом примере пользователю User4 предоставляются все доступные права на таблицу Employees.

6. **REVOKE ALL**: Отзыв всех прав доступа к объекту базы данных у пользователя или роли. Пример:
   
```sql
REVOKE ALL ON Employees FROM User5;
```

В этом примере отзываются все права доступа к таблице Employees у пользователя User5. 

Эти команды DCL позволяют администраторам базы данных управлять правами доступа и обеспечивать безопасность данных, определяя, кто может выполнять какие операции с данными в базе данных.

### 9.2.4 TCL

Команды управления транзакциями (TCL - Transaction Control Language) в SQL используются для управления транзакциями в базе данных. Вот некоторые примеры команд TCL:

1. **COMMIT**: Фиксация (завершение успешной) текущей транзакции и сохранение всех внесенных изменений в базе данных. Пример:

```sql
COMMIT;
```

Эта команда подтверждает все изменения, сделанные в текущей транзакции, и сохраняет их в базе данных.

2. **ROLLBACK**: Откат (отмена) текущей транзакции и отмена всех внесенных изменений. Пример:

```sql
ROLLBACK;
```

Эта команда отменяет все изменения, сделанные в текущей транзакции, и возвращает базу данных к состоянию до начала транзакции.

3. **SAVEPOINT**: Создание точки сохранения внутри текущей транзакции, чтобы можно было выполнить откат только до этой точки. Пример:

```sql
SAVEPOINT my_savepoint;
```

После создания точки сохранения `my_savepoint`, вы можете выполнить откат только до этой точки без отмены всей транзакции.

4. **ROLLBACK TO SAVEPOINT**: Откат транзакции до определенной точки сохранения. Пример:

```sql
ROLLBACK TO my_savepoint;
```

Эта команда отменяет изменения, сделанные после создания точки сохранения `my_savepoint`.

5. **SET TRANSACTION**: Установка параметров транзакции, таких как уровень изоляции и другие опции. Пример:

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

Эта команда устанавливает уровень изоляции транзакции на SERIALIZABLE, что означает самый высокий уровень изоляции.

Команды TCL позволяют управлять транзакциями, обеспечивая целостность данных и обратимость изменений в базе данных.

## 9.3 SQLite
---
### 9.3.1 SQLite benefits

SQLite – это компактная и простая в использовании система управления базами данных, имеющая ряд преимуществ:

1. **Легкость внедрения и использования:** SQLite легко интегрировать в приложения благодаря своей простоте и минималистичности. Для начала работы с ним не требуется настройка серверов или сложная установка.
    
2. **Отсутствие клиент-серверной архитектуры:** SQLite работает в режиме файловой базы данных без необходимости поддержки отдельного сервера. Это упрощает управление и устраняет сложности, связанные с настройкой серверов.
    
3. **Кроссплатформенность:** SQLite поддерживается на большинстве платформ, включая Windows, macOS, Linux, iOS, Android и другие. Это позволяет разрабатывать приложения, работающие на различных устройствах.
    
4. **Эффективность и высокая производительность:** SQLite хорошо оптимизирован для большинства типов запросов и операций с данными, обеспечивая высокую производительность при правильном использовании.
    
5. **Надежность:** Базы данных SQLite обычно надежны, имеют хорошую устойчивость к ошибкам и обеспечивают целостность данных. Отказы, в случае возникновения, часто ограничиваются отдельными файлами базы данных.
    
6. **Транзакционная поддержка:** SQLite поддерживает транзакции, что позволяет выполнять группу операций как единое целое, обеспечивая атомарность, согласованность, изоляцию и устойчивость (ACID).
    
7. **Хранение в одном файле:** Вся база данных SQLite хранится в одном файле, что упрощает резервное копирование, перенос и обмен данными между системами.
    
8. **Поддержка SQL:** SQLite использует стандартный SQL для работы с данными, что делает его знакомым и удобным для многих разработчиков.
    
9. **Бесплатность и открытость исходного кода:** SQLite распространяется под свободной лицензией, что позволяет использовать его бесплатно в коммерческих и некоммерческих проектах. Исходный код открыт для аудита и модификаций.
    
10. **Расширяемость:** SQLite имеет возможность расширения с помощью загрузчиков модулей, что позволяет добавлять дополнительную функциональность по мере необходимости.
    
Эти преимущества делают SQLite популярным выбором для небольших и средних проектов, где требуется легкая, быстрая и надежная система управления базами данных.

### 9.3.2 Syntax diagrams

SQLite Syntax Diagrams (синтаксические диаграммы SQLite) представляют собой графическое представление синтаксиса языка SQL, используемого в SQLite, с использованием спецификаций BNF (Backus-Naur Form). Эти диаграммы помогают визуально представить структуру SQL-запросов и команд для базы данных SQLite. Они часто используются в документации SQLite и других учебных материалах для облегчения понимания синтаксиса SQL.

Официальная документация SQLite содержит синтаксические диаграммы для различных SQL-команд и выражений. Вы можете найти эти диаграммы в разделе документации SQLite, посвященном SQL:

[SQLite SQL Syntax](https://www.sqlite.org/lang.html)

На этой странице вы найдете синтаксические диаграммы для различных SQL-команд, таких как SELECT, INSERT, UPDATE, DELETE, и многих других. Эти диаграммы могут помочь вам лучше понять, как строить SQL-запросы для работы с базой данных SQLite.
### 9.3.3 DB browser

SQLite DB Browser (ранее известный как "SQLite Database Browser") - это бесплатный графический инструмент для работы с базами данных SQLite. Он предоставляет удобный способ просматривать, редактировать и управлять данными в файлах баз данных SQLite. SQLite DB Browser поддерживает операции, такие как создание таблиц, вставка, редактирование и удаление записей, выполнение SQL-запросов и многое другое.

Вот как использовать SQLite DB Browser:

1. **Загрузка и установка:** Сначала вам нужно скачать и установить SQLite DB Browser. Вы можете найти его на официальном сайте или на ресурсах для скачивания программного обеспечения. Он доступен для различных операционных систем, включая Windows, macOS и Linux.
    
2. **Открытие базы данных:** Запустите SQLite DB Browser и выберите "Открыть базу данных" из меню. Затем укажите путь к файлу базы данных SQLite, который вы хотите открыть.
    
3. **Просмотр данных:** После открытия базы данных вы увидите список таблиц. Выберите таблицу, чтобы просмотреть её содержимое. Вы сможете видеть данные в таблице и редактировать их, если это разрешено.
    
4. **Выполнение SQL-запросов:** SQLite DB Browser также предоставляет возможность выполнения SQL-запросов. Вы можете выбрать "Выполнить SQL" или "Запрос SQL" из меню, чтобы вставить и выполнить свои SQL-запросы.
    
5. **Создание и изменение структуры таблиц:** Вы можете создавать новые таблицы, изменять структуру существующих таблиц, добавлять индексы и многое другое. Эти операции обычно выполняются с использованием встроенных инструментов и редакторов.
    
6. **Сохранение изменений:** После внесения изменений в базу данных не забудьте сохранить их, выбрав "Сохранить базу данных" из меню.
    

SQLite DB Browser - это мощный инструмент для работы с базами данных SQLite, особенно если вы предпочитаете графический интерфейс. Он удобен для разработки, отладки и анализа данных в файлах SQLite.
## 9.4 MySQL
---
### 9.4.1 MySQL Workbench

#TODO 

### 9.4.2 MySQL benefits

MySQL - это популярная система управления реляционными базами данных (СУБД), и у неё есть множество преимуществ:

1. **Бесплатность и открытый исходный код:** MySQL доступен бесплатно в рамках лицензии GPL, что делает его доступным для широкого круга пользователей и разработчиков. Кроме того, существует коммерческая версия (MySQL Enterprise), которая предоставляет дополнительную поддержку и функциональность.
    
2. **Высокая производительность:** MySQL известен своей высокой производительностью и способностью обрабатывать большие объемы данных и запросов. Он оптимизирован для быстрого выполнения запросов и обеспечения эффективного управления памятью.
    
3. **Масштабируемость:** MySQL легко масштабируется, позволяя добавлять дополнительные серверы (горизонтальное масштабирование) или увеличивать ресурсы существующего сервера (вертикальное масштабирование) для поддержки роста приложения.
    
4. **Поддержка множества языков программирования:** MySQL обладает различными драйверами и API, что делает его совместимым с множеством языков программирования, включая PHP, Python, Java, Ruby и многие другие.
    
5. **Богатый набор функциональности:** MySQL предоставляет широкий набор функций и типов данных для обработки данных, включая поддержку транзакций, хранимых процедур, триггеров, представлений и многих других возможностей.
    
6. **Сообщество и поддержка:** MySQL имеет активное сообщество пользователей и разработчиков, что обеспечивает доступ к богатому источнику знаний и поддержке через форумы, документацию и ресурсы.
    
7. **Безопасность:** MySQL обеспечивает многоуровневую систему безопасности, включая аутентификацию и авторизацию пользователей, что позволяет защитить данные от несанкционированного доступа.
    
8. **Поддержка транзакций:** MySQL поддерживает транзакции, что обеспечивает целостность данных при выполнении группы операций как единое целое.
    
9. **Репликация и отказоустойчивость:** MySQL предоставляет механизмы репликации, которые позволяют создавать резервные копии данных и обеспечивать отказоустойчивость системы.
    
10. **Популярность и экосистема:** MySQL является одной из самых популярных СУБД в мире, что означает наличие богатой экосистемы инструментов и сторонних приложений для работы с ней.

По сравнению с **PostgreSQL**:

MySQL и PostgreSQL - две популярные системы управления реляционными базами данных (СУБД), и у каждой из них есть свои преимущества и недостатки. Вот основные преимущества MySQL по сравнению с PostgreSQL:

1. **Производительность и масштабируемость:**
    - MySQL часто считается быстрее в простых запросах и может быть более производительным в случае больших нагрузок на чтение. Он хорошо подходит для веб-приложений с высокой нагрузкой.
    - Масштабируемость MySQL более проста и поддерживает репликацию и разделение нагрузки между несколькими серверами.
2. **Простота использования:**
    - MySQL имеет более простой синтаксис и менее строгие требования к схеме данных, что делает его более доступным для новичков и разработчиков.
3. **Широкая поддержка хостинг-поставщиков:**
    - Многие хостинг-поставщики предоставляют MySQL в качестве базы данных по умолчанию, что делает его более доступным для хостинга веб-приложений.
4. **Большое сообщество и ресурсы:**
    - MySQL имеет большое и активное сообщество пользователей, что обеспечивает доступ к обширным ресурсам и поддержке в Интернете.
5. **Коммерческая поддержка:**
    - MySQL предоставляет коммерческую поддержку через Oracle Corporation для организаций, которые ищут гарантированный уровень поддержки.
6. **Большое количество драйверов и интеграций:**
    - MySQL поддерживается множеством драйверов для различных языков программирования и имеет широкий набор интеграций и сторонних библиотек.
7. **Подходящий для малых и средних проектов:**
    - MySQL часто рассматривается как хороший выбор для малых и средних проектов, особенно если нет необходимости в сложных аналитических запросах.

Важно отметить, что выбор между MySQL и PostgreSQL зависит от конкретных потребностей проекта. PostgreSQL может предоставлять более мощные возможности аналитики, а также строгий контроль над данными и более сложные запросы. Поэтому выбор СУБД следует рассматривать с учетом конкретных требований и задач проекта.
## 9.5 PostgreSQL
---
### 9.5.1 PostgreSQL benefits

Основные преимущества PostgreSQL:

1. **Открытый исходный код**: PostgreSQL является свободной и открытой системой управления базами данных (СУБД), что позволяет свободно использовать, модифицировать и распространять ее без ограничений.
    
2. **Мощность и надежность**: PostgreSQL предлагает высокую производительность и надежность для обработки больших объемов данных и высоконагруженных приложений.
    
3. **Поддержка SQL**: PostgreSQL поддерживает стандарт языка SQL, что обеспечивает совместимость с большинством приложений и инструментами, работающими с реляционными базами данных.
    
4. **Расширяемость**: СУБД PostgreSQL обладает гибкой архитектурой и поддерживает множество расширений и настраиваемых типов данных, позволяя пользователям адаптировать ее под свои потребности.
    
5. **Поддержка JSON и других неструктурированных данных**: PostgreSQL обеспечивает возможность хранения и запросов данных в формате JSON, что удовлетворяет современные потребности в работе с полуструктурированными данными.
    
6. **Геоданные и пространственный анализ**: PostgreSQL предоставляет богатые возможности для работы с геоданными и пространственным анализом, что полезно в геоинформационных системах (ГИС) и других приложениях.
    
7. **Поддержка многозадачности**: СУБД позволяет выполнять множество параллельных запросов, что улучшает производительность и масштабируемость.
    
8. **Транзакционная целостность**: PostgreSQL обеспечивает ACID-совместимость (Atomicity, Consistency, Isolation, Durability), что гарантирует целостность данных и безопасность транзакций.
    
9. **Репликация и высокая доступность**: PostgreSQL поддерживает механизмы репликации, что позволяет создавать резервные копии данных и обеспечивать высокую доступность приложений.
    
10. **Активное сообщество и поддержка**: Вокруг PostgreSQL существует большое и активное сообщество разработчиков и пользователей, что обеспечивает доступ к обширным ресурсам для получения помощи и развития экосистемы инструментов.
    
11. **Множество дополнительных инструментов**: Существует множество сторонних инструментов, библиотек и драйверов, разработанных для работы с PostgreSQL.
    
12. **Безопасность**: PostgreSQL предоставляет множество механизмов безопасности, включая аутентификацию, авторизацию и шифрование данных.
    
13. **Совместимость с различными операционными системами**: PostgreSQL поддерживает различные операционные системы, включая Linux, Windows и macOS.
    
14. **Эффективное использование ресурсов**: PostgreSQL умеет эффективно управлять ресурсами сервера, что позволяет экономить место и снижать нагрузку на аппаратное обеспечение.
    
15. **Постоянное развитие**: PostgreSQL активно развивается, постоянно добавляются новые функции и улучшения, чтобы соответствовать современным требованиям.
    
16. **Бесплатная лицензия**: PostgreSQL распространяется под лицензией, которая позволяет использовать ее бесплатно, что снижает затраты на лицензии в сравнении с некоторыми коммерческими СУБД.

По сравнению с **MySQL**:

1. **ACID-совместимость**: PostgreSQL обеспечивает полную поддержку ACID (Atomicity, Consistency, Isolation, Durability), что обеспечивает надежность и целостность данных в транзакциях. В то время как MySQL поддерживает ACID, но некоторые его конфигурации могут иметь ограничения.
    
2. **Расширяемость и гибкость**: PostgreSQL предоставляет более широкие возможности для расширения и настройки, включая поддержку пользовательских типов данных, функций и расширений. MySQL менее гибок в этом отношении.
    
3. **Многозадачность и параллелизм**: PostgreSQL имеет более продвинутую систему управления многозадачностью, что может привести к более высокой производительности при обработке множества одновременных запросов.
    
4. **Геоданные и пространственный анализ**: PostgreSQL предоставляет богатые возможности для работы с геоданными и пространственным анализом, что делает его предпочтительным выбором для геоинформационных систем (ГИС) и местоположенных данных.
    
5. **Поддержка JSON и полнотекстового поиска**: PostgreSQL имеет встроенную поддержку для хранения и запросов данных в формате JSON, а также расширенные возможности для полнотекстового поиска, что упрощает работу с разнообразными типами данных.
    
6. **Безопасность**: PostgreSQL предоставляет более продвинутые механизмы аутентификации и авторизации, а также возможности для шифрования данных на более высоком уровне, что способствует повышенной безопасности.
    
7. **Сложные запросы и аналитика**: PostgreSQL обычно более подходит для сложных запросов и аналитических операций благодаря расширенным возможностям оконных функций и аналитических функций.
    
8. **Триггеры и процедурные языки**: PostgreSQL предоставляет более богатые возможности для создания триггеров и процедурных языков, что упрощает создание сложных бизнес-логик в базе данных.
    
9. **Репликация**: PostgreSQL предоставляет более гибкие и продвинутые механизмы репликации, включая логическую репликацию, что упрощает создание резервных копий и обеспечивает высокую доступность данных.
    
10. **Активное сообщество и поддержка**: PostgreSQL имеет активное и преданное сообщество разработчиков и пользователей, что обеспечивает обширные ресурсы для поддержки и развития СУБД.
### 9.5.2 psql

**Psql** - это интерактивный командный интерфейс (CLI) для работы с системой управления базами данных PostgreSQL. PostgreSQL - это мощная и распространенная система управления реляционными базами данных. Psql предоставляет пользователям доступ к PostgreSQL и позволяет выполнять различные операции с базами данных, такие как создание, изменение, удаление таблиц, выполнение SQL-запросов, управление пользователями и многое другое.

Вот как использовать psql:

1. **Установка PostgreSQL**: Прежде всего, убедитесь, что PostgreSQL установлен на вашем компьютере. Вы можете скачать и установить его с официального сайта PostgreSQL ([https://www.postgresql.org/download/](https://www.postgresql.org/download/)), либо использовать пакетный менеджер вашей операционной системы (например, `apt`, `yum`, `brew`).
    
2. **Запуск psql**: Вы можете запустить psql, введя следующую команду в командной строке или терминале:

```Shell
psql -U ваше_имя_пользователя -d имя_базы_данных`
```
   
Где: 
    - `-U` указывает имя пользователя PostgreSQL.
    - `-d` указывает имя базы данных, к которой вы хотите подключиться.
    После ввода этой команды вас попросят ввести пароль для пользователя PostgreSQL.

3. **Выполнение SQL-запросов**: После успешного подключения к базе данных вы можете выполнять SQL-запросы. Просто введите SQL-команду и нажмите Enter. Например:
    
```sql
SELECT * FROM ваша_таблица;
```
   
Это выполнит запрос и вернет результат в консоли.
   
4. **Выход из psql**: Для выхода из psql введите команду:

```Shell
\q
```

Или используйте комбинацию клавиш `Ctrl + D`.
   
5. **Дополнительные команды**: Psql также поддерживает различные метакоманды, которые начинаются с `\`. Например, `\l` покажет список всех баз данных, `\dt` - список таблиц в текущей базе данных, и так далее. Вы можете использовать `\?` для получения списка доступных метакоманд.

**Psql** - это мощный инструмент для работы с PostgreSQL и позволяет администрировать и взаимодействовать с базами данных с помощью командной строки. При необходимости вы также можете написать SQL-скрипты и выполнять их с помощью **psql**.

Вот некоторые основные команды **psql**:

1. `\l` - Список баз данных
    Эта команда отображает список всех доступных баз данных в текущей **PostgreSQL** установке. Она покажет вам имена баз данных, владельцев и другую информацию.
    
2. `\c dbname` - Подключение к базе данных
    С помощью этой команды вы можете подключиться к другой базе данных. Просто укажите имя базы данных, к которой вы хотите подключиться, после `\c`.
    
3. `\d` - Список всех таблиц, представлений и последовательностей
    Эта команда отображает список всех таблиц, представлений и последовательностей в текущей базе данных. Она также показывает информацию о столбцах в каждой таблице.
    
4. `\dt` - Список таблиц
    Эта команда отображает список всех таблиц в текущей базе данных.
    
5. `\dv` - Список представлений (view)
    Эта команда показывает список всех представлений (view) в текущей базе данных.
    
6. `\di` - Список индексов
    Эта команда отображает список индексов в текущей базе данных, включая информацию о таблицах, к которым они принадлежат.
    
7. `\du` - Список пользователей 
    Эта команда отображает список всех пользователей PostgreSQL и их ролей.
    
8. `\dp` - Права доступа к объектам
    Эта команда показывает права доступа к объектам базы данных, таким как таблицы и представления.
    
9. `\q` - Выход из **psql**
    Эта команда завершает сеанс **psql** и выходит из интерактивного режима.
    
10. `\i filename` - Выполнение SQL-скрипта из файла
    Эта команда позволяет выполнить SQL-скрипт, который находится в указанном файле.
    
11. `\e` - Редактирование текущего запроса
    Если вы начали вводить SQL-запрос, но передумали и хотите отредактировать его в текстовом редакторе, используйте эту команду. После редактирования запроса и сохранения файла, он будет выполнен.
    
12. `?` - Список доступных команд
    Эта команда отображает список всех доступных команд в **psql**.

### 9.5.3 pgAdmin

#TODO 

## 9.6 ORM
---
### 9.6.1 peewee

**Peewee** - это небольшая и простая библиотека для работы с реляционными базами данных в языке Python. Она предоставляет ORM (Object-Relational Mapping) для удобной работы с базами данных, позволяя разработчикам взаимодействовать с базами данных, используя объектно-ориентированный подход. Вот некоторая информация о Peewee:

1. **Установка Peewee**: Вы можете установить Peewee с помощью `pip`, Python's package manager:
 
```Shell
pip install peewee
```
   
2. **Поддерживаемые базы данных**: Peewee поддерживает несколько реляционных СУБД, включая SQLite, MySQL, PostgreSQL и другие.

3. **Основные концепции**:
   
    - **Модели (Models)**: В Peewee вы определяете классы моделей, которые соответствуют таблицам в базе данных.
    - **Поля (Fields)**: Поля класса модели определяют структуру таблицы и типы данных.
    - **Запросы (Queries)**: Peewee позволяет создавать SQL-запросы с использованием Python-подобного синтаксиса.

4. **Пример создания модели**:

```Python
from peewee import Model, CharField, IntegerField

class Person(Model):
    name = CharField()
    age = IntegerField()

    class Meta:
        database = db
```

5. **Создание таблиц и выполнение запросов**: Вы можете использовать Peewee для создания таблиц в базе данных, выполнения запросов и манипулирования данными. Примеры включают `create_table()`, `select()`, `insert()`, `update()`, `delete()`, и многое другое.

6. **Пример использования**:

```Python
# Создание новой записи
person = Person.create(name="Alice", age=30)

# Выполнение запроса на выборку
people = Person.select().where(Person.age < 40)

# Обновление записи
person.age = 31
person.save()

# Удаление записи
person.delete_instance()
```
   
7. **Миграции**: Peewee не включает в себя инструменты для миграции базы данных, но существуют сторонние расширения, такие как `playhouse.migrate`, которые облегчают миграции.

8. **Документация**: Официальная документация Peewee содержит подробные сведения о библиотеке и ее использовании: [http://docs.peewee-orm.com/en/latest/](http://docs.peewee-orm.com/en/latest/)

Peewee предоставляет удобный и понятный способ взаимодействия с реляционными базами данных в Python и широко используется в сообществе разработчиков.
### 9.6.2 SQLAlchemy

**SQLAlchemy** - это библиотека для работы с реляционными базами данных в языке Python. Она предоставляет ORM (Object-Relational Mapping) для удобного взаимодействия с базами данных, а также SQL-выражения и множество других инструментов для выполнения различных операций с данными. Вот подробное объяснение того, как работать с **SQLAlchemy**:

1. **Установка SQLAlchemy**: Вы можете установить **SQLAlchemy** с помощью `pip`, Python's package manager:

```Shell
pip install sqlalchemy
```

2. **Подключение к базе данных**: **SQLAlchemy** позволяет подключаться к разным типам баз данных (например, SQLite, MySQL, PostgreSQL) через соответствующие "диалекты". Чтобы подключиться к базе данных, создайте объект `engine` с указанием URL-адреса базы данных:

```Python
from sqlalchemy import create_engine

db_url = "sqlite:///mydatabase.db"
engine = create_engine(db_url)
```

3. **Определение моделей (Models)**: В **SQLAlchemy** вы определяете классы моделей, которые соответствуют таблицам в базе данных. Эти классы наследуются от `Base` и содержат определения полей и их типов данных, а также другие настройки:

```Python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Person(Base):
    __tablename__ = 'people'

    id = Column(Integer, primary_key=True)
    name = Column(String)
    age = Column(Integer)
```

4. **Создание таблиц**: После определения моделей вы можете создать таблицы в базе данных, используя метод `create_all()`:

```Shell
Base.metadata.create_all(engine)
```

5. Создание сессии: Сессия (Session) в **SQLAlchemy** предоставляет контекст для выполнения операций с базой данных. Создайте сессию, чтобы начать работу с данными:

```Python
from sqlalchemy.orm import Session

session = Session(engine)
```

6. **Операции с данными**: Вы можете выполнять операции CRUD (Create, Read, Update, Delete) с данными, используя объекты моделей и методы сессии. Например:

- Создание новой записи:

```Python
person = Person(name="Alice", age=30)
session.add(person)
session.commit()
```

- Чтение данных:

```Python
people = session.query(Person).filter_by(age=30).all()
```

- Обновление данных:

```Python
person = session.query(Person).filter_by(name="Alice").first()
person.age = 31
session.commit()
```

- Удаление данных:

```Python
person = session.query(Person).filter_by(name="Alice").first()
session.delete(person)
session.commit()
```

7. **Запросы SQL**: SQLAlchemy также позволяет выполнять SQL-запросы напрямую, если это необходимо:

```Python
result = engine.execute("SELECT * FROM people WHERE age > 25")
for row in result:
    print(row)
```

8. **Миграции**: Для управления миграциями базы данных в **SQLAlchemy** вы можете использовать сторонние инструменты, такие как Alembic.
    
9. **Документация**: Официальная документация **SQLAlchemy** содержит подробные сведения о библиотеке и ее использовании: [https://docs.sqlalchemy.org/en/20/](https://docs.sqlalchemy.org/en/20/)

SQLAlchemy предоставляет мощные средства для работы с реляционными базами данных в Python, позволяя разработчикам создавать эффективные и выразительные приложения, которые взаимодействуют с данными.

---

```Python
# Импортируем необходимые модули SQLAlchemy
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# Создаем подключение к базе данных
# Замените 'postgresql://username:password@localhost/mydatabase' на ваше собственное соединение с базой данных
db_url = 'postgresql://username:password@localhost/mydatabase'
engine = create_engine(db_url)

# Создаем базовый класс для определения моделей данных
Base = declarative_base()

# Определяем модель данных (таблицу)
class User(Base):
    __tablename__ = 'users'
    
    id = Column(Integer, primary_key=True)
    username = Column(String(50))
    email = Column(String(100))

# Создаем таблицы в базе данных (если они еще не существуют)
Base.metadata.create_all(engine)

# Создаем сессию для взаимодействия с базой данных
Session = sessionmaker(bind=engine)
session = Session()

# Пример добавления данных в базу данных
new_user = User(username='john_doe', email='john@example.com')
session.add(new_user)
session.commit()

# Пример запроса данных из базы данных
user = session.query(User).filter_by(username='john_doe').first()
if user:
    print(f'Пользователь с именем {user.username} и email {user.email} найден.')

# Закрываем сессию при завершении работы
session.close()
```

Этот код выполняет следующие действия:

1. Импортирует необходимые модули SQLAlchemy.
    
2. Создает подключение к базе данных с использованием URL-адреса базы данных.
    
3. Определяет модель данных (в данном случае, таблицу `User`) с помощью SQLAlchemy.
    
4. Создает таблицы в базе данных, если они еще не созданы.
    
5. Создает сессию для взаимодействия с базой данных.
    
6. Добавляет новую запись в таблицу.
    
7. Выполняет запрос к базе данных для поиска пользователя с указанным именем.
    
8. Закрывает сессию после завершения работы.

### 9.6.3 Django ORM

#TODO 