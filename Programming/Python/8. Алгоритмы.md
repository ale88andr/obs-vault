![[Pasted image 20230710094521.png]]

### 8.1 FizzBuzz

#TODO 

### 8.2 O(n)

#TODO 

### 8.3 Sort

### 8.3.0 В чем заключается задача сортировки?

Задача сортировки заключается в перестановке элементов так, чтобы они были упорядочены по возрастанию или убыванию. Это одна из основных задач программирования.

### 8.3.1 Что такое алгоритм сортировки?

**Алгоритм сортировки** — это алгоритм упорядочивания элементов в списке. Алгоритмы сортировки оцениваются по скорости выполнения и эффективности использования памяти:

**Время** — основной параметр, характеризующий быстродействие алгоритма;

**Память** — ряд алгоритмов требует выделения дополнительной памяти под временное хранение данных.

Алгоритмы сортировки, не потребляющие дополнительной памяти, относят к **сортировкам на месте**.

### 8.3.2 Какие основные алгоритмы сортировки существуют?

_Медленные_:
1.      Пузырьковая сортировка (**Bubble sort**);
2.      Сортировка выбором (**Selection sort**);
3.      Сортировка простыми вставками (**Insertion sort**).

_Быстрые_:
1.      Сортировка Шелла (**Shell sort**);
2.      Быстрая сортировка (**Quick sort**);
3.      Сортировка слиянием (**Merge sort**);
4.      Пирамидальная сортировка (**Heap sort**);
5.      Сортировка **TimSort** (используется в Java и Python).

Наглядная работа алгоритмов сортировки: https://www.toptal.com/developers/sorting-algorithms

### 8.3.3 Как реализовать сортировку пузырьком?

Алгоритм сортировки пузырьком состоит из повторяющихся проходов по сортируемому списку. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по списку повторяются `n - 1` раз, где `n` – длина списка. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент списка ставится на свое место в конце списка рядом с предыдущим «наибольшим элементом».

Наибольший элемент каждый раз «_всплывает_» до нужной позиции, как пузырёк в воде — отсюда и название алгоритма.

Алгоритм пузырьковой сортировки считается учебным и практически не применяется вне учебной литературы, а на практике применяются более эффективные.

Рассмотрим работу алгоритма на примере сортировки списка `a = [5, 1, 4, 2, 8]` по возрастанию.

**Первый проход:**

1.    `[5, 1, 4, 2, 8] → [1, 5, 4, 2, 8]`: меняем местами первый и второй элементы, так как `5 > 1`;

2.    `[1, 5, 4, 2, 8] → [1, 4, 5, 2, 8]`: меняем местами второй и третий элементы, так как `5 > 4`;

3.      `[1, 4, 5, 2, 8] → [1, 4, 2, 5, 8]`: меняем местами третий и четвертый элементы, так как `5 > 2`;

4.      `[1, 4, 2, 5, 8] → [1, 4, 2, 5, 8]`: не меняем четвертый и пятый элементы местами, так как `5 < 8`;

5.      Самый большой элемент встал («всплыл») на свое место.

**Второй проход:**

1.    `[1, 4, 2, 5, 8] → [1, 4, 2, 5, 8`]: не меняем первый и второй элементы местами, так как `1 < 4`;

2.    `[1, 4, 2, 5, 8] → [1, 2, 4, 5, 8`]: меняем местами второй и третий элементы, так как `4 > 2`;

3.      `[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8`]: не меняем местами третий и четвертый элементы, так как `4 < 5`;

Второй по величине элемент встал («всплыл») на свое место.

Теперь список полностью отсортирован, но алгоритму это неизвестно и он работает дальше.

**Третий проход:**

1.    `[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8`]: не меняем первый и второй элементы местами, так как `1 < 2`;

2.    `[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]`: не меняем второй и третий элементы местами, так как `2 < 4`;

Третий по величине элемент встал («всплыл») на свое место. (на котором и был)

**Четвертый проход:**

1.    `[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]`: Четвертый по величине элемент встал («всплыл») на свое место.

Теперь список отсортирован и алгоритм может быть завершен.

**Реализация алгоритма**

```Python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
capacity = len(a) - 1

for i in range(capacity):
    for j in range(capacity - i):
        if a[j] > a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]

print(a)  # [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
```

**Оптимизация алгоритма**

Алгоритм пузырьковой сортировки можно немного ускорить. Если на одном из очередных проходов окажется, что обмены больше не нужны, то это означает, что все элементы списка находятся на своих местах, то есть список отсортирован. Для реализации такого ускорения нужно воспользоваться сигнальной меткой, то есть флажком и оператором прерывания **break**.

### 8.3.4 Как реализовать сортировку выбором

Сортировка выбором улучшает пузырьковую сортировку, совершая **всего один обмен за каждый проход по списку**. Для этого алгоритм ищет максимальный элемент и помещает его на соответствующую позицию. Как и для пузырьковой сортировки, после первого прохода самый большой элемент находится на правильном месте. После второго прохода на своё место становится следующий максимальный элемент. Проходы по списку повторяются `n - 1` раз, где `n` – длина списка, поскольку последний из них автоматически оказывается на своем месте.

_Алгоритм сортировки выбором также считается учебным и практически не применяется вне учебной литературы. На практике используют более эффективные алгоритмы._

Рассмотрим работу алгоритма на примере сортировки списка `a = [5, 1, 8, 2, 4]` по возрастанию.

**Первый проход:**

Находим максимальный элемент **`8`** в неотсортированной части списка и меняем его с последним элементом списка:

`[5, 1, 4, 2, 8]`.

**Второй проход:**

Находим максимальный элемент **`5`** в неотсортированной части списка и меняем его с предпоследним элементом списка:

`[2, 1, 4, 5, 8]`.

**Третий проход:**

Находим максимальный элемент **`4`** в неотсортированной части списка и меняем его с пред-предпоследним элементом списка:

`[2, 1, 4, 5, 8]`.

**Четвертый проход:**

Находим максимальный элемент **`2`** в неотсортированной части списка и меняем его с вторым элементом списка:

`[1, 2, 4, 5, 8]`.

Теперь список отсортирован и алгоритм может быть завершен.

**Реализация алгоритма**

```Python
a = [78, -32, 5, 39, 58, -5, -63, 57, 72, 9, 53, -1, 63, -97, -21, -94, -47, 57, -8, 60, -23, -72, -22, -79, 90, 96, -41, -71, -48, 84, 89, -96, 41, -16, 94, -60, -64, -39, 60, -14, -62, -19, -3, 32, 98, 14, 43, 3, -56, 71, -71, -67, 80, 27, 92, 92, -64, 0, -77, 2, -26, 41, 3, -31, 48, 39, 20, -30, 35, 32, -58, 2, 63, 64, 66, 62, 82, -62, 9, -52, 35, -61, 87, 78, 93, -42, 87, -72, -10, -36, 61, -16, 59, 59, 22, -24, -67, 76, -94, 59]

n = len(a)

for i in range(n):
    minimum = min(a[i:])
    idx = n - a[::-1].index(minimum) - 1
    a[i], a[idx] = minimum, a[i]

print(a)  # [-97, -96, -94, -94, -79, -77, -72, -72, -71, -71, -67, -67, -64, -64, -63, -62, -62, -61, -60, -58, -56, -52, -48, -47, -42, -41, -39, -36, -32, -31, -30, -26, -24, -23, -22, -21, -19, -16, -16, -14, -10, -8, -5, -3, -1, 0, 2, 2, 3, 3, 5, 9, 9, 14, 20, 22, 27, 32, 32, 35, 35, 39, 39, 41, 41, 43, 48, 53, 57, 57, 58, 59, 59, 59, 60, 60, 61, 62, 63, 63, 64, 66, 71, 72, 76, 78, 78, 80, 82, 84, 87, 87, 89, 90, 92, 92, 93, 94, 96, 98]
```

### 8.3.5 Как реализовать сортировку простыми вставками?

Алгоритм сортировки простыми вставками делит список на 2 части — *отсортированную* и *неотсортированную*. Из неотсортированной части извлекается очередной элемент и вставляется на нужную позицию, в результате чего отсортированная часть списка увеличивается, а неотсортированная уменьшается. Так происходит, пока не исчерпан набор входных данных и не отсортированы все элементы.

>Сортировка простыми вставками наиболее эффективна когда список уже частично отсортирован и элементов массива немного. Если элементов в списке меньше 10, то этот алгоритм — один из самых быстрых.

Рассмотрим его работу на примере сортировки списка `a = [5, 1, 8, 2, 4]` по возрастанию.

**Первый проход:**

Делим список на две части: отсортированную `[5]` и неотсортированную `[1, 8, 2, 4]`.

Извлекаем первый элемент **`1`** из неотсортированной части списка и находим ему место в отсортированной части:

`[1, 5, 4, 2, 8]`.

**Второй проход:**

Делим список на две части: отсортированную `[1, 5]` и неотсортированную `[8, 2, 4]`.

Извлекаем первый элемент **`8`** из неотсортированной части списка и находим ему место в отсортированной части:

`[1, 5, 8, 2, 4]`.

**Третий проход:**

Делим список на две части: отсортированную `[1, 5, 8]` и неотсортированную `[2, 4]`.

Извлекаем первый элемент **`2`** из неотсортированной части списка и находим ему место в отсортированной части:

`[1, 2, 5, 8, 4]`.

**Четвертый проход:**

Делим список на две части: отсортированную `[1, 2, 5, 8]` и неотсортированную `[4]`.

Извлекаем первый элемент **`4`** из неотсортированной части списка и находим ему место в отсортированной части:

`[1, 2, 4, 5, 8]`.

Теперь список отсортирован и алгоритм может быть завершен.

**Реализация алгоритма**

```Python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
n = len(a)

for i in range(1, n):
    elem = a[i]
    j = i
    while j >= 1 and a[j - 1] > elem:
        a[j] = a[j - 1]
        j -= 1
    a[j] = elem

print(a)  # [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
```
### 8.4 Graphs

#TODO 

### 8.5 Search

#TODO 

### 8.6 Methods

### 8.6.1 Divide and conquer

#TODO 

### 8.6.2 Рекурсия

**Рекурсивная функция** – это функция, которая вызывает саму себя.

```Python
def message():
    print('Это рекурсивная функция')
    message()

message()
```

Функция message() выводит на экран строку текста Это **рекурсивная функция**, а затем вызывает саму себя. При каждом вызове функцией самой себя цикл повторяется. Несложно заметить, что при такой реализации функции message() в ней не предусмотрен способ остановки рекурсивных вызовов. Эта функция выглядит как бесконечный цикл, поскольку отсутствует программный код, который остановил бы ее бесконечные вызовы.

В ситуации, когда не предусмотрен способ остановки рекурсивных вызовов происходит **переполнение аппаратного стека** и возбуждается исключение **RecursionError**.

Подобно циклу, **рекурсивная функция** должна иметь определенный способ **управлять количеством своих повторов**.

```Python
def message(times):
    if times > 0:
        print('Это рекурсивная функция')
        message(times - 1)

message(5)
```

Строка текста Это рекурсивная функция будет выводиться до тех пор, пока times больше нуля, при этом функция будет вызывать саму себя повторно, передавая уменьшенный на единицу аргумент.

Во время **каждого вызова** функции message() в оперативной памяти создается **новый экземпляр переменной** **times**. При первом вызове функции times имеет значение 5. Когда функция себя вызывает, создается новый экземпляр переменной times и в него передается значение 4. Этот цикл повторяется до тех пор, пока в функцию в качестве аргумента не будет передан 0.

![[Pasted image 20230713165942.png]]

Как видно из рисунка, функция message() вызывается шесть раз. В первый раз она вызывается из основной программы, а остальные пять раз **она вызывает саму себя**. Количество раз, которые функция вызывает саму себя, называется **глубиной рекурсии**. В этом примере глубина рекурсии равняется пяти. Когда функция достигает своего шестого вызова, значение переменной times равно 0. В этой точке условное выражение оператора if становится ложным, и поэтому функция завершает свою работу. **Поток управления программы** **возвращается** из шестого экземпляра функции **в точку в пятом экземпляре непосредственно после вызова рекурсивной функции**. Поскольку после вызова рекурсивной функции больше нет инструкций, пятый экземпляр функции message() возвращает поток управления программы назад в четвертый экземпляр функции и т.д.

```Python
def message(times):
    if times > 0:
        print('Это рекурсивная функция.')
        message(times - 1)
        print(times)

message(5)
```

```
Это рекурсивная функция.
Это рекурсивная функция.
Это рекурсивная функция.
Это рекурсивная функция.
Это рекурсивная функция.
1
2
3
4
5
```

Рекурсия может оказаться мощным инструментом для решения повторяющихся задач. Задача может быть решена на основе рекурсии, если ее разделить на уменьшенные задачи, которые по структуре идентичны общей задаче.

Рекурсивные алгоритмы обычно **менее эффективны**, чем итеративные алгоритмы. Это связано с тем, что **процесс вызова** функции требует выполнения компьютером **нескольких действий**. Эти действия включают **выделение памяти под параметры и локальные переменные и для хранения адреса местоположения программы**. Такие действия, которые иногда называются **накладными расходами**, происходят **при каждом** вызове функции. Накладные расходы не требуются при использовании цикла.

**Аппаратный стек** используется для нужд выполняющейся программы: **хранения переменных и вызова функций**. При вызове функции процессор помещает в стек **адрес команды**, **следующей за командой вызова функции**, — «адрес возврата» из функции. По команде возврата из функции **из стека извлекается адрес возврата** и осуществляется переход по этому адресу.

Некоторые повторяющиеся задачи легче решаются на основе рекурсии, чем на основе цикла. Там, где цикл приводит к более быстрому времени исполнения, программист может быстрее разработать рекурсивный алгоритм. В целом рекурсивная функция работает следующим образом:
-        если в настоящий момент задача может быть решена без рекурсии, то функция ее решает
-        если в настоящий момент задача не может быть решена, то функция ее сводит к уменьшенной и при этом аналогичной задаче и вызывает саму себя для решения этой уменьшенной задачи

Для того чтобы применить такой подход, во-первых, мы **идентифицируем по крайней мере один случай**, в котором задача может быть решена **без рекурсии**. Он называется **базовым случаем**. Во-вторых, мы о**пределяем то, как задача будет решаться рекурсивно во всех остальных случаях**. Это называется **рекурсивным случаем**. В рекурсивном случае мы все время должны **сводить задачу к уменьшенному варианту исходной задачи**. С каждым рекурсивным вызовом задача уменьшается. **В результате будет достигнут базовый случай, и рекурсия прекратится**.
![[Pasted image 20230713165959.png]]

**Решение задач на рекурсию**

**Задача 1.** Реализовать функцию factorial() с использованием рекурсии, которая принимает один аргумент:

**n** – неотрицательное число

и возвращает факториал числа **n**. при этом полагают, что 0!=1.

```Python
def factorial(n):
    if n == 0:
        return 1                        # базовый случай
    else:
        return n * factorial(n-1)       # рекурсивный случай
```

Хотя это и инструкция **return**, она не возвращает значение немедленно. Прежде чем возвращаемое значение будет определено, должно быть **определено** значение **factorial(n - 1)**. Функция **factorial()** вызывается рекурсивно вплоть до пятого вызова, в котором значение параметра n будет равно 0.

![[Pasted image 20230713170125.png]]
Если каждый рекурсивный вызов работает с **уменьшенным вариантом задачи**, то работа рекурсивных вызовов **сводится к базовому случаю**. Базовый случай не требует рекурсии, и поэтому он останавливает цепочку рекурсивных вызовов.

**Задача 2.** Реализовать функцию sum_to() с использованием рекурсии, которая принимает один аргумент:

n – неотрицательное число

и возвращает сумму чисел от 0 до n включительно.

```Python
def sum_to(n):
    if n == 0:
        return 0                       # базовый случай
    else:
        return n + sum_to(n - 1)       # рекурсивный случай
```

**Задача 3**. Реализовать функцию recursive_sum() с использованием рекурсии, которая принимает один аргумент:

nums – список чисел

и возвращает сумму элементов списка nums.

```Python
def recursive_sum(nums):
    if not nums:
        return 0                                       # базовый случай
    return nums[0] + recursive_sum(nums[1:])           # рекурсивный случай
```

**Задача 4.** Во всех предыдущих задачах тело функции содержало ровно один рекурсивный вызов. Однако так бывает не всегда. Классический пример – числа Фибоначчи.

Числа Фибоначчи – последовательность чисел:

1,1,2,3,5,8,13,21,34,55,89,…

```Python
def fib(n):
    if n <= 2:
        return 1                             # базовый случай
    else:
        return fib(n - 1) + fib(n - 2)       # рекурсивный случай
```

Функция fib() порождает **два рекурсивных вызова** fib(n - 1) и fib(n - 2). Дерево рекурсивных вызовов будет иметь вид:
![[Pasted image 20230713170248.png]]

Во время вычисления значения числа Фибоначчи мы неявно обходим **дерево в глубину**. Важно понимать, что экземпляры функции выполняются не параллельно, а **последовательно**: сначала **левое** поддерево, а потом **правое** поддерево **из любой вершины**.

Обратите внимание на то, что дерево рекурсивных вызовов очень быстро разрастается при росте номера числа Фибоначчи, что влечет **замедление программы и трату памяти**. А все потому, что в рекурсивном случае мы много раз вычисляем одно и то же число Фибоначчи.

Для решения проблемы повторного вычисления чисел Фибоначчи можно использовать механизм **мемоизации**.

**Мемоизация** – это способ **оптимизации**, при котором **сохраняется результат выполнения функции**, и этот результат используется при следующем вызове.

```Python
cache = {1: 1, 2: 1} # ключ - номер числа, значения - число Фибоначчи

def fib(n):
    result = cache.get(n)
    if result is None:
        result = fib(n - 2) + fib(n - 1)
        cache[n] = result
    return result
```

Мемоизация присутствует по умолчанию во многих функциональных языках программирования. В Python включать такой функционал надо вручную (декоратор lru_cache).

**Рекурсивный обход коллекций**

Рекурсия является незаменимым помощником при работе с вложенными структурами данных.

**Задача 1.** Дан список, элементами которого могут быть только строки или аналогичные списки, содержащие строки и вложенные списки. Необходимо вывести все строки из данного списка и из всех вложенных, разделив пробелом.

```Python
def get_all_str(data):
    if type(data) == str:
        print(data, end=' ')            # базовый случай

    if type(data) == list:
        for i in data:
            get_all_str(i)              # рекурсивный случай
```

**Задача 2.** Дан словарь произвольной вложенности, то есть значениями в словаре могут быть другие словари. Необходимо определить значение, которое соответствует заданному ключу, и вернуть его. При этом гарантируется, что такой ключ имеется в словаре, причем он единственный.

```Python
def find_key(data, key):
    if key in data:
        return data[key]                # базовый случай

    for k, v in data.items():
        if type(v) == dict:
            value = find_key(v, key)    # рекурсивный случай
            if value is not None:
                return value

info = {'name': 'Alyson',
        'surname': 'Hannigan',
        'birthday': {'day': 24, 'month': 'March', 'year': 1974},
        'family': {'parents': {'mother': 'Emilie Posner', 'father': 'Alan Hannigan'}}}

print(find_key(info, 'year'))  # 1974
print(find_key(info, 'father'))  # Alan Hannigan
```

```Python
def matryoshka(n: int):
    # крайний случай
    if n == 1:
        print('Матрёшка')
    # реккурентный случай
    else:
        print('Верх матрёшки n=', n)
        matryoshka(n-1)
        print('Низ матрёшки n=', n)

        
# matryoshka(5)


def f(n):
    if n == 0:
        return 1
    return f(n-1) * n


def pow(a: float, n:int):
    if n == 0:
        return 1
    else:
        return pow(a, n-1) * a

       
def generate_numbers(n: int, m: int, prefix=None):
    """ Генерирует все числа (с лидирующими нулями)
        в n-ричной системе счисления (N <= 10), длинной m 
    """
    prefix = prefix or []
    if m == 0:
        print(prefix)
        return
    for digit in range(n):
        prefix.append(digit)
        generate_numbers(n, m-1, prefix)
        prefix.pop()
        

generate_numbers(10, 2)
```

**Настройка глубины рекурсии в Python**

По умолчанию Python имеет ограничение на максимальную глубину рекурсивных вызовов. Это ограничение не позволяет бесконечной рекурсии вызывать переполнение стека.

Получить значение по умолчанию для максимальной глубины рекурсии можно с помощью функции **getrecursionlimit()** из модуля **sys**.

Мы также можем явно установить значение максимальной глубины рекурсии. Для этого используется функция **setrecursionlimit()** из модуля **sys**.

> Рекомендуемые книги для дальнейшего углубленного изучения рекурсии: Рубио-Санчес М. "Введение в рекурсивное программирование"

### 8.6.3 Dynamic programming

#TODO 

### 8.6.4 Greedy algorithm

#TODO 