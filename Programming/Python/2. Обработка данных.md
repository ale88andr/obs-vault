![[Pasted image 20230529191508.png]]

# 1. Срезы (slice)

### 1.1 Что такое срезы?

*Срезы* - это самый простой метод обработки данных, просто возвращает ту часть данных, местоположение которой (*индексы*) удовлетворяет определенным условиям.

```Python
a:str = "Pack my box with five dozen liquor jugs"
start, stop = 8, 21

# Значения от start до stop-1
b:str = a[start:stop]  # box with five

# Значения от start до конца структуры
c:str = a[start:]  # box with five dozen liquor jugs

# Значения от начала до stop-1
d:str = a[:stop]  # Pack my box with five

# Полная копия структуры
e:str = a[:]  # Pack my box with five dozen liquor jugs
```

Значения `start` и `stop` могут быть отрицательными, это будет означать, что отсчет ведется от конца структуры. Можно также использовать значение `step`, чтобы на выход среза попали не все подряд данные из входной структуры.

```Python
a:str = "Step on no pets"

b:str = a[-4:]  # pets
c:str = a[::-1]  # step on no petS
d:str = a[4::-1]  # petS
e:str = a[::2]  # Se nn es
```

# 2. Сортировка (sort, sorted)

### 2.1 Чем отличается метод sort от sorted()

`sort()` - сортирует данные «на месте» меняя последовательность.
`sorted()` - порождает новую структуру.

```Python
a: list = [5, 2, 3, 1, 4]

b: list = sorted(a)
print(a, b)  # [5, 2, 3, 1, 4] [1, 2, 3, 4, 5]

a.sort()
print(a)  # [1, 2, 3, 4, 5]
```

### 2.2 Для чего нужен параметр key?

И `sort()`, и `sorted()` имеют параметр `key` для указания функции, которая будет вызываться на каждом элементе.

```Python
dinos: list = 'Dinosaurs were Big and small'.split()
b = sorted(dinos, key=len)  # ['Big', 'and', 'were', 'small', 'Dinosaurs']
```

# 3. Comprehension

### 3.1 Что такое Comprehension?

**Comprehension (списковое включение)** — способ компактного описания операций обработки списков, словарей, и множеств. Если нужно получить из списка другой список, включающий только те значения, которые удовлетворяют какому-то определенному условию, или вычисляемые из первого списка по каким-то определенным правилам, то **comprehension** — претендент на решение этой задачи № 1.

```Python
# list
a = [i+1 for i in range(10)]         # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# set
b = {i for i in range(10) if i > 5}  # {8, 9, 6, 7}
# iter
c = (2*i+5 for i in range(10))       # [5, 7, 9, 11, 13, 15, 17, 19, 21, 23]
# dict
d = {i: i**2 for i in range(10)}     # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}

d: dict = {"Italy": "Pizza", "US": "Hot-Dog", "China": "Dim Sum", "South Korea": "Kimchi"}

# Вернет новый словарь, отфильтрованный по значению
a: dict = {k: v for k, v in d.items() if "i" in v}

# Вернет новый словарь, отфильтрованный по ключу
b: dict = {k: v for k, v in d.items() if "i" in k}

# Вернет новый словарь, отфильтрованный по длине значений
c: dict = {k: v for k, v in d.items() if len(v) >= 7}
```

# 4. Операции над строками

### 4.1 Какие основные операции над строками можете назвать?

```Python
s: str = "camelCase string"

print(s.lower())      # camelcase string
print(s.upper())      # CAMELCASE STRING
print(s.capitalize()) # Camelcase string
print(s.title())      # Camelcase String

s: str = "  ~~##A big blahblahblah##~~  "

# Удаляет все пробельные символы с обоих концов строки
s = s.strip()         # '~~##A big blahblahblah##~~'

# Удаляет все указанные символы с обоих концов строки
s = s.strip("~#")     # 'A big blahblahblah'

# Удаляет указанный символ(ы) с начала строки
s = s.lstrip(" A")    # 'big blahblahblah'

# Удаляет указанный символ(ы) с конца строки
s = s.rstrip("habl")  # 'big '

s1: str = "Follow the white rabbit, Neo"

# Разделяет строрку по пробельному символу
c1 = s1.split()       # ['Follow', 'the', 'white', 'rabbit,', 'Neo']

# Разделяет строрку по указанному символу только maxsplit раз
c2 = s1.split(sep=", ", maxsplit=1)  # ['Follow the white rabbit', 'Neo']

s1: str = "abcABC!"

for ch in s1:
    print(f"{ch} -> {ord(ch)}")  # Порядковый номер символа в таблице кодировки

nums = [72, 101, 108, 108, 111, 33]

for num in nums:
    print(f"{num} -> {chr(num)}")  # Символ в таблице кодировки по порядковому номеру
```

# 5. Регулярные выражения (Regex)

### 5.1 Что такое regex?

**Регулярные выражения** (regular expression, regex, регулярка) – это мощный способ обработки текста, позволяющий находить в строках подстроки по сложным условиям.

Чуть более формально, **регулярное выражение** — это строка, задающая шаблон поиска подстрок в тексте. Одному шаблону может соответствовать много разных строк. Регулярное выражение состоит из обычных символов и специальных командных последовательностей. Например, `\d` задаёт любую цифру, а `\d+` — задает любую последовательность из одной или более цифр.

Регулярные выражения обычно применяют для:
-   поиска подстрок в строке
-   разделения строки на подстроки
-   замены части строки

Несколько примеров регулярных выражений:

| Регулярное выражение | Его смысл |
|--|--|
| `string` | означает в точности строку `string` |
| `\d` | означает любую цифру от 00 до 99 |
| `\d{5}` | означает любую последовательность из 55 цифр |
| `\d\d/\d\d/\d{4}` | означает любую дату в формате ДД/ММ/ГГГГ |
| `[-+]?\d+` | означает любое целое число (например, 88, +34+34, −69−69, 007007) |

Регулярные выражения позволяют очень компактно описывать текстовые шаблоны.

> Термин **регулярные выражения** является переводом английского словосочетания **regular expressions**. Перевод не очень точно отражает смысл, правильнее было бы **шаблонные выражения**.

### 5.2 Сырые строки и экранирование

В языке Python некоторые символы нужно экранировать, чтобы они воспринимались правильно. К таким символам относятся:
-   обратный слэш `\`
-   одинарная кавычка `'`
-   двойная кавычка `"`
-   и многие другие

Приведенный ниже код:

```python
print('\\')
print('\'')
print("\"")
```

выводит:

```no-highlight
\
'
"
```

> Экранированные последовательности — это последовательности, которые начинаются с символа `\`, за которым следует один или более символов (`\\, \', \", \n, \t` и т.д.).

Чтобы написать правильно строку, в которой находятся два символа обратного слэша `\\`, оба символа надо экранировать, и в итоге получится строка вида `\\\\`. Вместо экранирования можно использовать *сырые* (**raw**) *строки*, и тогда каждый символ будет восприниматься так, как написан. Сырые строки отличаются от обычных тем, что при создании строки вначале пишется буква `r`.

Приведенный ниже код:

```python
print(r'\\привет мир')
print(r'\\\\')
print(r'\n')
print(r'\t')
```

выводит:

```no-highlight
\\привет мир
\\\\
\n
\t
```

Так как в регулярных выражениях часто используется символ обратного слэша `\`, то рекомендуется использовать сырые строки для описания регулярных выражений. Некоторые выражения правильно отработают и без них, но использование сырых строк для регулярных выражений это хороший тон.

### 5.3 Поиск с помощью регулярных выражений

**Поиск заданного текста**

Для создания регулярных выражений необходимо использовать специальный синтаксис. Любая строка текста сама по себе является регулярным выражением. Например, `String` – это регулярное выражение. Поскольку это просто текст, он ничем не напоминает регулярное выражение, однако он им таки является. Регулярные выражения могут содержать простой текст и могут даже состоять из простого текста.

Регулярному выражению:

```no-highlight
is
```

в тексте:

Hello, my name is J. Doe. Please visit my website at https://stepik.org/org/pygen.

соответствует (выделено жирным шрифтом):

Hello, my name **is**. Please v**is**it my website at https://stepik.org/org/pygen.

> Регулярные выражения сами по себе всегда ищут все вхождения.

Регулярные выражения являются **регистрозависимыми**, то есть регулярному выражению `String` не будет соответствовать строка `string`.

**Поиск любого символа**

С помощью регулярных выражений можно искать не только известный заранее (статический) текст, но и текст в котором есть неизвестные символы. Чтобы найти соответствие некоторому шаблону, в регулярных выражениях используются специальные символы (или наборы символов), которые называются **метасимволами**. Символ точка `.` соответствует одному любому символу.

Регулярному выражению:

```no-highlight
sales.
```

в тексте:

sales.csv
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv

соответствует (выделено жирным шрифтом):

**sales**.csv
**sales1**.csv
orders3.csv
**sales2**.csv
**sales3**.csv
apac1.csv
europe2.csv

Регулярное выражение `sales.`, позволяет найти все имена файлов, содержащие подстроку `sales`, за которой следует еще один произвольный символ.

**Поиск символа точки**

Точка `.` имеет специальное значение в регулярных выражениях. Если в регулярном выражении нужен сам символ точки `.`, то ее необходимо экранировать. Для этого необходимо предварить точку символом обратного слэша `\`.

Регулярному выражению:

```no-highlight
.a.\.csv
```

в тексте:

sales1.csv
orders3.csv
sales2.csv
sales3.csv
na1.csv
na2.csv
sa1.csv

соответствует (выделено жирным шрифтом):

sales1.csv
orders3.csv
sales2.csv
sales3.csv
**na1**.csv
**na2**.csv
**sa1**.csv

**Поиск цифр**

Для поиска любой цифры от 0 до 9 используется метасимвол `\d`.

Регулярному выражению:

```no-highlight
..\d
```

в тексте:

sales.csv
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
na1.csv
na2.csv
sa1.csv

соответствует (выделено жирным шрифтом):

sales.csv
sal**es1**.csv
orde**rs3**.csv
sal**es2**.csv
sal**es3**.csv
ap**ac1**.csv
euro**pe2**.csv
**na1**.csv
**na2**.csv
**sa1**.csv

Для поиска любого **нецифрового** символа используется метасимвол `\D`.

**Поиск пробельных символов**

Для поиска пробельного символа (*пробел, табуляция, конец строки*) используется метасимвол `\s`.

Регулярному выражению:

```python
.\s.
```

в тексте:

привет наконец начали изучать регулярные выражения.

соответствует (выделено жирным шрифтом):

приве**т** **н**аконе**ц** **н**ачал**и** **и**зучат**ь** **р**егулярны**е** **в**ыражени**я**.

Для поиска любого **непробельного** символа используется метасимвол `\S`.

**Поиск алфавитно-цифровых символов**

Для поиска буквы (в верхнем и нижнем регистре), цифры и символ подчеркивания используется метасимвол `\w`.

Регулярному выражению:

```no-highlight
\w\w\w\w
```

в тексте:

\_xy\_
1234
geek
-xy-
Code
a1b2

соответствует (выделено жирным шрифтом):

**\_xy\_**
**1234**
**geek**
-xy-
**Code**
**a1b2**

Для поиска символов, не являющихся буквой, цифрой и подчёркиванием используется метасимвол `\W`.

Регулярному выражению:

```no-highlight
\w\W\W\w
```

в тексте:

x!?y
a..b
geek
1+-2
1234
x__y

соответствует (выделено жирным шрифтом):

**x!?y**
**a..b**
geek
**1+-2**
1234
x__y

> Сайт для отладки регулярных выражений доступен по [ссылке](https://regex101.com/)

**Соответствие одному из нескольких символов**

В регулярных выражениях набор символов определяется с помощью метасимволов `[` и `]`. Метасимволы `[` и `]` определяют набор допустимых символов.

Регулярному выражению:

```no-highlight
[ns]a.\.csv
```

в тексте:

sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
sam.csv
na1.csv
na2.csv
sa1.csv
ca1.csv

соответствует (выделено жирным шрифтом):

sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
**sam.csv
na1.csv
na2.csv
sa1.csv**
ca1.csv

Используемое здесь регулярное выражение начинается с `[ns]`, которое соответствует либо символу `n`, либо символу `s`.

**Использование диапазона набора символов**

При работе с регулярными выражениями часто приходится определять диапазоны символов (от `0` до `9`, от `A` до `Z` и т.д.). Чтобы упростить работу с символьными диапазонами, в регулярных выражениях для определения диапазонов используется специальный метасимвол: дефис `-`.

> Символ дефис - рассматривается как специальный метасимвол только тогда, когда он используется в диапазоне, то есть между [ и ]. Вне диапазона символ - является обычным символом и соответствует только самому себе. 

Регулярному выражению:

```no-highlight
[ns]a[0-9]\.csv
```

в тексте:

sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
sam.csv
na1.csv
na2.csv
sa1.csv
ca1.csv

соответствует (выделено жирным шрифтом):

sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
sam.csv
**na1.csv
na2.csv
sa1.csv**
ca1.csv

Регулярное выражение `[0-9]` функционально эквивалентно выражению `[0123456789]`.

Диапазоны могут состоять не только из цифр. Приведем примеры правильных (допустимых) диапазонов:

- `[A-Z]` соответствует всем символам латинского алфавита верхнего регистра от `A` до `Z`
- `[a-z]` соответствует всем символам латинского алфавита нижнего регистра от `a` до `z`
- `[A-F]` соответствует всем символам латинского алфавита верхнего регистра от `A` до `F`
- `[А-Я]` соответствует всем символам русского алфавита верхнего регистра от `А` до `Я`
- `[а-ф]` соответствует всем символам русского алфавита нижнего регистра от `а` до `ф`

**Соответствие с чем угодно, кроме**

Наборы символов обычно используются для того, чтобы определить список символов, любой из которых может соответствовать одному символу. Но иногда проще указать список символов, ни с одним из которых не должен совпадать данный символ. Другими словами, нужно указать соответствие с чем угодно, кроме того, что указано в наборе символов.

Вместо того, чтобы перечислять каждый символ, можно инвертировать наборы символов, используя метасимвол `^`.

Регулярному выражению:

```no-highlight
[ns]a[^0-9]\.csv
```

в тексте:

europe2.csv
sam.csv
na1.csv
na2.csv
sa1.csv
ca1.csv

соответствует (выделено жирным шрифтом):

europe2.csv
**sam.csv**
na1.csv
na2.csv
sa1.csv
ca1.csv

Диапазон `[0-9]` соответствует всем цифрам (и только цифрам). Выражение `[^0-9]` соответствует чему угодно, кроме цифр указанного диапазона.

**Соответствие одному из нескольких регулярных выражений**

Символ вертикальной черты `|` выполняет роль логического оператора ИЛИ в регулярных выражениях и служит для задания набора альтернатив. Мы можем использовать его всегда, когда хотим найти соответствие одному из нескольких альтернативных выражений.

Регулярному выражению:

```no-highlight
sales[0-9]|[ns]a[0-9]\.csv
```

в тексте:

sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
sam.csv
na1.csv
na2.csv
sa1.csv
ca1.csv

соответствует (выделено жирным шрифтом):

**sales1.csv**
orders3.csv
**sales2.csv
sales3.csv**
apac1.csv
europe2.csv
sam.csv
**na1.csv 
na2.csv 
sa1.csv** 
ca1.csv

Таблица соответствия некоторых метасимволов и диапазонов:

|Метасимвол|Диапазон|Описание|
|---|---|---|
|`\d`|`[0-9]`|любая цифра|
|`\D`|`[^0-9]`|любой нецифровой символ|
|`\w`|`[0-9a-zA-Zа-яА-ЯёЁ_]`|любой алфавитно-цифровой символ и символ `_`|
|`\W`|`[^0-9a-zA-Zа-яА-ЯёЁ_]`|любой символ, отличный от алфавитно-цифрового и `_`|
|`\s`|`[ \f\n\r\t\v]`|любой пробельный символ|
|`\S`|`[^ \f\n\r\t\v]`|любой непробельный символ|

**Повторение совпадений**

**Соответствие с одним или несколькими символами**

Символ `+` устанавливает соответствие с одним или более символами. Таким образом, если регулярное выражение `a` соответствует одному символу `a`, то регулярное выражение `a+` соответствует одному или нескольким символам `a`.

Регулярному выражению:

```no-highlight
a+[0-9]+
```

в тексте:

acedia1.csv
acediaaa1.csv
acediaa12345.csv
baham98.csv
sea777.json
shaaaaa123456789.json
spa.doc
naaa1.csv
na2.csv
sab1.csv
cattt1.csv

соответствует (выделено жирным шрифтом): 

acedi**a1**.csv
acedi**aaa1**.csv
acedi**aa12345**.csv
baham98.csv
se**a777**.json
sh**aaaaa123456789**.json
spa.doc
n**aaa1**.csv
n**a2**.csv
sab1.csv
cattt1.csv

Метасимвол `+` может также использоваться для того чтобы установить соответствие с одним или несколькими наборами символов.

```no-highlight
[\w.]+@[\w.]+\.\w+
```

**Поиск нуля и большего количества символов**

Символ `+` устанавливает соответствие с одним или более символами. С отсутствующими символами (то есть с нулевым количеством символов) соответствие установлено не будет.

**Соответствие с нулем вхождений или с вхождением одного символа**

Метасимвол `?`, позволяет установить соответствие с необязательными символами. В отличие от символа `*`, символ `?` соответствует только отсутствию вхождений или одному вхождению.

Шаблон `https?://` соответствует либо `http://`, либо `https://`, и ничему другому.

**Использование интервалов**

Интервалы определяются между символами `{` и `}`.

**Указание точного количества совпадений**

Чтобы определить точное количество совпадений, число совпадений указывают между фигурными скобками `{` и `}`. Например `{3}` означает поиск соответствий с тремя экземплярами предыдущего символа или набора.

**Установление соответствия в случае интервала-диапазона**

Чтобы определить диапазон количества вхождений (от минимального до максимального), также используются интервалы. Диапазоны определяются, например, так: `{2,4}`. Этот диапазон задает 2 в качестве минимального значения для количества вхождений и 4 – в качестве максимального значения для количества вхождений.

**Установление соответствия в случае интервала типа "не менее" и "не более"** 

Интервалы также можно использовать для того, чтобы определить минимальное количество совпадений, не указывая при этом максимального. Синтаксис для этого типа интервала подобен синтаксису для диапазонов, но в нем опущен максимум. Например, шаблону `{3,}` означает совпадение не менее чем с 3 вхождениями.

|Шаблон|Описание|
|---|---|
|`{n}`|ровно `n` повторений|
|`{m,n}`|от `m` до `n` повторений включительно|
|`{m,}`|не менее `m` повторений|
|`{,n}`|не более `n` повторений|
|`?`|ноль или одно вхождение, синоним `{0,1}`|
|`*`|ноль или более, синоним `{0,}`|
|`+`|одно или более, синоним `{1,}`|

**Жадность и ленивость**

Метасимволы `*` и `+` являются **жадными**, то есть они ищут наибольшее возможное соответствие, а не наименьшее. Из-за этого кажется, что соответствие начинается не с начала, а с конца текста и продолжается назад (в направлении к началу), пока не будет найдено следующее соответствие.

Если нам не нужно жадное поведение, то необходимо использовать **ленивые** аналоги этих метасимволов

Ленивые метасимволы определяются путем добавления в конец `?` к используемому метасимволу, причем для каждого жадного метасимвола имеется ленивый эквивалент.

|Жадный|Ленивый|
|---|---|
|`*`|`*?`|
|`+`|`+?`|
|`?`|`??`|
|`{m,n}`|`{m,n}?`|
|`{,n}`|`{,n}?`|
|`{m,}`|`{m,}?`|

**Использование границ**

**Границы слова**

Символ `\b` указывает границу слова. Таким образом, `\b` соответствует началу или концу слова.

Регулярному выражению:

```no-highlight
\bcat\b
```

в тексте:

The cat scattered his food all over the room.

соответствует (выделено жирным шрифтом):

The **cat** scattered his food all over the room.

Перед словом `cat` и после него есть пробел, и слово вместе с пробелами соответствует регулярному выражению `\bcat\b`, так как пробел – один из символов, которые обычно отделяют слова.

Регулярное выражение `\bcap` соответствует любому слову, которое начинается с `cap`

Регулярное выражение `cap\b` соответствует любому слову, которое заканчивается на `cap`

**Определение границ строк**

Границы строк используются для нахождения соответствий с шаблоном регулярного выражения в начале или конце всей строки. Метасимволы для границ строк – крышка `^` (начало строки) и доллар `$` (конец строки).

> Метасимвол `^` имеет несколько значений. Этот символ отрицает набор, только если находится в наборе (то есть заключен в квадратные скобки `[` и `]`) и является первым символом после открывающей скобки `[`. Вне набора и в начале шаблона символ `^` соответствует началу строки.

**Подвыражения**

Подвыражения – части большого выражения, которые группируются так, чтобы они обрабатывались как единый объект. Подвыражения заключаются между символами `(` и `)`.

Подвыражения могут быть вложенными. Одни подвыражения могут быть вложены в другие подвыражения, которые, в свою очередь, вложены в третьи подвыражения, и т.д.

> Подвыражения используются для группировки частей регулярного выражения, они заключаются в круглые скобки `(` и `)`. Обычно подвыражения используются для того, чтобы точно указать, к каким частям регулярного выражения относятся метасимволы повторения, и правильно определяют операнды операторов ИЛИ (`|`). При необходимости подвыражения могут быть вложены.

### 5.4 Модуль re



# 6. Файлы

### 6.1 Какие параметры у функции open

```Python
f = open("f.txt", mode='r', encoding="utf-8", newline=None)
```

Режимы (mode):
- `r` — чтение (поведение по умолчанию)
- `w` — запись (информация, ранее присутствующая в файле, будет стёрта)
- `x` — эксклюзивное создание и запись; если файл уже существует, будет выброшено исключение `FileExistsError`
- `a` — открытие с последующим добавлением в конец файла
- `w+` — чтение и запись
- `r+` — чтение и запись с начала файла
- `a+` — чтение и запись с конца файла
- `t` — текстовый режим (`rt`, `wt` и т. д.; поведение по умолчанию)
- `b` — двоичный режим (`rb`, `wb`, `xb` и т. д.)

`encoding=None` — будет использована кодировка по умолчанию (зависит от системы). Если нет специальных требований, просто используйте везде `encoding="utf-8"`.

`newline=None` — при чтении системные символы конца строки будут конвертированы в `\n`; при записи, наоборот, `\n` будут конвертированы в системные символы конца строки.

### 6.2  Какие исключения могут возникнуть при работе с файлами

Возможные исключения при работе с файлами:
- **FileNotFoundError** при чтении в режиме `r` или `r+`.
- **FileExistsError** при записи в режиме `x`.
- **IsADirectoryError, PermissionError** — в любом режиме.

### 6.3 Как произвести чтение из файла?

Для работы с файлами лучше использовать *менеджеры контекста*, т. е. конструкции вида "**with** ...". Даже если что-то пойдет не так, как задумано (например, вы не обработаете исключение во время работы с файлом), менеджер контекста «зачистит хвосты», и ваша оплошность не отразится, например, на файловой системе.

```Python
with open("f.txt", encoding="utf-8") as f:
    chars = f.read(5)  # Считывает символы\байты с начала файла пока не встретит EOF
    print(chars)  # Hello

    f.seek(0)  # Передвигает указатель на позицию
    lines = f.readlines()  # Считывает строки в список
    print(lines)  # ['Hello from file!']
```

### 6.4 Как произвести запись в файл?

```Python
with open("f.txt", "w", encoding="utf-8") as f:
    f.write("Hello from file!")  # Или f.writelines(<collection>)
```

# 7. JSON

### 7.1 Что такое JSON?

**JSON** (англ. JavaScript Object Notation) — текстовый формат обмена данными, основанный на языке программирования JavaScript. JSON легко читается людьми. Несмотря на происхождение, формат считается независимым от языка и может использоваться практически с любым языком программирования.

JSON обладает рядом преимуществ, которые и сделали его популярным:
-       не занимает много места, является компактным в написании и быстро компилируется
-       создание текстового содержимого понятно человеку, просто в реализации, а чтение со стороны среды разработки не вызывает никаких проблем. Чтение может осуществляться и человеком, поскольку ничего сложного в представлении данных нет
-       структура преобразуется для чтения на любых языках программирования
практически все языки имеют соответствующие библиотеки или другие инструменты для чтения данных JSON

### 7.2 Каков синтаксис JSON формата?

Данные в формате JSON имеют структуру ключ-значение. Это напоминает словарь Python, но в отличие от словаря, ключи в JSON **могут быть только строками**, заключенными в двойные кавычки. В качестве значений в JSON могут быть использованы:
-       число (целое или вещественное)
-       литералы `true` (истина), `false` (ложь), `null` (отсутствие значения)
-       строка (последовательность символов, заключенная в двойные кавычки)
-       список (заключается в квадратные скобки [ ], значения разделяются запятыми). Список может быть пустым, значения в пределах одного списка могут иметь разный тип
-       вложенный объект (неупорядоченное множество пар ключ: значение, заключённое в фигурные скобки `{ }`). Ключ описывается строкой, между ним и значением стоит символ `:`. Пары ключ-значение отделяются друг от друга запятыми.

```Python
{
   "firstName": "Иван",
   "age": 29,
   "smoke": false,
   "address": {
       "city": "Москва",
       "postalCode": 125315
   },
   "phoneNumbers": ["+7 (919) 424-84-34", "+7 (916) 928-92-34"]
}
```

В формате JSON используются только **двойные** кавычки.

### 7.3 Как осуществить запись и чтение JSON файла?

```Python
import json


d: dict = {1: "Lemon", 2: "Apple", 3: "Banana!"}
object_as_string: str = json.dumps(d, indent=2)

print(object_as_string)  # {'1': 'Lemon', '2': 'Apple', '3': 'Banana!'}

restored_object = json.loads(object_as_string)

# Запись объекта в JSON файл
with open("1.json", 'w', encoding='utf-8') as file:
    json.dump(d, file, indent=2)

# Чтение объекта из JSON файла
with open("1.json", encoding='utf-8') as file:
    restored_from_file = json.load(file)

print(restored_from_file)  # {'1': 'Lemon', '2': 'Apple', '3': 'Banana!'}
```

### 7.4 Модуль json

Преобразование переменных программы (Python-объектов) в формат для хранения называется «**сериализацией**», а обратное преобразование — «**десериализацией**». В Python для сериализации и десериализации в формат json есть модуль — **json**.

Функция `dumps()`

Для сериализации данных в json строку используется функция dumps() из модуля json. Для того, чтобы сериализовать данные с ее помощью, достаточно передать в нее аргументом любой сериализуемый Python объект.

```Python
import json


data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow'}
# сериализуем словарь data в json строку
json_data = json.dumps(data)

print(type(json_data))  # <class 'str'>
print(json_data)        # {"name": "Russia", "phone_code": 7, "capital": "Moscow}
```

Функция `dump()`

В отличие от функции `dumps()`, которая преобразует (сериализует) Python объект в json строку, функция `dump()` записывает переданный Python объект в файл.

```Python
import json


data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}

with open('contries.json', 'w') as file:
    json.dump(data, file)
```

создает файл `contries.json` и сохраняет в него информацию из словаря` data` в json формате.

Если открыть файл `contries.json`, мы увидим, что `json` выведен в одну строку без форматирования:

```json
{"name": "Russia", "phone_code": 7, "capital": "Moscow", "currency": "RUB"}
```

Необязательные аргументы `indent`, `sort_keys` и `separators`

Функции записи `dumps()` и `dump()` имеют необязательные аргументы `indent`, `sort_keys` и separators, которые можно использовать для более удобного чтения человеком.

Аргумент `indent` задает отступ от левого края. По умолчанию имеет значение `None` для более компактного представления без отступов.

Аргумент `sort_keys` задает сортировку ключей в результирующем json. По умолчанию имеет значение `False` для более быстрого создания json. Если установить значение аргумента в True, то ключи будут отсортированы в алфавитном порядке, что особенно удобно, когда ключей много.

Аргумент `separators` задает кортеж, состоящий из двух элементов (`item_separator`, `key_separator`), которые представляют разделители для элементов и ключей.  По умолчанию аргумент имеет значение (', ', ': ').

Функция `loads()`

Для десериализации данных нужно использовать функцию `loads()`. Ее аргумент — это строка с данными в формате json.

```Python
import json


json_data = '{"name": "Russia", "phone_code": 7, "capital": "Moscow"}'
data = json.loads(json_data)

print(type(data))  # <class 'dict'>
print(data)        # {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow'}
```

Как видно из примера, функция `loads()` десериализует json строку в **словарь**.

В случае если строка для десериализации содержит данные с ошибкой, то модуль json не сможет правильно прочитать такую строку, и программа завершится с ошибкой (исключением): **json.decoder.JSONDecodeError**

Функция `load()`

В отличие от функции `loads()`, которая в качестве аргумента принимает строку с данными в формате json, функция `load()` принимает файловый объект и возвращает его десериализованное содержимое.

```json
{
  "name": "Russia",
  "phone_code": 7,
  "capital": "Moscow",
  "cities": ["Abakan", "Almetyevsk", "Anadyr", "Anapa"],
  "currency": "RUB"
}
```

```Python
import json


with open('data.json') as file:
    data = json.load(file)  # передаем файловый объект
    for key, value in data.items():
        if type(value) == list:
            print(f'{key}: {", ".join(value)}')
        else:
            print(f'{key}: {value}')
```

- `json.dumps` - на вход объект (обычно словарь), на выход json-строка
- `json.dump` - на вход объект (обычно словарь), на выход json-файл
- `json.loads` - на вход json-строка, на выход объект (обычно словарь)
- `json.load` - на вход json-файл, на выход объект (обычно словарь)

### 7.5 Типы данных в json

```Python
import json


json_data = '''
{
   "name": "Russia",
   "phone_code": 7,
   "latitude": 60.0,
   "capital": "Moscow",
   "timezones": ["Anadyr", "Barnaul", "Moscow", "Kirov"],
   "translations": {
      "nl": "Rusland",
      "hr": "Rusija",
      "de": "Russland",
   }
}
'''

data = json.loads(json_data)

print(type(data['name']))           # <class 'str'>
print(type(data['phone_code']))     # <class 'int'>
print(type(data['latitude']))       # <class 'float'>
print(type(data['timezones']))      # <class 'list'>
print(type(data['translations']))   # <class 'dict'>
```

Таким образом модуль json автоматически определяет тип значения при десериализации.

Таблица конвертации типов данных Python в JSON:

|**Python**|**JSON**|
|---|---|
|dict|object|
|list, tuple|array|
|str|string|
|int, float|number|
|True|true|
|False|false|
|None|null|

Таблица конвертации JSON в типы данных Python:

|**JSON**|**Python**|
|---|---|
|object|dict|
|array|list|
|string|str|
|number (int)|int|
|number (real)|float|
|true|True|
|false|False|
|null|None|

# 8. Pickle

### 8.1 Что такое pickle?

**Pickle** - бинарный формат для хранения и передачи данных.

```Python
import pickle


d: dict = {1: "Lemon", 2: "Apple", 3: "Banana!"}

# Запись объекта в бинарный файл
with open("1.bin", "wb") as file:
    pickle.dump(d, file)

# Чтение объекта из файла
with open("1.bin", "rb") as file:
    restored_from_file = pickle.load(file)

print(restored_from_file)
```

### 8.2 Модуль pickle

Cериализованный формат — набор байт или строка, которую можно легко сохранить на диск или передать другой программе, в отличие от самого объекта. А значит, задача сохранения объекта/группы объектов при этом сводится к простой задаче сохранения набора байт или строки.

Помимо сериализации в формат json мы также можем использовать бинарную сериализацию, то есть сериализацию в байты. Для этого в Python используется модуль `pickle`.

Функции `dump()` и `load()`

Функция `dump()` модуля `pickle` принимает сериализуемый Python объект, сериализует его в бинарный, Python-зависимый формат, используя протокол `pickle`, и сохраняет его в открытый для записи бинарный файл

```Python
import pickle


obj = {'Python': 1991, 'Java': 1995, 'C#': 2002}

with open('file.pkl', 'wb') as file:
    pickle.dump(obj, file)
```

создает файл `file.pkl`, содержащий бинарное представление объекта `obj` на основе протокола `pickle`.

Функция `load()` принимает файловый объект, читает из него сериализованные данные, десериализует их в Python-объект и возвращает полученный Python-объект.

```Python
import pickle


# используется файл полученный на предыдущем шаге
with open('file.pkl', 'rb') as file:
    obj = pickle.load(file)

    print(obj)        # {'Python': 1991, 'Java': 1995, 'C#': 2002}
    print(type(obj))  # <class 'dict'>
```

Функции `dumps()` и `loads()`

Функция `dumps()` выполняет такую же сериализацию, как и функция `dump()`. Но вместо того чтобы сохранять сериализованные данные в открытый для записи бинарный файл, она просто возвращает эти сериализованные данные.

```Python
import pickle


obj = {'Python': 1991, 'Java': 1995, 'C#': 2002}
binary_obj = pickle.dumps(obj)

print(binary_obj)        # b'\x80\x03}q\x00(X\x06\x00\x00\x00Pythonq\...\xd2\x07u.'
print(type(binary_obj))  # <class 'bytes'>
```

Тип данных **bytes** — это неизменяемые последовательности отдельных байтов. Синтаксис для байтовых литералов в основном такой же, как и для строковых литералов, за исключением того, что добавляется префикс b.

Функция `loads()` выполняет такую же десериализацию, как и функция `load()`. Но вместо того чтобы принимать файловый объект, она принимает объект типа `bytes`, содержащий сериализованные данные.

```Python
import pickle


obj = {'Python': 1991, 'Java': 1995, 'C#': 2002}

# b'\x80\x03}q\x00(X\x06\x00\x00\x00Pythonq\...\xd2\x07u.'
binary_obj = pickle.dumps(obj)
new_obj = pickle.loads(binary_obj)

print(new_obj)  # {'Python': 1991, 'Java': 1995, 'C#': 2002}
```

Объекты **obj** и **new_obj** равны, то есть имеют одинаковое содержимое, однако объекты не являются идентичными. Мы создали идеальную копию, но это всё же копия.

Название модуля `pickle` переводится с английского на русский как **мариновать**.
Модуль pickle может сериализовывать:
-       все встроенные типы данных (`bool`, `int`, `float`, `complex`, `str`, `None`)
-       cписки, кортежи, словари и множества, содержащие любую комбинацию встроенных типов данных
-       cписки, кортежи, словари и множества, содержащие любую комбинацию списков, кортежей, словарей и множеств
-       функции, классы и экземпляры классов

Модуль `pickle` сериализует и десериализует данные быстрее чем модуль `json`.

# 9. Пути (Paths)

### 9.1 Основные команды для работы с путями

```Python
from os import getcwd, path, listdir
from pathlib import Path


# Возвращает текущую рабочую директорию
s1: str = getcwd()
print(s1)  # c:\Users\user\Documents\python\test

# Возвращает полный путь
s2: str = path.abspath("1.bin")
print(s2)  # c:\Users\user\Documents\python\test\1.bin

# Возвращает имя файла
s3: str = path.basename(s2)
# Возвращает путь без файла
s4: str = path.dirname(s2)  
# Возвращает кортеж из пути и имени файла
t1: tuple = path.splitext(s2)  

print(s3, s4, t1)  # 1.bin c:\Users\user\Documents\python\test ('c:\\Users\\user\\Documents\\python\\test', '.bin')

p = Path(s2)
st = p.stat()
print(st)  # os.stat_result(st_mode=33206, st_ino=3940649674252864, st_dev=1249105128, st_nlink=1, st_uid=0, st_gid=0, st_size=48, st_atime=1670508800, st_mtime=1670508811, st_ctime=1670508800)

b1: bool = p.exists()
b2: bool = p.is_file()
b3: bool = p.is_dir()
print(b1, b2, b3)  # True True False

# Возвращает список имен файлов, находящихся по указанному пути
c: list = listdir(path=s1)
# Возвращает имя файла без расширения
s5: str = p.stem
# Возвращает расширение файла
s6: str  = p.suffix
# Возвращает все элементы пути как отдельные строки
t2: tuple = p.parts

print(s5, s6, t2)  # 1 .bin ('c:\\', 'Users', 'user', 'Documents', 'python', 'test', '1.bin')
```

# 10. Другое

### 10.1 Простейшие вычисления — Sum, Count, Min, Max

```Python
a: list = [1, 2, 3, 4, 5, 2, 2]

s = sum(a)      # Вернет сумму элементов списка
c = a.count(2)  # Вернет количество вхождений
mn = min(a)     # Вернет минимальный элемент коллекции
mx = max(a)     # Вернет максимальный элемент коллекции
```

### 10.2 Побитовые операции

```Python
a: int = 0b01010101
b: int = 0b10101010

print(f"And: 0b{a & b:08b}")           # And: 0b00000000
print(f"Or:  0b{a | b:08b}")           # Or:  0b11111111
print(f"Xor: 0b{a ^ b:08b}")           # Xor: 0b11111111
print(f"Left shift: 0b{a << 4:08b}")   # Left shift: 0b10101010000
print(f"Right shift: 0b{b >> 4:08b}")  # Right shift: 0b00001010
print(f"Not: 0b{~a:08b}")              # Not: 0b-1010110
```

### 10.3 Any, All

`any()` вернет `True`, если хотя бы один элемент итерируемой коллекции истинен, `all()` вернет `True` только в случае истинности всех элементов коллекции.

```Python
animals = ["Squirrel", "Beaver", "Fox"]
sentence = "Bison likes squirrels and beavers"

any_a: bool = any(animal.lower() in sentence.lower() for animal in animals)  # True
all_a: bool = all(animal.lower() in sentence.lower() for animal in animals)  # False
```
