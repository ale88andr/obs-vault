### SQL injection в разных частях запроса

Большинство уязвимостей SQL injection возникает в **WHERE‑условии** запроса SELECT. Опытные тестировщики хорошо знакомы с этим типом SQLi.

Однако уязвимости SQL injection могут возникать в любой части запроса и в разных типах запросов. Другие распространённые места:

- В операторах `UPDATE` — в обновляемых значениях или в `WHERE`‑условии.
- В операторах `INSERT` — во вставляемых значениях.
- В операторах `SELECT` — в имени таблицы или столбца.
- В операторах `SELECT` — в секции `ORDER BY`.

### Примеры SQL injection

Существует множество уязвимостей, атак и техник SQL injection, которые проявляются в разных ситуациях. Некоторые распространённые примеры:

- **Извлечение скрытых данных** — модификация SQL‑запроса для возврата дополнительных результатов.
- **Подрыв логики приложения** — изменение запроса для вмешательства в бизнес‑логику.
- **UNION‑атаки** — получение данных из других таблиц базы данных.
- **Слепой SQL injection** — когда результаты управляемого запроса не возвращаются напрямую в ответах приложения.

### Извлечение скрытых данных (пример)

Представим приложение интернет‑магазина, которое отображает товары по категориям. Когда пользователь нажимает на категорию _Gifts_, его браузер запрашивает URL:

```
https://insecure-website.com/products?category=Gifts
```

Это заставляет приложение выполнить SQL‑запрос для получения данных о товарах:

```sql
SELECT * FROM products WHERE category = 'Gifts' AND released = 1
```

Этот запрос просит базу данных вернуть все данные (`*`) из таблицы `products`, где категория = _Gifts_ и `released = 1`.

Условие `released = 1` используется для скрытия товаров, которые ещё не выпущены (для невыпущенных товаров `released = 0`).

Приложение не реализует защиту от SQL injection. Это значит, что злоумышленник может построить атаку, например:

```
https://insecure-website.com/products?category=Gifts'--
```

Результирующий запрос:

```sql
SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1
```

Здесь `--` — это индикатор комментария в SQL. Всё, что идёт после него, игнорируется. В результате условие `AND released = 1` удаляется, и отображаются все товары, включая невыпущенные.

Аналогично можно заставить приложение показать все товары из любой категории, даже неизвестной:

```
https://insecure-website.com/products?category=Gifts'+OR+1=1--
```

Результирующий запрос:

```sql
SELECT * FROM products WHERE category = 'Gifts' OR 1=1--' AND released = 1
```

Такой запрос вернёт все товары, так как условие `1=1` всегда истинно.

> ⚠️ Предупреждение
> Будьте осторожны при внедрении условия `OR 1=1` в SQL‑запрос. Даже если оно кажется безвредным в текущем контексте, приложения часто используют данные из одного запроса в нескольких разных SQL‑операторах. Если такое условие попадёт в UPDATE или DELETE, это может привести к случайной потере данных.

### Подрыв логики приложения (Subverting application logic)

Представим приложение, которое позволяет пользователям входить в систему с именем пользователя и паролем. Если пользователь вводит имя пользователя **wiener** и пароль **bluecheese**, приложение проверяет учётные данные, выполняя следующий SQL‑запрос:

```sql
SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese'
```

Если запрос возвращает данные пользователя, вход считается успешным. В противном случае он отклоняется.

В этом случае злоумышленник может войти под любым пользователем без необходимости знать пароль. Для этого он может использовать последовательность комментария SQL `--`, чтобы удалить проверку пароля из условия **WHERE** запроса.

Например, если ввести имя пользователя:

```
administrator'--
```

и оставить поле пароля пустым, получится следующий запрос:

```sql
SELECT * FROM users WHERE username = 'administrator'--' AND password = ''
```

Этот запрос возвращает пользователя с именем **administrator** и позволяет злоумышленнику успешно войти в систему от его имени.

### Извлечение данных из других таблиц базы данных

В случаях, когда приложение возвращает результаты SQL‑запроса, злоумышленник может использовать уязвимость SQL‑инъекции для получения данных из других таблиц базы данных. Для этого можно использовать ключевое слово **UNION**, чтобы выполнить дополнительный запрос **SELECT** и добавить его результаты к исходному запросу.

Например, если приложение выполняет следующий запрос с пользовательским вводом _Gifts_:

```sql
SELECT name, description FROM products WHERE category = 'Gifts'
```

Злоумышленник может ввести:

```sql
' UNION SELECT username, password FROM users--
```

В результате приложение вернёт все имена пользователей и пароли вместе с названиями и описаниями товаров.

### Уязвимости слепой SQL‑инъекции (Blind SQL injection vulnerabilities)

Многие случаи SQL‑инъекций являются **слепыми уязвимостями**. Это означает, что приложение не возвращает результаты SQL‑запроса или детали ошибок базы данных в своих ответах.

Тем не менее, такие уязвимости всё ещё могут быть использованы для получения несанкционированного доступа к данным, но применяемые техники, как правило, более сложные и трудновыполнимые.

### Техники эксплуатации слепых SQL‑инъекций

В зависимости от характера уязвимости и используемой базы данных можно применять следующие методы:

- **Изменение логики запроса**, чтобы вызвать различие в ответе приложения в зависимости от истинности определённого условия. Это может включать внедрение нового условия в булеву логику или условное вызвание ошибки, например деление на ноль.
    
- **Условная задержка выполнения запроса.** Это позволяет определить истинность условия по времени, которое приложение затрачивает на ответ.
    
- **Внеполосное сетевое взаимодействие (OAST).** Эта техника чрезвычайно мощная и работает в ситуациях, когда другие методы неэффективны. Часто она позволяет напрямую эксфильтровать данные через внеполосный канал. Например, можно встроить данные в DNS‑запрос к домену, который контролирует злоумышленник.
    

Хочешь, я соберу для тебя краткую таблицу с видами **Blind SQLi** и их индикаторами (по ответу, по времени, по OAST), чтобы было удобнее запоминать?

### SQL‑инъекция второго порядка (Second‑order SQL injection)

**SQL‑инъекция первого порядка** возникает тогда, когда приложение обрабатывает пользовательский ввод из HTTP‑запроса и небезопасным образом вставляет его в SQL‑запрос.

**SQL‑инъекция второго порядка** возникает тогда, когда приложение принимает пользовательский ввод из HTTP‑запроса и сохраняет его для будущего использования. Обычно это делается путём помещения данных в базу данных, и на этапе сохранения уязвимость не проявляется. Позже, при обработке другого HTTP‑запроса, приложение извлекает сохранённые данные и небезопасным образом вставляет их в SQL‑запрос.

По этой причине SQL‑инъекция второго порядка также известна как **хранимая SQL‑инъекция (stored SQL injection)**.

![[second-order-sql-injection.svg]]
