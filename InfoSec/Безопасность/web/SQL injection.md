### SQL injection в разных частях запроса

Большинство уязвимостей SQL injection возникает в **WHERE‑условии** запроса SELECT. Опытные тестировщики хорошо знакомы с этим типом SQLi.

Однако уязвимости SQL injection могут возникать в любой части запроса и в разных типах запросов. Другие распространённые места:

- В операторах `UPDATE` — в обновляемых значениях или в `WHERE`‑условии.
- В операторах `INSERT` — во вставляемых значениях.
- В операторах `SELECT` — в имени таблицы или столбца.
- В операторах `SELECT` — в секции `ORDER BY`.

### Примеры SQL injection

Существует множество уязвимостей, атак и техник SQL injection, которые проявляются в разных ситуациях. Некоторые распространённые примеры:

- **Извлечение скрытых данных** — модификация SQL‑запроса для возврата дополнительных результатов.
- **Подрыв логики приложения** — изменение запроса для вмешательства в бизнес‑логику.
- **UNION‑атаки** — получение данных из других таблиц базы данных.
- **Слепой SQL injection** — когда результаты управляемого запроса не возвращаются напрямую в ответах приложения.

### Извлечение скрытых данных (пример)

Представим приложение интернет‑магазина, которое отображает товары по категориям. Когда пользователь нажимает на категорию _Gifts_, его браузер запрашивает URL:

```
https://insecure-website.com/products?category=Gifts
```

Это заставляет приложение выполнить SQL‑запрос для получения данных о товарах:

```sql
SELECT * FROM products WHERE category = 'Gifts' AND released = 1
```

Этот запрос просит базу данных вернуть все данные (`*`) из таблицы `products`, где категория = _Gifts_ и `released = 1`.

Условие `released = 1` используется для скрытия товаров, которые ещё не выпущены (для невыпущенных товаров `released = 0`).

Приложение не реализует защиту от SQL injection. Это значит, что злоумышленник может построить атаку, например:

```
https://insecure-website.com/products?category=Gifts'--
```

Результирующий запрос:

```sql
SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1
```

Здесь `--` — это индикатор комментария в SQL. Всё, что идёт после него, игнорируется. В результате условие `AND released = 1` удаляется, и отображаются все товары, включая невыпущенные.

Аналогично можно заставить приложение показать все товары из любой категории, даже неизвестной:

```
https://insecure-website.com/products?category=Gifts'+OR+1=1--
```

Результирующий запрос:

```sql
SELECT * FROM products WHERE category = 'Gifts' OR 1=1--' AND released = 1
```

Такой запрос вернёт все товары, так как условие `1=1` всегда истинно.

> ⚠️ Предупреждение
> Будьте осторожны при внедрении условия `OR 1=1` в SQL‑запрос. Даже если оно кажется безвредным в текущем контексте, приложения часто используют данные из одного запроса в нескольких разных SQL‑операторах. Если такое условие попадёт в UPDATE или DELETE, это может привести к случайной потере данных.

### Подрыв логики приложения (Subverting application logic)

Представим приложение, которое позволяет пользователям входить в систему с именем пользователя и паролем. Если пользователь вводит имя пользователя **wiener** и пароль **bluecheese**, приложение проверяет учётные данные, выполняя следующий SQL‑запрос:

```sql
SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese'
```

Если запрос возвращает данные пользователя, вход считается успешным. В противном случае он отклоняется.

В этом случае злоумышленник может войти под любым пользователем без необходимости знать пароль. Для этого он может использовать последовательность комментария SQL `--`, чтобы удалить проверку пароля из условия **WHERE** запроса.

Например, если ввести имя пользователя:

```
administrator'--
```

и оставить поле пароля пустым, получится следующий запрос:

```sql
SELECT * FROM users WHERE username = 'administrator'--' AND password = ''
```

Этот запрос возвращает пользователя с именем **administrator** и позволяет злоумышленнику успешно войти в систему от его имени.

### Извлечение данных из других таблиц базы данных

В случаях, когда приложение возвращает результаты SQL‑запроса, злоумышленник может использовать уязвимость SQL‑инъекции для получения данных из других таблиц базы данных. Для этого можно использовать ключевое слово **UNION**, чтобы выполнить дополнительный запрос **SELECT** и добавить его результаты к исходному запросу.

Например, если приложение выполняет следующий запрос с пользовательским вводом _Gifts_:

```sql
SELECT name, description FROM products WHERE category = 'Gifts'
```

Злоумышленник может ввести:

```sql
' UNION SELECT username, password FROM users--
```

В результате приложение вернёт все имена пользователей и пароли вместе с названиями и описаниями товаров.

