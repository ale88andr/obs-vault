В этом разделе мы объясним, что такое межсайтовый скриптинг, опишем различные разновидности уязвимостей XSS и расскажем, как находить и предотвращать XSS.

### Что такое межсайтовый скриптинг (XSS)?

Межсайтовый скриптинг (также известный как XSS) — это уязвимость веб‑безопасности, которая позволяет злоумышленнику скомпрометировать взаимодействие пользователей с уязвимым приложением. Она позволяет злоумышленнику обойти политику одного источника (same origin policy), которая предназначена для разделения разных веб‑сайтов друг от друга.

Уязвимости XSS обычно позволяют злоумышленнику выдавать себя за жертву‑пользователя, выполнять любые действия, которые может выполнять пользователь, и получать доступ к любым данным пользователя. Если у жертвы есть привилегированный доступ в приложении, злоумышленник может получить полный контроль над всей функциональностью и данными приложения.

### Как работает XSS?

Межсайтовый скриптинг работает путём манипуляции уязвимым веб‑сайтом так, чтобы он возвращал пользователям вредоносный JavaScript. Когда вредоносный код выполняется в браузере жертвы, злоумышленник может полностью скомпрометировать её взаимодействие с приложением.

![[cross-site-scripting.svg]]

## Доказательство концепции XSS (Proof of Concept)

Вы можете подтвердить большинство видов уязвимостей XSS, внедрив полезную нагрузку (payload), которая заставляет ваш собственный браузер выполнить произвольный JavaScript. Долгое время обычной практикой было использование функции **alert()** для этой цели, потому что она короткая, безвредная и довольно заметная, когда успешно вызывается. Фактически, большинство наших XSS‑лабораторных заданий решаются путём вызова **alert()** в браузере имитируемой жертвы.

К сожалению, есть небольшая загвоздка, если вы используете Chrome. Начиная с версии 92 (20 июля 2021 года), кросс‑доменные iframe больше не могут вызывать **alert()**. Так как они используются для построения некоторых более продвинутых XSS‑атак, вам иногда придётся использовать альтернативный PoC‑payload. В этом случае мы рекомендуем функцию **print()**. Если вам интересно узнать больше об этом изменении и о том, почему мы предпочитаем **print()**, ознакомьтесь с нашей публикацией в блоге на эту тему.

Так как имитируемая жертва в наших лабораторных заданиях использует Chrome, мы изменили соответствующие лабораторные работы так, чтобы их также можно было решить с помощью **print()**. Мы указали это в инструкциях там, где это актуально.

## Какие бывают типы XSS‑атак?

Существует три основных типа XSS‑атак:

- **Reflected XSS** — когда вредоносный скрипт поступает из текущего HTTP‑запроса.
    
- **Stored XSS** — когда вредоносный скрипт поступает из базы данных веб‑сайта.
    
- **DOM‑based XSS** — когда уязвимость существует в коде на стороне клиента, а не на стороне сервера.
    

### Reflected cross‑site scripting

Reflected XSS — это самая простая разновидность межсайтового скриптинга. Она возникает, когда приложение получает данные в HTTP‑запросе и включает эти данные в немедленный ответ небезопасным образом.

Простой пример уязвимости Reflected XSS:

```
https://insecure-website.com/status?message=All+is+well.
<p>Status: All is well.</p>
```

Приложение не выполняет никакой дополнительной обработки данных, поэтому злоумышленник может легко сконструировать атаку вроде этой:

```
https://insecure-website.com/status?message=<script>/*+Bad+stuff+here...+*/</script>
<p>Status: <script>/* Bad stuff here... */</script></p>
```

Если пользователь посетит URL, сконструированный злоумышленником, то скрипт злоумышленника выполнится в браузере пользователя в контексте его сессии с приложением. В этот момент скрипт может выполнять любые действия и получать любые данные, к которым имеет доступ пользователь.

## Хранимый межсайтовый скриптинг (Stored XSS)

Хранимый XSS (также известный как **persistent XSS** или **second‑order XSS**) возникает, когда приложение получает данные из ненадёжного источника и включает эти данные в свои последующие HTTP‑ответы небезопасным образом.

Рассматриваемые данные могут быть отправлены в приложение через HTTP‑запросы; например:

- комментарии к записи в блоге,
    
- никнеймы пользователей в чате,
    
- контактные данные в заказе клиента.
    

В других случаях данные могут поступать из других ненадёжных источников; например:

- веб‑почтовое приложение, отображающее сообщения, полученные по SMTP,
    
- маркетинговое приложение, отображающее публикации из социальных сетей,
    
- система мониторинга сети, отображающая данные пакетов из сетевого трафика.
    

Простой пример уязвимости хранимого XSS:

Приложение форума позволяет пользователям отправлять сообщения, которые отображаются другим пользователям:

```html
<p>Hello, this is my message!</p>
```

Приложение не выполняет никакой дополнительной обработки данных, поэтому злоумышленник может легко отправить сообщение, которое атакует других пользователей:

```html
<p><script>/* Bad stuff here... */</script></p>
```

Хочешь, я соберу для тебя **таблицу с тремя колонками**: _Тип XSS → Как проявляется → Последствия_ — чтобы у тебя был быстрый справочник по Reflected, Stored и DOM‑based XSS?

## Межсайтовый скриптинг на основе DOM (DOM-based XSS)

DOM‑based XSS (также известный как DOM XSS) возникает, когда приложение содержит некоторый JavaScript на стороне клиента, который обрабатывает данные из ненадёжного источника небезопасным образом, обычно записывая эти данные обратно в DOM.

В следующем примере приложение использует JavaScript, чтобы прочитать значение из поля ввода и записать это значение в элемент внутри HTML:

```js
var search = document.getElementById('search').value;
var results = document.getElementById('results');
results.innerHTML = 'You searched for: ' + search;
```

Если злоумышленник может контролировать значение поля ввода, он легко может сконструировать вредоносное значение, которое приведёт к выполнению его собственного скрипта:

```
You searched for: <img src=1 onerror='/* Bad stuff here... */'>
```

В типичном случае поле ввода будет заполняться из части HTTP‑запроса, например параметра строки запроса URL, что позволяет злоумышленнику доставить атаку с помощью вредоносного URL, аналогично отражённому XSS.

## Для чего может использоваться XSS?

Злоумышленник, который эксплуатирует уязвимость межсайтового скриптинга, обычно способен:

- Выдавать себя за жертву‑пользователя.
    
- Выполнять любые действия, которые может выполнять пользователь.
    
- Читать любые данные, к которым имеет доступ пользователь.
    
- Захватывать учётные данные для входа пользователя.
    
- Выполнять виртуальный «дефейсинг» веб‑сайта.
    
- Встраивать троянскую функциональность в веб‑сайт.
    

## Влияние уязвимостей XSS

Фактическое влияние XSS‑атаки обычно зависит от характера приложения, его функциональности и данных, а также от статуса скомпрометированного пользователя. Например:

- В приложении‑«визитке», где все пользователи анонимны и вся информация является публичной, влияние часто будет минимальным.
    
- В приложении, содержащем конфиденциальные данные, такие как банковские транзакции, электронные письма или медицинские записи, влияние обычно будет серьёзным.
    
- Если скомпрометированный пользователь имеет повышенные привилегии в приложении, то влияние, как правило, будет критическим, позволяя злоумышленнику получить полный контроль над уязвимым приложением и скомпрометировать всех пользователей и их данные.

## Как находить и тестировать уязвимости XSS

Подавляющее большинство уязвимостей XSS можно быстро и надёжно обнаружить с помощью веб‑сканера уязвимостей Burp Suite.

Ручное тестирование на наличие отражённого (reflected) и хранимого (stored) XSS обычно включает отправку некоторого простого уникального ввода (например, короткой буквенно‑цифровой строки) во все точки ввода приложения, определение всех мест, где отправленный ввод возвращается в HTTP‑ответах, и индивидуальное тестирование каждого места, чтобы определить, можно ли использовать специально подготовленный ввод для выполнения произвольного JavaScript. Таким образом, вы можете определить контекст, в котором возникает XSS, и выбрать подходящую полезную нагрузку (payload) для эксплуатации.

Ручное тестирование DOM‑based XSS, возникающего из параметров URL, включает аналогичный процесс: помещение некоторого простого уникального ввода в параметр, использование инструментов разработчика браузера для поиска этого ввода в DOM и тестирование каждого места, чтобы определить, является ли оно эксплуатируемым. Однако другие типы DOM‑XSS труднее обнаружить. Чтобы найти DOM‑уязвимости, возникающие из не связанных с URL источников ввода (например, `document.cookie`) или не связанных с HTML приёмников (sinks), таких как `setTimeout`, нет замены ручному анализу JavaScript‑кода, что может быть чрезвычайно трудоёмким.

## Политика безопасности содержимого (Content Security Policy, CSP)

Политика безопасности содержимого (CSP) — это механизм браузера, направленный на снижение воздействия межсайтового скриптинга (XSS) и некоторых других уязвимостей. Если приложение, использующее CSP, содержит поведение, похожее на XSS, то CSP может затруднить или предотвратить эксплуатацию уязвимости. Однако часто CSP можно обойти, чтобы всё же эксплуатировать основную уязвимость.

## Внедрение «висящей» разметки (Dangling markup injection)

Внедрение «висящей» разметки — это техника, которая может использоваться для захвата данных между доменами в ситуациях, когда полноценная эксплуатация XSS невозможна из‑за фильтров ввода или других средств защиты. Часто её можно использовать для захвата конфиденциальной информации, доступной другим пользователям, включая CSRF‑токены, которые могут применяться для выполнения несанкционированных действий от имени пользователя.

## Как предотвратить XSS‑атаки

Предотвращение межсайтового скриптинга в некоторых случаях тривиально, но может быть гораздо сложнее в зависимости от сложности приложения и способов обработки данных, контролируемых пользователем.

В целом, эффективное предотвращение XSS‑уязвимостей, скорее всего, будет включать комбинацию следующих мер:

- **Фильтрация ввода при получении.** В момент получения пользовательского ввода фильтруйте его максимально строго, исходя из ожидаемого или допустимого формата.
    
- **Кодирование данных при выводе.** В момент, когда данные, контролируемые пользователем, выводятся в HTTP‑ответах, кодируйте их, чтобы предотвратить интерпретацию как активного содержимого. В зависимости от контекста вывода это может требовать комбинации HTML‑, URL‑, JavaScript‑ и CSS‑кодирования.
    
- **Использование соответствующих заголовков ответа.** Чтобы предотвратить XSS в HTTP‑ответах, которые не должны содержать HTML или JavaScript, можно использовать заголовки **Content-Type** и **X-Content-Type-Options**, чтобы гарантировать, что браузеры интерпретируют ответы именно так, как вы задумали.
    
- **Content Security Policy.** В качестве последней линии защиты можно использовать CSP, чтобы снизить серьёзность любых XSS‑уязвимостей, которые всё же возникают.

## Часто задаваемые вопросы о межсайтовом скриптинге (XSS)

**Насколько распространены уязвимости XSS?** Уязвимости XSS очень распространены, и XSS, вероятно, является самой часто встречающейся уязвимостью веб‑безопасности.

**Насколько распространены XSS‑атаки?** Трудно получить надёжные данные о реальных XSS‑атаках, но, вероятно, они эксплуатируются реже, чем другие уязвимости.

**В чём разница между XSS и CSRF?** XSS включает в себя заставление веб‑сайта возвращать вредоносный JavaScript, в то время как CSRF подразумевает побуждение жертвы выполнять действия, которые она не намеревалась совершать.

**В чём разница между XSS и SQL‑инъекцией?** XSS — это уязвимость на стороне клиента, которая нацелена на других пользователей приложения, тогда как SQL‑инъекция — это уязвимость на стороне сервера, которая нацелена на базу данных приложения.

**Как предотвратить XSS в PHP?** Фильтруйте ввод с помощью белого списка разрешённых символов и используйте подсказки типов или приведение типов. Экранируйте вывод с помощью `htmlentities` и `ENT_QUOTES` для HTML‑контекста или используйте Unicode‑экранирование для JavaScript‑контекста.

**Как предотвратить XSS в Java?** Фильтруйте ввод с помощью белого списка разрешённых символов и используйте библиотеку, такую как **Google Guava**, для HTML‑кодирования вывода в HTML‑контексте, либо используйте Unicode‑экранирование для JavaScript‑контекста.

