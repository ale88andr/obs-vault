### Обман веб‑кэша (Web cache deception)

Обман веб‑кэша — это уязвимость, которая позволяет злоумышленнику обмануть веб‑кэш и заставить его сохранить чувствительное, динамическое содержимое. Она возникает из‑за различий в том, как сервер кэша и исходный сервер обрабатывают запросы.

В атаке типа «обман веб‑кэша» злоумышленник убеждает жертву перейти по вредоносному URL, вынуждая браузер жертвы отправить неоднозначный запрос на получение конфиденциального содержимого. Кэш неверно интерпретирует этот запрос как обращение к статическому ресурсу и сохраняет ответ. Затем злоумышленник может запросить тот же URL и получить доступ к закэшированному ответу, тем самым получив несанкционированный доступ к приватной информации.

![[wcd-image-1.png]]

> Примечание
> Важно различать **обман веб‑кэша (web cache deception)** и **отравление веб‑кэша (web cache poisoning)**. Хотя обе атаки используют механизмы кэширования, делают они это по‑разному:
> - **Отравление веб‑кэша** манипулирует ключами кэша, чтобы внедрить вредоносное содержимое в закэшированный ответ, который затем будет выдан другим пользователям.
> - **Обман веб‑кэша** эксплуатирует правила кэширования, чтобы обмануть кэш и заставить его сохранить конфиденциальное или приватное содержимое, к которому затем может получить доступ злоумышленник.

### Веб‑кэши

**Веб‑кэш** — это система, расположенная между исходным сервером и пользователем. Когда клиент запрашивает статический ресурс, запрос сначала направляется в кэш. Если кэш не содержит копии ресурса (так называемый _cache miss_ — «промах кэша»), запрос пересылается на исходный сервер, который обрабатывает его и формирует ответ. Ответ затем отправляется в кэш перед тем, как попасть к пользователю. Кэш использует заранее настроенные правила, чтобы определить, сохранять ли ответ.

Когда в будущем поступает запрос на тот же статический ресурс, кэш напрямую выдаёт пользователю сохранённую копию ответа (так называемый _cache hit_ — «попадание в кэш»).

![[caching.svg]]

Кэширование стало распространённым и важным аспектом доставки веб‑контента, особенно с широким использованием сетей доставки контента (CDN). CDN используют кэширование для хранения копий контента на распределённых серверах по всему миру. Они ускоряют доставку, обслуживая контент с сервера, ближайшего к пользователю, сокращая время загрузки за счёт уменьшения расстояния, которое должны пройти данные.

### Ключи кэша

Когда кэш получает HTTP‑запрос, он должен решить, есть ли у него закэшированный ответ, который можно отдать напрямую, или нужно переслать запрос на исходный сервер. Кэш принимает это решение, создавая «ключ кэша» из элементов HTTP‑запроса. Обычно в него входят путь URL и параметры запроса, но также могут учитываться и другие элементы, такие как заголовки и тип содержимого.

Если ключ кэша входящего запроса совпадает с ключом предыдущего запроса, кэш считает их эквивалентными и отдаёт копию закэшированного ответа.

### Правила кэширования

Правила кэширования определяют, **что может быть закэшировано и на какой срок**. Обычно правила настраиваются для хранения статических ресурсов, которые, как правило, не меняются часто и используются на нескольких страницах. Динамическое содержимое не кэшируется, так как оно с большей вероятностью содержит конфиденциальную информацию, и это гарантирует, что пользователи получают актуальные данные напрямую с сервера.

Атаки типа _обман веб‑кэша_ (web cache deception) используют особенности применения правил кэширования, поэтому важно знать о разных типах правил, особенно тех, что основаны на определённых строках в пути URL‑запроса. Например:

- **Правила по расширению файлов (Static file extension rules):** Эти правила сопоставляют расширение запрашиваемого ресурса, например `.css` для таблиц стилей или `.js` для JavaScript‑файлов.
- **Правила по директориям (Static directory rules):** Эти правила сопоставляют все пути URL, начинающиеся с определённого префикса. Часто применяются к каталогам, содержащим только статические ресурсы, например `/static` или `/assets`.
- **Правила по имени файла (File name rules):** Эти правила сопоставляют конкретные имена файлов, которые универсально требуются для работы веб‑сайта и редко меняются, например `robots.txt` и `favicon.ico`.

Кэши также могут реализовывать **пользовательские правила** на основе других критериев, таких как параметры URL или динамический анализ.

### Построение атаки типа «обман веб‑кэша» (Web Cache Deception)

В общем случае базовая атака обмана веб‑кэша включает следующие шаги:
1. **Определите целевой эндпоинт**, который возвращает динамический ответ с конфиденциальной информацией. Просмотрите ответы в Burp, так как часть чувствительных данных может быть не видна на отрендеренной странице. Сосредоточьтесь на эндпоинтах, поддерживающих методы **GET, HEAD или OPTIONS**, так как запросы, изменяющие состояние исходного сервера, обычно не кэшируются.
2. **Определите расхождение** в том, как кэш и исходный сервер интерпретируют путь URL. Это может быть различие в том, как они:
    - сопоставляют URL с ресурсами,
    - обрабатывают разделители,
    - нормализуют пути.
3. **Сформируйте вредоносный URL**, который использует это расхождение, чтобы обмануть кэш и заставить его сохранить динамический ответ. Когда жертва перейдёт по этому URL, её ответ будет сохранён в кэше. Затем, используя Burp, вы можете отправить запрос на тот же URL и получить закэшированный ответ с данными жертвы. Избегайте делать это напрямую в браузере, так как некоторые приложения перенаправляют пользователей без сессии или инвалидируют локальные данные, что может скрыть уязвимость.

### Использование «cache buster»

При тестировании расхождений и создании эксплойта обмана веб‑кэша убедитесь, что каждый отправляемый запрос имеет **разный ключ кэша**. Иначе вы можете получать закэшированные ответы, что исказит результаты теста.

Так как в ключ кэша обычно входят путь URL и параметры запроса, вы можете изменять ключ, добавляя строку запроса и меняя её при каждом запросе. Автоматизировать этот процесс можно с помощью расширения **Param Miner**. После установки выберите в меню _Param Miner > Settings_ пункт **Add dynamic cachebuster**. Теперь Burp будет добавлять уникальную строку запроса к каждому вашему запросу. Добавленные параметры можно просматривать во вкладке _Logger_.

### Определение закэшированных ответов

Во время тестирования важно уметь определять, был ли ответ закэширован. Для этого смотрите на **заголовки ответа** и **время ответа**.

Примеры заголовков:

- **X-Cache: hit** — ответ отдан из кэша.
- **X-Cache: miss** — в кэше не было ответа для данного ключа, запрос ушёл на исходный сервер. Обычно ответ затем кэшируется. Чтобы подтвердить, отправьте запрос повторно и проверьте, изменится ли значение на _hit_.
- **X-Cache: dynamic** — контент сгенерирован динамически, обычно не кэшируется.
- **X-Cache: refresh** — закэшированный контент устарел и был обновлён/проверен.

**Cache-Control** также может содержать директивы вроде _public_ с _max-age > 0_, указывающие на возможность кэширования. Но это лишь рекомендация — кэш может переопределить этот заголовок.

Разница во времени ответа на одинаковый запрос также может указывать на то, что более быстрый ответ пришёл из кэша.

### Эксплуатация правил кэширования по статическим расширениям

Правила кэширования часто нацелены на статические ресурсы, сопоставляя распространённые расширения файлов, такие как `.css` или `.js`. Это поведение по умолчанию в большинстве CDN.

Если кэш и исходный сервер по‑разному сопоставляют путь URL с ресурсами или используют разделители, злоумышленник может сформировать запрос к динамическому ресурсу с «статическим» расширением. Сервер проигнорирует расширение, а кэш воспримет его как статический файл и сохранит ответ.

### Несоответствия в сопоставлении путей (Path Mapping Discrepancies)

**Сопоставление пути URL** — это процесс связывания путей URL с ресурсами на сервере (файлами, скриптами, командами). Существуют разные стили, например:

- **Традиционное сопоставление:** путь напрямую соответствует файлу в файловой системе.
    
```
http://example.com/path/in/filesystem/resource.html
```

Здесь `/path/in/filesystem/` — путь в файловой системе, `resource.html` — конкретный файл.
    
- **REST‑стиль:** путь абстрагирован в логические части API.

```
http://example.com/path/resource/param1/param2
```

Здесь `/path/resource/` — эндпоинт, а `param1` и `param2` — параметры.

Пример уязвимости:

```
http://example.com/user/123/profile/wcd.css
```

- Сервер с REST‑сопоставлением интерпретирует это как запрос к `/user/123/profile` и возвращает профиль пользователя 123, игнорируя `wcd.css`.
- Кэш с традиционным сопоставлением видит это как запрос к файлу `wcd.css` в каталоге `/user/123/profile/`. Если настроено кэширование для `.css`, он сохранит и выдаст профиль как CSS‑файл.

### Эксплуатация несоответствий в сопоставлении путей

- Чтобы проверить, как сервер сопоставляет путь, добавьте произвольный сегмент к URL. Если ответ остаётся тем же (например, `/api/orders/123/foo` возвращает те же данные, что и `/api/orders/123`), значит сервер абстрагирует путь и игнорирует сегмент.
- Чтобы проверить, как кэш сопоставляет путь, добавьте статическое расширение: `/api/orders/123/foo.js`. Если ответ кэшируется, это значит:
    - кэш учитывает полный путь с расширением,
    - есть правило кэширования для `.js`.

Попробуйте разные расширения: `.css`, `.ico`, `.exe`.

Таким образом можно создать URL, который возвращает динамический ответ, но сохраняется в кэше. Однако атака ограничена конкретным эндпоинтом, так как сервер может по‑разному абстрагировать пути для разных ресурсов.

### Несоответствия в использовании разделителей (Delimiter discrepancies)

**Разделители** определяют границы между различными элементами в URL. Использование символов и строк в качестве разделителей в целом стандартизировано. Например, символ `?` обычно используется для отделения пути URL от строки запроса. Однако так как RFC для URI достаточно либерален, между различными фреймворками или технологиями всё же встречаются вариации.

Несоответствия в том, как кэш и исходный сервер используют символы и строки в качестве разделителей, могут привести к уязвимостям типа _обман веб‑кэша_ (web cache deception). Рассмотрим пример `/profile;foo.css`:

- **Java Spring** использует символ `;` для добавления параметров, известных как _matrix variables_. Поэтому исходный сервер на Java Spring интерпретирует `;` как разделитель, обрезает путь после `/profile` и возвращает информацию профиля.
- Большинство других фреймворков не используют `;` как разделитель. Следовательно, кэш, который не работает на Java Spring, скорее всего воспримет `;` и всё, что идёт после него, как часть пути. Если в кэше есть правило сохранять ответы на запросы, оканчивающиеся на `.css`, он может закэшировать и выдать информацию профиля как будто это CSS‑файл.

То же самое справедливо и для других символов, которые используются непоследовательно в разных фреймворках или технологиях. Рассмотрим запросы к серверу на **Ruby on Rails**, который использует `.` как разделитель для указания формата ответа:

- `/profile` — обрабатывается HTML‑форматтером по умолчанию, возвращается информация профиля пользователя.
- `/profile.css` — распознаётся как расширение CSS. Так как CSS‑форматтера нет, запрос не принимается и возвращается ошибка.
- `/profile.ico` — расширение `.ico` не распознаётся Ruby on Rails. Запрос обрабатывается HTML‑форматтером по умолчанию, и возвращается информация профиля пользователя. В этой ситуации, если кэш настроен сохранять ответы на запросы, оканчивающиеся на `.ico`, он закэширует и выдаст информацию профиля как будто это статический файл.

Иногда в качестве разделителей могут использоваться и закодированные символы. Например, запрос `/profile%00foo.js`:

- Сервер **OpenLiteSpeed** использует закодированный нулевой символ `%00` как разделитель. Поэтому он интерпретирует путь как `/profile`.
- Большинство других фреймворков возвращают ошибку, если в URL встречается `%00`. Однако кэш на **Akamai** или **Fastly** интерпретирует `%00` и всё, что идёт после него, как часть пути.

### Эксплуатация несоответствий в использовании разделителей

Вы можете использовать несоответствие в разделителях, чтобы добавить статическое расширение к пути, которое будет воспринято кэшем, но не исходным сервером. Для этого нужно определить символ, который используется как разделитель исходным сервером, но не кэшем.

1. **Определите разделители, используемые исходным сервером.** Для начала добавьте произвольную строку в URL целевого эндпоинта. Например, измените `/settings/users/list` на `/settings/users/listaaa`. Используйте этот ответ как эталон при тестировании разделителей.
    
    ⚠️ _Примечание:_ Если ответ идентичен исходному, это указывает на перенаправление. Нужно выбрать другой эндпоинт для теста.
    
2. **Добавьте возможный разделитель** между исходным путём и произвольной строкой, например `/settings/users/list;aaa`:
    - Если ответ идентичен базовому, это значит, что символ `;` используется как разделитель, и сервер интерпретирует путь как `/settings/users/list`.
    - Если ответ совпадает с вариантом `/settings/users/listaaa`, значит `;` не используется как разделитель, и сервер интерпретирует путь как `/settings/users/list;aaa`.
3. **Проверьте, как кэш обрабатывает разделитель.** Для этого добавьте статическое расширение в конец пути. Если ответ кэшируется, это указывает:
    - что кэш не использует данный символ как разделитель и интерпретирует полный путь с расширением,
    - что существует правило кэширования для запросов, оканчивающихся на `.js`.

Обязательно протестируйте все ASCII‑символы и разные распространённые расширения: `.css`, `.ico`, `.exe`. В лабораториях предоставлен список потенциальных разделителей (_Web cache deception lab delimiter list_). Используйте **Burp Intruder** для быстрого тестирования символов. Чтобы Burp Intruder не кодировал символы‑разделители, отключите автоматическое кодирование в настройках _Payload encoding_.

### Пример эксплуатации

Можно построить эксплойт, который активирует правило кэширования по статическому расширению. Например, полезная нагрузка:

```
/settings/users/list;aaa.js
```

- Кэш интерпретирует путь как: `/settings/users/list;aaa.js`
- Исходный сервер интерпретирует путь как: `/settings/users/list`

Исходный сервер возвращает динамическую информацию профиля, которая сохраняется в кэше.

Так как разделители обычно используются последовательно в пределах одного сервера, такую атаку можно применять на многих разных эндпоинтах.

### Несоответствия при декодировании разделителей (Delimiter decoding discrepancies)

Иногда веб‑сайтам необходимо передавать в URL данные, содержащие символы, которые имеют специальное значение в URL, например разделители. Чтобы такие символы интерпретировались как данные, их обычно кодируют. Однако некоторые парсеры декодируют определённые символы до обработки URL. Если символ‑разделитель будет декодирован, он может быть воспринят как разделитель и привести к усечению пути URL.

Различия в том, какие символы‑разделители декодируются кэшем и исходным сервером, могут привести к расхождениям в интерпретации пути URL, даже если оба используют одни и те же символы как разделители. Рассмотрим пример `/profile%23wcd.css`, где используется закодированный символ `#`:

- Исходный сервер декодирует `%23` в `#`. Он использует `#` как разделитель, поэтому интерпретирует путь как `/profile` и возвращает информацию профиля.
- Кэш также использует символ `#` как разделитель, но не декодирует `%23`. Он интерпретирует путь как `/profile%23wcd.css`. Если в кэше есть правило для расширения `.css`, он сохранит ответ.

Кроме того, некоторые серверы кэша могут сначала декодировать URL и затем переслать запрос с декодированными символами. Другие сначала применяют правила кэширования к закодированному URL, а затем декодируют его и пересылают дальше. Эти различия также могут привести к несоответствиям в интерпретации пути URL кэшем и исходным сервером. Рассмотрим пример `/myaccount%3fwcd.css`:

- Сервер кэша применяет правила кэширования к закодированному пути `/myaccount%3fwcd.css` и решает сохранить ответ, так как есть правило для расширения `.css`. Затем он декодирует `%3f` в `?` и пересылает изменённый запрос на исходный сервер.
- Исходный сервер получает запрос `/myaccount?wcd.css`. Он использует символ `?` как разделитель, поэтому интерпретирует путь как `/myaccount`.

### Эксплуатация несоответствий при декодировании разделителей

Вы можете использовать несоответствие при декодировании, добавив закодированный разделитель к пути так, чтобы кэш воспринимал его с расширением статического файла, а исходный сервер — нет.

Используйте ту же методологию тестирования, что и для обычных несоответствий разделителей, но применяйте диапазон закодированных символов. Обязательно протестируйте закодированные непечатаемые символы, особенно `%00`, `%0A` и `%09`. Если они будут декодированы, это также может усечь путь URL.

### Эксплуатация правил кэширования статических директорий

Обычная практика веб‑серверов — хранить статические ресурсы в определённых директориях. Правила кэширования часто нацелены на эти директории, сопоставляя определённые префиксы пути URL, такие как `/static`, `/assets`, `/scripts` или `/images`. Эти правила также могут быть уязвимы для атак типа _обман веб‑кэша_.