**OWASP** (Open Web Application Security Project) — открытый проект по безопасности веб-приложений, созданный и поддерживаемый некоммерческой организацией OWASP Foundation.

В [последней редакции](https://owasp.org/www-project-top-ten/) OWASP Top Ten названы следующие уязвимости:

- нарушение контроля доступа;
- недочёты криптографии;
- инъекции;
- небезопасный дизайн;
- небезопасная конфигурация;
- использование уязвимых или устаревших компонентов;
- ошибки идентификации и аутентификации;
- нарушения целостности программного обеспечения и данных;
- ошибки логирования и мониторинга безопасности;
- подделка запросов на стороне сервера.

## **Нарушение контроля доступа**

Это набор уязвимостей, при которых система плохо контролирует уровни доступа к информации или к своей функциональности. Из-за этого злоумышленники могут пользоваться функциями, к которым не должны иметь доступа.

Представьте веб-приложение, где каждая учётная запись имеет разные права доступа. Если оно слабо защищено, злоумышленник может модифицировать запросы или параметры URL, чтобы получить доступ к данным, на которые у него нет права.

Такая уязвимость может привести к разглашению или утрате конфиденциальной информации, взлому учётных записей пользователей и нарушению целостности данных.

**Что делать:**

- Проектируйте контроль доступа на основе принципа наименьших привилегий. Пользователи должны иметь только те права, которые необходимы для выполнения их задач.
- Проводите аутентификацию и авторизацию на всех уровнях приложения— и на серверной, и на клиентской стороне.
- Регулярно проводите тестирование и аудит контроля доступа.

**Чего не стоит делать:**

- Полагаться только на скрытие ссылок или кнопок в пользовательском интерфейсе для ограничения доступа. Это не предотвратит доступ к закрытой функциональности по прямым запросам.
- Доверять пользовательским входным данным при авторизации. Всегда следует проводить проверку на сервере.
- Оставлять прежней политику контроля доступа при изменении требований и бизнес-логики приложения.

## **Недостатки криптографии**

Недостатки криптографии — это уязвимости, связанные с неправильной настройкой и использованием криптографических методов для защиты данных. К ним относят недостаточную длину ключей, ненадёжные условия их хранения, использование устаревших алгоритмов и другие ошибки в криптографической реализации.

Слабая криптография — как картонный сейф: делает данные уязвимыми для атакующих, но создаёт иллюзию защищённости. Например, если веб-приложение использует устаревший и слабый алгоритм шифрования для защиты паролей пользователей, то хакер довольно быстро взломает его методом перебора. Но разработчики будут думать, что их система защищена.

**Что делать:**

- Обновляйте и пересматривайте криптографические методы и ключи с учётом последних рекомендаций и стандартов.
- Храните криптографические ключи в надёжном месте. Избегайте их хранения вместе с кодом приложения или в открытом виде.

**Чего не стоит делать:**

- Использовать устаревшие или слабые алгоритмы шифрования.
- Реализовывать собственные криптографические методы, если вы не являетесь экспертом в этой области.
- Хранить криптографические ключи в открытом виде или внутри кода приложения.

## **Инъекции**

Инъекция — это пользовательский ввод с вредоносным кодом. Чаще всего инъекции включают SQL-запросы и команды на языке оболочки операционной системы.

Инъекции позволяют злоумышленникам внедрять свой вредоносный код на сервер и выполнять его. Результат — потеря данных, кража данных или повреждение системы.

Представьте, что у компании есть база данных с информацией о клиентах. Если в форме ввода пользовательской информации — допустим, для обращения в службу поддержки — не установлена фильтрация и валидация вводимых данных, то злоумышленник может написать в ней обычный SQL-запрос и получить в ответ от сервера конфиденциальную информацию из базы клиентов.

**Что делать:**

- Используйте параметризованные запросы или ORM (object-relational mapping) для работы с базой данных.
- Валидируйте и фильтруйте входные данные. Принимайте только допустимые символы и структуры данных.
- Применяйте принцип наименьших привилегий: ограничивайте права доступа к базе данных необходимыми.
- Используйте LIMIT и другие элементы управления SQL в запросах для предотвращения массового раскрытия записей в случае SQL-инъекции.

**Чего не стоит делать:**

- Конкатенировать и вставлять непроверенные данные пользователя напрямую в SQL-запросы, команды операционной системы или другие исполняемые на сервере контексты.
- Надеяться на то, что фильтрация одного типа данных предотвратит инъекции. Злоумышленники могут использовать разные методы атак.
- Хранить конфиденциальные данные в чистом тексте без шифрования в базе данных.

## **Небезопасный дизайн архитектуры приложения**

Широкая категория уязвимостей, впервые появившаяся в последней версии OWASP Top Ten. Уязвимости этой категории возникают потому, что сама логика работы приложения может позволять использовать существующие функции для взлома.

Например, в веб-приложение пользователи загружают файлы на сервер без их проверки. Злоумышленники могут использовать эту функцию и загрузить на сервер исполняемый файл с вредоносным кодом.

**Что делать:**

- Продумывайте аспекты безопасности на ранних этапах проектирования приложения.
- Оценивайте потенциальные угрозы и риски на этапе проектирования и разрабатывайте меры их предотвращения.
- Обязательно моделируйте угрозы для критической аутентификации, контроля доступа, бизнес-логики и ключевых потоков в приложении.
- Ограничивайте количество ресурсов на сервере, которое выделяется на одного пользователя и на одну сессию.

**Чего не стоит делать:**

- Полагаться только на обеспечение безопасности на уровне кода. Безопасный дизайн важен для создания надёжной системы в целом.
- Разрабатывать систему, не учитывая возможные атаки на неё.

## **Небезопасная конфигурация**

Небезопасная конфигурация — это ситуация, когда настройки приложения, сервера, базы данных или других компонентов системы не являются безопасными. К этой группе уязвимостей относят ненадёжные или отсутствующие настройки аутентификации, авторизации и доступа.

Предположим, что разработчик не закрыл доступ к административной панели приложения для пользователей без аутентификации или со стандартными настройками входа. Такое часто встречается у начинающих программистов. В этом случае злоумышленники легко могут взломать административную панель и изменить её настройки, подделать или украсть данные.

**Что делать:**

- Проводите безопасную настройку всех компонентов приложения и инфраструктуры, следуя рекомендациям и стандартам безопасности.
- Продумайте и поддерживайте политику настройки доступов.
- Отключайте или удаляйте ненужные функции и службы на сервере, чтобы сократить возможный спектр атак.
- Реализуйте автоматизированный процесс проверки эффективности конфигураций и настроек во всех средах.
- Регулярно проверяйте настройки на наличие уязвимостей.

**Чего не стоит делать:**

- Оставлять дефолтные пароли, настройки или ключи. Обязательно меняйте их на уникальные и сложные.
- Оставлять включёнными даже те функции и службы, что кажутся избыточными.
- Полагаться только на документацию по установке. Проверяйте и дорабатывайте настройки с учётом текущих требований безопасности.

## **Использование уязвимых или устаревших компонентов**

К этому типу уязвимостей относят случаи, когда веб-приложение использует сторонние фреймворки, библиотеки, плагины или другие компоненты, которые имеют выявленные дефекты безопасности.

У злоумышленников даже есть автоматизированные инструменты, которые помогают находить непропатченные или неправильно сконфигурированные системы. Например, поисковая система Shodan IoT ищет устройства, которые страдают от уязвимости Heartbleed, исправленной в апреле 2014 года. Удивительно, но они встречаются и в 2023 году.

**Что делать:**

- Регулярно обновляйте используемые компоненты. Следите за выпуском обновлений и исправлений, касающихся безопасности компонентов.
- Удаляйте неиспользуемые зависимости, ненужные функции, компоненты и файлы.
- Используйте источники, которые предоставляют информацию о безопасности компонентов: [OWASP Dependency-Check](https://owasp.org/www-project-dependency-check/), [Retire.js](https://retirejs.github.io/retire.js/) и другие.

**Чего не стоит делать:**

- Использовать устаревшие компоненты без обновления.
- Игнорировать предупреждения о безопасности, которые касаются используемых компонентов.

## **Ошибки идентификации и аутентификации**

Слабые пароли, недостаточная проверка подлинности, неэффективные системы учёта сеансов — всё это OWASP относит к ошибкам идентификации и аутентификации.

Предположим, что веб-приложение допускает слабые пароли, такие как «123456», «admin» или «qwerty». Злоумышленник может легко взломать аккаунт, угадав такой пароль или просто перебрав варианты.

Сюда же относятся:

- незащищённые способы восстановления паролей — например, подходы на основе знаний, когда человек должен ответить на секретный вопрос;
- отсутствие многофакторной авторизации;
- раскрытие идентификатора сессии в URL.

**Что делать:**

- Используйте сильные механизмы аутентификации, такие как двухфакторная аутентификация.
- Требуйте от пользователей создавать пароли с высокой устойчивостью к взлому, включающие в себя не только буквы, но и другие символы.
- Не раскрывайте идентификаторы сессии в URL-адресе.
- Блокируйте аккаунты после определённого количества неудачных попыток входа.

**Чего не стоит делать:**

- Разрешать пользователям использовать слабые пароли или пароли по умолчанию.
- Хранить пароли пользователей в открытом виде в базе данных. Храните хеши паролей [с солью](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BB%D1%8C_\(%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F\)).

## **Нарушения целостности программного обеспечения и данных**

К этой группе уязвимостей относят случаи, когда после обновления приложение или оборудование начинает работать неправильно. Например, роутер после обновления прошивки не требует пароля для подключения или сбрасывает его до заводского.

**Что делать:**

- Используйте проверку целостности данных, используя хеши и цифровые подписи для обнаружения несанкционированных изменений.
- Ограничивайте доступ и возможность изменения данных для неавторизованных пользователей.
- Внедряйте подробные журналы и мониторинг подозрительной активности, чтобы сохранять информацию о совершаемых пользователями действиях.

**Чего не стоит делать:**

- Хранить критически важные данные в открытом виде или без требования авторизации.
- Выдавать всем пользователям полные права на изменение данных. Всегда используйте принцип наименьших привилегий, выдавая только действительно необходимые права.
- Игнорировать предупреждения системы мониторинга о подозрительной активности. Реагируйте на них своевременно.

## **Ошибки логирования и мониторинга безопасности**

Это уязвимости, при которых система неправильно регистрирует аномальные события, касающиеся безопасности. К ним также относят отсутствие или неправильную настройку механизмов логирования и отсутствие уведомлений о подозрительных событиях.

Если в системе отсутствует мониторинг безопасности, то атаки злоумышленников могут остаться незамеченными. Это снижает вероятность быстрой реакции на возникающие инциденты, обнаружение угроз и определение их источников.

Предположим, что веб-приложение не регистрирует попытки неудачной аутентификации. Злоумышленник пытается многократно взломать аккаунт пользователя или администратора, а разработчик не замечает этого — система не фиксирует такие попытки.

**Что делать:**

- Внедрите механизмы логирования для регистрации важных событий, таких как попытки аутентификации, изменения в конфигурации и доступе к чувствительным данным.
- Установите систему мониторинга, которая анализирует логи на наличие подозрительной активности и уведомляет вас об инцидентах.
- Определите чёткие процедуры реагирования на инциденты и оповещения и обязательно расскажите о них всей команде.

**Чего не стоит делать:**

- Оставлять логирование без внимания. Регулярно анализируйте логи для выявления аномальных событий.
- Обходиться без мониторинга. Обязательно убедитесь, что система мониторинга активна и правильно настроена.
- Использовать только автоматические уведомления о состоянии системы. Регулярно вручную проверяйте состояние системы и логов.

## **Подделка запросов на стороне сервера**

Подделка запросов на стороне сервера (server-side request forgery, SSRF) — это тип уязвимости, при котором злоумышленник заставляет сервер отправлять запросы к внутренним ресурсам или внешним сайтам.

SSRF часто используется злоумышленниками для обнаружения и атаки внутренних ресурсов, к которым они обычно не имеют доступа извне. Представьте веб-приложение, которое выполняет HTTP-запросы к внешним URL-адресам на основе пользовательского ввода. Если сервер слабо защищён от SSRF, злоумышленник может ввести зловредный URL, который заставит сервер отправить запрос ко внутреннему серверу с базой данных, и получить оттуда данные.

**Что делать:**

- Ограничивайте или фильтруйте пользовательский ввод, который используется для формирования запросов.
- Используйте белый список (whitelist) разрешённых адресов, на которые сервер может отправлять запросы.
- Ограничьте и контролируйте доступ сервера к внутренним ресурсам.

**Чего не стоит делать:**

- Доверять непроверенным или неконтролируемым URL-адресам, переданным пользователем.
- Открывать доступ сервера к внутренним ресурсам без проверки.
- Использовать пользовательский ввод напрямую для формирования запросов на стороне сервера.

# Академия web безопасности

### Обман веб‑кэша (Web cache deception)

Обман веб‑кэша — это уязвимость, которая позволяет злоумышленнику обмануть веб‑кэш и заставить его сохранить чувствительное, динамическое содержимое. Она возникает из‑за различий в том, как сервер кэша и исходный сервер обрабатывают запросы.

В атаке типа «обман веб‑кэша» злоумышленник убеждает жертву перейти по вредоносному URL, вынуждая браузер жертвы отправить неоднозначный запрос на получение конфиденциального содержимого. Кэш неверно интерпретирует этот запрос как обращение к статическому ресурсу и сохраняет ответ. Затем злоумышленник может запросить тот же URL и получить доступ к закэшированному ответу, тем самым получив несанкционированный доступ к приватной информации.

![[wcd-image-1.png]]

> Примечание
> Важно различать **обман веб‑кэша (web cache deception)** и **отравление веб‑кэша (web cache poisoning)**. Хотя обе атаки используют механизмы кэширования, делают они это по‑разному:
> - **Отравление веб‑кэша** манипулирует ключами кэша, чтобы внедрить вредоносное содержимое в закэшированный ответ, который затем будет выдан другим пользователям.
> - **Обман веб‑кэша** эксплуатирует правила кэширования, чтобы обмануть кэш и заставить его сохранить конфиденциальное или приватное содержимое, к которому затем может получить доступ злоумышленник.

### Веб‑кэши

**Веб‑кэш** — это система, расположенная между исходным сервером и пользователем. Когда клиент запрашивает статический ресурс, запрос сначала направляется в кэш. Если кэш не содержит копии ресурса (так называемый _cache miss_ — «промах кэша»), запрос пересылается на исходный сервер, который обрабатывает его и формирует ответ. Ответ затем отправляется в кэш перед тем, как попасть к пользователю. Кэш использует заранее настроенные правила, чтобы определить, сохранять ли ответ.

Когда в будущем поступает запрос на тот же статический ресурс, кэш напрямую выдаёт пользователю сохранённую копию ответа (так называемый _cache hit_ — «попадание в кэш»).

![[caching.svg]]

Кэширование стало распространённым и важным аспектом доставки веб‑контента, особенно с широким использованием сетей доставки контента (CDN). CDN используют кэширование для хранения копий контента на распределённых серверах по всему миру. Они ускоряют доставку, обслуживая контент с сервера, ближайшего к пользователю, сокращая время загрузки за счёт уменьшения расстояния, которое должны пройти данные.

### Ключи кэша

Когда кэш получает HTTP‑запрос, он должен решить, есть ли у него закэшированный ответ, который можно отдать напрямую, или нужно переслать запрос на исходный сервер. Кэш принимает это решение, создавая «ключ кэша» из элементов HTTP‑запроса. Обычно в него входят путь URL и параметры запроса, но также могут учитываться и другие элементы, такие как заголовки и тип содержимого.

Если ключ кэша входящего запроса совпадает с ключом предыдущего запроса, кэш считает их эквивалентными и отдаёт копию закэшированного ответа.

### Правила кэширования

Правила кэширования определяют, **что может быть закэшировано и на какой срок**. Обычно правила настраиваются для хранения статических ресурсов, которые, как правило, не меняются часто и используются на нескольких страницах. Динамическое содержимое не кэшируется, так как оно с большей вероятностью содержит конфиденциальную информацию, и это гарантирует, что пользователи получают актуальные данные напрямую с сервера.

Атаки типа _обман веб‑кэша_ (web cache deception) используют особенности применения правил кэширования, поэтому важно знать о разных типах правил, особенно тех, что основаны на определённых строках в пути URL‑запроса. Например:

- **Правила по расширению файлов (Static file extension rules):** Эти правила сопоставляют расширение запрашиваемого ресурса, например `.css` для таблиц стилей или `.js` для JavaScript‑файлов.
- **Правила по директориям (Static directory rules):** Эти правила сопоставляют все пути URL, начинающиеся с определённого префикса. Часто применяются к каталогам, содержащим только статические ресурсы, например `/static` или `/assets`.
- **Правила по имени файла (File name rules):** Эти правила сопоставляют конкретные имена файлов, которые универсально требуются для работы веб‑сайта и редко меняются, например `robots.txt` и `favicon.ico`.

Кэши также могут реализовывать **пользовательские правила** на основе других критериев, таких как параметры URL или динамический анализ.

### Построение атаки типа «обман веб‑кэша» (Web Cache Deception)

В общем случае базовая атака обмана веб‑кэша включает следующие шаги:
1. **Определите целевой эндпоинт**, который возвращает динамический ответ с конфиденциальной информацией. Просмотрите ответы в Burp, так как часть чувствительных данных может быть не видна на отрендеренной странице. Сосредоточьтесь на эндпоинтах, поддерживающих методы **GET, HEAD или OPTIONS**, так как запросы, изменяющие состояние исходного сервера, обычно не кэшируются.
2. **Определите расхождение** в том, как кэш и исходный сервер интерпретируют путь URL. Это может быть различие в том, как они:
    - сопоставляют URL с ресурсами,
    - обрабатывают разделители,
    - нормализуют пути.
3. **Сформируйте вредоносный URL**, который использует это расхождение, чтобы обмануть кэш и заставить его сохранить динамический ответ. Когда жертва перейдёт по этому URL, её ответ будет сохранён в кэше. Затем, используя Burp, вы можете отправить запрос на тот же URL и получить закэшированный ответ с данными жертвы. Избегайте делать это напрямую в браузере, так как некоторые приложения перенаправляют пользователей без сессии или инвалидируют локальные данные, что может скрыть уязвимость.

### Использование «cache buster»

При тестировании расхождений и создании эксплойта обмана веб‑кэша убедитесь, что каждый отправляемый запрос имеет **разный ключ кэша**. Иначе вы можете получать закэшированные ответы, что исказит результаты теста.

Так как в ключ кэша обычно входят путь URL и параметры запроса, вы можете изменять ключ, добавляя строку запроса и меняя её при каждом запросе. Автоматизировать этот процесс можно с помощью расширения **Param Miner**. После установки выберите в меню _Param Miner > Settings_ пункт **Add dynamic cachebuster**. Теперь Burp будет добавлять уникальную строку запроса к каждому вашему запросу. Добавленные параметры можно просматривать во вкладке _Logger_.

### Определение закэшированных ответов

Во время тестирования важно уметь определять, был ли ответ закэширован. Для этого смотрите на **заголовки ответа** и **время ответа**.

Примеры заголовков:

- **X-Cache: hit** — ответ отдан из кэша.
- **X-Cache: miss** — в кэше не было ответа для данного ключа, запрос ушёл на исходный сервер. Обычно ответ затем кэшируется. Чтобы подтвердить, отправьте запрос повторно и проверьте, изменится ли значение на _hit_.
- **X-Cache: dynamic** — контент сгенерирован динамически, обычно не кэшируется.
- **X-Cache: refresh** — закэшированный контент устарел и был обновлён/проверен.

**Cache-Control** также может содержать директивы вроде _public_ с _max-age > 0_, указывающие на возможность кэширования. Но это лишь рекомендация — кэш может переопределить этот заголовок.

Разница во времени ответа на одинаковый запрос также может указывать на то, что более быстрый ответ пришёл из кэша.

### Эксплуатация правил кэширования по статическим расширениям

Правила кэширования часто нацелены на статические ресурсы, сопоставляя распространённые расширения файлов, такие как `.css` или `.js`. Это поведение по умолчанию в большинстве CDN.

Если кэш и исходный сервер по‑разному сопоставляют путь URL с ресурсами или используют разделители, злоумышленник может сформировать запрос к динамическому ресурсу с «статическим» расширением. Сервер проигнорирует расширение, а кэш воспримет его как статический файл и сохранит ответ.

### Несоответствия в сопоставлении путей (Path Mapping Discrepancies)

**Сопоставление пути URL** — это процесс связывания путей URL с ресурсами на сервере (файлами, скриптами, командами). Существуют разные стили, например:

- **Традиционное сопоставление:** путь напрямую соответствует файлу в файловой системе.
    
```
http://example.com/path/in/filesystem/resource.html
```

Здесь `/path/in/filesystem/` — путь в файловой системе, `resource.html` — конкретный файл.
    
- **REST‑стиль:** путь абстрагирован в логические части API.

```
http://example.com/path/resource/param1/param2
```

Здесь `/path/resource/` — эндпоинт, а `param1` и `param2` — параметры.

Пример уязвимости:

```
http://example.com/user/123/profile/wcd.css
```

- Сервер с REST‑сопоставлением интерпретирует это как запрос к `/user/123/profile` и возвращает профиль пользователя 123, игнорируя `wcd.css`.
- Кэш с традиционным сопоставлением видит это как запрос к файлу `wcd.css` в каталоге `/user/123/profile/`. Если настроено кэширование для `.css`, он сохранит и выдаст профиль как CSS‑файл.

### Эксплуатация несоответствий в сопоставлении путей

- Чтобы проверить, как сервер сопоставляет путь, добавьте произвольный сегмент к URL. Если ответ остаётся тем же (например, `/api/orders/123/foo` возвращает те же данные, что и `/api/orders/123`), значит сервер абстрагирует путь и игнорирует сегмент.
- Чтобы проверить, как кэш сопоставляет путь, добавьте статическое расширение: `/api/orders/123/foo.js`. Если ответ кэшируется, это значит:
    - кэш учитывает полный путь с расширением,
    - есть правило кэширования для `.js`.

Попробуйте разные расширения: `.css`, `.ico`, `.exe`.

Таким образом можно создать URL, который возвращает динамический ответ, но сохраняется в кэше. Однако атака ограничена конкретным эндпоинтом, так как сервер может по‑разному абстрагировать пути для разных ресурсов.

### Несоответствия в использовании разделителей (Delimiter discrepancies)

**Разделители** определяют границы между различными элементами в URL. Использование символов и строк в качестве разделителей в целом стандартизировано. Например, символ `?` обычно используется для отделения пути URL от строки запроса. Однако так как RFC для URI достаточно либерален, между различными фреймворками или технологиями всё же встречаются вариации.

Несоответствия в том, как кэш и исходный сервер используют символы и строки в качестве разделителей, могут привести к уязвимостям типа _обман веб‑кэша_ (web cache deception). Рассмотрим пример `/profile;foo.css`:

- **Java Spring** использует символ `;` для добавления параметров, известных как _matrix variables_. Поэтому исходный сервер на Java Spring интерпретирует `;` как разделитель, обрезает путь после `/profile` и возвращает информацию профиля.
    
- Большинство других фреймворков не используют `;` как разделитель. Следовательно, кэш, который не работает на Java Spring, скорее всего воспримет `;` и всё, что идёт после него, как часть пути. Если в кэше есть правило сохранять ответы на запросы, оканчивающиеся на `.css`, он может закэшировать и выдать информацию профиля как будто это CSS‑файл.
    

То же самое справедливо и для других символов, которые используются непоследовательно в разных фреймворках или технологиях. Рассмотрим запросы к серверу на **Ruby on Rails**, который использует `.` как разделитель для указания формата ответа:

- `/profile` — обрабатывается HTML‑форматтером по умолчанию, возвращается информация профиля пользователя.
- `/profile.css` — распознаётся как расширение CSS. Так как CSS‑форматтера нет, запрос не принимается и возвращается ошибка.
- `/profile.ico` — расширение `.ico` не распознаётся Ruby on Rails. Запрос обрабатывается HTML‑форматтером по умолчанию, и возвращается информация профиля пользователя. В этой ситуации, если кэш настроен сохранять ответы на запросы, оканчивающиеся на `.ico`, он закэширует и выдаст информацию профиля как будто это статический файл.

Иногда в качестве разделителей могут использоваться и закодированные символы. Например, запрос `/profile%00foo.js`:

- Сервер **OpenLiteSpeed** использует закодированный нулевой символ `%00` как разделитель. Поэтому он интерпретирует путь как `/profile`.
- Большинство других фреймворков возвращают ошибку, если в URL встречается `%00`. Однако кэш на **Akamai** или **Fastly** интерпретирует `%00` и всё, что идёт после него, как часть пути.

### Эксплуатация несоответствий в использовании разделителей

Вы можете использовать несоответствие в разделителях, чтобы добавить статическое расширение к пути, которое будет воспринято кэшем, но не исходным сервером. Для этого нужно определить символ, который используется как разделитель исходным сервером, но не кэшем.

1. **Определите разделители, используемые исходным сервером.** Для начала добавьте произвольную строку в URL целевого эндпоинта. Например, измените `/settings/users/list` на `/settings/users/listaaa`. Используйте этот ответ как эталон при тестировании разделителей.
    
    ⚠️ _Примечание:_ Если ответ идентичен исходному, это указывает на перенаправление. Нужно выбрать другой эндпоинт для теста.
    
2. **Добавьте возможный разделитель** между исходным путём и произвольной строкой, например `/settings/users/list;aaa`:
    - Если ответ идентичен базовому, это значит, что символ `;` используется как разделитель, и сервер интерпретирует путь как `/settings/users/list`.
    - Если ответ совпадает с вариантом `/settings/users/listaaa`, значит `;` не используется как разделитель, и сервер интерпретирует путь как `/settings/users/list;aaa`.
3. **Проверьте, как кэш обрабатывает разделитель.** Для этого добавьте статическое расширение в конец пути. Если ответ кэшируется, это указывает:
    - что кэш не использует данный символ как разделитель и интерпретирует полный путь с расширением,
    - что существует правило кэширования для запросов, оканчивающихся на `.js`.

Обязательно протестируйте все ASCII‑символы и разные распространённые расширения: `.css`, `.ico`, `.exe`. В лабораториях предоставлен список потенциальных разделителей (_Web cache deception lab delimiter list_). Используйте **Burp Intruder** для быстрого тестирования символов. Чтобы Burp Intruder не кодировал символы‑разделители, отключите автоматическое кодирование в настройках _Payload encoding_.

### Пример эксплуатации

Можно построить эксплойт, который активирует правило кэширования по статическому расширению. Например, полезная нагрузка:

```
/settings/users/list;aaa.js
```

- Кэш интерпретирует путь как: `/settings/users/list;aaa.js`
- Исходный сервер интерпретирует путь как: `/settings/users/list`

Исходный сервер возвращает динамическую информацию профиля, которая сохраняется в кэше.

Так как разделители обычно используются последовательно в пределах одного сервера, такую атаку можно применять на многих разных эндпоинтах.

