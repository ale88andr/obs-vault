
Безопасность транспортного уровня (**TLS**), также известная как [Secure Socket Layer (SSL)](https://wiki.merionet.ru/servernye-resheniya/43/kak-rabotaet-internet-bezopasnost-tls-ssl-i-ca/), является протоколом безопасного транспортного уровня, развернутым по умолчанию в большинстве веб-браузеров. Когда пользователи видят маленький зеленый замок, указывающую на то, что веб-сайт "безопасен", это означает, что SSL-сертификат действителен, а трафик между хостом (на котором работает браузер) и сервером (на котором работает веб-сервер) шифруется. TLS-это сложный протокол с большим количеством различных опций; в этом разделе будет представлен приблизительный обзор его работы. На рисунке 3 показаны компоненты пакета TLS.

![[Pasted image 20240122104626.png]]

На рисунке 3:

- Протокол рукопожатия отвечает за инициализацию сеансов и настройку параметров сеанса, включая начальный обмен закрытыми ключами.
- Протокол предупреждений отвечает за обработку ошибок.
- Изменение спецификации шифра отвечает за запуск шифрования.
- Протокол записи разбивает блоки данных, представленные для транспортировки, на фрагменты, (необязательно) сжимает данные, добавляет **Message Authentication Code (MAC)**, шифрует данные с помощью симметричного ключа, добавляет исходную информацию в блок, а затем отправляет [блок в Transmission Control Protocol (TCP) для транспортировки по сети](https://wiki.merionet.ru/seti/23/tcp-i-udp-v-chem-raznica/).

Приложения, работающие поверх TLS, используют специальный номер порта для доступа к службе через TLS. Например, веб-службы, использующие [протокол передачи гипертекста (HTTP)](https://wiki.merionet.ru/servernye-resheniya/3/protocol-http/), обычно доступны через TCP-порт 80. Протокол HTTP с шифрованием TLS обычно доступен через порт 443. Хотя служба остается той же, изменение номера порта позволяет процессу TCP направлять трафик, который должен быть незашифрован, чтобы конечное приложение могло его прочитать.

MAC, который в этом контексте будет означать код аутентификации сообщения, используется для обеспечения аутентификации отправителя. В то время как некоторые криптографические системы предполагают, что успешное шифрование данных с помощью ключа, известного получателю, доказывает, что отправитель действительно тот, за кого он себя выдает, TLS этого не делает.

Вместо этого TLS включает MAC, который проверяет отправителя отдельно от ключей, используемых для шифрования сообщений в сети. Это помогает предотвратить атаки **MitM** на потоки данных, зашифрованные с помощью TLS.

На рисунке 4 показано рукопожатие запуска TLS, которое управляется протоколом рукопожатия.

![[Pasted image 20240122104640.png]]
На рисунке 4:

1. Приветствие клиента отправляется в виде открытого текста и содержит информацию о версии TLS, которую использует клиент, 32 случайных октета (**nonce**), идентификатор сеанса (который позволяет восстановить или восстановить предыдущий сеанс), список алгоритмов шифрования (**наборов шифров**), поддерживаемых клиентом, и список алгоритмов сжатия данных, поддерживаемых клиентом.
2. Приветствие сервера также отправляется в виде открытого текста и содержит ту же информацию, что и выше, с точки зрения сервера. В приветственном сообщении сервера поле алгоритма шифрования указывает тип шифрования, который будет использоваться для этого сеанса. Обычно это "**лучший**" алгоритм шифрования, доступный как на клиенте, так и на сервере (хотя он не всегда "**лучший**").
3. Сервер отправляет свой открытый ключ (**сертификат**) вместе с nonce, который клиент отправил на сервер, где nonce теперь шифруется с помощью закрытого ключа сервера.
4. Сообщение сервера **hello done** (принятие приветствия) указывает, что теперь у клиента есть информация, необходимая для завершения настройки сеанса.
5. Клиент генерирует закрытый ключ и использует открытый ключ сервера для его шифрования. Это передается в сообщении обмена ключами клиента на сервер.
6. После того, как это было передано, клиент должен подписать что-то, что известно, как серверу, так и клиенту, чтобы убедиться, что отправитель является правильным устройством. Обычно до этого момента подпись присутствует во всех сообщениях обмена. Как правило, криптографический хеш используется для генерации проверки.
7. Сообщение об изменении спецификации шифра по существу подтверждает, что сеанс запущен и работает.
8. Готовое сообщение (завершение) еще раз аутентифицирует все предыдущие сообщения рукопожатия до этого момента.
9. Затем сервер подтверждает, что сеанс шифрования установлен, отправив сообщение изменения спецификации шифра.
10. Затем сервер отправляет готовое сообщение, которое аутентифицирует предыдущие сообщения, отправленные в рукопожатии таким же образом, как и выше.

> **Примечание**. Дополнительные шаги в рукопожатии TLS были исключены из этого объяснения для ясности.

После того, как сеанс запущен, приложения могут отправлять информацию принимающему хосту по правильному номеру порта. Эти данные будут зашифрованы с использованием предварительно согласованного закрытого ключа и затем переданы TCP для доставки.