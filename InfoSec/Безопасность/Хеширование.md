Хеширование означает использование некоторой функции или алгоритма для сопоставления данных объекта с некоторым репрезентативным целочисленным значением. Результат этой функции известен как хеш-значение или просто хэш (**hash**). Хорошая хеш-функция использует алгоритм одностороннего хеширования, или, другими словами, хэш нельзя преобразовать обратно в исходный ключ.

Обеспечение того, чтобы данные не изменялись (модифицировались) во время передачи, очень важно, и чтобы помочь нам определить, сохраняется ли целостность сообщения, мы можем использовать алгоритмы хеширования. Алгоритмы хеширования предназначены для получения входных данных, например, строки текста или файла, а затем использования односторонней функции для создания дайджеста. **Дайджест (digest)** - это хеш-представление ввода, и его нельзя отменить. Каждый уникальный файл или сообщение генерирует уникальное хеш-значение (дайджест). Это означает, что, если данные каким-либо образом изменены, значение хеш-функции будет однозначно другим.

На следующем рисунке показан процесс одностороннего хеширования:
![[Pasted image 20240122101330.png]]Как этот процесс работает между устройствами? Представьте, что отправитель, хост A, хочет отправить сообщение на устройство назначения, хост B. Вместо того, чтобы хост A отправлял сообщение как есть, хост A создаст дайджест сообщения. Как только в дайджесте будет создано сообщение, хост A отправит и сообщение, и дайджест хосту B. На следующем рисунке показано, что хост A отправляет сообщение с дайджестом хосту B:

![[Pasted image 20240122101401.png]]

Когда хост B получает сообщение от источника, он также создает дайджест сообщения и сравнивает его с дайджестом, полученным от хоста A. Если оба значения хеш-функции (дайджесты) совпадают, это означает, что сообщение не было изменено во время передачи. Однако, если значения дайджеста различаются, это означает, что где-то по пути сообщение было изменено и, следовательно, содержимое сообщения не совпадает.

Возможно ли, что два разных файла будут иметь одинаковое хеш-значение? Хотя алгоритмы хеширования предназначены для создания уникального дайджеста для каждого уникального файла, в прошлом были случаи, что у двух разных файлов одно и то же значение хеш-функции. Это известно, как **хэш-коллизия**. Если произошла коллизия хеширования, это означает, что алгоритм хеширования, используемый во время процесса, уязвим, и ему не следует доверять. Однако некоторые из самых популярных алгоритмов хеширования, которые используются в настоящее время, подвержены коллизии хеширования.

---

### Алгоритмы хеширования

**Message Digest 5 (MD5)** - это алгоритм хеширования, который создает 128-битный дайджест. Алгоритм MD5 был реализован во многих системах на протяжении многих лет и работал хорошо до тех пор, пока не произошла коллизия хеширования. Это сделало MD5 уязвимым алгоритмом хеширования, который больше не рекомендуется.

На следующем рисунке представлен процесс хеширования MD5:
![[Pasted image 20240122101459.png]]

Как показано на предыдущей диаграмме, сообщение отправляется алгоритму MD5, который затем преобразуется в 128-битный дайджест. Хотя MD5 все еще используется во многих системах, рекомендуется использовать более безопасную функцию, такую как **Secure Hashing Algorithm 2 (SHA-2)**.

Еще одна хорошо известная функция хеширования - это **Secure Hashing Algorithm 1 (SHA-1)**. Этот алгоритм хеширования был создан еще в 1990-х годах Национальным институтом стандартов и технологий (NIST). NIST разработал этот алгоритм с функциями, аналогичными MD5. Одним из основных преимуществ использования SHA-1 для проверки целостности является то, что он создает 160-битный дайджест любого сообщения или файла.

На следующем рисунке представлена функция SHA-1:
![[Pasted image 20240122101533.png]]

Хотя SHA-1 считается лучше, чем MD5, так как создает более крупный дайджест, он работает медленнее, чем MD5, и содержит уязвимости в самом алгоритме. Однако NIST разработал более новую версию, известную как SHA-2.

SHA-2 позволяет создавать дайджест с использованием битов большого размера, таких как:

- SHA-224 (224 bit)
- SHA-256 (256 bit)
- SHA-384 (384 bit)
- SHA-512 (512 bit)

Имейте в виду, что даже если вы знаете, что для проверки целостности сообщения использовалось хеширование, оно все равно уязвимо для атаки [MiTM](https://wiki.merionet.ru/seti/74/ataka-man-in-the-middle/). Представьте, что источник отправляет сообщение с хеш-значением. Злоумышленник может перехватить сообщение, изменить его содержимое и пересчитать новый хэш перед его отправкой адресату. Чтобы помочь получателю проверить подлинность источника, нам нужно применить **Hash Message Authentication Code (HMAC)** к нашему процессу хеширования.

Чтобы добавить аутентификацию источника во время процесса хеширования, добавляется HMAC. HMAC - это секретный ключ, который объединяет входное сообщение с алгоритмом хеширования, таким как MD5 или SHA-1, для создания уникального дайджеста.

На следующем рисунке показано использование HMAC с функцией хеширования:

![[Pasted image 20240122101631.png]]
Поскольку этот секретный ключ (HMAC) используется только отправителем и предполагаемым получателем, значение выходного дайджеста будет просто зависеть от фактического входного сообщения (данных) и секретного ключа, используемого для применения дополнительного уровня безопасности для аутентификации источника. Поскольку источник и место назначения будут единственными сторонами, которые знают секретный ключ (значение HMAC), атака MiTM не будет успешной с точки зрения нарушения целостности любых сообщений, которые проходят через сеть.

На следующем скриншоте показан секретный ключ (HMAC), примененный к строке текста:
![[Pasted image 20240122101702.png]]

Как показано на предыдущем рисунке, текстовая строка (сообщение) была объединена с секретным ключом и обработана с использованием алгоритма хеширования MD5 и SHA-1 для создания уникального дайджеста.