
Некоторые из самых ранних криптографических систем включали обертывание бумагой цилиндра определенного размера. Цилиндр должен был каким-то образом переноситься между двумя участниками зашифрованной связи, чтобы противник не захватил его. В более поздние годы блоки ключей физически переносились между двумя конечными точками зашифрованной системы. Некоторые из них были организованы таким образом, чтобы определенная страница использовалась в течение определенного периода времени, а затем вырывалась и уничтожалась, заменена новой страницей на следующий день. Другие были разработаны таким образом, чтобы каждая страница в блокноте использовалась для шифрования одного сообщения, после чего страница вырывалась и заменялась одноразовым блокнотом.

Концепция одноразового блокнота была перенесена в современный мир с системами аутентификации, которые позволяют пользователю создавать код, который используется один раз, а затем отбрасывается, чтобы быть замененным новым кодом в следующий раз, когда пользователь попытается аутентифицироваться. Любая система, использующая код, который используется один раз, по-прежнему называется одноразовым блокнотом (**one-time pad**).

В современном мире есть другие способы обмена криптографическим материалом, будь то использование общего секретного ключа или получение закрытого ключа.

Во многих случаях в криптографии легче объяснить, как что-то работает, на тривиальных примерах. В следующих пояснениях Фаина и Дима будут двумя пользователями, которые пытаются обмениваться защищенной информацией, причем Фаина является инициатором и отправителем, а Дима - получателем.

---

### Обмен публичными ключами

Фаина хотела бы отправить сообщение Диме таким образом, чтобы его мог прочитать только Дима. Для этого ей нужен открытый ключ Димы (помните, что у нее не должно быть доступа к закрытому ключу Димы). Где она может получить эту информацию? Она могла:

- Спросить об этом у Димы напрямую. Это может показаться простым, но в реальной жизни это может быть очень сложно. Как, например, она может быть уверена, что действительно общается с Димой?
- Найти открытый ключ Димы в открытой базе данных ключей (на сервере ключей). Опять же, это кажется простым, но как она узнает, что нашла нужный ключ или кто-то не разместил ложный ключ для Димы на этом конкретном сервере?

Эти две проблемы можно решить с помощью какой-то системы репутации. Например, в случае открытого ключа Дима может попросить нескольких своих друзей, которые хорошо его знают, подписать его открытый ключ, используя свои закрытые ключи. Их подпись на его открытом ключе, по сути, гласит: "Я знаю Дмитрия, и я знаю, что это его открытый ключ". Фаина может изучить этот список друзей, чтобы определить, кому из них она может доверять. Основываясь на этом исследовании, Фаина может определить, что она либо верит, что этот конкретный ключ является ключом Димы, либо нет.

В этой ситуации Фаина сама решает, сколько и какого рода доказательств она примет. Должна ли она, например, признать, что ключ, который у нее есть, на самом деле принадлежит Диме, потому что:

- Она напрямую знает одного из друзей Димы и верит, что этот третий человек скажет ей правду.
- Она знает кого-то, кто знает одного из друзей Димы, и доверяет своему другу, чтобы он рассказал ей правду о друге Димы, и, следовательно, доверяет другу Димы рассказать правду о Диме и его ключе.
- Она знает нескольких человек, которые знают нескольких друзей Димы, и принимает решение доверять этому ключу Димы, основываясь на свидетельствах нескольких человек.

Такая система называется паутиной доверия. Общая идея заключается в том, что доверие имеет разные уровни транзитивности. Концепция транзитивного доверия несколько противоречива, но идея, лежащая в основе сети доверия, заключается в том, что, если вы получаете достаточно доказательств, вы можете создать доверие в паре человек/ключ. Примером такого рода паутины доверия является система **Pretty Good Privacy**, где люди встречаются на конференциях, чтобы перекрестно подписывать ключи друг друга, создавая паутину транзитивных доверительных отношений, на которые можно положиться, когда их общение переходит в сферу только электронных.

Другой вариант - владелец сервера ключей может каким-то образом провести расследование в отношении Дмитрия и определить, действительно ли он тот, кем он себя выдает, и действительно ли это его ключ. Самый яркий пример такого решения в "реальном мире" - это нотариус. Если вы подписываете документ перед нотариусом, он проверяет наличие какой-либо формы удостоверения личности (подтверждающей, кто вы), а затем наблюдает, как вы физически подписываете документ (проверяя ваш ключ).

Этот вид проверки называется центральным источником доверия (или аналогичным - хотя в нем почти всегда есть слово "централизованный") или инфраструктурой открытого ключа (**Public Key Infrastructure -PKI**). Решение зависит от доверия Фаины процессу и честности централизованного хранилища ключей.

---

### Обмен закрытыми ключами

Учитывая, что криптография с симметричным ключом обрабатывается намного быстрее, чем криптография с открытым ключом, в идеале вы хотели бы зашифровать любые давно существующие или большие потоки с использованием симметричного общего секретного ключа. Но, если не считать физического обмена ключами, как можно обмениваться одним закрытым ключом между двумя устройствами, подключенными по сети? Рисунок 1 демонстрирует это.

![[Pasted image 20240122105011.png]]На рисунке выше:

1. Предположим, А начинает процесс. A зашифрует одноразовый номер, случайное число, которое используется один раз в процессе, а затем выбрасывается (по сути, одноразовый номер представляет собой форму одноразового блокнота), используя открытый ключ B. Поскольку одноразовый номер был зашифрован с помощью открытого ключа B, теоретически только B может расшифровать одноразовый номер, поскольку только B должен знать закрытый ключ B.
2. B, после расшифровки одноразового номера, теперь отправит новый одноразовый номер в A. Он может включать исходный одноразовый номер A или исходный одноразовый номер A плюс некоторая другая информация. Дело в том, что A должен точно знать, что исходное сообщение, включая одноразовый номер A, было получено B, а не какой-либо другой системой, действующей как B. Это обеспечивается B, включая некоторую часть информации, которая была зашифрована с использованием его открытого ключа, поскольку B - единственная система, которая могла его расшифровать.
3. A и B, используя одноразовые номера и другую информацию, обмениваемую до этого момента, вычисляют закрытый ключ, который затем используется для шифрования / расшифровки информации, передаваемой между двумя системами.

Описанные здесь шаги несколько наивны. Есть лучшие и более безопасные системы, такие как протокол **Internet Key Exchange (IKE)**.