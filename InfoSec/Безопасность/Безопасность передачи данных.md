
Когда вы входите на финансовый или медицинский веб-сайт и входите в систему, вы должны ожидать, что полученная вами информация не будет перехвачена и прочитана кем-либо на пути между вашим компьютером и сервером. Менее очевидная, но не менее важная проблема заключается в том, что информация, которую вы отправляете на сайт, не должна быть открыта для изменения во время ее передачи по сети.

Но как это можно обеспечить? Это две области, для решения которых можно использовать транспортную безопасность. В этой серии статей будет рассмотрено пространство проблем транспортной безопасности, а затем будет проведено исследование нескольких видов решений, включая шифрование. Наконец, в этой серии статей мы рассмотрим спецификацию безопасности транспортного уровня (**TLS**) в качестве примера шифрования транспортного уровня.

---

### Проблемное пространство

Безопасность обычно решает одну из четырех проблем: подтверждение того, что данные не были изменены при передаче, предотвращение доступа к информации никому, кроме предполагаемого получателя, защита конфиденциальности людей, использующих сеть, и подтверждение того, что информация была доставлена. Вторая и третья проблемы, предотвращение несанкционированного доступа к данным при их передаче по сети и защита конфиденциальности пользователей, являются связанными проблемами, но будут рассматриваться отдельно в следующих разделах. Последняя отмеченная проблема, проблема доказательства обхода (которая аналогична проблеме доказательства работы, которая встречается в других контекстах информационных технологий), здесь не рассматривается, поскольку это область активных исследований с небольшим количеством развернутых систем.

---

### Проверка данных

Если вы войдете на сайт своего банка и переведете 100 рублей с одного счета на другой, вы, скорее всего, будете расстроены, если на самом деле сумма перевода составит 1000 рублей или если номера счетов будут изменены, так что 100 рублей окажутся на чьем-то другом счете. Существует ряд других ситуаций, когда необходимо убедиться, что передаваемые данные совпадают с полученными, например:

- Если вы покупаете пару синих туфель, вы не хотите, чтобы вместо них доставили комплект красных.
- Если ваш врач дает вам рецепт на лекарство от изжоги (вероятно, вызванной стрессом от работы сетевым инженером), вы не хотите, чтобы вам доставляли лекарство от артрита (вероятно, из-за того, что вы печатаете так много документов и книг).

Существует множество ситуаций, когда полученные данные должны совпадать с переданными, а отправитель и/или получатель должны быть поддающимися проверке.

---

### Защита данных от проверки

Примеры защиты данных, приведенные выше, позволяют сделать еще один шаг вперед: вы не хотите, чтобы кто-то видел номер вашего счета, рецепт или другую информацию, когда она передается по сети. Номера счетов, пароли и любая личная информация (PII) очень важны, поскольку эти виды информации могут быть использованы для взлома счетов с целью кражи денег или даже для кражи конфиденциальной информации.

Как можно защитить такую информацию? Основным средством защиты, используемым для предотвращения неавторизованных пользователей (или злоумышленников), является шифрование.

---

### Защита конфиденциальности пользователей

Конфиденциальность - это не просто приятно особенность глобального интернета, это требование пользователей доверять системе. Это верно и для локальных сетей, если пользователи считают, что за ними каким-то образом шпионят, они вряд ли будут использовать сеть. Скорее всего, они будут использовать **sneakernet**, распечатывая информацию и перенося ее вручную, а не передавая по сети. Хотя многие люди считают, что конфиденциальность не является обоснованной проблемой, в этой области существует много обоснованных проблем.

Например, в области управления информацией часто говорят: "**Знание - сила**". Информация о компьютере или сети дает вам определенную власть над компьютером, сетью или системой. Например, предположим, что банк настраивает автоматическое резервное копирование для определенной таблицы базы данных; когда остатки на счете, хранящемся в таблице, изменяются на определенную величину, резервное копирование запускается автоматически. Это может показаться вполне разумным вариантом резервного копирования, но оно требует исчерпания некоторого объема данных.

> **Примечание**: исчерпание данных - это информация о физических движениях людей или информация, которая может быть использована для вывода о том, что делают эти люди или эта информация. Например, если вы каждое утро едете на работу одним и тем же маршрутом, кто-то может сделать вывод, что после того, как вы проделали какую-то небольшую часть поездки в сочетании со временем суток, вы собираетесь работать. Такие же типы данных существуют и в сетевом мире; если каждый раз, в определенное время суток, через сеть передается определенный фрагмент данных определенного размера, и он случайно совпадает с определенным событием, таким как перевод денег между двумя счетами, то, когда появляются эти конкретные данные, передача должна иметь место. Просмотр, история электронной почты и другие действия в интернете-все это приводит к исчерпанию данных, которые иногда могут быть использованы для вывода содержимого потока данных, даже если поток зашифрован.

Уязвимость здесь заключается в следующем: если злоумышленник создает резервную копию вместе с изменением значения учетной записи, этот человек будет точно знать, какова модель активности учетной записи. Достаточное количество таких подсказок можно превратить в целый набор планов атаки.

То же самое верно и в отношении людей; знание о людях может дать вам некоторую способность влиять на людей в определенных направлениях. Хотя влияние на людей не так велико, как влияние на машины, передача власти одному человеку над другим всегда несет в себе моральные последствия, с которыми нужно обращаться осторожно.

---

### Область решений

Хотя каждое решение проблем безопасности и конфиденциальности, описанных в предыдущих разделах, обычно включает в себя сложные математические вычисления, в этом разделе будут (попытаемся) описать решения без математических расчетов.

---

### Шифрование

Шифрование берет блок информации (открытый текст) и кодирует его, используя некоторую форму математической операции, чтобы скрыть текст, в результате чего получается зашифрованный текст. Чтобы восстановить исходный простой текст, математические операции должны быть отменены. Хотя шифрование часто рассматривается как математическая конструкция, иногда проще начать думать о нем как о шифре подстановки с таблицей подстановок, которая меняется в зависимости от используемого ключа. Рисунок 1 иллюстрирует это.

> Кстати, [про типы шифрования в России и за рубежом можно почитать тут](https://wiki.merionet.ru/seti/27/tipy-shifrovaniya-v-rossii-i-za-rubezhom/).

На рисунке 1 показан четырехбитовый блок информации - тривиальный пример, но все же полезный для демонстрации. Процесс шифрования концептуально представляет собой серию прямых замен:

![[Pasted image 20240122105103.png]]

Рис. 1 Блок шифрования как таблица подстановки

- Если 0001 находится в исходном блоке данных (открытый текст) и используется ключ 1, то 1010 подставляется в фактический передаваемый поток (зашифрованный текст).
- Если 0010 обнаружен в открытом тексте и используется ключ 1, то 0100 подставляется в передаваемые данные.
- Если 0001 найден в открытом тексте и используется ключ 2, то в передаваемые данные подставляется 0000.
- Если 0110 находится в открытом тексте и используется ключ 2, то в передаваемые данные подставляется 1001.

Процесс замены одного блока бит на другой называется преобразованием. Эти преобразования должны быть симметричными: они должны не только позволять шифрование открытого текста в зашифрованный текст, но они также должны позволять восстанавливать открытый текст (незашифрованный) из зашифрованного текста. В таблице подстановок этот процесс включает поиск ключа на стороне зашифрованного текста таблицы и замену эквивалента открытого текста.

Размер таблицы подстановки определяется размером блока или количеством битов, кодируемых за один раз. Если, например, используется 128-битный блок, в поисковой таблице должно быть 2128 записей - действительно, очень большое количество. Этот вид пространства все еще можно быстро найти с помощью эффективного алгоритма, поэтому блок должен иметь некоторые другие особенности, кроме просто большого размера.

Во-первых, шифротекстовая сторона блока подстановки должна быть как можно более случайной. Чтобы преобразование было идеальным, любой шаблон, найденный в открытом тексте, не должен быть доступен для анализа в результирующем зашифрованном тексте. Выход зашифрованного текста должен выглядеть как можно ближе к случайному набору чисел, независимо от того, какой вход.

Во-вторых, блок подстановки должен быть настолько большим, насколько это практически возможно. Чем более случайным и большим является блок подстановки, тем труднее вернуться от открытого и зашифрованного текста к обнаружению используемого шаблона подстановки. Чтобы выполнить **brute-force** атаку против подстановки с использованием 128-битного размера блока, злоумышленник должен соотнести как можно больше из 2128 записей в блоке открытого текста с 2128 записями в блоке подстановки зашифрованного текста-если информация использует только небольшой (или разреженный) набор возможных записей из исходного 128-битного пространства, практически нет способа сделать корреляцию достаточно быстрой, чтобы сделать такую атаку практичной, учитывая, что шифрующий отправитель достаточно часто меняет свой ключ.

> **Примечание.** Когда дело доходит до размера блока, существует закон убывающей доходности; в какой-то момент увеличение размера блока не увеличивает эффективность шифра при сокрытии информации.

Плотность лучше всего объяснить на примере. Предположим, что вы используете шифр прямой подстановки в английском языке, где каждая буква заменяется буквой, смещенной на четыре шага в алфавите. В этом виде (тривиального) шифра:

- Каждая буква А будет заменена буквой Е.
- Каждая буква B будет заменена буквой F.
- Каждая буква С будет заменена буквой G.
- и т.д.

Теперь попробуйте зашифровать два разных предложения с помощью этого преобразования:

- THE SKY IS BLUE == XLI WOC MW FPYI
- THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG == XLI UYMGO FVSAR JSB NYQTIH SZIV XLI PEDC HSK

Для злоумышленника, пытающегося выяснить, как версия предложения с зашифрованным текстом соотносится с версией открытого текста, первое предложение представляет 9 совпадающих пар букв из пространства, содержащего 26 возможных букв. Есть хороший шанс, что вы сможете угадать правильное преобразование - переместитесь на четыре шага вправо - из этого небольшого образца, но возможно, что здесь задействован какой-то "трюк", из-за которого будущие сообщения, зашифрованные с помощью этого преобразования, не будут расшифрованы правильно. Однако второе предложение - это хорошо известный пример предложения, содержащего все возможные буквы английского алфавита. Преобразование может быть проверено на соответствие каждому возможному значению во всем диапазоне ввода и вывода, что делает обнаружение преобразования тривиальным.

В этом примере первое предложение будет менее плотным, чем второе. В реальных криптографических системах общая идея состояла бы в том, чтобы использовать всего несколько тысяч возможных символов из 2128 или 2512 возможных символов, что создает гораздо менее плотный набор информации для работы. В какой-то момент плотность становится достаточно низкой, преобразование - достаточно сложным, а зашифрованный текст - достаточно случайным, так что не существует практического способа вычислить взаимосвязь между входом (открытым текстом) и выходом (зашифрованный текст).

В реальной жизни блоки замены не вычисляются заранее таким образом. Скорее, для вычисления значения замены в реальном времени используется криптографическая функция. Эти криптографические функции принимают входной размер блока, открытый текст, выполняют преобразование и выводят правильный зашифрованный текст. Ключ - это второй вход, который изменяет выходные данные преобразования, поэтому каждый ключ приводит к тому, что преобразование производит разные выходные данные. Если размер ключа равен 128 битам, а размер блока равен 256 битам, существует 2128 × 2256 возможных выходных комбинаций из преобразования. Рисунок 2 иллюстрирует это.

На рисунке 2 каждая таблица подстановки представляет собой размер блока. Если размер блока составляет 256 бит, то в каждой таблице имеется 2256 возможных замен. Каждый ключ создает новую таблицу, поэтому, если ключ составляет 128 бит, то существует 2128 возможных таблиц. Есть два основных способа атаковать такую систему шифрования.

![[Pasted image 20240122105149.png]]

Первый способ атаковать этот тип системы шифрования-попытаться сопоставить каждое возможное входное значение с каждым возможным выходным значением, раскрывая всю таблицу подстановок. Если входные данные представляют только небольшой набор возможных входных данных (таблица используется редко или, точнее, представляет собой разреженный массив), эта задача практически невыполнима. Если пользователь меняет свой ключ, а следовательно, и конкретную таблицу среди возможного набора таблиц, достаточно часто, нет никакого способа выполнить это сопоставление быстрее, чем изменяется ключ.

> **Примечание**. Даже в больших блоках, объединенных с преобразованиями, все еще есть потенциальные слабые места, позволяющие получить почти случайный результат-другими словами, даже если преобразование близко к идеалу. Если вы соберете 23 человека в одной комнате, есть большая вероятность, что у двух из них будет один и тот же день рождения-но это кажется иррациональным, потому что есть 365 потенциальных дней (не считая високосные года), в которые человек может родиться. Причина несоответствия между тем, что должно произойти, и тем, что происходит, заключается в следующем: в реальном мире дни рождения людей группируются по очень небольшому числу дней в течение года. Таким образом, входные данные представляют собой очень плотное "пятно" в умеренно большом наборе возможных значений. Когда это происходит, разреженность данных может работать против системы шифрования. Если небольшой набор данных повторяется в большом наборе на регулярной основе, злоумышленник может сосредоточиться только на наиболее часто используемых заменах и потенциально обнаружить содержимое сообщения, достаточное для восстановления большей части смысла.

Второй способ атаковать систему шифрования такого типа - атаковать само преобразование - криптографическую функцию. Помните, что эти большие таблицы подстановки часто невозможно сгенерировать, сохранить и транспортировать, поэтому используется некоторая форма криптографической функции, чтобы принимать блок открытого текста в качестве входных данных и генерировать блок зашифрованного текста в качестве выходных данных. Если бы вы могли обнаружить эту функцию преобразования, то вы могли бы вычислить вывод таким же образом, как передатчик и приемник, и расшифровать открытый текст в реальном времени.

В реальном мире эта проблема усложняется из-за:

- **Принцип Керкхоффа**, согласно которому само преобразование не должно быть секретом. Скорее, только ключ, используемый для выбора таблицы из возможных, должен храниться в секрете.
- По крайней мере, некоторый открытый и зашифрованный текст иногда может быть восстановлен из текущей зашифрованной передачи данных по различным причинам-возможно, ошибка, или, возможно, смысл шифрования заключается в проверке текста, а не в том, чтобы не дать тексту быть прочитанным.

Учитывая эти ограничения, следует учитывать несколько ключевых моментов:

- Сложность вычисления ключа из открытого текста, зашифрованного текста и криптографической функции (преобразования) должна быть очень высокой.
- Случайность вывода криптографической функции должна быть очень высокой, чтобы снизить вероятность успешных brute-force атак - просто перебора всех возможных ключей в пространстве.
- Ключевое пространство должно быть большим, опять же, чтобы предотвратить успешные brute-force атаки.

Качество криптографической функции определяется способностью функции выдавать максимально близкий к случайному результату практически любой вход таким образом, чтобы злоумышленник не мог обнаружить, какой ключ используется, даже если у них есть как открытый текст, так и зашифрованный текст. Таким образом, криптографические функции обычно используют ту или иную форму одной из самых сложных для вычисления задач. В частности, часто используется вычисление множителей очень больших простых чисел.

Что произойдет, если вы используете 128-битный блок и у вас есть 56 бит данных для транспортировки? В этой ситуации наиболее естественным образом было бы дополнить открытый текст некоторым числом: скорее всего, всеми нулями или единицами. Качество вывода в некоторой степени зависит от разреженности ввода, чем меньше диапазон чисел используется как вход, тем более предсказуемым будет выход криптографической функции. В этом случае важно использовать заполнение, максимально приближенное к случайному. Существует целая область изучения того, как дополнять блоки открытого текста, чтобы "помочь" криптографической функции создавать зашифрованный текст, максимально приближенный к случайному.

---

### Несколько раундов шифрования

Одну и ту же информацию можно обрабатывать с помощью криптографической функции несколько раз. Например, если у вас есть 128-битный блок и 128-битный ключ, вы можете:

- Возьмите открытый текст и с помощью ключа вычислите зашифрованный текст. Назовите это ct1.
- Возьмите ct1 и с помощью ключа вычислите шифротекст второго раунда; назовите это ct2.
- Возьмите ct2 и, используя ключ, вычислите шифротекст третьего раунда; назовите это ct3.

Фактический передаваемый шифротекст будет последним ct3. К чему приводит этот процесс? Помните, что качество процесса шифрования связано со случайностью выхода по отношению к входу. Каждый раунд во многих ситуациях лишь немного увеличивает случайность. В этом процессе есть точка уменьшения отдачи; обычно после третьего раунда данные не становятся "**более случайными**", и, следовательно, больше раундов, по сути, просто тратят вычислительную мощность и время для очень небольшого выигрыша.

---

### Криптография с открытым и закрытым ключом

Существует класс криптографических функций, которые могут преобразовывать открытый текст в зашифрованный текст и обратно, используя два разных ключа. Эта возможность полезна, когда вы хотите иметь возможность зашифровать блок данных одним ключом и позволить кому-то другому расшифровать данные, используя другой ключ. Ключ, который вы держите в секрете, называется закрытым ключом, а ключ, который вы передаете другим или публикуете, называется открытым ключом.

Например, чтобы доказать, что вы являетесь фактическим отправителем конкретного файла, вы можете зашифровать файл своим закрытым ключом. Теперь любой человек с вашим открытым ключом может расшифровать файл, который мог быть отправлен только вами. Обычно вы не шифруете весь блок данных своим закрытым ключом (на самом деле большинство систем, использующих пары ключей, спроектированы так, что вы не можете этого сделать). Скорее, с помощью вашего закрытого ключа создается подпись, которая может быть проверена с помощью вашего открытого ключа. Чтобы убедиться, что только человек, которому вы отправляете данные, может что-то прочитать, вы можете зашифровать некоторые данные своим открытым ключом, опубликовать их, и только человек с правильным закрытым ключом может их расшифровать.

Такие системы называют криптографией с открытым ключом (иногда названия, которые выбирают инженеры, возможно, слишком очевидны), или асимметричной криптографией. В криптографии с открытым ключом открытый ключ часто "выпускается на волю"; это то, что может найти любой, у кого есть доступ к ключевому серверу или другому источнику.

Альтернативой криптографии с открытым ключом является криптография с симметричным ключом. В криптографии с симметричным ключом отправитель и получатель используют один ключ, который используется как для шифрования, так и для расшифровки данных (общий секрет). Учитывая, что общие секреты (очевидно) сложно создавать и использовать, почему вообще используется криптография с симметричным ключом? При выборе между симметричной криптографией и криптографией с открытым / закрытым ключом необходимо учитывать два основных компромисса:

- **Сложность обработки**: системы криптографии с открытым ключом обычно требуют гораздо большей вычислительной мощности для шифрования и расшифровки передаваемых данных. Системы с симметричными ключами, как правило, намного проще разрабатывать и развертывать, не требуя больших вычислительных мощностей и времени. Из-за этого криптография с открытым ключом часто используется для шифрования очень небольших объемов данных, таких как закрытый ключ.
- **Безопасность**: криптография с открытым ключом обычно требует отчасти уникального набора механизмов математического преобразования. Системы с симметричным ключом, как правило, имеют более широкий диапазон доступных преобразований, которые также являются более сложными и, следовательно, более безопасными (они обеспечивают большую случайность на выходе и, следовательно, их труднее взломать).

С учетом этих компромиссов и реальных требований есть место для обоих типов систем.