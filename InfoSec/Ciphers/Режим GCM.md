# 1. Режим GCM (Galois/Counter Mode)

**GCM** — это режим работы блочного шифра, который сочетает в себе:
- **CTR (Counter Mode)** — для шифрования данных
- **Аутентификацию Галуа (Galois)** — для проверки целостности и подлинности

Он обеспечивает **две ключевые функции одновременно**:
- **Конфиденциальность** — защита содержимого
- **Целостность и аутентификация** — защита от подделки и изменений

##### Преимущества GCM

- **Очень быстрый** — поддерживает параллельную обработку
- **Безопасный** — обеспечивает как шифрование, так и аутентификацию
- **Стандартизован** — используется в TLS, IPsec, IEEE 802.1AE
- **Устойчив к повторным атакам** — при правильном управлении одноразовыми номерами

## 1.1 Как работает GCM
1. **Генерация одноразового номера (nonce)**
    - Уникальное значение, используемое для каждого сообщения (например, счётчик или случайное число)
2. **Шифрование данных (CTR)**
    - Вместо прямого шифрования текста, GCM шифрует **счётчик**, а затем **XOR'ит** его с открытым текстом
    - Это позволяет **параллельно обрабатывать блоки**, ускоряя выполнение
3. **Генерация тега аутентификации (MAC)**
    - Используется **алгоритм Галуа** для создания **тега**, который проверяет, что данные не были изменены
    - Тег зависит от: шифртекста, одноразового номера, дополнительной аутентифицируемой информации (AAD)
4. **Отправка данных**
    - Получатель получает: шифртекст + тег аутентификации + одноразовый номер
5. **Проверка на стороне получателя**
    - Получатель расшифровывает данные и **проверяет тег**
    - Если тег не совпадает — данные считаются **подделанными или повреждёнными**

### 1.1.1 Что такое nonce

**Nonce** (от англ. _number used once_) — это **уникальное значение**, которое используется **один раз** в процессе шифрования. Оно **не является секретом**, но играет критически важную роль в обеспечении **уникальности шифрования**.

##### Зачем нужен nonce?

В режимах, таких как **CTR** или **GCM**, шифрование работает по следующему принципу:
- Вместо прямого шифрования текста, шифруется **счётчик**, основанный на **nonce**.
- Полученный результат **XOR'ится с открытым текстом**, создавая шифртекст.

Если **один и тот же nonce используется повторно с тем же ключом**, это может привести к **утечке информации** — злоумышленник сможет сравнивать шифротексты и делать выводы о содержимом.

##### Как генерируется nonce?

Есть несколько подходов:

|Метод|Описание|Преимущества|Недостатки|
|---|---|---|---|
|**Случайный (random)**|Генерируется случайным образом|Прост в реализации|Требует надёжного генератора случайных чисел|
|**Счётчик (counter)**|Увеличивается на 1 при каждом сообщении|Гарантирует уникальность|Нужно хранить состояние между сессиями|
|**Комбинированный**|Например, timestamp + ID|Баланс между случайностью и предсказуемостью|Может быть уязвим при плохой реализации|

##### Пример в GCM

В режиме **GCM**, nonce обычно имеет длину **96 бит (12 байт)**. Если длина другая, GCM применяет **хеширование**, чтобы привести nonce к нужному формату.

Пример:

```
Nonce: 0x00112233445566778899aabb
Key:   256-битный AES ключ
Plaintext: "Hello, world!"
→ GCM использует nonce + счётчик → шифрует → добавляет тег аутентификации
```

##### Пример: генерация nonce для AES-GCM

```python
import os
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# Генерация 256-битного ключа (32 байта)
key = AESGCM.generate_key(bit_length=256)

# Генерация одноразового номера (nonce) — 12 байт (96 бит), как рекомендует NIST
nonce = os.urandom(12)

# Создание объекта шифра AES-GCM
aesgcm = AESGCM(key)

# Данные для шифрования
data = bytes("секретное сообщение", "utf-8")
aad = bytes("дополнительные данные", "utf-8")  # необязательные аутентифицируемые данные

# Шифрование
ciphertext = aesgcm.encrypt(nonce, data, aad)

print("Nonce:", nonce.hex())
print("Зашифрованные данные:", ciphertext.hex())
```



