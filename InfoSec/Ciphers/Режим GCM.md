# 1. Режим GCM (Galois/Counter Mode)

**GCM** — это режим работы блочного шифра, который сочетает в себе:
- **CTR (Counter Mode)** — для шифрования данных
- **Аутентификацию Галуа (Galois)** — для проверки целостности и подлинности

Он обеспечивает **две ключевые функции одновременно**:
- **Конфиденциальность** — защита содержимого
- **Целостность и аутентификация** — защита от подделки и изменений

##### Преимущества GCM

- **Очень быстрый** — поддерживает параллельную обработку
- **Безопасный** — обеспечивает как шифрование, так и аутентификацию
- **Стандартизован** — используется в TLS, IPsec, IEEE 802.1AE
- **Устойчив к повторным атакам** — при правильном управлении одноразовыми номерами

## 1.1 Как работает GCM
1. **Генерация одноразового номера (nonce)**
    - Уникальное значение, используемое для каждого сообщения (например, счётчик или случайное число)
2. **Шифрование данных (CTR)**
    - Вместо прямого шифрования текста, GCM шифрует **счётчик**, а затем **XOR'ит** его с открытым текстом
    - Это позволяет **параллельно обрабатывать блоки**, ускоряя выполнение
3. **Генерация тега аутентификации (MAC)**
    - Используется **алгоритм Галуа** для создания **тега**, который проверяет, что данные не были изменены
    - Тег зависит от: шифртекста, одноразового номера, дополнительной аутентифицируемой информации (AAD)
4. **Отправка данных**
    - Получатель получает: шифртекст + тег аутентификации + одноразовый номер
5. **Проверка на стороне получателя**
    - Получатель расшифровывает данные и **проверяет тег**
    - Если тег не совпадает — данные считаются **подделанными или повреждёнными**

### 1.1.1 Что такое nonce

**Nonce** (от англ. _number used once_) — это **уникальное значение**, которое используется **один раз** в процессе шифрования. Оно **не является секретом**, но играет критически важную роль в обеспечении **уникальности шифрования**.

##### Зачем нужен nonce?

В режимах, таких как **CTR** или **GCM**, шифрование работает по следующему принципу:
- Вместо прямого шифрования текста, шифруется **счётчик**, основанный на **nonce**.
- Полученный результат **XOR'ится с открытым текстом**, создавая шифртекст.

Если **один и тот же nonce используется повторно с тем же ключом**, это может привести к **утечке информации** — злоумышленник сможет сравнивать шифротексты и делать выводы о содержимом.

##### Как генерируется nonce?

Есть несколько подходов:

|Метод|Описание|Преимущества|Недостатки|
|---|---|---|---|
|**Случайный (random)**|Генерируется случайным образом|Прост в реализации|Требует надёжного генератора случайных чисел|
|**Счётчик (counter)**|Увеличивается на 1 при каждом сообщении|Гарантирует уникальность|Нужно хранить состояние между сессиями|
|**Комбинированный**|Например, timestamp + ID|Баланс между случайностью и предсказуемостью|Может быть уязвим при плохой реализации|

##### Пример в GCM

В режиме **GCM**, nonce обычно имеет длину **96 бит (12 байт)**. Если длина другая, GCM применяет **хеширование**, чтобы привести nonce к нужному формату.

Пример:

```
Nonce: 0x00112233445566778899aabb
Key:   256-битный AES ключ
Plaintext: "Hello, world!"
→ GCM использует nonce + счётчик → шифрует → добавляет тег аутентификации
```

##### Пример: генерация nonce для AES-GCM

```python
import os
import base64
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# Генерация 256-битного ключа (32 байта)
key = AESGCM.generate_key(bit_length=256)

# Генерация одноразового номера (nonce) — 12 байт (96 бит), как рекомендует NIST
nonce = os.urandom(12)

# Создание объекта шифра AES-GCM
aesgcm = AESGCM(key)

# Данные для шифрования
data = bytes("секретное сообщение", "utf-8")
aad = bytes("дополнительные данные", "utf-8")  # необязательные аутентифицируемые данные

# Шифрование
ciphertext = aesgcm.encrypt(nonce, data, aad)

print("Nonce:", int.from_bytes(nonce, "big"))
print("Nonce hex:", nonce.hex())
print("Зашифрованные данные:", ciphertext.hex())

# Дешифрование
decrypted = aesgcm.decrypt(nonce, ciphertext, aad)

print("Открытый текст:", plaintext.decode())
print("Зашифрованный текст (hex):", ciphertext.hex())
print("Расшифрованный текст:", decrypted.decode())
```

## Пояснения

- `AESGCM.generate_key()` — безопасная генерация ключа.
- `os.urandom(12)` — безопасный способ получить уникальный nonce.
- `encrypt()` — возвращает шифротекст с тегом аутентификации.
- `decrypt()` — проверяет целостность и расшифровывает данные.

Если тег аутентификации не совпадает (например, данные были изменены), `decrypt()` вызовет исключение.

##### Сохранение ключа и nonce в файл:

```python
import os

# Генерация ключа и nonce
key = os.urandom(32)     # 256-битный ключ
nonce = os.urandom(12)   # 96-битный одноразовый номер

# Сохранение в файл
with open("crypto_data.bin", "wb") as f:
    f.write(key)
    f.write(nonce)

# Чтение из файла
with open("crypto_data.bin", "rb") as f:
    key = f.read(32)     # первые 32 байта — ключ
    nonce = f.read(12)   # следующие 12 байт — nonce

print("Ключ:", key.hex())
print("Nonce:", nonce.hex())
```

### 1.1.2 CTR (Counter Mode)

**CTR (Counter Mode)** — это режим работы блочного шифра, который превращает его в **потоковый шифр**. Он не шифрует данные напрямую, а использует **счётчик**, который шифруется и затем **XOR'ится** с открытым текстом.

##### Как работает CTR

1. **Генерация одноразового номера (nonce)**
    - Уникальное значение, общее для всего сообщения (например, случайное число или идентификатор сессии)
2. **Инициализация счётчика**
    - Счётчик начинается с **nonce** и увеличивается на 1 для каждого блока данных
3. **Шифрование счётчика**
    - Каждый блок счётчика шифруется с помощью симметричного алгоритма (например, AES)
4. **XOR с открытым текстом**
    - Полученный шифр счётчика XOR'ится с соответствующим блоком открытого текста → получается шифротекст
    - открытый текст **разбивается на блоки фиксированной длины**, обычно по **16 байт (128 бит)**, если используется алгоритм AES.
5. **Дешифрование**
    - Тот же процесс: шифруется счётчик → XOR с шифртекстом → получается исходный текст

##### Пример

```
Nonce:         0x00000001
Counter block: 0x00000001, 0x00000002, 0x00000003, ...
AES(key, counter) → keystream
Keystream XOR Plaintext → Ciphertext
```

##### Как это выглядит на практике:

1. Открытый текст делится на блоки по 16 байт.
2. Для каждого блока:
    - Генерируется уникальный **счётчик** (на основе nonce + порядкового номера).
    - Счётчик шифруется → получается **ключевой поток**.
    - Ключевой поток **XOR'ится с блоком открытого текста** → получается шифртекст.
3. Последний блок может быть **короче 16 байт** — и это нормально: **CTR не требует дополнения (padding)**.

### 1.1.3 Генерация тега аутентификации (MAC)

**тег аутентификации (MAC)** в режиме **GCM (Galois/Counter Mode)** — это ключевой элемент, обеспечивающий **целостность и подлинность** зашифрованных данных.

##### Что такое тег аутентификации в GCM?

Тег аутентификации (иногда называют **тегом целостности**, **authentication tag** или **MAC**) — это **короткая строка байтов**, которая добавляется к шифротексту и позволяет получателю убедиться, что:
- Данные **не были изменены**,
- Они были **зашифрованы доверенной стороной**.

В GCM этот тег создаётся с помощью **математики Галуа** — отсюда и название режима.

##### Что входит в тег

Тег зависит от:
- **Ключа шифрования**
- **Nonce (одноразового номера)**
- **AAD (если есть)**
- **Шифротекста**

Изменение **любого** из этих компонентов приведёт к **несовпадению тега** при проверке.

##### Проверка тега при расшифровке
1. Получатель расшифровывает данные.
2. Вычисляет **свой тег** на основе полученных данных.
3. Сравнивает его с тегом, пришедшим вместе с шифртекстом.
4. Если теги **совпадают** — данные считаются подлинными.
5. Если **не совпадают** — выбрасывается ошибка: данные могли быть подделаны.

##### Как извлечь тег отдельно (если нужно):

```python
tag = ciphertext[-16:]         # последние 16 байт — это тег
encrypted_data = ciphertext[:-16]  # остальное — шифртекст
```

При дешифровании `AESGCM.decrypt()` **проверяет тег**. Если он не совпадает — выбрасывается исключение `InvalidTag`.

