
**Криптография** – это способ хранения и передачи данных, позволяющий лишь уполномоченным лицам (процессам) читать и обрабатывать их. Криптография – это наука защиты информации путем ее преобразования в нечитаемый вид. Криптография является эффективным способом защиты критичной информации при ее хранении и передаче по недоверенным каналам связи.

Одной из целей криптографии и лежащих в ее основе механизмов, является скрытие информации от неуполномоченных лиц. Однако хакеры, обладающие достаточным объемом времени, ресурсов и мотивации, могут взломать почти любой алгоритм и получить доступ к зашифрованной информации. Более реалистичной целью криптографии является попытка сделать взлом зашифрованной информации слишком сложной и длительной по времени задачей для злоумышленника, обладающего ограниченными ресурсами.

## 1. История криптографии

В 16-м веке во Франции Виженер разработал полиалфавитный шифр подстановки для Генри III. Он был основан на шифре Цезаря, но увеличивал сложность процессов шифрования и расшифрования.

Как показано на Рисунке, нам нужно зашифровать сообщение `SYSTEM SECURITY AND CONTROL`. У нас есть ключ, который имеет значение `SECURITY`. Также у нас есть таблица Виженера (или алгоритм), который в действительности является просто более продвинутым вариантом шифра Цезаря. Тогда как Цезарь использовал для шифрования только один сдвинутый алфавит, шифр Виженера использовал 27 сдвинутых алфавитов, в каждом из которых алфавит был сдвинут на одну букву дальше, чем в предыдущем.

![[Pasted image 20241111124430.png]]

Итак, взглянув на пример на Рисунке, мы берем первую букву ключа «`S`» и начинаем с первого алфавита в нашем алгоритме, отыскивая в нем столбец «`S`». Затем мы берем первую букву открытого текста «`S`» и опускаемся по выбранному столбцу вниз, до строки «`S`». На пересечении этих строки и столбца мы видим букву «`K`». Это и есть первая буква шифротекста для нашего исходного сообщения – записываем ее. Затем мы берем следующую букву ключа «`E`» и следующую букву открытого текста «`Y`». На пересечении столбца «`E`» и строки «`Y`» мы видим букву «`C`». Это вторая буква шифротекста, которую мы записываем рядом с первой. Мы продолжаем этот процесс для всего сообщения (если длина сообщения превышает длину ключа, буквы ключа циклически повторяются). Полученный в результате шифротекст мы отправляем получателю. Получатель должен использовать тот же самый алгоритм (таблицу Виженера) и иметь тот же ключ (`SECURITY`) для выполнения обратного процесса преобразования и получения исходного текста сообщения.

В Средние века эволюция криптографии продолжилась. Различные страны улучшали свои методы, используя новые инструменты. В конце 19 века криптография стала неотъемлемой частью взаимодействия между военными подразделениями.

Когда были изобретены компьютеры, возможности методов и устройств шифрования возросли экспоненциально, криптография была многократно усилена. Эра компьютеров дала разработчикам криптографии беспрецедентные возможности для разработки новых методов шифрования. Самым известным и успешным проектом был *Люцифер*, разработанный IBM. *Люцифер* использовал сложные математические уравнения и функции, которые позднее были адаптированы и модифицированы NSA (National Security Agency – Агентство национальной безопасности США) в выпущенном им в 1976 году стандарте DES (Data Encryption Standard – Стандарт шифрования данных), ставшим правительственным стандартом. DES использовался во всем мире для проведения финансовых и иных транзакций, он был встроен в огромное количество коммерческих приложений.

Большинство сетевых протоколов, разработанных на заре компьютерной эры, были усовершенствованы путем включения в них криптографических возможностей и добавления необходимых уровней защиты. Шифрование используется в аппаратных устройствах и программном обеспечении, оно предназначено для защиты данных, банковских транзакций, корпоративных сетевых коммуникаций в экстрасетях, сообщений электронной почты, веб-транзакций, беспроводных коммуникаций, хранения конфиденциальной информации, факсов, телефонных звонков и многого другого.

> **Криптоанализ** (cryptanalysis) – это наука, изучающая и взламывающая секреты шифровальных процессов, компрометирующая схемы аутентификации и выполняющая обратный инжиниринг алгоритмов и ключей. Криптоанализ является важной частью криптографии и криптологии. Криптоанализ, выполняемый хорошими парнями, предназначен для выявления недостатков и слабостей, заставляя разработчиков вернуться к чертежной доске и усовершенствовать компоненты. Также криптоанализ выполняется любопытными и мотивированными хакерами, для выявления тех же недостатков, но только с целью получения ключа шифрования для несанкционированного доступа с его помощью к конфиденциальной информации.

## 2. Определения и концепции криптографии

**Шифрование** – это метод преобразования читаемых данных, называемых **открытым текстом** (`plaintext`), в форму, которая выглядит случайной и нечитаемой, она называется **шифротекстом** (`chiphertext`). Открытый текст – это форма текста, понятная каждому человеку (документ) или компьютеру (исполняемый код). После того, как открытый текст будет преобразован в шифротекст, ни человек, ни машина не смогут правильно обработать его до выполнения расшифрования. Это позволяет передавать конфиденциальную информацию через незащищенные каналы, не опасаясь несанкционированного доступа к ней. При хранении данных на компьютере, они обычно защищаются логическими и физическими механизмами контроля доступа. Однако при передаче данных по сети, они больше не защищаются этими механизмами и находятся в более уязвимом состоянии.

![[Pasted image 20241111125452.png]]

Системы или продукты, которые предоставляют функции зашифрования и расшифрования, называются **криптосистемами** (`cryptosystem`), они могут создаваться в виде аппаратных компонентов или программного кода в приложениях. Криптосистемы используют алгоритмы шифрования (которые определяются как простые или сложные с точки зрения процесса шифрования), ключи, а также необходимые программные компоненты и протоколы. Большинство алгоритмов являются сложными математическими формулами, которые в определенной последовательности применяются к открытому тексту. Большинство методов шифрования используют секретное значение, называемое ключом (обычно ключ представляет собой длинную последовательность битов), который используется в процессе работы алгоритмом для зашифрования и расшифрования текста.

**Алгоритм** – это набор правил, также называемый шифром. Он определяет, как должно происходить зашифрование и расшифрование. Многие математические алгоритмы, используемые сегодня в компьютерных системах, являются публично доступными и широкоизвестными – процесс шифрования не является секретом. Раз внутренние механизмы алгоритма не секретны, значит секретным должно быть что-то другое. Секретной частью общеизвесного алгоритма шифрования является ключ. Здесь можно провести аналогию с замком, чтобы проиллюстрировать это. Замок можно купить в любом магазине, множество людей используют замки одинакового производителя. Однако это вовсе не означает, что они могут открыть дверь друг друга и получить несанкционированный доступ в квартиру. Каждый замок имеет свой собственный ключ, который может открыть только соответствующий ему конкретный экземпляр замка.

В шифровании, **ключ** (криптопеременная) – это значение, которое состоит из длинной последовательности случайных битов. Но действительно ли это просто случайный набор битов, собранных вместе? На самом деле – нет. Алгоритм использует ключевое пространство (keyspace), являющееся диапазоном значений, которые могут использоваться для создания ключа. Когда алгоритму нужно сгенерировать новый ключ, он использует случайные значения из этого ключевого пространства. Чем шире ключевое пространство, тем больше доступных значений можно использовать для создания ключа, а чем больше случайных вариантов ключей, тем сложнее взломщику подобрать их. Например, если алгоритм позволяет использовать ключи длиной `2` бита, ключевое пространство для этого алгоритма составляет всего `2^2=4` возможных значения, это максимальное количество возможных вариантов различных ключей для этого алгоритма. Это очень узкое ключевое пространство, поэтому атакующему не потребуется много времени, чтобы найти правильный ключ и воспользоваться им.

Широкое ключевое пространство включает в себя гораздо больше возможных вариантов ключей. Сегодня используются ключи, которые чаще всего имеют длину `128`, `256`, `512` или `1024` бита. Если размер ключа равен `512` бит, он обеспечивает `2^512` возможных вариантов ключей (ключевое пространство). Алгоритмы шифрования должны использовать все ключевое пространство и выбирать значение для нового ключа максимально случайным образом. Если используется небольшое ключевое пространство, оно может обеспечить слишком мало вариантов для генерации ключа. Это повышает шансы атакующего взломать ключ и дешифровать защищенную информацию.

![[Pasted image 20241111125909.png]]
Если злоумышленник перехваатит сообщение, передаваемое между двумя людьми, он сможет просмотреть это сообщение, однако, если оно передается в зашифрованном виде, оно нечитаемо. Даже если злоумышленник знает алгоритм, используемый этими людьми для зашифрования и расшифрования информации, без знания ключа эта информация будет бесполезной для злоумышленника

### 2.1. Принцип Керкхофса

Огюст Керкхофс опубликовал в 1883 году статью, в которой он заявил, что в криптосистеме единственным секретом должен быть ключ, алгоритм должен быть общеизвестен. Он утверждал, что если секретность основана на слишком большом количестве секретов, она становилась более уязвимой, и этим можно было воспользоваться.

Однако не все приняли эту философию. Правительства по всему миру создают собственные алгоритмы, не делая их публичными. Они считают, что чем меньше людей знает, как работает алгоритм, тем меньше людей узнает, как взломать его. Криптографы в коммерческой области не согласились с таким подходом и не доверяют алгоритмам, которые не проверили сами.

### 2.2. Стойкость криптосистем

**Стойкость** методов шифрования основывается на алгоритме, обеспечении секретности ключа, длине ключа, векторах инициализации, а также том, как все это работает вместе в рамках криптосистемы. При обсуждении стойкости шифрования, говорят о сложности вскрытия алгоритма или ключа, даже если алгоритм не является публичным. При попытке взлома криптосистемы, обычно выполняют перебор всех возможных значений (обычно количество возможных значений колоссально), чтобы найти именно то значение (ключ), которое позволяет расшифровать конкретное сообщение. Стойкость метода шифрования находится в прямой связи с величиной мощностей и количеством времени, необходимых для взлома криптосистемы (перебора всех возможных значений) и получения правильного ключа. Взлом криптосистемы может выполняться с помощью брутфорс-атаки, при которой проверяется каждое возможное значение ключа до тех пор, пока полученный в результате расшифрования исходного сообщения с помощью очередного ключа открытый текст не станет понятным. В зависимости от алгоритма и длины ключа, это может быть как легкой задачей, так и практически невозможной. Если ключ можно взломать за три часа на компьютере с процессором Pentium II, шифр считается абсолютно нестойким. Если ключ может быть взломан только при использовании многопроцессорной системы с тысячей процессоров за 1,2 миллионов лет, шифр считается очень стойким.

> Синонимом стойкости криптосистемы является **фактор трудозатрат**, который указывает на оценку необходимых ресурсов для взлома криптосистемы атакующим.

Для обеспечения стойкости шифрования важно **использовать алгоритмы, не имеющие недостатков**, **применять длинные ключи**, при генерации ключей **использовать весь возможный диапазон ключевого пространства**, а также хорошо **защищать ключ**. Если хотя бы один из этих пунктов не выполняется, это может оказать негативное влияние на весь процесс.

### 2.3. Сервисы криптосистем

Криптосистемы могут предоставлять следующие сервисы:
- **Конфиденциальность**. Информация приводится в форму, нечитаемую для всех, кроме уполномоченных людей (или систем).
- **Целостность**. Данные не могут быть несанкционированно изменены в процессе их создания, передачи или хранения.
- **Аутентификация**. Проверка личности пользователя или системы, создавшей информацию.
- **Авторизация**. После идентификации человек вводит ключ или пароль, который позволяет получить доступ к определенному ресурсу.
- **Неотрекаемость** (nonrepudiation). Обеспечивает невозможность отрицания отправителем факта отправки.

В качестве примера, иллюстрирующего работу этих сервисов, представим, что ваш начальник отправляет вам сообщение об увеличении вашей зарплаты вдвое. Сообщение зашифровано, поэтому вы можете быть уверены, что оно исходит от вашего начальника (**аутентичность**), что никто не изменил сообщение до момента его получения вашим компьютером (**целостность**), что никто не смог прочитать его в процессе передачи по сети (**конфиденциальность**), и что ваш начальник не сможет позднее сказать, что не отправлял вам это сообщение (**неотказуемость**).

Различные типы сообщений и транзакций в различной степени нуждаются в некоторых (или во всех) этих сервисах, обеспечиваемых криптографией. Военные и разведывательные агенства больше всего беспокоются о сохранении своей информации в тайне, поэтому они выбирают механизмы шифрования, обеспечивающие высокий уровень секретности. Финансовые организации также заботятся о конфиденциальности, но еще важнее для них вопросы целостности данных при их передаче, поэтому выбираемые ими механизмы шифрования немного отличаются от механизмов шифрования, выбираемых военными. При передаче финансового сообщения, даже если в нем будет изменен всего один символ, это может привести к очень серьезным последствиям. Юридические фирмы в большей степени заботятся об аутентичности получаемых сообщений. Если полученная информация должна быть представлена в суде, ее аутентичность не должна вызывать никаких сомнений. Поэтому используемые этими фирмами методы шифрования должны обеспечивать аутентичность, подтверждающюю личность отправителя информации.

Определения в криптографии. В криптографии важно правильно понимать следующие определения:
	• **Управление доступом**. Ограничение и контроль попыток доступа субъектов к объектам.
	• **Алгоритм**. Набор математических правил, используемых для зашифрования и расшифрования.
	• **Шифр**. Другое название алгоритма.
	• **Криптография**. Наука секретного письма, которая позволяет сохранять и передавать данные в форме, доступной только уполномоченным лицам.
	• **Криптосистема**. Аппаратная или программная реализация криптографии, которая преобразует исходное сообщение в шифротекст, либо шифротекст обратно в открытый текст.
	• **Криптоанализ**. Практическая работа по взлому криптосистем.
	• **Криптология**. Изучение криптографии и криптоанализа.
	• **Аутентификация источника данных** (data origin authentication). Проверка источника сообщения (аутентификация системы).
	• **Зашифрование** (encipher). Действие по преобразованию исходных данных в нечитаемый формат.
	• **Аутентификациия отправителя** (entity authentication). Проверка личности отправителя сообщения.
	• **Расшифрование** (decipher). Действие по преобразованию шифротекста обратно в читаемую форму.
	• **Ключ**. Секретная последовательность битов и инструкций, которые управляют выполнением действий при зашифровании и расшифровании.
	• **Кластеризация ключей** (key clustering). Случай, когда с помощью двух различных ключей генерируется одинаковый шифротекст из одинакового открытого текста.
	• **Ключевое пространство** (keyspace). Диапазон возможных значений, используемый при создании ключа.
	• **Открытый текст** (plaintext). Данные в читаемом формате, также называемые простым текстом (cleartext).
	• **Квитанция** (receipt). Подтверждение получения сообщения.
	• **Фактор трудозатрат** (work factor). Предполагаемое время, усилия и ресурсы, необходимые для взлома криптосистемы.

### 2.4. Одноразовый шифровальный блокнот

**Одноразовый шифровальный блокнот** (one-time pad) – это прекрасная схема шифрования, т.к. при правильной реализации она невзламываема. Она была создана Гилбертом Вернамом в 1917 году и иногда называется *шифром Вернама*.

Этот алгоритм не использует сдвиг алфавитов, как шифры Цезаря и Виженера, описанные ранее, вместо этого он использует блокнот, заполненный случайными значениями. Нам нужно зашифровать некое сообщение и преобразовать его в биты, для этого мы используем наш одноразовый шифровальный блокнот, который заполнен случайными битами. В процессе шифрования используется двоичная математическая функция «исключающее ИЛИ» (`XOR`).

![[Pasted image 20241111135058.png]]

---

`XOR` – это операция над двумя битами, она часто используется в двоичной математике и методах шифрования. При выполнении `XOR` над двумя битами, имеющими одинаковое значение, в результате получается `0` (`1 XOR 1 = 0`), если значение битов разное, в результате получается `1` (`1 XOR 0 = 1`). Например:

```
Поток сообщения:   1001010111
Ключевой поток:    0011101010
Поток шифротекста: 1010111101
```

---

Так, в нашем примере выполняется операция `XOR` над первым битом сообщения (`1`) и первым битом в одноразовом блокноте (`0`), что дает первое значение шифротекста (`1`). Затем выполняется XOR над следующим битом сообщения (`0`) и следующим битом в блокноте (`0`), что дает второе значение шифротекста (`0`). Этот процесс продолжается пока все сообщение не будет зашифровано. Полученное в результате зашифрованное сообщение отправляется получателю.

Получатель должен иметь точно такой же шифровальный блокнот для расшифрования сообщения путем выполнения обратного процесса. Получатель выполняет `XOR` над первым битом зашифрованного сообщения и первым битом в блокноте. В результате он получает первый бит открытого текста. Получатель продолжает этот процесс, пока не расшифрует все сообщение. Схема шифрования с использованием одноразового шифровального блокнота считается невзламываемой только в том случае, если в процессе ее реализации выполнены следующие условия:
	- Блокнот должен использоваться только один раз. Если он используется более одного раза, это может привести к появлению шаблонов (pattern) в процессе шифрования, что поможет злоумышленнику взломать шифр.
	- Блокнот должен существовать ровно столько же времени, что и само сообщение. Если он уничтожен раньше, не удастся расшифровать сообщение. А если он используется и в дальнейшем, его многократное применение создает описанную выше проблему с появлением шаблонов.
	- Блокнот должен распространяться безопасным образом и защищаться получателем. Это очень сложный и неудобный процесс, поскольку блокноты обычно представляют из себя просто отдельные листы бумаги, которые нужно доставлять с доверенным курьером и надежно охранять в каждом пункте назначения
	- Блокнот должен быть заполнен действительно случайными значениями. Это кажется простой задачей, однако даже современные компьютерные системы не обладают генераторами действительно случайных чисел, на них используются генераторы псевдослучайных чисел.

Хотя подход одноразовых шифровальных блокнотов может обеспечить очень высокий уровень безопасности, во многих ситуациях он оказывается не практичным из-за его многочисленных требований. Каждая пара субъектов, которым потенциально может понадобиться взаимодействовать таким способом, должна безопасным способом получить блокнот на время, равное времени актуальности сообщения. Такой способ управления ключами может быть чрезвычайно сложным, он ведет к большим накладным расходам, часто превышающим преимущества от его использования. Распространение блокнотов может быть очень сложным процессом, получатель и отправитель должны быть хорошо синхронизированы, чтобы каждый использовал одинаковый блокнот.

### 2.5. Динамические и скрытые шифры

Шифр с **динамическим ключом** может использовать ключ, которому не нужен электронный алгоритм и замена битов, вместо этого он использует компоненты окружающего его мира. Например, алгоритмом может быть набор книг, принятый отправителем и получателем. Ключом в таком шифре может быть страница в книге, номер строки и буквы. Например, если я получаю сообщение от суперсекретного шпиона, в котором написано «`149l6c7.299l3c7.911l5c8`», оно может означать, что мне нужно взять `первую` книгу из заранее определенного набора книг, открыть `49` страницу, найти `шестую` сверху строку и в ней седьмую от края страницы букву. Я записываю эту букву. Следующий числовой набор в сообщении говорит мне, что нужно взять вторую книгу, открыть `99` страницу, найти `третью` строку и в ней `седьмую` букву. Последнюю букву я беру из `девятой` книги, с `11` страницы, из `пятой` строки, `восьмую` в строке. Таким образом, я получаю важное секретное сообщение. Шифры с динамическим ключом могут использоваться многими различными способами, в том числе и более сложными, но основная идея в них одна и та же.

**Скрытие шифра** – это передача сообщения внутри другого сообщения. Например, я и мой суперсекретный шпион договариваемся, что значением ключа будет являться каждое третье слово в сообщении. Когда я получаю от него сообщение, я выделяю и записываю каждое третье слово. Предположим, я получаю от него сообщение, в котором написано «`The saying, ‘The time is right’ is not cow language, so is now a dead subject`». Поскольку ключом является выбор каждого третьего слова, я получаю сообщение «`The right cow is dead`».

> Скрытие шифра также называют нулевым шифром (null cipher), это является разновидностью стеганографии

### 2.6. Стеганография

**Стеганография** – это метод скрытия данных в данных другого типа, что очень эффективно. Только отправитель и получатель могут увидеть передаваемое таким образом сообщение, поскольку оно скрыто в графическом или звуковом файле, другом документе и т.п. Сообщение не зашифровано, оно просто скрыто. Зашифрованное сообщение само по себе может привлечь внимание злоумышленника, который может решить, что в нем есть что-то важное. А с помощью стеганографии, секретное сообщение может быть скрыто в фотографии бабушки, которая не вызовет интереса у злоумышленника, хотя внутри файла с этой фотографией может передаваться то же самое секретное сообщение. Стеганография является разновидностью «**безопасности посредством неизвестности**».

Стеганография выполняет скрытие информации внутри компьютерных файлов. Информация может быть скрыта внутри документов, графических файлов, исполняемых файлов программ, внутри протоколов, в неиспользуемом пространстве на жестком диске или секторах, помеченных испорченными. Аудио-, видео- и графические файлы являются идеальным форматом для стеганографии, поскольку обычно они имеют большой размер. Например, отправитель может взять совершенно безобидный графический файл и изменить цвет каждого сотого пикселя на буквы передаваемого сообщения. Такую замену очень сложно заметить, если специально не искать ее.

Отдельные составляющие, используемые стеганографией:
	• **Носитель** (carrier). Сигнал, поток данных или файл, внутри которого скрыта передаваемая информация.
	• **Стеганографическая среда** (stego-medium). Среда, в которой скрыта информация.
	• **Полезная нагрузка** (payload). Собственно информация, которая должна быть скрыта и передана.

Таким образом, секретное сообщение, которое вам нужно безопасно передать, является **полезной нагрузкой**. Изображение, в которое вы «встраиваете» ваше сообщение, является **файлом-носителем**, а **стеганографической средой** является формат этого графического файла, например, JPEG.

## 3. Типы шифров

Симметричные шифры делятся на два основных типа: **подстановки** (substitution) и **перестановки** (transposition, permutation). **Шифры подстановки** заменяют биты, символы или блоки на другие биты, символы или блоки. **Шифры перестановки** не меняют исходный текст, вместо этого они перемещают исходные значения внутри исходного текста – они переставляют биты, символы или блоки символов для скрытия первоначального смысла

### 3.1. Шифры подстановки

Шифры подстановки используют ключ, который указывает, как следует выполнять подстановку. В шифре Цезаря каждый символ заменялся символом, расположенным на три позиции дальше него в алфавите. Алгоритмом был алфавит, а ключом – инструкция «сдвигать на три символа».

Подстановка используется современными симметричными алгоритмами, но это сложно сравнить с таким простейшим методом, как шифр Цезаря. Однако шифр Цезаря является простым и наглядным примером концепции работы шифра подстановки.

### 3.2. Шифры перестановки

В шифре перестановки значение перемешивается (scrambled) или ставится в другом порядке. Ключ определяет позицию, на которую следует переместить значение

![[Pasted image 20241111142829.png]]

Это простейший пример шифра перестановки, он показывает только способ выполнения перестановки. Если применяются сложные математические функции, перестановка может стать достаточно сложной для взлома. Современные симметричные алгоритмы используют одновременно и длинные последовательности сложных подстановок и перестановок символов шифруемого сообщения. Алгоритм содержит возможные способы для процессов подстановки и перестановки (представленные в математических формулах). Ключ является инструкциями для алгоритма, точно указывая, как должна происходить обработка и в какой последовательности.

Простые шифры подстановки и перестановки уязвимы к атакам, выполняющим **частотный анализ** (frequency analysis). В каждом языке некоторые слова и шаблоны используются чаще, чем другие. Например, в тексте на английском языке обычно чаще используется буква «е». При выполнении частотного анализа сообщения, взломщик ищет самые часто повторяющиеся шабоны из 8 бит (составляющих символ). Если в коротком сообщении он нашел, например, 12 восьмибитных шаблонов, он может сделать вывод, что это вероятнее всего буква «е» - самая часто используемая буква в языке. Теперь взломщик может заменить эти биты на букву «е». Это даст ему опору в процессе, который позволит ему провести обратный инжиниринг и восстановить исходное сообщение.

## 4. Методы шифрования

### 4.1. Симметричные и Асимметричные алгоритмы

Криптографические алгоритмы делятся на **симметричные алгоритмы**, которые используют симметричные ключи (также называемые секретными ключами (secret key)), и **асимметричные алгоритмы**, которые используют асимметричные ключи (называемые также открытыми (public key) и закрытыми ключами (private key)).

**Симметричная криптография**

В криптосистеме, в которой применяется симметричная криптография, отправитель и получатель используют два экземпляра одного и того же ключа для зашифрования и расшифрования информации. Таким образом, ключ имеет двойную функциональность и применяется как в процессе зашифрования, так и в процессе расшифрования. Симметричные ключи также называют секретными ключами, т.к. этот тип шифрования предполагает, что каждый из пользователей хранит ключ в секрете и надлежащим образом защищает его. Если атакующий получит этот ключ, он сможет расшифровать с его помощью любое перехваченное зашифрованное на нем сообщение.

![[Pasted image 20241111143603.png]]

Каждой паре пользователей, для защищенного с помощью симметричной криптографии обмена данными, требуется два экземпляра одного и того же ключа. Например, если Дену и Ирине нужно обмениваться данными, им обоим нужно получить копию одного ключа. Если Ден хочет также с использованием симметричной криптографии взаимодействовать с Нормом и Дейвом, ему нужно иметь три отдельных ключа – по одному на каждого друга. Это не является большой проблемой, пока Дену не потребуется взаимодействовать с сотней других людей за несколько месяцев и сохранять историю переписки. Ведь это потребует использования соответствующего ключа для переписки с каждым конкретным получателем. В таком случае это может стать сложнейшей задачей. Если десяти людям необходимо безопасно обмениваться данными друг с другом с использованием симметричной криптографии, им потребуется 45 ключей. Если же взаимодействовать нужно ста людям, им потребуется 4950 ключей. Формула для расчета необходимого количества симметричных ключей выглядит следующим образом:

```
Число ключей = N(N – 1)/2, где N – число абонентов
```

При использовании симметричных алгоритмов отправитель и получатель используют один и тот же ключ для процессов зашифрования и расшифрования информации. Безопасность таких алгоритмов полностью зависит от того, насколько хорошо пользователи защищают ключи. В таком случае безопасность полностью зависит от персонала, который должен хранить свои ключи в секрете. Если ключ скомпрометирован, все сообщения, зашифрованные на этом ключе, могут быть расшифрованы и прочитаны злоумышленником. В действительности, это еще больше усложняется, поскольку ключи необходимо безопасно распространять и обновлять их при необходимости. Если Дену нужно взаимодействовать с Нормом впервые, Ден должен решить, каким образом безопасно передать Норму ключ. Если он сделает это небезопасно, например, просто отправив ключ по электронной почте, этот ключ может быть легко перехвачен и использован злоумышленником. Поэтому Ден должен передать ключ Норму нестандартным способом. К примеру, Ден может записать ключ на флеш-накопитель и положить его на стол Норму или отправить его Норму с доверенным курьером. Процесс распространения симметричных ключей может стать очень сложной и громоздкой задачей.

Поскольку оба пользователя используют один и тот же ключ для зашифрования и расшифрования сообщений, симметричные криптосистемы могут обеспечить конфиденциальность, но не аутентификацию или неотказуемость. Такой криптографический алгоритм не позволит доказать, кто реально отправил сообщение, т.к. оба пользователя используют один и тот же ключ.

Но если симметричные криптосистемы имеют столько недостатков и проблем, почему они используются почти повсеместно? Потому что они обеспечивают очень высокую скорость обработки данных и их очень трудно взломать. Симметричные алгоритмы гораздо быстрее асимметричных. Они могут сравнительно быстро зашифровывать и расшифровывать большие объемы данных. Кроме того, данные, зашифрованные симметричным алгоритмом с использованием длинного ключа, очень сложно вскрыть.

**Сильные стороны**:
- Гораздо быстрее асимметричных систем
- При использовании длинного ключа сложно взломать.

**Слабые стороны**:
- Требует безопасного механизма передачи ключей
- Каждой паре пользователей нужен уникальный ключ; по мере увеличении количества пользователей, возрастающее число ключей может сделать управление ими просто нереальной задачей
- Обеспечивает конфиденциальность, но не обеспечивает аутентификацию или неотказуемость.

Ниже приведены некоторые примеры симметричных алгоритмов
- Data Encryption Standard (DES)
- Triple-DES (3DES)
- Blowfish
- IDEA
- RC4, RC5 и RC6
- Advanced Encryption Standard (AES)

**Асимметричная криптография**

В криптографии с симметричными ключами для зашифрования и расшифрования используется один и тот же секретный ключ, тогда как в системах с **открытыми ключами** для этих целей используются **различные (асимметричные) ключи**. При этом два отличающихся асимметричных ключа **связаны между собой математически**. Если сообщение зашифровано одним ключом, для его расшифрования требуется другой ключ.

В системах с открытыми ключами, создается пара ключей, один из которых является закрытым, другой – открытым. *Открытый ключ* (public key) может быть известен всем, а *закрытый ключ* (private key) должен знать только его владелец. Часто открытые ключи хранятся в каталогах и базах данных адресов электронной почты, общедоступных всем желающим использовать эти ключи для зашифрования и расшифрования данных при взаимодействии с отдельными людьми.

Открытый и закрытый ключи асимметричной криптосистемы математически связаны, однако наличие у кого-то открытого ключа другого человека не позволяет узнать соответствующий ему закрытый ключ. Таким образом, если злоумышленник получит копию открытого ключа Боба, это вовсе не значит, что он с помощью какого-то математического волшебства сможет получить соответствующий ему закрытый ключ Боба. Однако, если кто-то получит закрытый ключ Боба, возникнет большая проблема. Поэтому никто кроме владельца не должен иметь доступа к закрытому ключу.

![[Pasted image 20241111144506.png]]

Если Боб зашифровал данные на своем закрытом ключе, получателю потребуется открытый ключ Боба, чтобы расшифровать их. Получатель может не только расшифровать сообщение Боба, но и ответить Бобу зашифрованным сообщением. Для этого ему нужно зашифровать свой ответ на открытом ключе Боба, тогда Боб сможет расшифровать этот ответ с помощью своего закрытого ключа. При использовании асимметричного алгоритма, невозможно зашифровывать и расшифровывать сообщение одним и тем же ключом, эти ключи, хотя и связаны математически, они не совпадают (в отличие от симметричных алгоритмов). Боб может зашифровать данные на своем закрытом ключе, тогда получатель сможет расшифровать их на открытом ключе Боба. Расшифровывая сообщение на открытом ключе Боба, получатель может быть уверен, что сообщение действительно исходит от Боба, ведь сообщение может быть расшифровано на открытом ключе Боба только в том случае, если оно было зашифровано на соответствующем закрытом ключе Боба. Это обеспечивает возможность аутентификации, т.к. Боб является (предположительно) единственным, кто имеет этот закрытый ключ. Если получатель хочет быть уверен, что единственным, кто сможет прочитать его ответ, будет Боб, он должен зашифровать свое сообщение Бобу на его открытом ключе. Тогда только Боб сможет расшифровать это сообщение, поскольку только у него есть необходимый для этого закрытый ключ.

Кроме того, получатель может решить зашифровать данных на своем закрытом ключе, а не на открытом ключе Боба. Что это ему даст? Аутентификацию. Боб будет знать, что сообщение пришло от него и не могло придти ни от кого другого. Если он зашифровывает данные на открытом ключе Боба, это не обеспечит аутентификацию, т.к. кто угодно может получить открытый ключ Боба. Если он использует свой закрытый ключ для зашифрования данных, тогда Боб может быть уверен, что сообщение исходит именно от него. Симметричные ключи не обеспечивают аутентификацию, т.к. обе стороны используют один и тот же ключ, что не может гарантировать, что сообщение исходит от конкретного человека.

Если отправителю в большей степени важна конфиденциальность передаваемой информации, ему следует зашифровать свое сообщение на открытом ключе получателя. Это называют **безопасным форматом сообщения** (secure message format), поскольку только человек, имеющий соответствующий закрытый ключ, сможет расшифровать это сообщение.

Если же отправителю в большей степени важна аутентификация, ему следует зашифровывать передаваемые данные на своем закрытом ключе. Это позволит получателю быть уверенным в том, что зашифровал данные именно тот человек, который имеет соответствующий закрытый ключ. Если отправитель шифрует данные на открытом ключе получателя, это не обеспечивает возможность аутентификации, т.к. открытый ключ доступен всем.

Шифрование данных на закрытом ключе отправителя называют **открытым форматом сообщения** (open message format), т.к. любой человек может расшифровать эти данные с помощью общедоступного открытого ключа отправителя. Конфиденциальность при этом не обеспечивается

> Оба ключа, как закрытый, так и открытый, могут использоваться и для зашифрования, и для расшифрования данных. Не подумайте, что открытый ключ нужен только для зашифрования, а закрытый – только для расшифрования. При этом следует понимать, что если данные зашифрованы на закрытом ключе, они не могут быть расшифрованы на нем же. Зашифрованные на закрытом ключе данные могут быть расшифрованы на соответствующем ему открытом ключе. И наоборот.

Асимметричный алгоритм работает медленнее, чем симметричный алгоритм, т.к. симметричные алгоритмы выполняют относительно простые математические функции над битами в процессах зашифрования и расшифрования. Они заменяют и перемешивают (перемещают) биты, что не очень сложно и не сильно загружает процессор. Причина их устойчивости к взлому заключается в том, что они выполняют эти функции много раз. Таким образом, в симметричных алгоритмах набор битов проходит более длинную серию замен и перестановок.

Асимметричные алгоритмы медленнее симметричных алгоритмов, т.к. они используют гораздо более сложную математику для выполнения своих функций, что требует больше процессорного времени. Однако асимметричные алгоритмы могут обеспечить аутентификацию и неотказуемость в зависимости от используемого алгоритма. Кроме того, асимметричные системы позволяют использовать более простой и управляемый процесс распространения ключей, по сравнению с симметричными системами и не имеют проблем с масштабируемостью, которые есть у симметричных систем. Причина этих различий в том, что при использовании асимметричных систем вы можете отправлять свой открытый ключ всем людям, с которыми вы хотите взаимодействовать, а не использовать для каждого из них отдельный секретный ключ.

**Сильные стороны**
- Лучше процесс распространения ключей, чем в симметричных системах
- Лучше масштабируемость, чем в симметричных системах
- Могут обеспечить аутентификацию и неотказуемость

**Слабые стороны**
- Работают гораздо медленнее симметричных систем
- Выполняют сложные математические преобразования

Примеры алгоритмов с асимметричными ключами
- RSA
- Криптосистема на основе эллиптических кривых (ECC – Elliptic curve cryptosystem)
- Алгоритм Диффи-Хеллмана Diffie-Hellman
- Эль Гамаль (El Gamal)
- Алгоритм цифровой подписи (DSA – Digital Signature Algorithm)
- Knapsack

![[Pasted image 20241111145405.png]]

### 4.2. Блочные и поточные шифры

Существует два основных типа симметричных алгоритмов: **блочные** шифры, которые работают с блоками битов, и **потоковые** шифры, которые обрабатывают по одному биту за раз.

**Блочные шифры**

Если для зашифрования и расшифрования данных используется блочный шифр, сообщение делится на блоки битов. Затем эти блоки передаются на обработку математическим функциям, по одному блоку за раз. Представьте, что вам нужно зашифровать сообщение для мамы с помощью блочного шифра, который работает с блоками по 64 бита. Длина вашего сообщения составляет 640 бит, поэтому оно делится на 10 отдельных блоков по 64 бита. Каждый блок последовательно передается на вход математической функции. Этот процесс продолжается до тех пор, пока каждый блок не будет преобразован в шифротекст. После этого вы отправляете зашифрованное сообщение вашей маме. Она использует такой же блочный шифр и тот же ключ. Эти 10 блоков шифротекста последовательно передаются в алгоритм в обратной последовательности до тех пор, пока не будет получен исходный открытый текст.

![[Pasted image 20241111145641.png]]

Для обеспечения стойкости шифра, в нем должны в достаточной степени использоваться два основных метода: **перемешивание** (confusion) и **рассеивание** (diffusion). **Перемешивание** обычно выполняется с помощью подстановки, тогда как **рассеивание** – с помощью перестановки. Чтобы шифр был действительно стойким, он должен использовать оба эти метода, чтобы сделать процесс обратного инжиниринга практически невозможным. На уровень перемешивания и рассеивания указывают случайность значения ключа и сложность применяемых математических функций.

В алгоритмах рассеивание может происходить как на уровне отдельных битов в блоках, так и на уровне самих блоков. Перемешивание выполняется с помощью сложных функций подстановки, чтобы злоумышленник не мог понять, каким образом заменялись исходные значения и получить оригинальный открытый текст.

Рассеивание, с другой стороны, означает, что один бит открытого текста оказывает влияние на несколько бит шифротекста. Замена значения в открытом тексте должна приводить к замене нескольких значений в шифротексте, а не одного. Фактически, в действительно стойком блочном шифре, при замене одного бита в открытом тексте, должны изменяться около 50% битов в шифротексте. Т.е. при изменении всего одного бита в открытом тексте, изменится около половины шифротекста.

**Поточные шифры**

Как было сказано ранее, блочные шифры выполняют математические функции над блоками битов. В отличие от них, **поточные шифры** (stream cipher) не делят сообщение на блоки. Они обрабатывют сообщение, как поток битов, и выполняют математические функции над каждым битом отдельно.

При использовании поточного шифра, в процессе шифрования каждый бит открытого текста преобразуется в бит шифротекста. Поточные шифры используют генератор ключевого потока, который производит поток битов, объединяемых с помощью операции XOR с битами открытого текста, с целью получения шифротекста.

![[Pasted image 20241111152116.png]]

Если криптосистема зависит только от симметричного поточного алгоритма, атакующий может получить копию открытого текста и результирующий шифротекст, объединить их вместе с помощью операции XOR и получить в результате использованный ключевой поток, которым он может воспользоваться в дальнейшем для расшифрования других сообщений. Поэтому умные люди решили вставлять ключ в этот поток.
В блочных шифрах ключ определяет, какие функции применяются к открытому тексту и в каком порядке. Ключ обеспечивает случайность процесса шифрования. Большинство алгоритмов шифрования является открытыми, поэтому люди знают, как они работают. Секретом является только ключ. В поточных шифрах случайность также обеспечивается с помощью ключа, делая максимально случайным поток битов, с которыми объединяется открытый текст.

![[Pasted image 20241111153200.png]]

**Векторы инициализации**

Векторы инициализации (IV – Initialization vectors) – это случайные значения, которые используются алгоритмом для обеспечения отсутствия шаблонов в процессе шифрования. Они используются совместно с ключами и их не нужно шифровать при отправке получателю. Если вектор инициализации не используется, два одинаковых открытых текста, зашифрованные на одном и том же ключе, дадут в результате один и тот же шифротекст. Такой шаблон существенно упростит задачу атакующего по взлому метода шифрования и вскрытию ключа. Если в вашем сообщении есть повторяющаяся часть (фраза или слово), вам нужно убедиться, что при шифровании каждой повторяющейся части открытого текста сообщения, создается различный шифротекст, т.е. не будет создаваться шаблон. Именно для обеспечения большей случайности в процессе шифрования и используется вектор инициализации совместно с ключом.

Стойкие и эффективные поточные шифры имеют следующие характеристики:
- Длинные периоды неповторяющихся шаблонов в значениях ключевого потока. Биты, генерируемые ключевым потоком должны быть случайны.
- Статистически непредсказуемый ключевой поток. Биты, получаемые на выходе генератора ключевого потока, не должны быть предсказуемы.
- Ключевой поток не имеет линейной связи с ключом. Если кто-то получил значения ключевого потока, это не должно привести к получению им значения ключа.
- Статистически равномерный ключевой поток (примерно равное количество нулей и единиц). В ключевом потоке не должны преобладать нули или единицы.

Поточные шифры требуют обеспечения случайности и шифруют по одному биту за раз. Это требует больше ресурсов процессора, чем при использовании блочного шифра, поэтому поточные шифры больше подходят для реализации на аппаратном уровне. А блочные шифры, поскольку они не требуют столько ресурсов процессора, проще реализовывать на программном уровне.

### 4.3. Гибридные методы шифрования

Ранее мы рассмотрели симметричные и асимметричные алгоритмы и отметили, что симметричные алгоритмы работают быстро, но имеют некоторые недостатки (плохая масштабируемость, сложное управление ключами, обеспечение только конфиденциальности), а асимметричные алгоритмы не имеют этих недостатков, но они очень медленные. Теперь рассмотрим гибридные системы, которые используют одновременно симметричные и ассиметричные методы шифрования.

**Совместное использование асимметричных и симметричных алгоритмов**

Криптография с открытым ключом использует два ключа (открытый и закрытый), сгенерированные асимметричным алгоритмом, она применяется для защиты ключей шифрования и их распространения. Секретный ключ генерируется симметричным алгоритмом и используется для основного процесса шифрования. В этом и заключается гибридное использование двух различных алгоритмов: симметричного и асимметричного. Каждый алгоритм имеет свои преимущества и недостатки, а их совместное использование позволяет взять лучшее от каждого из них.

В гибридном подходе две эти технологии дополняют друг друга, каждая выполняет свои функции. Симметричный алгоритм создает ключи, используемые для шифрования основного объема данных, а асимметричный алгоритм создает ключи, используемые для автоматизированного распространения симметричных ключей.

Симметричный ключ используется для шифрования отправляемых вами сообщений. Когда ваш друг получает зашифрованное вами сообщение, ему нужно расшифровать его, для чего ему требуется симметричный ключ, на котором зашифровано ваше сообщение. Но вы не хотите отправлять этот ключ незащищенным образом, т.к. сообщение может быть перехвачено и незащищенный ключ может быть извлечен из него злоумышленником для последующего использования в целях расшифрования и ознакомления с вашими сообщениями. Не следует использовать для шифрования сообщений симметричный ключ, если для него не обеспечена надлежащая защита. Для обеспечения защиты симметричного ключа можно использовать асимметричный алгоритм, с помощью которого он может быть зашифрован. Но зачем нам использовать симметричный ключ для
шифрования сообщений, а асимметричный ключ для шифрования симметричного ключа? Как было сказано ранее, асимметричный алгоритм работает медленно, т.к. он использует более сложную математику. А поскольку ваше сообщение, скорее всего, будет длиннее ключа, для его шифрования разумнее использовать более быстрый алгоритм (симметричный), а для шифрования ключа подойдет медленный (асимметричный), но обеспечивающий дополнительные сервисы безопасности.

![[Pasted image 20241111154224.png]]

Как это работает в реальности? Предположим, что Билл отправляет Полу сообщение и хочет, чтобы только Пол мог прочитать его. Билл зашифровывает сообщение на секретом ключе, теперь он имеет шифротекст и симметричный ключ. Ключ должен быть защищен, поэтому Билл зашифровывает симметричный ключ на асимметричном ключе. Асимметричные алгоритмы используют закрытый и открытый ключи, поэтому Билл зашифровывает симметричный ключ на открытом ключе Пола. Теперь у Билла есть шифротекст сообщения и шифротекст симметричного ключа. Почему Билл зашифровал симметричный ключ наоткрытом ключе Пола, а не на своем закрытом ключе? Если бы Билл зашифровал его на собственном закрытом ключе, кто угодно мог бы расшифровать его на открытом ключе Билла и получить симметричный ключ. Однако Биллу не нужно, чтобы любой, имеющий его открытый ключ, мог читать его сообщения Полу. Биллу нужно, чтобы такая возможность была только у Пола. Итак, Билл зашифровал симметричный ключ на открытом ключе Пола. Если Пол хорошо защищал свой закрытый ключ, только он один сможет прочитать сообщение Билла.

![[Pasted image 20241111154425.png]]

Аспекты:
	- Асимметричный алгоритм выполняет зашифрование и расшифрование, используя закрытый и открытый ключи, которые математически связаны между собой.
	- Симметричный алгоритм выполняет зашифрование и расшифрование с	использованием общего секретного ключа.
	- Симметричный (секретный) ключ используется для шифрования реальных сообщений.
	- Открытый ключ используются для зашифрования симметричного ключа с целью его безопасной передачи.
	- Секретный ключ – это то же самое, что симметричный ключ.
	- Асимметричный ключ может быть закрытым или открытым

**Сеаносвые ключи**

**Сеансовый ключ** ( session key) – это симметричный ключ, используемый для шифрования сообщений, которыми обмениваются два пользователя. Сеансовый ключ ничем не отличается от симметричного ключа, описанного ранее, но он действителен только в рамках одного коммуникационного сеанса между пользователями.

Если у Тани есть симметричный ключ, который она постоянно использует для шифрования сообщений между ней и Лансом, этот симметричный ключ не нужно перегенерировать или изменять. Они просто используют один и тот же ключ каждый раз при взаимодействии с использованием шифрования. Однако длительное повторное использование одного и того же ключа повышает вероятность его перехвата и компрометации безопаных коммуникаций. Чтобы избежать этого, следует генерировать новый симметричный ключ каждый раз, когда Тане и Лансу нужно взаимодействовать, и использовать его лишь на протяжении одного сеанса связи, а затем уничтожать. Даже если им потребуется снова взаимодействовать всего через час, будет сгенерирован новый сеансовый ключ.

![[Pasted image 20241111154821.png]]

Сеансовый ключ обеспечивает более высокий уровень защиты, по сравнению со статичным симметричным ключом, т.к. он действителен только на один сеанс связи между двумя компьютерами. Если атакующий сможет перехватить сеансовый ключ, он сможет использовать его для несанкционированного доступа к передаваемой информации только в течение небольшого периода времени.

Если двум компьютерам нужно взаимодействовать с применением шифрования, сначала они должны пройти процесс «рукопожатия», в рамках которого они договариваются об алгоритме шифрования, который будет использоваться для передачи сеансового ключа, предназначенного для дальнейшего шифрования данных в процессе взаимодействия компьютеров. По сути, два компьютера устанавливают виртуальное соединение друг с другом, которое называют сеансом. После завершения сеанса, каждый компьютер уничтожает любые структуры данных, созданные для этого сеанса, освобождает ресурсы и, в том числе, уничтожает использованный сеансовый ключ. Эти вещи операционная система и приложения выполняют в фоновом режиме и пользователю не нужно заботиться об этом. Однако специалист по безопасности должен понимать различия между типами ключей и связанные с ними вопросы.

## 5. Типы симметричных систем

В настоящее время используется несколько типов симметричных алгоритмов. Они по-разному выполняют функции зашифрования и расшифрования информации, но есть один аспект, который относится ко всем симметричным алгоритмам – отправитель и получатель должны использовать два экземпляра одного и того же ключа.

> Алгоритмы строятся на основе современного понимания математики. Когда люди существенно продвинутся в математике, уровень защиты современных алгоритмов может быть сведен к нулю.

### 5.1. Data Encryption Standard

DES – это симметричный блочный алгоритм шифрования. В него поступают 64-битные блоки открытого текста, которые преобразуются в 64-битные блоки шифротекста. Поскольку это симметричный алгоритм, в нем используется один и тот же ключ для зашифрования и расшифрования данных. Он использует 64-битные ключи: из 56 бит состоит реальный ключ, а 8 бит используются для контроля четности.

Алгоритм DES при работе с данными разделяет сообщение на блоки и работает с ними по отдельности. Блоки проходят 16 циклов применения функций перестановки и подстановки. Порядок и вид применяемых функций перестановки и подстановки зависит от значения ключа, переданного алгоритму. В результате получается 64-битный блок шифротекста.

**Режимы DES**

Блочные шифры имеют несколько режимов работы. Каждый режим определяет способ обработки блоков. Один режим может лучше работать в одном типе среды для выполнения определенных функций, тогда как другой будет лучше работать в другой среде с абсолютно другими требованиями:
- Электронная кодовая книга (ECB – Electronic Code Book)
- Сцепление блоков шифротекста (CBC – Cipher Block Chaining)
- Обратная связь по шифротекту (CFB – Cipher Feedback)
- Обратная связь по выводу (OFB – Output Feedback)
- Режим счетчика (CTR – Counter Mode)

*Электронная кодовая книга*

Режим электронной кодовой книги (`ECB` – Electronic Code Book) работает аналогично кодовой книге. 64-битные блоки данных вместе с ключом передаются в алгоритм, на выходе которого получается результирующий блок шифротекста. Для одного и того же блока открытого текста и ключа всегда производится один и тот же блок шифротекста. Длина сообщения не всегда кратна 64 битам, но `ECB` учитывает эту проблему. `ECB` – это простейший и самый быстрый режим работы, однако он имеет свои слабости.

Обычно ключ является инструкциями по использованию кодовой книги, которые обычно указывают, как именно блок текста должен зашифровываться и расшифровываться. Кодовая книга обеспечивает набор команд подстановки и перестановки, которые должны быть выполнены над блоком открытого текста. Проблемой безопасности режима `ЕСВ` является то, что каждый блок шифруется в точности тем же ключом, т.е. той же кодовой книгой. Это может привести к двум плохим вещам: атакующий может взломать ключ и получить возможность расшифровать все блоки данных, либо атакующий может собрать шифротекст и открытый текст для каждого блока и на основании этого создать кодовую книгу, использование которой не требует наличия ключа. 

Основная проблема заключается в том, что процесс шифрования независимых блоков недостаточно случаен, поэтому этот режим проще взломать, чем другие. Тогда возникает вопрос, а зачем вообще использовать этот режим? Дело в том, что это самый быстрый и самый простой режим, его применяют для шифрования небольших объемов данных, таких как PIN-коды, ключи, значения запрос/ответ в процессах аутентификации.

Поскольку `ЕСВ` не использует сцепление (chaining) с предыдущим блоком, не следует
использовать его для шифрования больших объемов данных, т.к. в шифротексте появится
периодический шаблон.

*Сцепление блоков шифротекста*

В режиме `ЕСВ` один и тот же блок открытого текста при шифровании на одинаковом ключе всегда будет давать в результате один и тот же шифротекст. Это позволяет атакующему выявить шаблон и приблизиться на шаг к компрометации процесса шифрования. При использовании режима сцепления блоков шифротекста (`CBC` – Cipher Block Chaining) шаблоны не создаются, т.к. алгоритмом при шифровании каждого блока текста используется не только ключ, но и значение, полученное при шифровании предыдущего блока. В результате получается более случайный шифротекст. Это подразумевает наличие зависимости между блоками, их «сцепление», что и обуславливает название данного режима. Эффект «сцепления» каждого следующего блока с предыдущим скрывает любые шаблоны.

![[Pasted image 20241111165808.png]]

Результирующее значение, полученное при шифровании одного блока, объединяется с помощью операции XOR со следующим блоком перед его шифрованием, т.е. каждый предыдущий блок используется для изменения следующего блока. Таким образом, эффект «сцепления» обуславливает зависимость каждого отдельного блока шифротекста от всех блоков, обработанных перед ним, а не только от предыдущего блока.

Когда мы зашифровываем самый первый блок открытого текста в режиме СВС, у нас нет предыдущего блока шифротекста, позволяющего добавить случайность в процесс шифрования. Но если мы не добавляем случайный элемент при шифровании первого блока, плохие парни могут найти шаблон, пройти в обратном порядке и вскрыть ключ. Поэтому нам нужно использовать вектор инициализации. 64-битный вектор инициализации объединяется с помощью операции XOR с первым блоком открытого текста, а затем все это передается в процесс шифрования. Полученный результат (шифротекст) объединяется со следующим блоком открытого текста, затем зашифровывается следующий блок. Это продолжается, пока все сообщение не будет зашифровано. Это и называется сцеплением блоков шифра, обеспечивающим необходимую случайность процесса шифрования, что позволяет использовать СВС для шифрования больших файлов. В результате ни отдельный блок шифротекста, ни все зашифрованное сообщение целиком не будут содержать шаблонов, что не позволит атакующему провести обратный инжиниринг и вскрыть ключ

**Обратная связь по шифротексту**

Иногда блочный шифр может эмулировать поточный шифр. Но зачем это нужно? Например, если вы собираетесь отправить зашифрованное сообщение по электронной почте своему начальнику, ваш почтовый клиент будет использовать симметричный блочный шифр, работающий в режиме `СВС`. Почтовый клиент не будет использовать режим `ЕСВ`, поскольку большинство сообщений являются достаточно длинными, чтобы в них в таком режиме зашифрования появился шаблон, который может использоваться для обратного инжиниринга процесса и вскрытия ключа шифрования. Режим `СВС` целесообразно использовать, когда вам нужно за раз отправить большой объем данных. Но что делать, если вам нужно отправить устойчивый поток данных получателю? К примеру, если вы работаете на терминале, взаимодействующем с терминальным сервером, при каждом нажатии клавиши и движении мыши на терминальный сервер отправляется всего несколько байт для обработки этого действия. Это необходимо, чтобы происходящее вяглядело так, как будто ваш компьютер (терминал) выполняет команды и обработку данных по вашим запросам, хотя в действительности все это происходит на терминальном сервере. Если вам нужно шифровать данные, передаваемые от терминала на терминальный сервер, вам не следует использовать режим `СВС`, т.к. он шифрует только блоки данных длиной в 64 бита. А ваши блоки данных имеют длину всего 8 бит. Именно для такой ситуации и предназначен режим обратной связи по шифротексту (`CFB` – Cipher Feedback).

`CFB`, который в действительности является комбинацией блочного и поточного шифра. Для зашифрования первого восьмибитного блока мы делаем то же самое, что и в режиме `СВС`, использующем вектор инициализации. Вспомним, как работает поточный шифр: ключ и вектор инициализации используются алгоритмом для создания ключевого потока, который является просто множеством случайных битов. Это множество битов объединяется с помощью операции `XOR` с блоком открытого текста, и создает в результате блок шифротекста такого же размера. Итак, первый восьмибитовый блок объединен с набором битов, созданных генератором ключевого потока. После этого одна копия этого восьмибитового результирующего блока шифротекста отправляется получателю (в нашем примере – терминальному серверу), а другая копия используется для шифрования следующего восьмибитового блока открытого текста. Использование этой второй копии шифротекста в процесс зашифрования следующего блока, обеспечивает большую случайность процесса шифрования.

![[Pasted image 20241112093951.png]]

Мы рассмотрели пример, в котором шифруются восьмибитные блоки, но в действительности режим CFB может использоваться для шифрования блоков любого размера, даже однобитовых. Однако в большинстве случаев этот режим применяется именно для шифрования восьмибитовых блоков, поскольку восемь бит представляют собой один символ.

> Как было сказано выше, вы можете использовать режим `ЕСВ` для шифрования маленьких объемов данных, таких как ключи или значения PIN-кодов. Режим `СВС` вы можете использовать для шифрования больших объемов данных блоками по 64 бита. В случаях, когда вам нужно последовательно шифровать небольшие объемы данных, вам нужен для работы шифр, похожий на поточный шифр, шифрующий отдельные биты блоков, такой как режим `CFB`.

**Обратная связь по выводу**

Если вам нужно шифровать что-то очень чувствительное к ошибокам режима `CBC`, например, цифровое видео или звук, вам не следует использовать режим `CFB`. Вместо него вам следует использовать режим обратной связи по выводу (`OFB` – Output Feedback), который уменьшает влияние повреждений отдельных битов.

`OFB` – это режим работы блочного шифра, применяемый при необходимости эмуляции потока (т.к. шифруются небольшие объемы данных за раз), и обеспечивающий низкую вероятность создания ошибок и их распространения на весь последующий процесс шифрования.

**Режим счетчика**

Режим счетчика (`CTR` – Counter Mode) очень похож на режим `OFB`, но вместо использования случайных уникальных значений вектора инициализации для генерации значений ключевого потока, этот режим использует счетчик, значение которого добавляется к кадому блоку открытого текста, который нужно зашифровать. Уникальное значение счетчика гарантирует, что каждый блок объединяется с уникальным значением ключевого потока.

Другое отличие заключается в том, что не применяется сцепление, т.е. при шифровании следующего блока не используется шифротекст предыдущего блока. Поскольку нет сцепления, шифрование отдельных блоков может происходить параллельно, что повышает производительность. Основной причиной использования режима CTR вместо других режимов является производительность.

![[Pasted image 20241112094631.png]]

### 5.2. Triple-DES

Мы сразу переходим от `DES` к `3DES`, пропуская `Double-DES`. Дело в том, что хотя `Double-DES` использует ключ длиной `112` бит, существует специальная атака против `Double-DES`, которая снижает фактор трудозатрат на примерно тот же уровень, что и для `DES`. Таким образом, он не более безопасен, чем `DES`.

`3DES` в своей работе использует 48 циклов, что существенно повышает его сопротивляемость дифференциальному криптоанализу. Однако это требует выполнения существенно большего объема работ, нанося удар по производительности. Процесс зашифрования и расшифрования данных может занимать до 3 раз больше времени, чем при использовании `DES`.

### 5.3. Advanced Encryption Standard

После 20-летнего использования `DES` в качестве стандарта шифрования, он был взломан, и в срочном порядке потребовалась новая технология. `NIST` решил, что нужен новый стандарт – `AES` (Advanced Encryption Standard), чтобы заменить `DES`. В январе 1997 года `NIST` объявил конкурс для кандидатов на `AES` и описал требования к нему в `FIPS PUB 197`. В качестве кандидатов на `AES` рассматривались симметричные блочные шифры, поддерживающие ключи длиной `128`, `192` и `256` бит. Финалистами стали следующие пять алгоритмов:
	• `MARS`. Разработан командой IBM, ранее создавшей Lucifer.
	• `RC6`. Разработан RSA Laboratories.
	• `Serpent`. Разработан Россом Андерсоном, Эли Бихэмом и Ларсом Кнудсеном.
	• `Twofish`. Разработан Counterpane Systems.
	• `Rijndael`. Разработан Джоанной Деймен и Венсентом Риджменом.

Из них был выбран `Rijndael`. `Rijndael` может работать с блоками `128`, `192` и `256` бит. Число циклов зависит от размера блока и длины ключа:
- Если длина ключа и блока составляет `128` бит, используется `10` циклов.
- Если длина ключа и блока составляет `192` бита, используется `12` циклов.
- Если длина ключа и блока составляет `256` бит, используется `14` циклов.

`Rijndael` хорошо работает как при аппаратной, так и при программной реализации во многих различных продуктах и средах. Он использует небольшой объем памяти и спроектирован таким образом, чтобы его было легко защитить от атак по времени (timing attack).

### 5.4. Blowfish

`Blowfish` – это блочный шифр, который работает с 64-битными блоками данных. Длина ключа может быть любой от `32` до `448` бит, а блоки данных проходят через 16 циклов криптографических функций. Этот алгоритм разработал Брюс Шнайер. Предполагалось, что именно `Blowfish` заменит устаревающий `DES`. `Blowfish` общедоступен и не запатентован, чем выгодно отличался от других алгоритмов, защищенных различными патентами, либо предназначенных для хранения государственных секретов.

### 5.5. RC4

`RC4` является одним из самых популярных среди реализованных поточных шифров. `RC4` использует ключи различной длины. Он применяется в протоколе `SSL`, был реализован (неудачно) в протоколе `WEP`. `RC4` был разработан в 1987 году Роном Ривестом и являлся собственностью компании `RSA Data Security, Inc.`, пока кто-то не опубликовал его исходный код. После этого алгоритм несколько раз внедрялся под именем `ArcFour` или `ARC4`, т.к. название `RC4` является зарегистрированной торговой маркой.

Алгоритм `RC4` очень прост, быстр и эффективен, из-за чего он и стал так популярен.

### 5.6. RC5

`RC5` – это блочный шифр, использующий различные параметры, которые могут определять размер блока, длину ключа, число используемых циклов. Он был разработан Роном Ривестом и исследован `RSA Data Security, Inc`. В этом алгоритме могут использоваться блоки, размером `32`, `64` или `128` бит, а размер ключа может достигать `2048` бит. Число циклов, выполняемое в процессе зашифрования и расшифрования, также может меняться. Оно может доходить до `255`.

### 5.7. RC6

`RC6` – это блочный шифр, созданный на основе `RC5`. Поэтому он имеет те же атрибуты, что и `RC5`. Алгоритм `RC6` был разработан в качестве претендента на `AES`, но вместо него был выбран `Rijndael`. Было реализовано несколько модификаций алгоритма `RC5`, целью которых было повышения его скорости. Одной из таких модификаций и является `RC6`.

> Условные обозначения в криптографии. В некоторых источниках вы можете встретить обозначения вида `rc5-w/r/b` (например, `RC5-32/12/16`). Это условное обозначение, описывающее конфигурацию алгоритма.
	- `w` – половина длины блока (в битах), может быть равен 16, 32 или 64 бита
	- `r` – число циклов от 0 до 255
	- `b` – длина ключа (в байтах)	
	Таким образом, `RC5-32/12/16` означает:
		• Шифруются 64-битные блоки данных
		• Используется 12 циклов
		• Длина ключа составляет 16 байт (128 бит)
	Разработчик указывает эти параметры в конкретной реализации алгоритма. Использование этих параметров дает разработчикам больше гибкости.

## 6. Типы асимметричных систем

Использование симметричной криптографии в чистом виде имеет три недостатка:
- **Сервисы безопасности**. В чистом виде криптография с симметричными ключами обеспечивает только конфиденциальность, но не аутентификацию или неотказуемость.
- **Масштабируемость**. Поскольку потребности человечества в коммуникациях растут, растет и количество необходимых симметричных ключей, которыми нужно управлять.
- **Безопасное распространение ключей**. Симметричный ключ должен быть доставлен получателю безопасным способом.

### 6.1. Алгоритм Диффи-Хеллмана

Первым недостатком симметричной криптографии, который было решено исправить, стало безопасное распространение симметричного ключа. Над этой проблемой работали Диффи и Хеллман, которые в итоге разработали первый алгоритм с асимметричными ключами, названный их именем.

Чтобы понять, как работает алгоритм `Диффи-Хеллмана`, представим себе следующий пример. Таня и Эрика хотят передавать данные по шифрованному каналу с использованием алгоритма `Диффи-Хеллмана`. Они обе генерируют свою пару ключей (открытый и закрытый) и обмениваются открытыми ключами. Программное обеспечение Тани берет ее закрытый ключ (являющийся просто числовым значением) и открытый ключ Эрики (другое числовое значение) и передает их в алгоритм Диффи-Хеллмана. Программное обеспечение Эрики берет ее закрытый ключ и открытый ключ Тани и также передает их в алгоритм `Диффи-Хеллмана` на своем компьютере. В результате на выходе из алгоритма Таня и Эрика получают одно и то же общее значение, которое используется для создания экземпляров симметричных ключей.

Таким образом, Таня и Эрика обменялись через недоверенную сеть информацией, которую не требуется защищать (их открытые ключи), а затем сгенерировали одинаковый симметричный ключ на своих системах. Теперь они обе имеют симметричный ключ для зашифрования и расшифрования передаваемой между ними информации.

Алгоритм `Диффи-Хеллмана` позволяет двум системам безопасно получить симметричный ключ без установления предварительных взаимоотношений или соглашений. Этот алгоритм позволяет распространять ключи, но он не обеспечивает функций шифрования и цифровой подписи. Алгоритм основан на сложности расчета дискретных логарифмов в конечном поле.

Оригинальный алгоритм `Диффи-Хеллмана` уязвим к атаке «**человек посередине**» (Man in the middle - MitM-атака), поскольку он не производит аутентификации перед обменом открытыми ключами. Вернемся к нашему примеру. При получении Эрикой открытого ключа, она не может быть уверена, что это открытый ключ Тани. Что если Ланс отправил Эрике свой открытый ключ от имени Тани? Эрика примет его ключ, думая, что это ключ Тани. Рассмотрим последовательность выполнения такой атаки

![[Pasted image 20241112102549.png]]

1. Таня отправляет свой открытый ключ Эрике, но Ланс перехватывает ключ в процессе передачи и не позволяет ему дойти до Эрики.
2. Ланс отправляет свой открытый ключ Эрике, представляясь Таней. Эрика думает, что это открытый ключ Тани.
3. Эрика отправляет свой открытый ключ Тане, но Ланс также перехватывает ее ключ в процессе передачи и не позволяет ему дойти до Тани.
4. Ланс отправляет свой открытый ключ Тане, представляясь Эрикой. Таня думает, что это открытый ключ Эрики.
5. Таня объединяет с помощью алгоритма Диффи-Хеллмана свой закрытый ключ с открытым ключом Ланса и создает симметричный ключ `S1`.
6. Ланс объединяет свой закрытый ключ с открытым ключом Тани и создает симметричный ключ `S1`.
7. Эрика объединяет свой закрытый ключ с открытым ключом Ланса и создает симметричный ключ `S2`.
8. Ланс объединяет свой закрытый ключ с открытым ключом Эрики и создает симметричный ключ `S2`.
9. Теперь Таня и Ланс имеют общий симметричный ключ `S1`, а Эрика и Ланс имеют другой общий симметричный ключ `S2`. Таня и Эрика думают, что у них есть общий симметричный ключ, они не знают о вмешательстве Ланса.
10. Таня пишет сообщение Эрике, используя свой симметричный ключ `S1` для зашифрования, и отправляет его.
11. Ланс перехватывает сообщение и расшифровывает его на симметричном ключе `S1`, читает или изменяет сообщение и перешифровывает его на симметричном ключе `S2`, а затем отправляет Эрике.
12. Эрика берет свой симметричный ключ `S2`, расшифровывает на нем сообщение и читает его, не догадываясь, что его изменил Ланс.

Контрмерой против такой атаки является проведение аутентификации перед принятием открытого ключа, что обычно обеспечивается с помощью цифровой подписи и цифровых сертификатов.

### 6.2. RSA

Название `RSA` состоит из имен его создателей ( Рон Ривест, Ади Шамир и Леонард Адлеман). Алгоритм `RSA` является алгоритмом с открытыми ключами, он стал самым популярным асимметричным алгоритмом с момента их появления. Фактически `RSA` является признанным во всем мире стандартом, он может использоваться для цифровой подписи, обмена ключами и шифрования. Он был разработан в 1978 году в Массачусетском технологическом институте (MIT - Massachusetts Institute of Technology) и обеспечил как аутентификацию, так и шифрование ключей.

Безопасность этого алгоритма основана на сложности разложения на множители произведения двух простых чисел. Открытый и закрытый ключи являются функцией пары больших простых чисел. Для расшифрования сообщения из шифротекста в открытый текст с использованием закрытого ключа выполняются действия, сравнимые с разложением на множители произведения двух простых чисел.

> Простое число – это положительное целое число, не имеющее собственных делителей, что означает, что это число можно разделить без остатка только на единицу и само это число.

> **В чем заключается отличие между криптографией с открытыми ключами и инфраструктурой открытых ключей (PKI)?**
> 
> **Криптография с открытыми ключами** использует асимметричный алгоритм. Понятия асимметричного алгоритма и криптографии с открытыми ключами взаимозаменяемы и, по сути, означают одно и то же. Примером асимметричного алгоритма является `RSA`, криптосистема на основе эллиптических кривых (`ЕСС`- Elliptic Curve Cryptosystem), алгоритм Диффи-Хеллмана, Эль Гамаль (`El Gamal`), `LUC` и `Knapsack`. Эти алгоритмы используются для создания ключевых пар (открытый/закрытый ключ), выполнения обмена ключами или соглашения о ключах, установки и проверки цифровых подписей. Отметим, что алгоритм Диффи-Хеллмана может выполнять только соглашение о ключах и не может устанавливать и проверять цифровую подпись.
> 
> **Инфраструктура открытых ключей** (PKI - Public key infrastructure) – это не алгоритм, протокол или приложение – это инфраструктура, основанная на криптографии с открытыми ключами.

Одним из преимуществ `RSA` является то, что он может использоваться и для шифрования, и для цифровой подписи. Используя свои односторонние функции, `RSA` выполняет зашифрование и проверку подписи, при выполнении этих функций в обратном направлении – расшифрование и установку подписи.

В настоящее время `RSA` реализован во множестве приложений, его используют операционные системы Microsoft, Apple, Sun, Novell, он применяется на аппаратном уровне в сетевых картах, системах защищенной телефонии, смарт-картах. Он может использоваться в качестве протокола обмена ключами, т.е. для шифрования симметричного ключа с целью его безопасной передачи получателю. `RSA` чаще всего используется совместно с симметричным алгоритмом `DES`, который был заменен алгоритмом `AES`. Таким образом, если в качестве протокола обмена ключами используется `RSA`, криптосистема сначала создает симметричный ключ для алгоритма `DES` или `AES`. Затем криптосистема зашифровывает симметричный ключ на открытом ключе получателя и отправляет его получателю. При этом симметричный ключ защищен, поскольку только человек, имеющий соответствующий закрытый ключ сможет расшифровать это сообщение и извлечь симметричный ключ.

**Ныряем в математику**

Криптография полностью основана на математике, используемой для преобразования данных в нечитаемый вид, а затем обратного преобразования в исходную форму, понятную человеку или компьютеру. Математика RSA основана на сложности разложения больших целых чисел на два простых сомножителя. Теперь рассмотрим, как этот алгоритм работает.

Алгоритм создает открытый ключ и закрытый ключ с помощью функции, выполняющейся над большими простыми числами. Если данные зашифрованы на открытом ключе, только с помощью соответствующего закрытого ключа можно расшифровать их. Процесс расшифрования обычно является тем же самым разложением на множители произведения двух простых чисел. Например, у меня есть секрет (зашифрованное сообщение), а вам, чтобы вскрыть этот секрет, нужно взять определенное большое число и разложить его на два сомножителя, получив в результате два числа, которые запиcаны у меня на листке бумаги. Кажется, что это совсем просто, но если это числа порядка `2^300`, задача усложняется. Следующая последовательность действий описывает работу алгоритма `RSA` с ключами.
1. Выбираем два случайных больших простых числа `р` и `q`.
2. Вычислям их произведение `n = pq`.
3. Выбираем случайное целое число `e (e < 1 < (p-1)(q-1))` в качестве ключа зашифрования. Убеждается, что `е` и `(p-1)(q-1)` являются взаимно простыми.
4. Рассчитываем ключ расшифрования `d`. `ed=1 mod (p-1)(q-1)` или `d=e^-1 mod ([p-1][q-1])`.
5. Открытый ключ = `(n,e)`.
6. Закрытый ключ = `(n,d)`.
7. Исходные простые числа `p` и `q` уничтожаются безопасным образом.

Теперь у нас есть открытый и закрытый ключи, но как они работают вместе?

Если вам нужно зашифровать сообщение `m` на вашем открытом ключе (`e, n`), применяется формула `C = m^e mod n`. Затем вам нужно расшифровать сообщение на вашем закрытом ключе (`d, n`), для этого применяется формула `M = c^d mod n`.

**Односторонние функции**

**Односторонние функции** ( one-way function) – это математические функции, которые легче рассчитать в прямом направлении, чем в обратном. Например, бросить на пол стакан очень просто, а вот собрать потом с пола все осколки и восстановить стакан практически нереально. Эта аналогия похожа на использование односторонних функций в криптографии, в частности в алгоритме `RSA` и других асимметричных алгоритмах, основанных на них.

В качестве простого направления расчета односторонней функции в алгоритме `RSA` используется перемножение двух больших простых чисел. Перемножить эти числа гораздо проще, чем потом разложить произведение на сомножители, чтобы получить исходные два числа. `RSA` основан на сложности разложения на сомножители больших чисел, являющихся произведением двух больших простых чисел. Атаки на такие криптосистемы не обязательно пытаются проверить каждое возможное значение ключа, чаще они предпринимают попытки разложить большое число на сомножители, что позволит атакующему получить закрытый ключ.

Если пользователь зашифровывает сообщение на открытом ключе, это сообщение кодируется с помощью односторонней функции (разбивающийся стакан). Эта функция имеет черный ход ( trapdoor) (знание о том, как собрать стакан обратно), но воспользоваться черным ходом можно только если знать о нем и использовать правильный код. Закрытый ключ и является тем самым черным ходом. Закрытый ключ знает об этом черном ходе, знает как получить исходные простые числа и имеет необходимый программный код, позволяющий использовать этот секретный черный ход с целью восстановления исходного сообщения на основе шифротекста (пересборки разбитого стакана). Именно знание о черном ходе и обладание правильным функционалом для его использования и делает закрытый ключ закрытым.

При выполнении односторонней функции в прямом направлении, доступна функциональность зашифрования и проверки цифровой подписи. При выполнении односторонней функции в обратном направлении, доступна функциональность расшифрования и установки цифровой подписи. Таким образом, только открытый ключ может использоваться для зашифрования и проверки подписи, и только закрытый ключ – для расшифрования и установки подписи.

**Основная мысль этого раздела** – это то, что все асимметричные алгоритмы обеспечивают безопасность путем использования математических уравнений, которые просто выполнять в одном направлении и практически невозможно в другом. Это основано на математической сложности этой задачи. Математическая сложность алгоритма RSA основана на сложности разложения больших числел на исходные простые сомножители. Алгоритм Диффи-Хеллмана и Эль Гамаль основаны на сложности расчета логарифмов в конечном поле.

### 6.3. Эль Гамаль

**Эль Гамаль** (El Gamal) – это алгоритм с открытыми ключами, который может использоваться для цифровой подписи, шифрования и обмена ключами. Он основан не на сложности разложения на сомножители больших чисел, а на расчете дискретных логарифмов в конечном поле. В действительности Эль Гамаль является расширением алгоритма Диффи-Хеллмана. Эль Гамаль обеспечивает ту же функциональность, что и другие асимметричные алгоритмы, однако его основной недостаток – это низкая производительность. По сравнению с другими алгоритмами он самый медленный.

### 6.4. Криптосистемы с эллиптическими кривыми

**Эллиптические кривые** – это богатые математические структуры, с пользой применяемые во множестве различных приложений. Криптосистема с эллиптическими кривыми (`ЕСС` – Elliptic Curve Cryptosystem) реализует большинство функций `RSA`: цифровая подпись, безопасное распространение ключей и шифрование. Единственным отличительным фактором `ЕСС` является ее эффективность. `ЕСС` более эффективна, чем `RSA` и другие асимметричные алгоритмы.

На показан пример эллиптической кривой. В этом математическом поле, точки на кривой объединяются в структуры, называемые группами. Эти точки являются значениями, используемыми в математических формулах процессов зашифрования и расшифрования в `ECC`. Алгоритм рассчитывает дискретные логарифмы эллиптических кривых, которые отличаются от расчета дискретных логарифмов в конечном поле (который используют Диффи-Хеллман и Эль Гамаль)

![[Pasted image 20241112114152.png]]

### 6.5. LUC

Этот алгоритм основан на « последовательностях Люка» (Lucas sequences). Он выполняет расчет дискретных логарифмов в конечном поле, но использует последовательности Люка, позволяющие ускорить выполнение расчетов.

### 6.6. Доказательство с нулевым разглашением

Когда военные представляют новостным изданиям обзоры некоторых мировых событий, они преследуют только одну цель: рассказать такую историю, которую общественность ожидает услышать и ничего больше. Не предоставляйте больше информации, чем это нужно, чтобы сделать выводы, т.е. больше информации, чем они должны знать. Военные делают это, поскольку понимают, что не только хорошие парни смотрят CNN. Это пример доказательства с нулевым разглашением (zero knowledge proof). Вы сообщаете кому-то только ту информацию, которую он должен знать, и ничего более. Доказательство с нулевым разглашением также используется в криптографии. Если я зашифровываю что-то на своем закрытом ключе, вы можете проверить мой закрытый ключ, расшифровав данные на моем открытом ключе. Шифруя что-то на своем закрытом ключе, я доказываю, что обладаю им, но при этом я не передаю и не показываю никому свой закрытый ключ. Только владелец закрытого ключа может таким образом доказать, что он владеет им.

## 7. Целостность сообщения

Биты четности и функции `CRC` (Cyclic Redundancy Check - Циклический избыточный код) используются в протоколах для выявления изменений в потоке битов, проходящем от одного компьютера к другому, но обычно они могут выявить только неумышленные изменения. Такие изменения могут произойти из-за перепадов напряжения, помех, затухания сигнала в проводах или других физических причин, вызывающих повреждение битов при их передаче между компьютерами. Биты четности не могут выявить факт перехвата сообщения злоумышленником, его изменения и последующей отправки получателю, т.к. злоумышленник может просто рассчитать новое значение четности и указать его в новом сообщении, и получатель никогда не заметит разницы. Для защиты от такой атаки необходимы алгоритмы хэширования, позволяющие успешно выявлять факты и умышленного, и неумышленного изменения данных. Сейчас мы рассмотрим некоторые алгоритмы хэширования и их характеристики.

### 7.1. Односторонний хэш

**Односторонний хэш** ( one-way hash) – это функция, которая создает строки и сообщения переменной длины, а также значения фиксированной длины, называемые значениями хэша. Например, если Кевину нужно отравить сообщение Марии, и он хочет быть уверенным, что в его сообщение не будут внесены несанкционированные изменения в процессе передачи, он должен рассчитать хэш-значение своего сообщения и добавить его к самому сообщению. Когда Мария получит сообщение, она выполнит такую же функцию хэширования, что и Кевин, и сравнит полученный результат со значением, указанным в сообщении. Если два значения совпадают, Мария может быть уверена, что сообщение не было изменено в процессе передачи. Если два значения отличаются, Мария узнает, что сообщение было изменено умышленно или неумышленно, и уничтожит это сообщение.

Алгоритм хэширования не является секретом – он общеизвестен. Секретность односторонней функции хэширования обеспечивается ее «односторонностью». Эта функция работает только в прямом направлении, но не в обратном. В этом состоит ее отличие от односторонней функции в криптографии с открытыми ключами, в которой секретность обеспечивается за счет того, что никто не знает «черного хода», а выполнить одностороннюю функцию в обратном направлении, чтобы привести зашифрованное сообщение к читаемому виду, очень сложно. Однако односторонние функции хэширования никогда не выполняются в обратном направлении – получатель не пытается провести обратный процесс, он просто запускает ту же самую функцию хэширования в прямом направлении над тем же самым сообщением, чтобы сравнить результаты.

Односторонняя функция хэширования выполняется без использования каких-либо ключей. Это означает, например, что Черил пишет сообщение, рассчитывает дайджест сообщения, добавляет его к самому сообщению и отправляет сообщение вместе с дайджестом Скотту. Брюс может перехватить это сообщение и изменить его, а затем рассчитать новый дайджест, присоединить новый дайджест к измененному сообщению и отправить Скотту. Когда Скотт получит его, он проверит дайджест сообщения, но так и не узнает, что в действительности сообщение было изменено Брюсом. Скотт будет думать, что сообщение пришло от Черила в неизменном виде, т.к. он сравнил два значения дайджеста (рассчитанное самостоятельно и прикрепленное к сообщению) и они были равны. Если Черилу нужен более высокий уровень защиты, ему нужно использовать **код аутентификации сообщения** (`МАС` – Message Authentication Code).

Функция МАС – это схема аутентификации, полученная в результате применения секретного ключа к сообщению. Но это не означает, что используется симметричный ключ для шифрования сообщения.

##### HMAC

Выше мы рассматривали пример, когда Черил передавал сообщение Скотту. Посмотрим, что изменится, если Черил воспользуется функцией `НМАС` вместо простого алгоритма хэширования. Перед передачей в алгоритм хэширования к его сообщению прикрепляется симметричный ключ. Затем к исходному сообщению, уже без симметричного ключа, прикрепляется полученное значение `МАС` и результат отправляется Скотту. Если Брюс перехватит это сообщение и изменит его, он не сможет рассчитать правильное новое значение `МАС`, поскольку у него нет необходимого симметричного ключа.

![[Pasted image 20241112121835.png]]

![[Pasted image 20241112121841.png]]

Ниже перечислены основные шаги процесса хэширования, показанного на Рисунке:
1. Отправитель пропускает сообщение через функцию хэширования.
2. Генерируется значение дайджеста сообщения.
3. Дайджест сообщения добавляется к сообщению.
4. Отправитель отправляет сообщение получателю.
5. Получатель пропускает сообщение через функцию хэширования.
6. Получатель генерирует свое собственное значение дайджеста сообщения.
7. Получатель сверяет два значения дайджеста сообщения. Если они совпадают, сообщение не было изменено.

В нижней части Рисунка показаны шаги `НМАС`:
1. Отправитель добавляет симметричный ключ к сообщению.
2. Результат помещается в алгоритм хэширования.
3. Генерируется значение МАС.
4. Значение МАС добавляется к сообщению.
5. Отправитель отправляет сообщение получателю (только сообщение с присоединенным к нему значением МАС, симметричный ключ вместе с сообщением не передается).
6. Получатель добавляет свою копию симметричного ключа к полученному сообщению.
7. Получатель пропускает результат через хэширующий алгоритм и генерирует свое собственное значение МАС.
8. Получатель сравнивает два значения МАС. Если они совпадают, сообщение не было изменено.

Эта технология требует, чтобы у отправителя и получателя был одинаковый симметричный ключ. Функция НМАС не реализует безопасную передачу симметричного ключа получателю. Для этого применяются другие технологии, которые мы уже обсуждали ранее ( алгоритм Диффи-Хеллмана и соглашение о ключах, либо RSA и обмен ключами).

##### CBC-MAC

При использовании `СВС-МАС`, сообщение шифруется симметричным блочным шифром в режиме `СВС`, а последний блок шифротекста используется в качестве `МАС`. При этом отправитель не отправляет зашифрованную версию сообщения, он отправляет открытый текст с прикрепленным к нему `МАС`. Получатель зашифровывает полученный открытый текст таким же симметричным блочным шифром в режиме `СВС` и независимо рассчитывает свое значение `МАС`. Затем получатель сравнивает рассчитанное значение `МАС` со значением в полученном сообщении. Этот метод, в отличие от `НМАС`, не использует алгоритмов хэширования.

Использование симметричного ключа гарантирует, что целостность сообщения может проверить только человек, обладающий копией этого ключа. Больше проверить это не может никто, и если кто-то перехватит и изменит данные, он не сможет сгенерировать новое значение `МАС` (`НМАС` или `СВС-МАС`) так, чтобы получатель не смог заметить подмены. Любые изменения будут заметны получателю.

Таким образом, получатель знает, что полученное сообщение пришло от отправителя, который имеет другую копию того же симметричного ключа, что обеспечивает возможность для **аутентификации источника данных** (data origin authentication), иногда называемой аутентификацией системы (system authentication). Это отличается от аутентификации пользователя, которая требует использования закрытого ключа. Закрытый ключ связан с конкретным человеком, а симметричный ключ – нет. Таким образом, МАС-аутентификация обеспечивает слабый вид аутентификации, т.к. аутентифицируется не сам пользователь, а только компьютер или устройство.

Как и в большинстве других алгоритмов, в `CBC-MAC` были найдены некоторые проблемы безопасности, для решения которых был создан `CMAC` (Cipher-Based Message Authentication Code - Код аутентификации сообщения, основанный на шифровании). `CMAC` обеспечивает такой же вариант аутентификации источника данных и контроля целостности, как и `CBCMAC`, но он более защищен с математической точки зрения.

![[Pasted image 20241112122919.png]]

### 7.2. Различные алгоритмы хэширования

Стойкие односторонние функции хэширования не должны давать одинаковое значение хэша для двух и более разных сообщений. Если хэширующий алгоритм дает гарантии создания различных хэшей для двух и более различных сообщений, говорят, что он не подвержен коллизиям (collision free).

Хорошие криптографические функции хэширования должны иметь следующие характеристики:
- Хэш должен вычисляться на основе всего сообщения.
- Хэширование должно быть односторонним, чтобы сообщение нельзя было восстановить по значению хэша
- Не должно существовать двух различных сообщений, при хэшировании которых получаются одинаковые значения хэша.
- Функция должна быть устойчива к «атаке дня рождения» (birthday attack)

![[Pasted image 20241112123049.png]]

**MD2**

`MD2` – это односторонняя функция хэширования, разработанная Роном Ривестом, она
создает 128-битное значение дайджеста сообщения. Она не обязательно слабее всех
остальных алгоритмов семейства MD, но она очень медленная.

**MD4**

`MD4` – это односторонняя функция хэширования, разработанная Роном Ривестом. Она также создает 128-битные значения дайджеста сообщения. Она используется для высокоскоростных вычислений в программных реализациях и оптимизирована для микропроцессоров.

**MD5**

`MD5` также создана Роном Ривестом и является новой версией `MD4`. Она также создает 128-битные хэши, но ее алгоритм более сложен и более устойчив к взлому. `MD5` добавляет четвертый цикл операций, выполняемых в процессе работы функции хэширования, он увеличивает количество выполняемых математических операций и повышает сложность, обеспечивая более высокий уровень безопасности. 

**SHA**

`SHA` предназначен для формирования цифровых подписей. `SHA` создает 160-битное значение хэша (или дайджеста сообщения). Затем это значение хэша передается в асимметричный алгоритм, который рассчитывает значение подписи для сообщения.
`SHA` похож на `MD4`. Он использует некоторые дополнительные математические функции и создает 160-битные значения хэша (а не 128-битные). Он более устойчив к брутфорс-атакам, включая атаку «дня рождения». `SHA` был усовершенствован и переименован в `SHA-1`. Недавно были разработаны и выпущены новые версии этого алгоритма (вместе называемые семейством алгоритмов `SHA-2`): `SHA-256`, `SHA-384` и `SHA-512`.

### 7.3. Атаки на односторонние функции хэширования

Хороший алгоритм хэширования не должен создавать одинаковое значение хэша для двух различных сообщений. Одинаковое значение хэша для двух (или более) различных сообщений называется **коллизией** (collision). Атакующий может попытаться создать коллизию специально, что называется **атакой «дня рождения»** (birthday attack). Эта атака основана на математическом парадоксе «день рождения», существующем в обычной статистике. Например, сколько людей нужно собрать в одной комнате, чтобы среди них нашелся человек, родившийся в тот же день, что и вы? Ответ: 253. Сколько людей нужно собрать в одной комнате, чтобы среди них нашлись два или более человека, родившийся в один день? Ответ: 23.

Но зачем это нам? Парадокс «день рождения» может применяться в криптографии. Для любой случайной группы из 23 человек высока вероятность (не менее 50%), что в ней найдутся два человека с одинаковым днем рождения. Переводя это в криптографию, можно сказать, что если алгоритм хэширования создает 60-битные значения хэшей, существует высокая вероятность коллизии при сравнении хэшей всего `2^30` сообщений. 

Основная задача атакующего – попытаться с помощью брутфорс-атаки найти сообщения, значения хэшей которых совпадают со значением хэша определенного сообщения. Если это ему удается, это аналогично нахождению человека с таким же днем рождения. Если он находит два сообщения с одним и тем же значением хэша, это аналогично нахождению двух людей с одинаковым днем рождения.

**Как может произойти атака дня рождения в криптографии?**

Предположим, что Сью и Джо собираются пожениться, но перед этим они заключают брачный контракт, в котором указано, что в случае развода Сью получит свою первоначальную собственность, а Джо – свою. Чтобы гарантировать, что контракт не изменен, используется функция хэширования и создается дайджест сообщения.

Через месяц после свадьбы Сью делает копию значения дайджеста сообщения и пишет новый брачный контракт, в котором указывает, что в случае развода она получает не только свою собственность, но и собственность Джо. Сью создает хэш нового контракта и сравнивает его с хэшем первоначального варианта. Они не совпадают. Тогда Сью немного изменяет новый контракт, рассчитывает новое значение хэша и снова сравнивает его с первоначальным. Она продолжает вносить незначительные (почти незаметные) изменения в новый контракт, пока не находит коллизию, в результате которой выполнение той же функции хэширования над ее новым вариантом контракта дает такое же значение дайджеста сообщения, что и первоначальный контракт. Затем Сью заменяет первоначальный контракт на новый и по-быстрому разводится с Джо. Забирая собственность Джо, она показывает ему новый контракт, и доказывает его неизменность, сравнивая значения хэша. Алгоритм хэширования обычно создает значения хэша достаточно большого размера (значение `n`), затрудняя нахождение коллизий, но они остаются реальными. Например, алгоритм, создающий 160-битные хэши (например, `SHA-1`), требует перебрать порядка `2^80` вариантов сообщения для нахождения коллизии. Таким образом, существует менее одного шанса на `2^80`, что кому-то удастся выполнить успешную атаку «дня рождения». Парадокс «день рождения» показывает важность использования длинных значений хэша. Чем более длинный результат выдает алгоритм хэширования, тем меньше он уязвим к брутфорс-атаке, такой как атака «дня рождения». Именно по этой причине новая версия `SHA` выдает такие длинные значения дайджеста сообщения.

### 7.4. Цифровая подпись

**Цифровая подпись** – это значение хэша, зашифрованное на закрытом ключе отправителя.

![[Pasted image 20241112124026.png]]

Функция **хэширования** гарантирует **целостность сообщения**, а **подписание** значения хэша обеспечивает **аутентификацию и неотказуемость**. Подписание сообщения цифровой подписью в действительности просто означает, что значение хэша сообщения зашифровывается на закрытом ключе.

Вам должны быть понятны все доступные механизмы криптографии, т.к. различные алгоритмы и отдельные шаги предоставляют различные сервисы безопасности:
- Сообщение может быть зашифровано, что обеспечивает конфиденциальность.
- Для сообщения может быть рассчитано значение хэша, что обеспечивает целостность.
- Сообщение может быть подписано цифровой подписью, что обеспечивает аутентификацию, неотказуемость и целостность.
- Сообщение может быть зашифровано и подписано цифровой подписью, что обеспечит конфиденциальность, аутентификацию, неотказуемость и целостность.

Некоторые алгоритмы могут выполнять только шифрование, тогда как другие поддерживают и цифровую подпись, и шифрование. Для хэширования используется алгоритм хэширования, а не алгоритм шифрования.

Важно понимать, что не все алгоритмы реализуют одновременно все сервисы безопасности. Большинство алгоритмов используются в комбинации с другими, для обеспечения необходимого набора сервисов безопасности.

![[Pasted image 20241112124804.png]]

### 7.5. Стандарт цифровой подписи

Поскольку применение цифровой подписи является крайне важным компонентом при определении того, кто отправил сообщение, правительство США решило издать стандарт, относящийся к функциональности и приемлемому использованию цифровой подписи. В 1991 году NIST предложил федеральный стандарт, названный Стандартом цифровой подписи (DSS – Digital Signature Standard).

Федеральное правительство требует, чтобы его департаменты использовали `DSA`, `RSA` или `ECDSA` (Elliptic Curve Digital SignatureAlgorithm). Реализовано это следующим образом: `SHA` создает дайджесты сообщений длиной 160 бит, которые затем передаются в один из трех вышеуказанных алгоритмов для формирования цифровой подписи. При этом `SHA` используется для обеспечения целостности сообщений. Это пример совместного использования двух различных алгоритмов для получения нужного сочетания сервисов безопасности.

## 8. Инфраструктура открытых ключей

**PKI** (Public key infrastructure – Инфраструктура открытых ключей) состоит из программ, форматов данных, процедур, коммуникационных протоколов, политик безопасности и криптографических механизмов с открытыми ключами, работающих совместно, с целью предоставления широкого спектра возможностей для безопасных и предсказуемых коммуникаций. Другими словами, `PKI` устанавливает уровень доверия в пределах окружения. `PKI` является аутентификационной платформой ISO, использующей криптографию с открытыми ключами и стандарт `Х.509`. Эта платформа позволяет выполнять аутентификацию между различными сетями, а также сетью Интернет. Отдельные протоколы и алгоритмы не имеют спецификации, поэтому `PKI` называется платформой, а не конкретной технологией.

`PKI` обеспечивает аутентификацию, конфиденциальность, неотказуемость и целостность при обмене сообщениями. `PKI` – это гибридная система, в которой применяются алгоритмы и методы с симметричными и асимметричными ключами.

> Существуют различия между криптографией с открытыми ключами и `PKI`. Криптография с открытыми ключами – это просто другое название асимметричных алгоритмов, в то время как название `PKI` говорит о том, что это **инфраструктура**. Эта инфраструктура отвечает за **однозначное подтверждение личности отправителя с помощью сертификатов, а также выполнение автоматического процесса обмена ключами с помощью асимметричного алгоритма**. Для этого данная инфраструктура содержит компоненты, выполняющие идентификацию пользователей, создание и распространение сертификатов, поддержку и аннулирование сертификатов, распространение и поддержку ключей шифрования, а также позволяющие всем технологиям, из которых состоит данная инфраструктура, взаимодействовать и совместно работать, обеспечивая возможности для осуществления зашифрованных коммуникаций и аутентификации.

Каждый человек, который хочет участвовать в `PKI`, должен получить **цифровой сертификат**, являющийся его удостоверением личности. **Цифровой сертификат** содержащий открытый ключ этого человека, а также другую идентификационную информацию. Сертификат создается и подписывается ( цифровой подписью) **доверенной третьей стороны**, которой является **Удостоверяющий центр** (Центр сертификации). При подписании Центром сертификации сертификата, открытый ключ человека связывается с его идентификационными данными, а Удостоверяющий центр берет на себя ответственность за проверку личности этого человека. Эта доверенная третья сторона (Удостоверяющий центр) позволяет людям, которые никогда не встречались друг с другом, проводить взаимную аутентификацию и взаимодействовать с помощью безопасных механизмов. 

К примеру, если Кевин никогда не встречался с Дэвидом, но ему нужно взаимодействовать с ним безопасным образом, и при этом они оба доверяют одному и тому же Удостоверяющему центру, Кевин может получить в нем цифровой сертификат Дэвида и они могут начать процесс безопасного взаимодейтствия.

### 8.1. Центр сертификации

**Центр сертификации** (`СА` – Certificate Authority, Удостоверяющий центр) – это доверенная организация (или сервер), которая выпускает и осуществляет поддержку цифровых сертификатов. Если человек запрашивает сертификат, Центр регистрации проверяет личность этого человека, после чего передает запрос на сертификат в Центр сертификации. Центр сертификации выпускает сертификат, подписывает его, отправляет запросившему его человеку и в дальнейшем поддерживает этот сертификат на протяжении всего времени его жизни. Если с этим человеком нужно взаимодействовать другому человеку, Центр сертификации обеспечивает подтверждение его личности.

После того, как Дэвид получит цифровой сертификат от Кевина, Дэвид выполнит определенные шаги, чтобы проверить его. Предоставляя свой цифровой сертификат Дэвиду, Кэвин говорит что-то вроде: «Я знаю, что ты не знаешь меня и не доверяешь мне, но вот документ, созданный тем, кого ты знаешь и кому ты доверяешь. Документ говорит о том, что я хороший парень, и ты можешь доверять мне». Проверив цифровой сертификат, Дэвид извлекает из него открытый ключ Кевина. При этом Дэвид уверен, что этот открытый ключ принадлежит Кевину. Также Дэвид знает, что если он получит сообщение, цифровую подпись которого он сможет расшифровать на открытом ключе Кевина, он может быть уверен, что это сообщение пришло от Кевина, поскольку цифровая подпись была зашифрована на его (Кевина) закрытом ключе.

В обязанности Центра сертификации входит создание, выдача сертификатов, их поддержка и, при необходимости, отзыв. Отзыв сертификатов производится Центром сертификации, информация об отозванных сертификатах сохраняется в **списке отозванных сертификатов** (`CRL` – Certificate revocation list). В этом списке указываются все сертификаты, которые были отозваны на момент формирования списка. Список отозванных сертификатов поддерживается и регулярно обновляется. Сертификат может быть отозван по причине компрометации закрытого ключа владельца или если Удостоверяющему центру стало известно, что сертификат был выпущен не тому человеку. Если сертификат стал по каким-либо причинам недействительным, именно список отозванных сертификатов является тем механизмом Удостоверяющего центра, который позволяет другим узнать об этом

**Протокол OSCP** (Online Certificate Status Protocol) используется все чаще по сравнению с громоздким подходом `CRL`. При использовании `CRL`, браузер пользователя должен обратиться к центральному `CRL`, чтобы проверить, не был ли отозван сертификат, либо браузер должен постоянно обновлять `CRL` на стороне клиента, чтобы поддерживать его актуальность. При использовании `OSCP`, эта работа выполняется автоматически в фоновом режиме. `OSCP` выполняет проверку сертификатов в режиме реального времени и сообщает пользователю, является ли сертификат действительным, недействительным или неизвестным. `OCSP` проверяет `CRL`, поддерживаемый Центром сертификации. Фактически `CRL` продолжает использоваться, но `OSCP` существенно упрощает проверку `CRL` в процессе проверки сертификата.

### 8.2. Сертификаты

Одним из наиболее важных элементов PKI является цифровой **сертификат**. **Сертификат** является механизмом, который используется для связи открытого ключа с набором реквизитов способом, достаточным для уникальной идентификации заявленного владельца.

Центр сертификации создает сертификаты на основе стандарта `Х.509`, определяющего, какие поля должны быть предусмотрены в сертификате, а также правильные значения, которые могут быть указаны в этих полях. Многие криптографические протоколы (включая `SSL`) используют такие сертификаты.

В сертификате указывается его серийный номер, номер версии стандарта, идентификационная информация, информация об алгоритме, даты срока действия и подпись выпустившего его Удостоверяющего центра

![[Pasted image 20241113102331.png]]

### 8.3. Центр регистрации

**Центр регистрации** (`RA` – Registration Authority) выполняет задачи регистрации сертификатов. Центр регистрации устанавливает и подтверждает личность человека (будущего владельца сертификата), инициирует процесс сертификации в Центре сертификации от лица конечного пользователя и выполняет функции управления жизненным циклом сертификатов. Центр регистрации не может выпускать сертификаты, он выполняет функции посредника между пользователем и Центром сертификации. Если пользователю нужны новые сертификаты, он делает запрос в Центр регистрации, Центр регистрации проверяет всю необходимую идентификационную информацию, после чего передает запрос в Центр сертификации.

### 8.4. Шаги PKI

Теперь мы знаем некоторые основные компоненты `PKI` и то, как они совместно работают. Давайте еще раз рассмотрим это на примере. Предположим, что Васе нужно получить цифровой сертификат, чтобы принять участие в `PKI`. Для этого он должен выполнить следующие шаги:
1. Вася делает запрос в **Центр регистрации**.
2. Запрос в **Центр регистрации** содержит идентификационную информацию Васи, такую как, копия его водительских прав, номер его телефона, адрес и другую информацию.
3. После получения всей необходимой информации от Васи, **Центр регистрации** проверяет ее и пересылает его запрос на сертификат в **Центр сертификации**.
4. **Центр сертификации** создает сертификат открытого ключа Васи и включает в него идентификационную информацию Васи. (*Пара ключей (закрытый/открытый)* может генерироваться **Центром сертификации** или компьютером Васи, в зависимости от настроек системы. Если ключи создаются **Центром сертификации**, необходимо организовать безопасную доставку пользователю *закрытого ключа*. В большинстве случаев, пользователь самостоятельно генерирует пару ключей и отправляет свой открытый ключ процессе регистрации). 
Теперь Вася зарегистрирован и стал участником `PKI`. Джону нужно взаимодействовать с Аней. Для этого им нужно выполнить последовательность шагов

![[Pasted image 20241113103505.png]]

1. Вася запрашивает открытый ключ Ани из общего каталога.
2. Каталог (часто его называют репозиторием) отправляет Васе цифровой сертификат Ани.
3. Вася проверяет этот сертификат и извлекает из него открытый ключ Ани. Вася использует этот открытый ключ для зашифрования сеансового ключа, который будет использоваться для шифрования их сообщений. Вася отправляет Ане зашифрованный сеансовый ключ и свой сертификат, содержащий его открытый ключ.
4. При получении Аней сертификата Васи, ее браузер проверяет, является ли доверенным Центр сертификации, подписавший этот сертификат своей цифровой подписью. Браузер Ани доверяет этому Центру сертификации, поэтому после проверки сертификата Вася и Аня могут взаимодействовать с использованием шифрования.

`PKI` может состоять из следующих компонентов и функций:
- Центр сертификации
- Центр регистрации
- Репозиторий сертификатов
- Система отзыва сертификатов
- Система резервного копирования и восстановления ключей
- Автоматическое обновление ключей
- Управление историей ключей
- Установка меток времени
- Клиентское программное обеспечение

`PKI` обеспечивает следующие сервисы безопасности:
- Конфиденциальность
- Управление доступом
- Целостность
- Аутентификация
- Неотказуемость

`PKI` должен хранить историю ключей, чтобы отслеживать использование людьми как старых, так и актуальных открытых ключей. Например, если Кевин зашифровал симметричный ключ на старом открытом ключе Дэвида, у Дэвида должен существовать способ получения доступа к этим данным. Это может быть возможно только в том случае, если Центр сертификации хранит историю старых сертификатов и ключей Дэвида.

## 9. Управление ключами

Криптография может использоваться в качестве механизма безопасности, обеспечивающего конфиденциальность, целостность и аутентификацию, но только если используемые ключи не были скомпрометированы. Злоумышленник может перехватить, изменить, повредить или взломать ключи. Криптография основана на модели доверия. Люди должны доверять тому, что другие участники обеспечивают надлежащую защиту своих ключей, доверять администратору, поддерживающему эти ключи, доверять серверу, на котором хранятся, сопровождаются ключи, с которого осуществляется их распространение.

Многие администраторы знают, что управление ключами – самая большая головная боль при внедрении криптографии. Объем работ по поддержке и сопровождению ключей значительно превышает объем работ по их использованию для шифрования сообщений. Ключи должны безопасно распространяться уполномоченным пользователям и постоянно обновляться. Они должны надежно защищаться при их передаче и хранении на рабочих станциях и серверах. Ключи должны генерироваться, уничтожаться и восстанавливаться безопасным образом. Управление ключами может быть организовано вручную или с помощью автоматического процесса.

Хранение ключей выполняется и до, и после их передачи. Пользователь, при получении ключа, должен не просто бросить его на свой рабочий стол – он обязан разместить ключ в безопасном месте своей файловой системы для его надежного хранения и исключения возможности бесконтрольного использования. Ключ, алгоритм, использующий этот ключ, настройки и параметры сохраняются в модуле, который также должен быть хорошо защищен. Если атакующий сможет получить доступ к этим компонентам, он сможет выдавать себя за другого пользователя, чтобы получить возможности расшифровывать, читать или перешифровывать предназначенные для этого пользователя сообщения.

### 9.1. Принципы управления ключами

Ключ не должен находиться в виде открытого текста вне криптографического устройства (многие криптографические алгоритмы общедоступны, что усложняет защиту секретности ключа). Если атакующий знает, как работает алгоритм, в большинстве случаев для компрометации системы ему нужен только ключ. Поэтому ключи не должны быть доступны в открытом виде, ведь именно ключи обеспечивают секретность при шифровании.

Ключи подвержены риску утраты, уничтожения или повреждения. Следует организовать их резервное копирование, резервные копии должны быть легко доступны при необходимости. Если пользователь зашифровал данные, а затем потерял ключ, необходимый для их расшифрования, эта информация может быть навсегда потеряна, если не была создана резервная копия ключа. Криптографическое приложение может иметь специальные функции для восстановления ключей, либо требовать, чтобы пользователь организовал безопасное хранение копии ключей.

### 9.2. Правила использования ключей и управления ключами

Крайне важно обеспечить надлежащую защиту процесса управления ключами. К процессу управления ключами предъявляются следующие требования:
- Длина ключа должна быть достаточно большой для обеспечения необходимого уровня защиты.
- Ключи должны храниться и передаваться безопасными способами.
- Ключи должны быть абсолютно случайными, а алгоритмы их генерации должны полностью использовать все доступное ключевое пространство.
- Срок действия ключа должен соответствовать критичности защищаемых им данных. Менее критичные данные можно защищать ключом с большим сроком действия, тогда как критичные данные требуют использования ключей с коротким сроком действия.
- Чем чаще используется ключ, тем короче должен быть срок его действия.
- Должна быть создана резервная копия ключа, либо дубликат ключа должен быть передан на хранение независимой третьей стороне (escrowed) на случай чрезвычайной ситуации.
- Ключи должны надлежащим образом уничтожаться, когда завершается срок их действия.

## 10. Канальное и сквозное шифрование

Шифрование может выполняться различными способами и на различных коммуникационных уровнях. Существует два основных режима реализации шифрования – **канальное шифрование** и **сквозное шифрование**.

При **канальном шифровании** (link encryption) зашифровываются все данные, передаваемые по определенному коммуникационному маршруту, например, по спутниковой линии связи, линии Т3, телефонной линии. При этом шифруется не только пользовательская информация, но и заголовки, окончания, адреса, данные маршрутизации – шифрованию подлежит все содержимое передаваемых пакетов. В этой технологии не шифруется только трафик управляющих сообщений канального уровня, который включает в себя команды и параметры, используемые различными канальными устройствами для синхронизации процесса коммуникаций. Канальное шифрование обеспечивает защиту от перехвата пакетов и прослушивания сети.

При **сквозном шифровании** ( end-to-end encryption) информация в заголовках, адреса, данные маршрутизации и окончания не шифруются, что позволяет атакующим получить значительно больше информации из перехваченных пакетов и их заголовков.

**Канальное шифрование**, которое иногда называют *шифрованием в режиме реального времени* (online encryption), обычно реализуется провайдерами услуг и является частью сетевых протоколов. Поскольку вся информация зашифрована, пакеты должны расшифровываться на каждом узле (таком, как маршрутизатор) или ином промежуточном устройстве, чтобы этот узел мог принять решение, куда дальше отправлять этот пакет. Маршрутизатор должен расшифровать заголовок пакета, считать из него информацию маршрутизации и адреса, а затем снова зашифровать его и отправить дальше.

При **сквозном шифровании**, пакет не нужно расшифровывать и снова зашифровывать на каждом узле, т.к. заголовки и окончания пакетов при этом не шифруются. Узлы между отправителем и получателем могут просто считать всю необходимую им информацию маршрутизации и передать пакет дальше.

**Сквозное шифрование** обычно инициируется компьютером отправителя. **Сквозное шифрование** предоставляет больше гибкости для пользователей, позволяя им самим решать, нужно ли шифровать то или иное сообщение. Такое шифрование называется сквозным, поскольку сообщение остается в зашифрованном виде на всем своем пути от отправителя до получателя.

**Канальное шифрование** выполняется на канальном и физическом уровнях. Аппаратные устройства шифрования работают на физическом уровне, шифруя все проходящие через них данные. В этом случае атакующему не доступны никакие части данных, поэтому атакующий не может получить важную информацию о потоках данных в сети. Это называют безопасностью потока траффика (traffic-flow security).

![[Pasted image 20241113124454.png]]

> **Узел** (hop) – это устройство, которое помогает пакету достичь пункта своего назначения. Обычно это маршрутизатор, который анализирует адреса пакета, чтобы решить, куда его следует отправить далее. Обычно пакет проходит через множество узлов между компьютерами отправителя и получателя.

> Шифрование на различных уровнях. В действительности, шифрование может выполняться на разных уровнях операционной системы и сетевого стека. Ниже приведено несколько примеров:
	• Сквозное шифрование выполняется приложением.
	• Шифрование `SSL` выполняется на транспортном уровне.
	• Шифрование `РРТР` выполняется на канальном уровне.
	• Канальное шифрование выполняется на канальном и физическом уровнях.

Следующий список описывает преимущества и недостатки методов сквозного и канального шифрования.

| Тип шифрования           | Приемущества                                                                                                                                                                                                                                                                                                                      | Недостатки                                                                                                                                                                                                                                                                                                                                                        |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Сквозное шифрование**  | • Пользователям предосталяется больше гибкости в выборе того, что шифровать и как.<br>• Обеспечивается высокая детализация функциональности, т.к. каждое приложение или<br>пользователь могут выбрать специфические настройки.<br>• Не требуется, чтобы у каждого компьютера в сети был ключ для расшифрования<br>каждого пакета. | • Не зашифровывается информация заголовков, адреса, информация маршрутизации -<br>эта информация не защищена.                                                                                                                                                                                                                                                     |
| **Канальное шифрование** | • Все данные зашифрованы, включая заголовки, адреса и информацию маршрутизации.<br>• Пользователям ничего не нужно делать, чтобы это выполнялось. Шифрование<br>выполняется на нижнем уровне модели OSI.                                                                                                                          | • Распространение ключей и управление ими становится сложной задачей, т.к. каждое<br>устройство должно получить ключ. При смене ключа он должен обновляться на<br>каждом устройстве.<br>• Пакеты расшифровываются на каждом узле, поэтому существует много точек<br>потенциальных уязвимостей.<br>• Канальное шифрование препятствует выполнению анализа трафика. |

**Программные и аппаратные криптографические системы**. Шифрование может выполняться с помощью программного или аппаратного обеспечения, у каждого варианта есть свои преимущества и недостатки. Обычно, программные реализации дешевле, но медленнее аппаратных. Программные криптографические методы может быть существенно проще изменять и отключать по сравнению с аппаратными системами, но это зависит от конкретного программного приложения и аппаратного устройства. Если компании нужно выполнять функции шифрования на высокой скорости, для нее более предпочтительны аппаратные решения.

## 11. Квантовая криптография

Сегодня мы обладаем очень сложными и стойкими алгоритмами, стойкости которых более чем достаточно для большинства современных вариантов использования, включая финансовые транзакции и обмен секретной информацией. Однако некоторые типы передаваемых данных все же имеют столь высокую критичность и настолько сильно востребованы отдельными субъектами, обладающими значительными ресурсами, что стойкости современных алгоритмов может быть недостаточно для них. Такие данные могут быть перехвачены посредством шпионажа, информационных войн и т.п. Когда целая страна хочет взломать зашифрованные другой страной данные, она может привлечь к этому огромные ресурсы, что может привести к взлому современных алгоритмов.

Для удовлетворения потребностей в более стойких криптографических алгоритмах, умные люди смешали криптографию с квантовой физикой, что позволило получить системы, которые при правильной реализации являются невзламываемыми, а действия злоумышленников в них могут быть выявлены. В традиционной криптографии, мы пытаемся создать очень сложные алгоритмы, создавая максимум трудностей для злоумышленника, пытающегося взломать алгоритм шифрования или вскрыть ключ, но эти алгоритмы не позволяют выявить факты действий злоумышленника. В квантовой криптографии реализуется не только экстастойкое шифрование, но и возможности для выявления злоумышленников.

Квантовая криптография может быть реализована несколькими различными способами.

В **квантовой криптографии** для представления бита (`1` или `0`) используется поляризация фотона. **Поляризация** – это ориентация электромагнитных волн, которыми являются фотоны. Электромагнитные волны могут иметь ортогональную поляризацию (т.е. быть ориентированы в горизонтальной или вертикальной плоскости) или диагональную (т.е. быть наклонены влево или вправо).

Предположим, что Том и Кэти – шпионы, и им нужно передавать друг другу данные, будучи уверенными, что они не будут перехвачены. Для этого на обеих сторонах им нужно использовать симметричный ключ шифрования: одна копия ключа для Тома и одна – для Кэти.

Теперь представим, что у Кэти и Тома есть свои фотонные пушки, которые они будут использовать для обмена фотонами (информацией) друг с другом. Должна быть установлена связь между поляризацией фотона и двоичным значением. Поляризация может быть вертикальной (`|`), горизонтальной (`--`), левой (`\`) или правой (`/`), а поскольку у нас только два двоичных значения, возникает некоторое перекрытие.

В рамках этого примера будем считать, что фотон с вертикальной поляризацией соответствует двоичному значению `0`, левая поляризация – `1`, правая – `0`, а горизонтаотная – `1`. Эта «привязка» (кодирование) к двоичным значениям и является ключом шифрования. Том должен знать эту схему «привязки» поляризации фотонов к двоичным значениям, чтобы иметь возможность правильно интерпретировать информацию, которую ему отправляет Кэти. Если Том получит фотон с левой поряризацией, он декодирует его как «`1`», если он получит фотон с вертикальной поляризацией – то как «`0`». Производя декодирование сообщения с помощью такого ключа, он получит информацию, которую ему отправила Кэти.

Таким образом, для обмена информацией им необходимо договориться о ключе, которым будет являться соответствие между состояниями поляризации фотонов и двоичным представлением передаваемой информации. Это необходимо сделать заранее, до начала сеанса передачи информации по выделенной оптической линии. После того, как соглашение о симметричном ключе достигнуто сторонами, этот ключ может использоваться ими для зашифрования и расшифрования данных, передаваемых по открытым коммуникационным каналам. Случайность поляризации и сложность создания симметричного ключа способствует обеспечению того, что злоумышленник не может вскрыть ключ шифрования.

Поскольку этот тип криптографии основан на квантовой физике, а не на точной математике, отправитель и получатель могут быть уверены, что никакой злоумышленник не прослушивает коммуникационный канал и не выполняет атаку «человек посередине». Это связано с тем, что квантовый уровень – это уровень характеристик атомных и субатомных частиц. Если злоумышленник будет выполнять пассивную атаку, прослушивая коммуникационный канал (сниффинг), получатель сразу узнает об этом, т.к. даже это простое действие изменит характеристики (поляризацию) фотонов.

## 12. Безопасность в сети Интернет

Веб (web) – это не то же самое, что Интернет. Можно сказать, что веб работает над Интернетом. Веб – это множество HTTP-серверов, на которых хранятся и работают используемые нами веб-сайты. А Интернет – это множество физических устройств и коммуникационных протоколов, используемых для работы этих сайтов и взаимодействия с ними.

### 12.1. Основы

Руководство компании должно принять решение, какие функции сети Интернет должны быть доступны сотрудникам, а администратор должен реализовать это решение на практике и организовать контроль использования сервисов снаружи и внутри сети. Использование сервисов может быть ограничено различными способами, например: разрешение запуска в системе только определенных сервисов и ограничение доступа к системе; использование только безопасных версий сервисов; фильтрация запросов к сервисам; блокирование нежелательных сервисов. Выбор необходимых сервисов и способов ограничения доступа к остальным сервисам определяет безопасность и указывает технологии, которые нужны для обеспечения защиты.

**HTTP**

`НТТР` – это протокол веб. `НТТР` находится наверху `TCP/IP`. Когда пользователь нажимает на ссылку на веб-странице, его браузер использует `НТТР` для отправки запроса на веб-сервер, на котором размещен веб-сайт. Веб-сервер находит соответствующий файл и отправляет его пользователю также с помощью `НТТР`. Но где же здесь `TCP/IP`? Протокол `TCP` управляет процедурой «рукопожатия» и поддерживает соединение между пользователем и сервером, а протокол `IP` гарантирует правильную маршрутизацию и доставку файлов через Интернет пользователю. Таким образом, протокол `IP` находит способ передачи данных между веб-сервером и пользователем, `TCP` обеспечивает корректность отправителя и получателя, а `НТТР` представляет содержимое, которым является веб-страница.

Протокол `НТТР` не создает постоянных соединений – клиент и сервер создают и разрывают временное соединение для каждой операции. Когда пользователь запрашивает определенную веб-страницу, веб-сервер находит эту страницу, предоставляет ее пользователю и сразу разрывает соединение. Если пользователь нажимает на ссылку на полученной веб-странице, устанавливается новое соединение, на веб-сервер отправляется новый запрос, веб-сервер в ответ отправляет запрошенную страницу и снова разрывает соединение. Веб-сервер не запомнинает пользователей, запрашивающих у него веб-страницы, поскольку это потребовало бы гораздо больше ресурсов.

**HTTPS**

`HTTPS` (HTTP Secure) – это `HTTP`, работающий через `SSL` (`НТТР` работает на прикладном уровне, а `SSL` – на транспортном). `SSL` (Secure Socket Layer) использует криптографию с открытым ключом и обеспечивает шифрование данных, аутентификацию сервера, целостность сообщений и (опционально) аутентфикацию клиента.

При переходе пользователя с открытой страницы веб-сайта на безопасную страницу, 
- Веб-сервер обращается к `SSL` для защиты передаваемых данных. 
- Сервер возвращает сообщение обратно клиенту, указывая, что необходимо установить безопасное соединение, а клиент в своем ответе направляет параметры безопасности. 
- Сервер выполняет сверку этих параметры безопасности со своими собственными, пока не найдет совпадение. Это и есть фаза «**рукопожатия**» (handshaking phase).
- Аутентификация сервера клиентом производится с помощью цифрового сертификата сервера. Если клиент принимает решение о доверии серверу, процесс продолжается. Сервер также может потребовать цифровой сертификат клиента для выполнения аутентификации клиента (взаимная аутентификация), но это делается довольно редко.
- Клиент генерирует сеансовый ключ и зашифровывает его на открытом ключе сервера.
- Зашифрованный ключ направляется веб-серверу, который расшифровывает его на своем закрытом ключе. 
- Теперь они оба имеют симметричный сеансовый ключ, который в дальнейшем используют для шифрования данных, передаваемых в обоих направлениях. Таким образом создается безопасный канал.
- `SSL` поддерживает созданный коммуникационный канал в открытом состоянии, пока одна из сторон не пришлет запрос на окончание сеанса. Обычно окончание сеанса инициируется клиентом, который отправляет на сервер пакет `FIN`, указывающий на необходимость закрытия соединения.

Для использования `SSL` требуется его поддержка как сервером, так и браузером пользователя. `SSL` обеспечивает безопасность соединений, но не безопасность полученных данных, т.е. данные зашифрованы только в процессе их передачи, но не после их доставки на компьютер получателя. Таким образом, если пользователь отправляет в банк свою финансовую информацию через защищенное SSL-соединение, он может быть уверен в защите этих данных в процессе передачи, но он должен доверять банку, получившему эту информацию.

В стеке протоколов, `SSL` расположен ниже прикладного уровня, но выше сетевого уровня. Это обеспечивает независимость `SSL` от конкретных прикладных протоколов и возможность использования им транспортных коммуникационных стандартов Интернета. В различных источниках `SSL` может быть расположен на различных уровнях модели `OSI`, что может вызвать непонимание. Нужно учитывать, что модель `OSI` – это концептуальная конструкция, которая пытается описать сетевую реальность. В действительности `SSL` состоит из двух протоколов: один работает внизу сеансового уровня, а другой работает наверху транспортного уровня. Именно поэтому одни источники ставят `SSL` на сеансовый уровень, а другие – на транспортный. 

> `SSL` работает на транспортном уровне.

Текущей версией `SSL` является версия `3.0`. Поскольку `SSL` был разработан `Netscape`, он не является открытым протоколом. В связи с этим расширение функциональности `SSL` не является простой задачей. В спецификации и функции закрытого, защищенного авторскими правами протокола, независимые разработчики не могут вносить изменений. Открытой версией протокола `SSL` является протокол `TLS` (Transport Layer Security). Различия между `SSL 3.0` и `TLS` незначительны, однако `TLS` имеет значительно больше возможностей для расширения функциональности и при этом он обратно совместим с `SSL`.

**Куки (Cookie)**

**Куки (cookie)** – это текстовые файлы, которые браузер хранит на жестком диске пользователя. Куки имеют множество различных вариантов использования, например, в некоторых случаях они применяются для сбора демографической информации или в рекламных целях. Когда пользователь переходит с сайта на сайт в Интернете, эти сайты могут записывать данные в куки, сохраняемые в системе пользователя. С помощью этих данных сайты могут отслеживать перемещения пользователя по Интернету, его привычки и предпочтения в отношении определенных сайтов.

Порядок использования куки определяют серверы веб-сайтов. Если пользователь добавляет товар в свою корзину покупок на сайте, данные об этом обычно записываются в куки. Затем, когда пользователь закончил выбирать товары и готов оплатить покупку, данные о выбранных им товарах извлекаются из соответствующего куки и рассчитывается итоговая сумма покупки.

Протокол `НТТР` **не устанавливает соединений**, поэтому веб-сервер не расходует память на хранение информации о предыдущих соединениях. **Это является одной из причин использования куки. С помощью них сохраняются данные о предыдущих соединениях пользователя, которые могут использоваться последующими HTTP-соединениями.**

Например, как только вы запрашиваете доступ к своему банковскому счету, веб-сервер устанавливает соединение `SSL` и требует, чтобы вы прошли аутентификацию перед предоставлением вам доступа. Как только вы проходите аутентификацию, сервер создает куки, в который записывает информацию о вашей аутентификации и вашем счете. Сервер отправляет этот куки вашему браузеру, а он сохраняет куки на жестком диске или в памяти вашего компьютера.

> Некоторые куки хранятся на жестком диске в виде текстовых файлов. Эти файлы не должны содержать критичной информации, такой как номера кредитных карт или пароли. Куки, в которых хранится критичная информация, обычно содержатся только в памяти компьютера и не записываются на жесткий диск.

Основная часть данных, хранящихся в куки, связана с серверами соответствующих сайтов, но некоторые куки могут содержать имена пользователей и пароли для различных учетных записей пользователя на интернет-сайтах. Куки, содержащие критичную информацию, должны в обязательном порядке быть зашифрованы сервером распространяющего их сайта, но так происходит не всегда, поэтому атакующие могут найти критичную информацию на жестком диске пользователя и попытаться воспользоваться ей в собственных интересах.

**SSH**

`SSH` (Secure Shell - Безопасная оболочка) – является разновидностью механизма туннелирования, обеспечивающего терминальный доступ к удаленным компьютерам. `SSH` – это программа и протокол, которые могут использоваться для входа на другие компьютеры через сеть. `SSH` обеспечивает аутентификацию и безопасную передачу данных через небезопасные каналы связи, такие как Интернет.

`SSH` – это программа и набор протоколов, которые работают совместно для создания безопасного туннеля между двумя компьютерами. При установлении соединения оба компьютера проходят через процедуру «рукопожатия» и обмениваются (с помощью алгоритма `Диффи-Хеллмана`) сеансовым ключом, который используется на протяжении всего сеанса взаимодействия этих компьютеров для шифрования и защиты передаваемых данных.

![[Pasted image 20241113133943.png]]

После завершения «рукопожатия» и создания безопасного канала, два компьютера получают возможность для защищенного обмена данными, в процессе которого обеспечивается конфиденциальность и целостность передаваемой информации.

**IPSec**

Набор протоколов `IPSec` (Internet Protocol Security) предоставляет способ создания защищенного канала для безопасного обмена данными между двумя устройствами. Такими устройствами, работающими через защищенный канал, могут быть два сервера, два маршрутизатора, рабочая станция и сервер, два шлюза между двумя различными сетями. `IPSec` – это общепринятый стандарт, обеспечивающий защиту на сетевом уровне. Он может быть более гибок и менее дорог, по сравнению с методами сквозного и канального шифрования.

В `IPSec` применяются стойкие методы шифрования и аутентификации. Обычно он применяется для создания VPN-туннелей между сетями через Интернет, хотя может использоваться и для создания коммуникационных туннелей между отдельными компьютерами.

`IPSec` – это не жесткий протокол, диктующий тип алгоритма, ключей и используемых методов аутентификации. `IPSec` – это открытая модульная платформа, обеспечивающая большую гибкость для компаний, выбравших эту технологию. В состав `IPSec` входят два основных протокола безопасности: `AH` (Authentication Header - Аутентификация заголовка) и `ESP` (Encapsulating Security Payload - Безопасная инкапсуляция содержимого). `AH` – это протокол аутентификации, а `ESP` – протокол аутентификации и шифрования, используемый криптографическими механизмами для выполнения аутентификации источника, а также обеспечения конфиденциальности и целостности сообщений.

`IPSec` может работать в одном из двух режимов: **транспортный режим**, в котором защищено содержимое сообщений, и **туннельный режим**, в котором защищено не только содержимое сообщений, но и заголовки пакетов, и информация маршрутизации. При работе `ESP` в **транспортном режиме**, он выполняет шифрование **только содержимого сообщений**, что в случае их перехвата не позволит неуполномоченным лицам прочитать информацию. **Туннельный режим** обеспечивает более высокий уровень защиты, **дополнительно шифруя заголовки и окончания пакетов данных, в которых атакующий может найти полезные для него сведения.**

![[Pasted image 20241113135448.png]]

Каждое устройство должно иметь одну или более **ассоциаций безопасности** (`SA` – security association) на каждое используемое им безопасное соединение. `SA` – это конфигурационная запись в настройках устройства, необходимая для работы соединения `IPSec`. `SA` играет одну из важнейших ролей в архитектуре `IPSec`. Когда два устройства завершили процесс «**рукопожатия**», в рамках которого они достигли соглашения по большому количеству различных коммуникационных параметров, эти параметры должны быть где-то сохранены. Именно для этого и нужна `SA`. `SA` может содержать ключи аутентификации и шифрования, информацию о согласованных алгоритмах, срок жизни ключа, IP-адрес отправителя. Когда устройство получает пакет посредством протокола `IPSec`, именно `SA` говорит устройству, что нужно делать с этим пакетом. Так, если устройство `Б` получает пакет от устройства `В` посредством `IPSec`, устройство `Б` должно посмотреть в соответствующую `SA`, чтобы узнать, как расшифровать пакет, как правильно аутентифицировать отправителя пакета, какой ключ использовать, как отвечать на сообщение при необходимости.

`SA` учитывает только одно направление передачи данных, поэтому устройство должно иметь для каждого отдельного коммуникационного канала одну `SA` для исходящего трафика и одну – для входящего. Таким образом, если устройство подключено к трем другим устройствам, оно должно иметь не менее шести `SA` – по две (одна для исходящего трафика, другая – для входящего) на каждое удаленное устройство. Каким образом устройства хранят `SA` и обеспечивают применение нужных `SA` для соответствующих соединений? Это осуществляется с помощью индексов параметров безопасности (`SPI` – security parameter index). На каждом устройстве есть `SPI`, который отслеживает различные `SA` и сообщает устройству, какой ему нужен `SA` для обработки того или иного пакета. Значение `SPI` указывается в заголовке пакета `IPSec`, устройство считывает это значение, чтобы найти нужный `SA`.

![[Pasted image 20241113143257.png]]

`IPSec` может аутентифицировать устройства, отправляющие пакеты, с помощью `МАС`. Протокол `ESP` может обеспечить аутентификацию, целостность и конфиденциальность (если устройстве включена и настроена эта функциональность). Таким образом, если компании достаточно просто обеспечить уверенность в источнике пакетов и в целостности пакетов, ей следует выбрать `АН`. Если компании помимо этих функций необходимо обеспечить конфиденциальность, ей следует использовать протокол `ESP`, т.к. он предоставляет функции шифрования. В большинстве случаев применение `ESP` обуславливается наличием у компании потребности в создании безопасных VPN-соединений.

Может показаться, что шифрование является дополнением в протоколе `ESP`, а в остальном функциональность `AH` и `ESP` пересекается. `АН` обеспечивает аутентификацию и целостность, а `ESP` может обеспечивать помимо этих функций еще и конфиденциальность. Зачем в таком случае нужен `АН`? В большинстве случаев это вызвано использованием `NAT` (трансляция сетевых адресов). `IPSec` генерирует контрольное значение целостности (`ICV` – integrity check value), которое в действительности является тем же значением `МАС`, вычисленным для части пакета. Помните, что отправитель и получатель генерируют свои собственные значения для проверки целостности? В `IPSec` эти значения называются `ICV`. Получатель сравнивает самостоятельно рассчитанное значение `ICV` с аналогичным значением, полученным от отправителя. Если значения совпадают, получатель может быть уверен, что пакет не был изменен в процессе передачи. Если значения отличаются, пакет был изменен и получатель отбрасывает его.

Протокол `АН` рассчитывает значение `ICV` как над самими данными, так и над транспортным и сетевым заголовками. Если затем пакет проходит через устройство `NAT`, это устройство изменяет IP-адрес отправителя пакета. Это его работа. Однако при этом часть содержимого пакета (заголовок сетевого уровня), включенная ранее в расчет значения `ICV`, изменяется и, если получатель сгенерирует свое значение `ICV` для полученного пакета, оно будет отличаться от значения `ICV`, указанного в пакете, и пакет будет автоматически уничтожен.

Протокол `ESP` выполняет аналогичные шаги, за исключением того, что он не включает заголовок сетевого уровня в расчет значения `ICV`. Когда устройство NAT изменяет IP-адрес отправителя, это не влияет на значение `ICV`, т.к. заголовок сетевого уровня в расчете `ICV` не участвует.

![[Pasted image 20241113144711.png]]

Поскольку `IPSec` является платформой, он не диктует конкретные алгоритмы хэширования и шифрования или процедуры обмена ключами. Управление ключами может выполняться вручную или автоматически с использованием протокола управления ключами. Стандартом «де-факто» для `IPSec` является использование `IKE` (Internet Key Exchange - Обмен ключами в Интернет), который является комбинацией протоколов `ISAKMP` и `OAKLEY`. `ISAKMP` (Internet Security Association and Key Management Protocol - Протокол управления ключами и ассоциациями безопасности в Интернете) – это архитектура обмена ключами, независящая от типа используемых механизмов, связанных с ключами. `ISAKMP` предоставляет платформу, соглашение о деталях использования которой достигается в процессе создания соединения `IPSec` (алгоритмы, протоколы, режимы, ключи). Протокол `OAKLEY` – это протокол, который как раз и реализует достижение этого соглашения. Представьте, что `ISAKMP` – это игровое поле (инфраструктура), а `OAKLEY` – это парень, бегающий по полю туда и обратно (выполнение шагов заключения соглашения).

`IPSec` со всеми этими компонентами и различными возможными конфигурациями очень многообразен. Это многообразие обеспечивает высокую степень гибкости, поскольку компания имеет большой выбор конфигураций для достижения необходимого ей уровня защиты.

## 13. Атаки

Перехват и прослушивание передаваемых по сети данных называется **пассивной** атакой, т.к. атакующий не воздействует на протокол, алгоритм, ключ, само сообщение, какие-либо части системы шифрования. Пассивную атаку очень сложно обнаружить, в большинстве случаев проще попытаться предотвратить ее, чем выявить и остановить.

**Активными** атаками является изменение сообщений, изменение системных файлов, попытки выдать себя за другого человека. 

При выполнении **активных** атак атакующий что-то реально делает, а не просто собирает данные. **Пассивные** атаки обычно используются для сбора информации перед проведением активной атаки. 

### 13.1. Атака "Только шифротекст"

При выполнении атаки этого типа, атакующий имеет шифротекст нескольких сообщений. Каждое из сообщений зашифровано одним и тем же алгоритмом. Целью атакующего является вскрытие ключа, использованного в процессе шифрования. Если атакующий сможет вскрыть ключ, он сможет расшифровать все остальные сообщения, зашифрованные на том же ключе.

Атака «только шифротекст» (cipher-only attack) – это самый распространенный тип активных атак, поскольку получить шифротекст достаточно просто, например, прослушивая чей-то сетевой трафик. Однако это сложнейшая атака, в которой крайне сложно добиться успеха, поскольку атакующий имеет слишком мало информации о процессе шифрования.

### 13.2. Атака "Известный открытый текст"

При выполнении атаки типа «известный открытый текст» (known-plaintext attack), у атакующего есть открытый текст и соответствующий ему шифротекст одного или нескольких сообщений. Целью также является вскрытие ключа, использованного при шифровании этих сообщений, чтобы расшифровать и прочитать другие сообщения.

Обычно сообщения начинаются и заканчиваются одним и тем же текстом. Например, атакующий может узнать, что большинство сообщений сотрудников компании начинается с определенного приветствия и заканчивается подписью, в которую входит имя сотрудника, должность и контактная информация. Таким образом, атакующий имеет некоторый объем открытого текста (одинаковые данные в каждом сообщении) и может перехватить зашифрованное сообщение и извлечь из него шифротекст. Это позволит вскрыть несколько частей этой головоломки, а для завершения атаки нужно будет провести обратный инжиниринг, частотный анализ или брутфорс-атаку. Атаки типа «известный открытый текст» использовались США против Германии и Японии во Второй Мировой войне.

### 13.3. Атака "Выбранный открытый текст"

При выполнении атаки типа «выбранный открытый текст» (chosen-plaintext attack), у атакующего также есть открытый текст и соответствующий ему шифротекст, но он имеет возможность самостоятельно выбирать открытый текст и получать его в зашифрованном виде. Это дает атакующему дополнительные возможности для более глубокого изучения механизмов работы процесса шифрования, а также для сбора большего объема информации об используемом ключе. Если ему удастся вскрыть ключ, он сможет расшифровать другие сообщения, зашифрованные на этом ключе.

Как это делается? Например, атакующий может подготовить специальное сообщение, которое заставит получателя переслать его кому-то еще. Атакующий отправляет это сообщение пользователю, тот пересылает его своему коллеге, а почтовая программа на его компьютере автоматически зашифровывает сообщение перед отправкой. После этого атакующий перехватывает трафик пользователя и получает копию шифротекста к написанному им самим открытому тексту.

### 13.4. Атака "Выбранный шифротекст"

При выполнении атаки типа «выбранный шифротекст» (chosen-ciphertext attack), атакующий может выбирать шифротекст для расшифрования и имеет доступ к получаемому в результате открытому тексту. Целью опять же является вскрытие ключа. Это более сложная атака по сравнению с предыдущей. Для ее реализации атакующему может потребоваться контроль над системой, содержащей криптосистему.

**Открытые и секретные алгоритмы**. В настоящее время в мире в основном используются хорошо известные и понятные криптографические алгоритмы, а не секретные. Криптографы знают, насколько стойким и хорошо спроектированным должен быть алгоритм, представляемый на суд общественности. Тысячи умов лучше, чем пять, и часто это помогает найти в алгоритме проблемы, которые не заметили разработчики. Именно поэтому различные производители и компании устраивают соревнования по взлому их кодов и процессов шифрования. Если кому-то удается их взломать, разработчики возвращаются к чертежной доске и усиливают ту или иную часть алгоритма.

Однако не все алгоритмы сделаны общедоступными, например, некоторые алгоритмы, разработанные Агентством национальной безопасности США, являются секретными. Поскольку уровень критичности данных, с которыми работают шифры АНБ, настолько велик, они хотят максимально сохранить процесс в секрете. АНБ не проводит публичных тестов и исследований своих алгоритмов, однако это не говорит о слабости алгоритмов АНБ. Эти алгоритмы разрабатываются, исследуются и тестируются лучшими криптографами, имеющими очень высокую квалификацию.

### 13.5. Дифференциальный криптоанализ

Целью атаки этого типа также является вскрытие ключа, использованного при шифровании. Эта атака анализирует пары шифротекста, созданного при зашифровании пар открытого текста с определенными различиями, и анализирует их воздействие и результат, получаемый в результате этих различий. Первая такая атака была проведена в 1990 году против алгоритма `DES`. В дальнейшем она эффективно и успешно применялась для взлома `DES` и других блочных алгоритмов.

Атакующий берет два сообщения в виде открытого текста и следит за изменениями, которые происходят с блоками при их прохождении через различные S-боксы. (Каждое сообщение зашифровывается на одном и том же ключе). Выявленные расхождения в значениях получаемого в результате шифротекста используются в качестве карты вероятных значений для различных возможных значений ключа. Атакующий выполняет этот процесс для максимально возможного набора различных сообщений и определяет вероятные значения ключа. Постепенно ключ проявляется, и это с высокой вероятностью будет именно тот ключ, который использовался в процессе шифрования. Поскольку атакующий для атаки выбирает сообщения в виде открытого текста, это является атакой с «выбранным открытым текстом».

### 13.6. Линейный криптоанализ

Линейный криптоанализ является другим вариантом атаки, направленной на выявление наиболее вероятного значения ключа, использованного в процессе шифрования блочным алгоритмом. Атакующий выполняет атаку «известный открытый текст» на несколько различных сообщений, зашифрованных на одном и том же ключе. Чем больше сообщений потенциально может использовать атакующий для этой атаки, тем вероятность нахождения правильного ключа.

Атакующий анализирует входящие и исходящие значения для каждого S-бокса. Он анализирует вероятность того, что определенные входящие значения дают в результате определенную комбинацию. Выявление таких результирующих комбинаций позволяет ему оценивать вероятность для различных значений ключа, пока он не найдет повторяющийся шаблон, имеющий высокую вероятность.

### 13.7. Атаки с использованием побочных каналов

Все рассмотренные нами ранее атаки, основаны в первую очередь на математических аспектах криптографии. Использование открытого текста и шифротекста, а также применение мощных математических инструментов, направлено на вскрытие ключа, использованного в процессе шифрования.

Но существуют и другие методы. Предположим, мы видим какое-то животное, похожее на утку. Оно ходит как утка, издает звуки как утка, плавает в воде, ест жуков и маленьких рыб. Мы можем с уверенностью сделать вывод о том, что это утка. Так же и в криптографии, мы можем увидеть некоторые факты и сделать вывод о значении ключа. Например, мы можем измерить, сколько расходуется электроэнергии при зашифровании и расшифровании (по колебаниям электрического напряжения). Мы можем также перехватить создаваемые при этом излучения и затем рассчитать, сколько времени выполняются процессы. Анализ происходящего вне криптосистемы, измерение различных свойств и характеристик отличается от анализа того, что происходит в самой криптосистеме, но также дает данные, используя которые можно попытаться провести математические расчеты.

Если мне нужно узнать ваши привычки и предпочтения, но я не хочу, чтобы вы знали об этом, я не буду спрашивать вас напрямую. Вместо этого я прослежу, когда вы приходите на работу, когда уходите домой, какую одежду вы носите, что вы делаете, о чем говорите... Это тоже примеры получения информации с помощью побочных каналов (side-channel). Таким образом, в криптографии сбор «внешней» информации с целью вскрытия ключа шифрования – это просто еще один способ атаки на криптосистемы.

### 13.8. Атаки повтора

Большое проблемой в распределенной среде являются атаки повтора (replay attack), при выполнении которых атакующий перехватывает определенные данные, а затем отправляет их снова, надеясь, что получившее их устройство примет их за легитимную информацию. Чаще всего атакующий пытается перехватить и повторно использовать аутентификационные данные, чтобы пройти аутентификацию в системе от имени легитимного пользователя и получить таким образом несанкционированный доступ к ней.

### 13.9. Алгебраические атаки

При выполнении алгебраической атаки (algebraic attack), атакующий анализирует уязвимости в математических частях алгоритма и использует его внутренние алгебраические структуры. Для примера, атака на версию «текстовой книги» криптосистемы `RSA` использует такие свойства алгоритма, как факт, что при шифровании `0` получается `0`.

### 13.10. Аналитические атаки

Аналитические атаки (analytics attack) выявляют структурные слабости и недостатки алгоритма, вместо выполнения брутфорс-атаки, при которой просто перебираются все возможные значения, без учета специфических свойств алгоритма.
























































