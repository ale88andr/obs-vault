
Двумя фундаментальными понятиями в компьютерной и информационной безопасности являются политика безопасности и модель безопасности. 

**Политика безопасности** – это заявление, в котоfccром описывается, каким образом сущности взаимодействуют друг с другом, какие операции могут выполнять различные сущности, какой уровень защиты является необходимым для системы или программного продукта, а также какие действия следует предпринять, если эти требования будут нарушены.

>Политика безопасности описывает ожидания, которым должны удовлетворять аппаратные средства и программное обеспечение.

**Модель безопасности** описывает требования, необходимые для реализации и надлежащей поддержки политики безопасности. Если политика безопасности требует, чтобы все пользователи были идентифицированы, аутентифицированы и авторизованы перед тем, как им будет предоставлен доступ к сетевым ресурсам, модель безопасности может содержать матрицу контроля доступа, построенную таким образом, чтобы удовлетворять требованиям политики безопасности. Если политика безопасности требует, чтобы никто на нижнем уровне безопасности не имел возможности просмотра или изменения информации на более высоком уровне безопасности, поддерживающая модель безопасности будет описывать необходимую логику и правила, которые должны быть предприняты для обеспечения того, чтобы ни при каких обстоятельствах не мог произойти несанкционированный доступ субъекта на нижнем уровне к объекту на более высоком уровне безопасности. 

>Модель безопасности более глубоко объясняет требования к разработке операционной системы компьютера, реализация которых необходима для надлежащей поддержки конкретной политики безопасности.

## 1. Архитектура компьютера

Архитектура компьютера включает в себя все элементы компьютерной системы, необходимые для ее функционирования, включая операционную систему, память, логические схемы, устройства хранения информации, устройства ввода/вывода, шины, компоненты безопасности, сетевые компоненты.

### 1.1. Центральный процессор

**Центральный процессор** (CPU – central processing unit) – это «мозг» компьютера. Он извлекает из памяти команды и выполняет их. Хотя процессор является частью аппаратного обеспечения, он имеет свой собственный набор команд (поддерживаемый операционной системой), необходимый ему для выполнения своих задач. Каждый процессор имеет определенную архитектуру и набор команд. Операционная система должна быть спроектирована под конкретную архитектуру процессора.

Микросхемы в процессоре занимают всего несколько квадратных дюймов, но содержат десятки и сотни миллионов транзисторов. Все операции в процессоре выполняются с помощью электрических сигналов с различными напряжениями в различных комбинациях, каждый транзистор сохраняет определенное напряжение, переводимое компьютером в нули и единицы. Процессор имеет регистры, являющиеся сверхбыстрой памятью внутри процессора, предназначенной для временного хранения информации (например, указателя на адрес в памяти со следующей командой для выполнения процессором, указателя на текущую позицию в стеке, информации о состоянии обрабатываемых данных и т.п.). Доступ к памяти для получения очередной команды или данных – это значительно более медленный процесс, чем к обращение к регистру. Поэтому, когда процессор завершает одну задачу, он берет информацию о следующей задаче именно из регистров.

Программное обеспечение хранит свои команды и данные в памяти. Когда необходимо произвести определенное действие над данными, адреса команд и данных поступают в соответствующие регистры процессора. Когда устройство управления говорит процессору, что он может приступить к работе, адреса команд и данных поступают в процессор для реальной обработки, математических расчетов и управления данными. Результаты отправляются обратно в память запрашивающего процесса. 

**Устройство управления** (control unit) управляет и синхронизирует систему в процессе выполнения кода операционной системы и различных приложений. Устройство управления загружает код, интерпретирует его и следит за выполнением различных наборов команд. Оно определяет, какие команды приложения передаются на обработку, с каким приоритетом, и на какое время. Управление процессом выполнения команд позволяет приложениям обрабатывать данные. Процессорное время делится на отдельные кванты и предоставляется процессам. Именно это деление процессорного времени заставляет нас думать, что процессор выполняет различные команды одновременно, хотя на самом деле он выполняет их последовательно (по одной).

Процессор имеет несколько различных типов регистров, содержащих информацию о командах и данных, которые должны быть обработаны. **Регистры общего назначения** используются для хранения переменных и временных результатов. **Специальные регистры** (выделенные регистры) содержат такую информацию, как счетчик команд (program counter), указатель стека (stack pointer) и слово состояния программы (PSW – program status word). Регистр счетчика команд содержит адрес следующей команды для загрузки. После запуска команды на выполнение счетчик команд обновляется, в него записывается адрес памяти, содержащий следующую команду для выполнения.

Каждый процесс имеет свой собственный *стек* (stack), являющийся структурой данных в памяти, которую процесс может читать и в которую он может записывать данные способом LIFO (последним пришел - первым ушел). Процессору нужно отслеживать текущее местоположение в стеке, для чего и служит указатель стека. После получения первого элемента стека, указатель стека перемещается вниз, чтобы сообщить процессору, где в стеке находится следующий фрагмент данных.

**Слово состояния программы** хранит различные биты состояния. Один из битов указывает, работает ли процессор в реальном режиме (user mode), или в защищенном режиме (privileged mode) (также называемом режимом ядра (kernel или supervisor mode)). 

Чтобы обеспечить стабильную и безопасную среду, операционная система должна защищать себя от приложений, утилит и действий пользователей. Один из таких механизмов защиты реализуется посредством использования различных режимов работы. Когда приложение передает процессору для выполнения свои команды, процессор выполняет их в реальном режиме. Этот режим имеет низкий уровень привилегий, делающий недоступными для запрашивающего приложения многие из команд и функций процессора. Причиной для такой осторожности является то, что разработчики операционной системы не знают, кто разработал приложение, и как оно будет работать, поэтому процессор работает в непривилегированном режиме, когда выполняет такие команды.

Если соответствующий бит в PSW указывает, что команды должны выполняться в защищенном режиме, это означает, что запрос сделал доверенный процесс (процесс самой операционной системы), который имеет доступ к функциональности, недоступной в реальном режиме. Примером может служить взаимодействие операционной системы с периферийным устройством. Это привилегированные действия, которые обычное приложение не может выполнить самостоятельно.

Адреса памяти, указывающие на местонахождение команд и данных для обработки, хранятся в регистрах, пока они не понадобятся процессору. Процессор подключен к **адресной шине**, которая физически подключена к микросхемам оперативной памяти и отдельным устройствам ввода/вывода. Память разделена на сегменты, которые имеют собственные адреса. Устройствам ввода/вывода (CD-ROM, USB-устройства, жесткий диск, дисковод и т.д.) также выделены отдельные уникальные адреса. Если процессору нужен доступ к определенным данным из памяти или из устройства ввода/вывода, он отправляет по адресной шине адрес, где находятся необходимые данные. Логическая схема, связанная с памятью или устройством ввода/вывода, распознает полученный от процессора адрес, и дает команду памяти или устройству ввода/вывода прочитать запрошенные данные, а затем направляет их процессору по **шине данных**. Таким образом, адресная шина используется процессором для указания местоположения команд или данных, подлежащих обработке, а память или устройство ввода/вывода отвечает, посылая запрошенные данные через шину данных.

Когда процессор заканчивает вычисления, он должен вернуть результат в память запрашивающей программе. Для этого процессор посылает соответствующий адрес по адресной шине, а результаты – по шине данных вместе с командой записи. Таким образом, эти новые данные записываются в память запрашивающей программы.

**Многопроцессорная обработка** - в компьютерах для повышения производительности установлено более одного процессора. Для эффективной работы операционной системы с несколькими процессорами, она должна быть специально разработана для таких систем. При этом компьютер может быть настроен на работу в *симметричном* или *ассиметричном* режиме. 

В *симметричном* режиме процессоры берут новые задания по мере необходимости, как показано на рисунке с процессорами 1 и 2. Это похоже на среду с балансировкой нагрузки. Когда процессу нужно выполнить некоторые свои команды, планировщик определяет, какой процессор готов для дальнейшей работы и отправляет эти команды ему.

Если процессор будет выделен специально для конкретной задачи или приложения, все другие программы будут выполняться на других процессорах. Например, на рисунке процессор 4 выделен для одного приложения и его потоков, в то время как процессор 3 используется операционной системой. Когда процессор выделен, как в этом примере, система работает в асимметричном режиме. Обычно это означает, что на компьютере работает несколько чувствительных ко времени выполнения приложений, которые нуждаются в собственном персональном процессоре. Таким образом, системный планировщик отправляет команды от такого приложения процессору 4, а все остальные команды (от операционной системы и других приложений) процессору 3.

![[Pasted image 20241028105733.png]]

**Эволюция процессоров**

![[Pasted image 20241028110503.png]]

- **Микрон** – Наименьшая толщина проводника в микросхеме процессора в микронах (для сравнения, толщина человеческого волоса составляет 100 микрон).
- **Частота** – Тактовая частота, скорость, с которой процессор может выполнять команды. Для управления скоростью выполнения операций применяется внутренний таймер, который делит время на такты. Например, если система работает на частоте 100 МГц, это означает, что происходит 100 миллионов тактов в секунду.
- **Разрядность** – Указывает объем данных, который ALU может принять и обработать; пометка «шина – 64 бита» указывает на размер шины данных. Таким образом, современные системы передают по 64 бита данных, но ALU работает только 32 битами данных.
- **MIPS** – Миллионы операций в секунду, что является одним из основных показателей скорости работы процессора (однако на это оказывают влияние и другие факторы, такие как тактовая частота).

### 1.2. Архитектура операционной системы

Операционная система предоставляет среду для работы приложений и пользователей. Операционная система состоит из различных слоев и модулей, которые отвечают за управление оборудованием, памятью, операциями ввода/вывода, процессами, файловой системой, а также предоставляют системные сервисы.

**Управление процессами**

Операционные системы, утилиты и приложения в действительности являются просто множеством строк команд. Эти статические строки кода оживают после инициализации программы и размещения в памяти. Приложения работают как отдельные модули, называемые процессами, операционная система также имеет множество различных процессов, выполняющих различные функции. **Процесс** – это набор команд, запущенный на выполнение. Программа не является процессом, пока она не загружена в память и не активирована операционной системой. При создании процесса операционная система выделяет ему ресурсы, такие как сегменты памяти, кванты процессорного времени, доступ к интерфейсам API (application programming interface), файлам и т.п.

Операционная система имеет целый ряд процессов, которые обеспечивают и поддерживают среду для работы пользователей и приложений. Например, некоторые процессы обеспечивают такие функции, как отображение данных на экране, буферизацию заданий для печати, сохранение данных во временных файлах и т.д. Современные операционные системы являются многопрограммными, т.е. они способны одновременно исполнять более одной программы (или процесса). Именно это позволяет одновременно запускать антивирусное программное обеспечение, текстовый редактор, персональный межсетевой экран и клиент электронной почты. Каждое из этих приложений выполняется в виде одного или более процессов.

В ранних версиях операционных систем (Windows 3.1, Macintosh) была реализована **кооперативная многозадачность** (cooperative multitasking), когда процессы сами освобождали ресурсы компьютера, по своему усмотрению. В более современных версиях (Windows 2000, XP, Unix-системах и т.д.) реализована **вытесняющая многозадачность** (preemptive multitasking), при использовании которой операционная система сама управляет использованием ресурсов процессами. Кооперативная многозадачность не может обеспечить стабильную среду, т.к. если программист не написал (или неправильно написал) код, надлежащим образом освобождающий ресурс после выполнения своего приложения, этот ресурс может оказаться заблокированным на неопределенное время и недоступным для других процессов. При использовании вытесняющей многозадачности операционная система управляет тем, сколько времени процесс может использовать ресурс. Система может приостановить процесс, использующий процессор и позволить другим процессам получить доступ к нему с помощью разделения времени (time sharing).

Различные операционные системы используют различные модели процессов. Например, системы Unix и Linux позволяют своим процессам создавать новые дочерние процессы, что называется **ветвлением** (forking). 

Процесс может находиться в *состоянии выполнения* (running state – процессор выполняет команды процесса), в *состоянии готовности* (ready state – ожидание передачи команд процессору) или в *заблокированном состоянии* (blocked state – ожидание входящих данных).

![[Pasted image 20241028121430.png]]

Операционная система отвечает за создание новых процессов, выделение каждому из них ресурсов, синхронизацию их взаимодействия и контроль, что не происходит ничего опасного. Операционная система хранит специальную таблицу процессов (process table), в которой содержится информация о каждом процессе. В этой таблице хранятся связанные с процессами параметры, например, состояние процесса, указатель стека, программный счетчик, распределение памяти, состояние открытых файлов и т.д. Вся эта информация нужна операционной системе для того, чтобы процессор загружал ее в свои регистры, когда ему необходимо взаимодействовать, например, с процессом 1. Когда закончится квант процессорного времени, выделенный процессу 1, вся текущая информация о состоянии процесса 1 сохранится в таблице процессов, чтобы, когда этот процесс снова получит квант времени, все эти сведения можно было загрузить обратно в регистры процессора. При этом из таблицы процессов в регистры процессора будет загружена информация процесса 2, а когда закончится и его квант процессорного времени, информация из регистров снова будет записана в таблицу процессов.

Но как процесс узнает, когда он может взаимодействовать с процессором? Для этого используются **прерывания** (interrupt). Операционная система обманывает нас и приложения, заставляя думать, что процессор одновременно выполняет все задачи (операционную систему, приложения, операции с памятью, ввод/вывод и действия пользователей). Но в действительности это невозможно. Большинство процессоров могут выполнять только одну операцию за раз, поэтому система имеет аппаратные и программные прерывания. Когда устройству необходимо взаимодействовать с процессором, оно должно дождаться своего прерывания, которое его вызовет. То же самое происходит и в программном обеспечении. Каждый процесс имеет прерывание, связанное с ним.

> Когда процесс взаимодействует с процессором и происходит прерывание (еще один процесс запрашивает доступ к процессору), информация о текущем процессе сохраняется в таблице процессов, и следующий процесс получает свое время для взаимодействия с процессором.

**Управление потоками**

Когда процессу нужно отправить команды на выполнение процессору, он создает **поток**. **Поток** (thread) состоит из собственного набора команд и данных, которые должны быть обработаны процессором. Потоки создаются и уничтожаются динамически по мере необходимости.

Используя потоки, программа может выполнять несколько задач одновременно (например, выводить изображение на экран, взаимодействовать с другими программами, отправлять документ на печать). Приложение, использующее эту возможность, называется **многопоточным** (multithreaded) приложением.

> Каждый поток имеет общие ресурсы с процессом, который его создал. Все потоки процесса работают в том же адресном пространстве, что и сам процесс, имеют доступ к тем же файлам и системным ресурсам.

**Диспетчеризация процессов**

**Диспетчеризация** (scheduling) и синхронизация (synchronizing) различных процессов и их действий – это часть управления процессами, выполняемого операционной системой. Различные операционные системы могут использовать различные варианты диспетчеризации (по сути, алгоритмы управления разделением процессорного времени).  Операционная система создает и удаляет процессы по мере необходимости, меняет их состояние (готов, заблокирован, выполняется). Она также контролирует взаимные блокировки (deadlock) процессов, пытающихся использовать одни и те же ресурсы.

Когда один процесс делает запрос на доступ к ресурсу (памяти, принтеру, дисковому пространству и т.д.), операционная система создает определенные структуры данных и необходимые для выполнения этих действий процессы. Как только действия выполнены (документ, данные сохранены в файл или, наоборот, считаны с диска), процесс должен уничтожить эти структуры и освободить ресурсы, чтобы они стали доступны для других процессов. Если это не произойдет должным образом, может возникнуть взаимная блокировка процессов, или компьютеру может не хватить ресурсов, чтобы обрабатывать другие запросы (в результате возникнет отказ в обслуживании). Взаимная блокировка может возникнуть, когда один процесс ждет определенное событие, которое может быть вызвано только другим процессом, который, в свою очередь, ожидает результаты от первого процесса. При этом возникнет ситуация, когда оба процесса будут просто стоять и ждать друг друга.

**Работа процессов**

Компьютеры могут запускать различные приложения и процессы одновременно. Процессы совместно используют ресурсы и взаимодействуют друг с другом. Некоторые области памяти, файлы и переменные разделяются между различными процессами. Учитывая все это, крайне важно позаботиться об обеспечении стабильной, безопасной вычислительной среды и поддержании ее целостности. Необходимо гарантировать, что несколько процессов не могут одновременно осуществлять операции чтения и записи одного и того же ресурса. Именно операционная система является основной программой, которая обеспечивает соответствующие защитные механизмы и не позволяет программам повредить область памяти друг у друга. Операционная система работает с процессором, чтобы обеспечить деление времени на кванты с помощью прерываний, для предоставления процессам адекватного доступа к центральному процессору. Это также гарантирует, что вредоносные приложения не окажут негативного влияния на важные функции системы.

Для защиты процессов друг от друга операционная система может использовать **изоляцию процессов** ( process isolation). Изоляция процессов необходима, чтобы процессы «не наступали друг другу на ноги», взаимодействуя небезопасным образом, и не оказывали негативного влияния на производительность друг друга.

Для реализации изоляции процессов могут использоваться различные методы:
- **Инкапсуляция объектов** - когда процесс инкапсулирован, никакие другие процессы не могут взаимодействовать с его внутренним кодом. Если процессу А нужно взаимодействовать с процессом В, процессу А достаточно знать как взаимодействовать с интерфейсом процесса В. Интерфейс определяет порядок взаимодействия между двумя процессами. Программные компоненты должны знать, как правильно взаимодействовать с интерфейсами друг друга. Этот механизм обеспечивает целостность и модульность программного кода.
- **Временное мультиплексирование общих ресурсов**– это технология, которая позволяет процессам использовать одни и те же ресурсы. Мультиплексирование означает, что есть несколько источников данных, а также отдельные части данных, по конвейеру поступающие в один коммуникационный канал. В этом случае операционная система координирует различные запросы от различных процессов и проводит их конвейерную обработку посредством одного общего процессора.
- **Разделение имен** - просто означает, что все процессы имеют собственное уникальное имя или идентификатор. Обычно процессам назначаются идентификаторы процесса (PID), которые операционная система и другие процессы используют для обращения к ним. Если каждый процесс изолирован, это означает, что каждый процесс имеет свое собственное уникальное значение PID.
- **Виртуальное отображение** - Для приложений создается иллюзия того, что каждое из них является единственным запущенным приложением в операционной системе. Когда приложению требуется память для работы, оно говорит менеджеру памяти операционной системы, сколько памяти ему нужно. Операционная система выделяет необходимый объем памяти и связывает его с запрашивающим приложением. Приложение использует свою собственную схему адресации, которая обычно начинается с `0`, но в действительности приложение не работает с физическим адресным пространством (хотя ему кажется, что работает). Вместо этого, оно работает в адресном пространстве, которое ему предоставил менеджер памяти.

**Управление памятью**

Чтобы обеспечить безопасную и стабильную среду, операционная система должна осуществлять надлежащее управление памятью – это одна из наиболее важных ее задач. В конце концов, все происходит в памяти. Это подобно тому, как наше существование зависит от кислорода и гравитации.

Целями управления памятью являются:
- **Предоставление уровня абстракции программистам** - означает, что скрываются некие детали. Разработчики приложений не знают объем или тип памяти, который будет использоваться в каждой системе, на которую будет установлено их программное обеспечение. Если разработчик ориентировался на такие детали, его приложение будет иметь возможность работать только с очень ограниченным кругом систем, полностью соответствующих всем спецификациям. Для обеспечения переносимости приложений, менеджер памяти скрывает все вопросы в отношении памяти и просто предоставляет приложению сегмент памяти
- Максимизация производительности при ограниченном объеме доступной памяти
- Защита операционной системы и приложений, загруженных в память

Часть операционной системы, которая отслеживает использование различных типов памяти, называется **менеджером памяти**. Он выделяет и освобождает различные сегменты памяти, реализует управление доступом, гарантируя, что процессы взаимодействуют только с их собственными сегментами памяти, переносит участки памяти из оперативной памяти на жесткий диск ( файл подкачки).

![[Pasted image 20241028124850.png]]

Когда процесс создает поток для выполнения своих команд и обработки данных, процессор использует два регистра. Базовый регистр (base register) содержит начальный адрес, который был предоставлен этому процессу, а регистр границы области памяти (limit register) содержит конечный адрес

![[Pasted image 20241028125426.png]]

**Типы памяти**

**Память с произвольным доступом** (RAM – random access memory) – это разновидность временного хранилища данных, в котором данные и команды программного обеспечения могут храниться и изменяться. RAM используется операционной системой и приложениями для выполнения операций чтения/записи. Эта память является временной, т.к. при отключении электропитания вся информация в ней теряется.

Микросхема RAM состоит из миллионов транзисторов и конденсаторов. В конденсаторах хранятся электрические заряды, которые преобразуются системой в `1` или `0`. Транзистор работает как *затвор* (gate) или *переключатель* (switch). Для хранения двоичного значения `1`, конденсатор держит внутри себя несколько электронов, которые имеют отрицательный заряд, а если конденсатор пуст, это соответствует значению `0`. Когда операционная система записывает значение `0` поверх `1`, фактически это приводит просто к освобождению конденсатора от электронов.

Одной из проблем является то, что конденсаторы не могут долго держать заряд. Поэтому контроллер памяти должен «*перезаряжать*» конденсаторы, постоянно считывая и записывая в них соответствующие значения – это называется **регенерацией**. Если контроллер памяти не обновит значение `1`, конденсатор начнет терять электроны и значение в нем превратится в `0` или будет повреждено. Так организована работа динамической RAM (DRAM – dynamic RAM). Данные поступают на хранение в ячейки памяти, а затем постоянно динамически регенерируются, чтобы биты в них не исчезали. Операции регенерации осуществляется постоянно, что занимает определенное время, поэтому DRAM работает медленнее, чем статическая память.

> Когда мы имеем дело с работой памяти, мы используем время, измеряемое в наносекундах (нс), что является одной миллиардной долей секунды. Если вы посмотрите на микросхему RAM и увидите маркировку 70 нс, это означает, что чтение и регенерация каждой ячейки памяти занимает 70 наносекунд.

**Статическая RAM** (SRAM – static RAM) не требует постоянной регенерации, т.к. она использует другие технологии, с помощью которых хранит биты в ячейках памяти без использования конденсаторов, но SRAM требует большего количества транзисторов, чем DRAM. SRAM не нуждается в постоянной регенерации, поэтому она быстрее, чем DRAM, но поскольку SRAM требует больше транзисторов, она занимает больше места в микросхеме. Производители не могут разместить на микросхеме также много ячеек памяти SRAM, как DRAM, поэтому SRAM стоит дороже. Таким образом, DRAM дешевле и медленнее, а SRAM дороже и быстрее. SRAM обычно используется как кэш-память, а DRAM – как основная оперативная память.

**Память только для чтения** (ROM – read only memory) – это тип энергонезависимой памяти, в которой данные остаются в микросхемах памяти даже после выключения электропитания. Записанные в микросхемы ROM данные уже не могут быть изменены. Некоторые микросхемы ROM производятся с уже записанным программным обеспечением или подпрограммами. Программное обеспечение, которое хранится в ROM называется прошивкой.

**Программируемая ROM** (PROM – Programmable ROM) – это разновидность ROM, информация в которой может изменяться после ее изготовления, но только один раз, поскольку напряжение, которое используется для записи битов в ячейки памяти, фактически выжигает предохранители, которые соединяют отдельные ячейки памяти. Для прошивки PROM используются специальные программаторы.

**Стираемая и программируемая ROM** (**EPROM** – Erasable and programmable ROM) может быть очищена, изменена и обновлена. Данные в EPROM могут быть стерты с помощью ультрафиолетового света и перезаписаны электрическим способом. Для стирания микросхемы EPROM, ее нужно извлечь из компьютера и направить в имеющееся на ней специальное окно из кварцевого стекла ультрафиолетовый луч определенной мощности, который сотрет абсолютно все содержимое микросхемы. Чтобы не усложнять себе жизнь необходимостью использования ультрафиолета, изобрели другой вид ROM, данные на которой стираются электрическим способом без применения ультрафиолетовых лучей. Это **электрически стираемая и программируемая ROM** (**EEPROM** – Electrically erasable programmable ROM).

**Флеш-память** (flash memory) – это специальный тип памяти, который в наше время используется в цифровых камерах, микросхемах BIOS, накопителях для ноутбуков, игровых консолях и т.д. Флеш-память изготавливается по твердотельной (solid-state) технологии, т.е. она не имеет движущихся частей, и используется больше как разновидность жестких дисков, чем как память. Флэш-память работает на основе различных уровней напряжения, указывающих какое значение (1 или 0) хранится по определенному адресу. Ее работа больше похожа на работу ROM, чем RAM, она энергонезависима, также как ROM. Когда флэш-память должна быть стерта и возвращена в исходное состояние, программа активирует ее внутренние механизмы, которые выполняют стирание информации с помощью электрического поля. Удаление информации производится в рамках отдельных блоков или в рамках всей микросхемы, а не по одному байту за раз.

**Кэш-память**

Кэш-память ( cache memory) – это тип памяти, который используется для высокоскоростных операций чтения-записи. Когда система (ее программная логика) предполагает, что ей часто будет требоваться доступ к определенной информации, она организует хранение этой информации в кэш-памяти, чтобы она была быстро и легко доступна.

Данные из кэша можно получить гораздо быстрее, чем данные, хранящиеся в оперативной памяти. Поэтому любая информация, необходимая процессору очень быстро и очень часто, обычно хранится в кэш-памяти, тем самым повышая общую скорость работы компьютерной системы.

**Утечки памяти**

Когда приложение запрашивает сегмент памяти, операционная система выделяет ему соответствующий объем памяти. Когда приложение заканчивает работу с этим сегментом памяти, оно говорит операционной системе, что нужно освободить эту память, чтобы она стала доступна другим приложениям. Это правильно. Однако некоторые плохо написанные приложения не сообщают системе, что ранее выделенная для них память им больше не требуется. Когда это происходит большое число раз, у операционной системы начинает заканчиваться свободная память, что крайне негативно влияет на производительность системы.

Когда утечку памяти обнаруживают хакеры, это позволяет им провести DoS-атаку. Например, когда было обнаружено, что Unix-реализация отдельных версий протокола Telnet, содержит утечку памяти, хакеры воспользовались этой проблемой, усилив ее воздействие. Они постоянно посылали запросы системам с этой уязвимостью. Системы выделяли ресурсы для каждого из этих запросов и не освобождали ее. Это вело к все большему и большему расходу памяти. В конечном итоге системе не хватало памяти и она зависала

Существует две контрмеры против утечек памяти: **лучше разрабатывать код программ**, чтобы он должным образом освобождал память, либо использовать «**сборщики мусора**» (garbage collector), которые находят неиспользуемую память и сообщают системе, что ее можно считать свободной. Различные виды сборщиков мусора работают с различными операционными системами, языками программирования и алгоритмами.

**Виртуальная память**

Вторичным хранилищем (secondary storage) являются энергонезависимые носители информации, такие как жесткие диски, дискеты, компакт-диски и т.п. Когда RAM и вторичное хранилище используются совместно, вместе они образуют виртуальную память. Система использует пространство на жестком диске, чтобы увеличить объем своей оперативной памяти. Пространство файла подкачки – это зарезервированное пространство на жестком диске, которое используется для расширения оперативной памяти. Например, Windows-системы используют файл pagefile.sys для резервирования места на жестком диске. Когда система заполняет все пространство своей энергозависимой оперативной памяти, она записывает часть данных из памяти на жесткий диск. Когда программа запрашивает доступ к этим данным, они переносятся с жесткого диска обратно в память частями, называемыми «страницами» (pages). Этот процесс называется «подкачкой» (paging) виртуальной памяти.

Следует иметь в виду, что данные, выгруженные из памяти в файл подкачки на жестком диске, после выключения компьютера или завершения работы процессов, использовавших пространство файла подкачки, физически с жесткого диска не удаляются, просто указатели на соответствующие страницы памяти помечаются как свободные. Эти данные могут быть перехвачены и скомпрометированы. В очень безопасных операционных системах есть специальные процедуры для безопасной очистки пространства файла подкачки после завершения процесса и перед повторным использованием этого пространства.

### 1.3 Режимы процессора

Для обеспечения стабильности операционная система должна быть способна защитить себя от пользователей и их приложений. Для этого операционная система должна иметь возможность отличать свои операции от операций, выполняемых пользователями или приложениями, она должна отслеживать все действия приложений и убеждаться, что ни одно из них не нарушает политику безопасности системы. Это может быть очень сложной задачей, поскольку работа пользовательских приложений часто очень похожа на работу программного обеспечения операционной системы.

Операционная система имеет несколько защитных механизмов для исключения негативного влияния процессов друг на друга и на критичные компоненты самой операционной системы. Одним из таких механизмов является защита памяти, описанная ранее. Другим механизмом
являются кольца защиты (protection rings). Эти кольца защиты предоставляют жесткие рамки, определяющие, что процессы могут делать и к чему иметь доступ в рамках каждого кольца. Процессы, которые работают в рамках внутреннего кольца, имеют больше привилегий, чем процессы, работающие на внешних кольцах. С внутренним кольцом разрешается взаимодействовать только наиболее надежным компонентам и процессам. Хотя в различных операционных системах число используемых ими колец защиты может различаться, основной принцип остается неизменным – процессы, работающие на внутреннем кольце, работают в защищенном режиме процессора, а процессы на внешних кольцах – в реальном режиме

Компоненты операционной системы работают на внутреннем кольце, что дает им полный доступ к ячейкам памяти, периферийным устройствам, системным драйверам, критичным параметрам конфигурации. Поскольку это кольцо предоставляет наиболее опасный доступ к важнейшим ресурсам, оно является самым защищенным. Приложения обычно работают на кольце 3, на котором ограничен доступ к памяти, периферийным устройствам и драйверам, на этом кольце осуществляется управление доступом посредством системных вызовов и с помощью служб операционной системы.

![[Pasted image 20241028134414.png]]

Кольца защиты обеспечивают доступность, целостность и конфиденциальность необходимые многозадачной операционной системе. Наиболее часто используется архитектура с 4-мя кольцами защиты:
- **Кольцо 0**: Ядро операционной системы
- **Кольцо 1**: Остальные части операционной системы
- **Кольцо 2**: Драйверы и утилиты ввода/вывода
- **Кольцо 3**: Приложения и действия пользователей

Эти кольца защиты реализуют промежуточный слой между субъектами и объектами и используются для управления доступом при попытках субъектов получить доступ к объектам. Кольцо определяет уровень доступа к критичным ресурсам системы. Чем меньше номер кольца, тем большее привилегий у процесса, который работает в рамках этого кольца. Каждому субъекту и объекту логически присвоено число (от 0 до 3), соответствующее уровню доверия операционной системы к нему. Субъекты могут получить доступ только к объектам в рамках того же кольца, на котором находятся они сами, либо в рамках внешнего по отношению к ним кольца, но они не могут напрямую взаимодействовать с объектами на внутренних по отношению к ним кольцах. Так, например, субъекты на кольце 3 могут получить прямой доступ только к объектам на том же кольце 3, а субъекты на кольце 1 могут получить прямой доступ к объектам на кольцах 1, 2 и 3. Если приложению требуется доступ к компонентам на других кольцах, к которым ему не разрешен прямой доступ, оно отправляет соответствующий запрос операционной системе для выполнения необходимых задач. Для этого используются системные вызовы, позволяющие приложению выполнить команды, недоступные в реальном режиме. Запрос передается системным службам операционной системы, которые работают на более привилегированном уровне и могут выполнять более критичные функции.

> Когда операционная система выполняет команды процессов, находящихся на кольцах 0 и 1, она работает в защищенном режиме. Когда операционная система выполняет команды приложений и процессов на кольце 3, она работает в реальном режиме. Реальный режим предоставляет гораздо более ограниченную среду для работы приложения, что, в свою очередь, защищает систему от неправильного поведения программ.

### 1.4. Архитектура операционной системы

Операционная система может быть разработана с использованием различных типов архитектуры. Архитектура – это платформа, которая определяет размещение и взаимодействие служб и функций операционной системы.

**Монолитная архитектуру операционной системы** (monolithic operating system architecture) - Операционная система состоит в основном из различных процедур, бессистемно вызывающих друг друга. Системы этого типа имеют только один уровень безопасности, модули кода в них могут вызывать друг друга по мере необходимости. Взаимодействие между модулями не структурировано и не управляется как в многоуровневой архитектуре, скрытие данных не предусмотрено. Примером монолитной операционной системы является MS-DOS.

**Многоуровневая архитектура операционной системы** (layered operating system architecture) разделяет функциональность системы на иерархические уровни. Процессы на различных уровнях имеют интерфейсы для использования процессами, находящимися на уровень выше или ниже них. Это отличается от монолитной архитектуры, в которой каждый модуль может взаимодействовать с любым другим модулем. Многоуровневые операционные системы обеспечивают скрытие данных, не позволяющее командам и данным (упакованным в виде процедур) на одном уровне получить прямой доступ к командам и данным на любых других уровнях. Каждая процедура на каждом уровне имеет доступ только к своим данным и набору функций, которые ей необходимы для выполнения своих задач.

> Монолитная операционная система имеет только один уровень безопасности. В многоуровневой системе каждый уровень должен обеспечивать свою собственную безопасность и управление доступом.

Разделение программного обеспечения и его кода на модули повышает уровень предоставляемых системой гарантий, т.к. компрометация одного модуля не означает появления уязвимости для всех остальных модулей. Примерами многоуровневых систем являются `THE`, `VAX/VMS`, `Multics`, `Unix` (хотя THE и Multics больше не используются).

Другим подходом к проектированию системы является **клиент/серверная архитектура** (client/server architecture), в которой те части программного обеспечения и функции, которые ранее размещались в монолитном ядре, теперь находятся на более высоких уровнях операционной системы. Функции операционной системы делятся на несколько различных процессов, которые выполняются в реальном, а не в защищенном режиме.

Цель клиент/серверной архитектуры заключается в том, чтобы как можно больше кода вынести из ядра, работающего в защищенном режиме, оставив только компактное ядро, называемое микроядром. В этой модели процессы, осуществляющие запросы, называются клиентами, а процессы, выполняющие эти запросы, серверами (например, сервер файловой системы, сервер памяти, сервер ввода/вывода, сервер процессов). Эти серверы обычно называют подсистемами. Клиентом может быть пользовательский процесс или другая операционная система.

**Разделение на уровни и скрытие данных**

Хотя теоретически существует три основных типа архитектуры операционных систем, термины разделение на уровни (layering) и скрытие данных (data hiding) часто используют, когда речь идет о механизмах защиты операционных систем, в т.ч. в отношении операционных систем с клиент/серверной архитектурой, поскольку они также используют технологии разделения на уровни и скрытия данных для собственной защиты. Многоуровневая архитектура операционной системы в основном учитывает распределение функциональности и ее доступность пользователям и программам. Это обеспечивает иерархию функциональности, тогда как архитектура клиент/сервер предоставляет функциональность в более линейном виде. В клиент/серверной архитектуре запросу не нужно проходить через различные уровни, он просто направляется необходимой подсистеме. Но с точки зрения безопасности, обе архитектуры используют уровни и скрытие данных для защиты критичных процессов операционной системы от приложений, в сами приложения от других приложений.

> Причиной, из-за которой операционная система Windows (а также Unix и Linux) была разработана для использования монолитного ядра, является производительность. Ведь когда одни компоненты ядра работают в реальном режиме, а другие в защищенном, выполнение команд занимает у процессора гораздо больше времени, поскольку ему нужно постоянно переключаться между защищенным и реальным режимами.

Таким образом, большинство современных наиболее распространенных операционных систем в основном используют кольца 0 и 3 архитектуры колец защиты. Все ядро и драйверы устройств выполняются на кольце 0, а все пользовательские приложения – на кольце 3. Поскольку драйверы работают в защищенном режиме, крайне важно, чтобы они были правильно написаны и не могли быть использованы злоумышленниками каким-либо образом.

### 1.5 Управление устройствами ввода/вывода

Операционная система также должна управлять всеми устройствами ввода/вывода. Она посылает им команды, разрешает прерывания от них, когда им нужно взаимодействовать с процессором, а также обеспечивает интерфейс между устройствами и приложениями.

Устройства ввода/вывода обычно делят на *блочные* и *символьные*. Блочные устройства работают с блоками данных фиксированного размера. Каждый блок имеет собственный уникальный адрес (пример – любой дисковый накопитель). Символьные устройства (например, принтер, сетевая карта или мышь) работают с потоками символов неопределенного размера. Эти данные не адресуются.

Когда пользователь дает команду распечатать документ, открыть сохраненный файл в текстовом редакторе или сохранить файлы на переносном диске, такая команда идет от приложения (с которым работает пользователь) к запрошенному устройству через операционную систему. Операционная система использует драйвер соответствующего устройства для взаимодействия с его контроллером, который может представлять собой плату расширения, установленную в специальный слот на материнской плате. Контроллер имеет собственное программное обеспечение, позволяющее обмениваться данными между устройством и операционной системой. Операционная система отправляет команды в соответствующие регистры контроллера, а контроллер выполняет необходимые действия по чтению и записи данных. Если команда требует извлечь данные с жесткого диска, контроллер считывает необходимые биты данных с жесткого диска, помещает их в блок необходимого размера, выполняет контрольные функции для проверки целостности считанных данных. Если проверка целостности не выявила нарушений, данные помещаются в память для передачи процессору.

**Прерывания**

Когда устройство ввода/вывода завершает задачу, оно должно проинформировать процессор, что необходимые данные уже в памяти и доступны для обработки. Для этого контроллер устройства отсылает по шине специальный сигнал ( прерывание), который отслеживается контроллером прерываний. Если процессор занят, а прерывание устройства не имеет более высокого приоритета, чем уже выполняющаяся работа, то устройство ожидает, когда процессор освободится. Контроллер прерываний отправляет сообщение процессору, говоря ему, что устройство требует внимания. Операционная система имеет таблицу (называемую вектором прерывания) всех подключенных устройств ввода/вывода. Процессор сравнивает полученный номер со значениями в векторе прерывания и, таким образом, он узнает, какое именно устройство требует его внимания. Таблица содержит адреса памяти различных устройств ввода/вывода. Когда процессор выясняет, что внимания требует, к примеру, жесткий диск, он ищет в этой таблице соответствующий адрес памяти. Это новое значение счетчика команд, которое является начальным адресом, откуда процессор должен начинать чтение.

## 2. Архитектура системы

> Архитектура безопасности – это один из компонентов архитектуры продукта в целом, она предоставляет правила, используемые при проектировании продукта. Архитектура безопасности должна описывать требуемый уровень гарантий и потенциальные воздействия различных этапов разработки продукта на его безопасность. Поскольку проект разработки программного обеспечения переходит от архитектуры к проектированию, затем к техническим требованиям, а затем к разработке кода, архитектура безопасности и требования безопасности становятся более детальными на каждом шаге.

Если система удовлетворяет определенным критериям, считается, что она обеспечивает определенный уровень доверия и будет реагировать предсказуемо в различных ситуациях.

 **Доверенная компьютерная база** (TCB – Trusted Computing Base) -  определяется как сочетание всех защитных механизмов в рамках компьютерной системы. TCB включает в себя аппаратное и программное обеспечение, а также прошивки (firmware), поскольку все эти компоненты реализуют политику безопасности и не должны нарушать ее.

Если операционная система использует **TCB**, это означает, что она имеет защищенное ядро, отделяющее системные процессы. Ядро состоит из аппаратного обеспечения, программного обеспечения и прошивок – оно, по сути, и является **TCB**. Но в рамки **TCB** могут быть включены и другие компоненты, такие как доверенные команды, программы, конфигурационные файлы, напрямую взаимодействующие с ядром.

**Доверенный канал** (trusted path) – это коммуникационный канал взаимодействия между пользователями (или программами) и ядром. ТСВ обеспечивает защиту ресурсов, гарантируя невозможность компрометации этого канала. **Доверенная оболочка** (trusted shell)
гарантирует, что работающий в ней пользователь не сможет выйти за ее пределы, и никто другой (никакой другой процесс) не попадет внутрь нее.

Ранние операционные системы (например, MS-DOS, Windows 3.11, Novell Netware версии 3 и т.п.) не имели TCB. Windows 95 имел TCB, но он мог использоваться только при работе в 32-битном режиме. Windows NT был первой версией Windows, в которой реально была реализована идея TCB. Microsoft часто использует слова «Доверенные вычисления» ( Trustworthy Computing), но это концепция не принадлежит Microsoft. Многие производители разрабатывают все лучшие и лучшие TCB, создавая новые и совершенствуя существующие методы защиты программного обеспечения от компрометации. Просто Microsoft является первым производителем, внедрившим эти методы в свои продукты Windows 2003. В основном Microsoft строит свои продукты на основе текущей TCB, которую она назвала «Безопасной компьютерной базой нового поколения» (NGSCB – Next-Generation Secure Computing Base). Microsoft переименовала свое ядро безопасности, назвав его «nexus».

Каждая операционная система имеет ряд компонентов, компрометация которых может подвергнуть систему серьезной опасности. TCB предоставляет дополнительные уровни защиты вокруг таких компонентов, чтобы гарантировать невозможность их компрометации и обеспечить постоянную работу системы безопасным и предсказуемым образом.

Процессы в рамках TCB являются компонентами, защищающими
систему в целом. Поэтому разработчики операционной системы должны позаботиться, чтобы эти процессы имели собственный **домен выполнения**. Это означает, что они размещаются на кольце 0, их команды выполняются в защищенном режиме, а менее доверенные процессы не могут напрямую взаимодействовать с ними. Разработчики должны обеспечить поддержку операционной системой изолированного домена выполнения, чтобы эти процессы не могли быть скомпрометированы или взломаны. Ресурсы, используемые процессами TCB, должны быть также изолированы, для чего должно быть реализовано строгое управление доступом и все запросы на доступ и операции с ресурсами должны надлежащим образом контролироваться.

Четырьмя основными функциями ТСВ являются: **активация процессов**, **переключение доменов выполнения**, **защита памяти** и **операции ввода/вывода**.

**Активация процесса** относится к деятельности, выполняющейся в тот момент, когда процессу нужно передать на обработку процессору свои команды и данные.

Процессор заполняет свои регистры информацией запрашивающего
процесса (счетчик команд, базовый адрес и адрес границы области памяти, реальный или защищенный режим и т.д.). Процесс «активирован», когда вызвано его прерывание, позволяющее ему взаимодействовать с процессором. Процесс «деактивирован», когда его команды полностью выполнены процессором или когда другой процесс с более высоким приоритетом обратился к процессору. После деактивации процесса, регистры процессора должны быть заполнены новой информацией, относящейся к новому запрашивающему процессу. Данные, которые загружаются в регистры процессора и выгружаются из них, имеют критическое значение, поэтому компоненты TCB должны гарантировать их безопасность.

**Переключение домена выполнения** производится, когда процессу нужно вызвать другой, более доверенный, процесс, находящийся на более низком кольце защиты.

Доверенные процессы работают в реальном режиме и не могут выполнять
действия, такие как взаимодействие с аппаратными устройствами или прямая отправка запросов ядру. Процесс, работающий в реальном режиме (кольцо 3) должен делать запрос к службе операционной системы, которая работает на кольце 1. Информация менее доверенного процесса будет загружена в регистры процессора, и затем, когда процессор увидит, что была вызвана служба операционной системы, он переключит домены и контекст безопасности. Соответственно, информация процесса службы операционной системы будет загружена в регистры процессора, и процессор начнет выполнять ее команды в защищенном режиме. Таким образом, переключение домена выполнения – это, по сути, переключение процессора из выполнения команд в реальном режиме в защищенный режим и обратно. Все это должно происходить надлежащим образом, иначе менее доверенный процесс сможет выполняться в защищенном режиме и иметь прямой доступ к системным ресурсам.

**Защита памяти и операции ввода/вывода** - достигается путем разделения этой деятельности на отдельные модули, фактически являющиеся процессами, из которых состоит ядро. При этом даже компрометация одного из процессов ядра не означает, что атакующий получит контроль над всеми процессами.

### 2.1. Периметр безопасности

**Периметр безопасности** (security perimeter) – это границы, которые отделяют доверенное от недоверенного. Чтобы система оставалась в безопасном и доверенном состоянии, должны быть разработаны четкие стандарты взаимодействия, гарантирующие, что любое взаимодействие компонента TCB с компонентом вне TCB не может привести к неожиданному нарушению безопасности системы. Такое взаимодействие производится и управляется посредством интерфейсов.

### 2.2. Монитор обращений и ядро безопасности

**Монитор обращений** (reference monitor) – это абстрактная машина, являющаяся посредником, через которого проходят все обращения субъектов к объектам. Монитор обращений проверяет, что субъекты имеют необходимые права доступа, защищая объекты от несанкционированного доступа и изменения. Чтобы система достигла высокого уровня доверия, необходимо, чтобы субъекты (программы, пользователи и процессы) были полностью авторизованы перед их доступом к объектам (файлам, программам и ресурсам).
Субъекту не должно быть позволено использовать запрошенный ресурс, пока ему не будут предоставлены соответствующие привилегии доступа. Монитор обращений – это концепция управления доступом, а не реальный физический компонент

**Ядро безопасности** (security kernel) состоит из компонентов аппаратного обеспечения, программного обеспечения и прошивок, попадающих в рамки ТСВ и реализующих концепцию монитора обращений. Ядро безопасности осуществляет посредничество при доступе и работе субъектов с объектами. Ядро безопасности – это ядро ТСВ, это наиболее часто используемый подход к построению доверенных компьютерных систем (trusted computing system). Есть три основных требования к ядру безопасности:
- Оно должно обеспечивать изоляцию для процессов, реализующих концепцию монитора обращений, и процессов, которые должны быть защищены от внешних воздействий.
- Оно должно вызываться при каждой попытке доступа, не должно существовать возможностей обойти его.
- Оно должно быть полностью и всесторонне протестировано и проверено.

### 2.3. Политика безопасности

**Политика безопасности** – это набор правил и практик, диктующих порядок управления критичной информацией и ресурсами, их защиты и распространения. Политика безопасности точно определяет целевой уровень безопасности и указывает, какие механизмы безопасности предполагается реализовать для его достижения. Это важный элемент, который играет ключевую роль при определении структуры системы. Политика безопасности – это основа для технических требований к системе, она предоставляет базис для оценки системы.

Система обеспечивает доверие, выполняя и реализуя политику безопасности, контролируя взаимодействие между субъектами и объектами. Политика должна указывать, какие субъекты могут иметь доступ к определенным объектам, какие действия являются приемлемыми, а какие – нет. Политика безопасности дает основу для архитектуры безопасности системы.

> доверие к системе определяется тем, как она реализует свою собственную политику безопасности

### 2.4. Принцип наименьших привилегий

После обеспечения надлежащей изоляции процессов и ресурсов, необходимо внедрить принцип наименьших привилегий ( least privilege). Он означает, что процессы должны иметь не больше привилегий, чем им необходимо для выполнения своих функций. Только процессам, которым необходимо выполнять критичные системные функции, должен быть разрешен доступ к критичным системным ресурсам, а другим, менее привилегированным процессам, при необходимости выполнения таких действий следует обращаться к более привилегированным процессам. Такой вид непрямого взаимодействия защищает систему от плохо написанного и неправильно работающего кода. Процессы должны владеть повышенным уровнем привилегий только в течение того времени, пока действительно существует такая необходимость.

## 3. Модели безопасности

Важной концепцией в проектировании и анализе безопасных систем является модель безопасности, поскольку она включает в себя политику безопасности, которая должна быть реализована в системе. Модель – это символическое представление политики. Она преобразует желания создателей политики в набор правил, которым должна следовать компьютерная система.

Модель безопасности преобразует абстрактные цели политики в термины информационных систем, точно описывая структуры данных и средства (методы), необходимые для реализации политики безопасности. Модель безопасности обычно представляется в виде математических и аналитических идей, которые затем преобразуются в технические требования к системе, а затем разрабатывается программистами в коде программы. Таким образом, мы имеем политику, реализующую цели безопасности, типа «каждый субъект должен быть авторизован для доступа к каждому объекту». Модель безопасности берет эти требования и предоставляет необходимые математические формулы, взаимоотношения и структуру, которым необходимо следовать для достижения целей безопасности. Исходя из этого, разработаны технические требования для каждого типа операционной системы (Unix, Windows, Macintosh и т.д.), и отдельные производители могут решать, как им реализовывать механизмы, которые будут соблюдать эти технические требования.

> Политика безопасности описывает цели без конкретизации того, как они должны быть достигнуты. Модель – это платформа, которая придает политике форму и решает проблемы безопасного доступа к информации в конкретных ситуациях. Многие модели безопасности разработаны для реализации политик безопасности.

Обобщенная информация по моделям. Для упрощения понимания всех этих моделей, ниже приведены их ключевые концепции.
- **Модель Bell-LaPadula**. Это модель конфиденциальности, описывающая допустимые информационные потоки и формализующая военную политику безопасности. Это первая математическая модель многоуровневой политики безопасности, которая определяет концепцию безопасного состояния и необходимые режимы доступа.
	• Простое правило безопасности. Субъект не может читать данные более высокого уровня безопасности, чем его допуск («не читать сверху»);
	• Правило -свойства. Субъект не может записывать данные в объект меньшего уровня безопасности, чем его допуск («не записывать вниз»);
	• Строгое правило -свойства. Субъект может выполнять функции чтения-записи только в отношении объекта, находящегося на том же уровне безопасности.
- **Модель Biba**. Эта модель защищает целостность информации в рамках системы и происходящих в ней действий. Она учитывает первую цель целостности.
	• Простая аксиома целостности. Субъект не может читать данные с более низкого уровня целостности («не читать снизу»).
	• Аксиома -целостности. Субъект не может изменять объект на более высоком уровне целостности («не записывать вверх»).
- **Модель Clark-Wilson**. Это модель целостности, реализованная для защиты целостности данных и обеспечения того, чтобы выполнялись только корректные транзакции. Она учитывает все три цели целостности.
	• Субъекты могут получить доступ к объектам только посредством авторизованных программ (тройка доступа).
	• Реализация разделения обязанностей.
	• Требуется ведение аудита.
	• Модель матрицы контроля доступа. Это модель, которая принимает решения о предоставлении доступа на основе ACL объектов и таблиц разрешений субъектов.
- **Модель информационных потоков**. Это модель, в которой информация ограничена в своих потоках и может передаваться между сущностями только способами, которые не могут нарушить политику безопасности.
- **Модель невлияния**. Эта модель гласит, что команды и действия, выполняющиеся на одном уровне безопасности, не могут быть замечены и не могут оказать влияние на субъекты или объекты на другом уровне безопасности.
- **Модель Brewer and Nash**. Эта модель позволяет динамически изменять права доступа для защиты от конфликта интересов. Также известна как модель «Китайская стена».
- **Модель Graham-Denning**. Эта модель показывает, как следует создавать и удалять субъекты и объекты. Она также учитывает, как назначать отдельные права доступа.

## 4. Режимы безопасности функционирования

Система может работать в различных режимах в зависимости от критичности обрабатываемых данных, уровня допуска пользователей и того, на выполнение каких действий пользователи авторизованы. Режим функционирования описывает условия безопасности, в которых система реально функционирует.

**Специальный режим безопасности**. Все пользователи должны иметь:
	• Надлежащий допуск ко всей информации в системе
	• Формальное разрешение на доступ ко всей информации в системе
	• Подписанное NDA для всей информации в системе
	• Правильные категории "должен знать" для всей информации в системе
	• Все пользователи имеют доступ ко всем данным
**Режим повышенной безопасности системы**. Все пользователи должны иметь:
	• Надлежащий допуск ко всей информации в системе
	• Формальное разрешение на доступ ко всей информации в системе
	• Подписанное NDA для всей информации в системе
	• Правильные категории "должен знать" для некоторой информации в системе
	• Пользователи могут получить доступ к некоторым данным на основе своих категорий "должен знать"
**Раздельный режим безопасности**. Все пользователи должны иметь:
	• Надлежащий допуск к наивысшему классу информации, среди содержащихся в системе
	• Формальное разрешение доступа ко всей информации в системе, которую они будут использовать
	• Подписанное NDA для всей информации в системе, которую они будут использовать
	• Правильные категории "должен знать" для некоторой информации в системе
	• Все пользователи имеют доступ к некоторым данным на основе их категорий "должен знать" и формальных разрешений доступа
**Многоуровневый режим безопасности**. Все пользователи должны иметь:
	• Надлежащий допуск к необходимому ему классу информации
	• Формальное разрешение доступа ко всей информации в системе, которую они будут использовать
	• Подписанное NDA для всей информации в системе, которую они будут использовать
	• Правильные категории "должен знать" для некоторой информации в системе
	• Все пользователи могут использовать некоторые данные на основе своих категорий "должен знать", уровней допуска и формальных разрешений доступа

## 5. Сертификация vs. Аккредитация

**Сертификация** – это всесторонняя техническая оценка компонентов безопасности и их соответствия цели аккредитации. Процесс сертификации может использовать оценку мер безопасности, анализ рисков, проверку, тестирование и методы аудита для оценки пригодности конкретной системы.

> Цель процесса сертификации – гарантировать, что сеть, продукт или система подходят задачам покупателя.

**Аккредитация** – это формальное принятие руководством адекватности безопасности системы в целом и ее функциональности.






























































