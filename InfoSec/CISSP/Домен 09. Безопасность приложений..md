
Первоочередной целью разработки приложений и компьютерных систем является, как правило, реализация функциональности, а не обеспечение безопасности. Чтобы получить лучшее от обоих направлений, безопасность должна проектироваться и разрабатываться одновременно с функциональностью. Безопасность должна быть интегрирована в ядро продукта, она должна обеспечиваться на всех уровнях. В противном случае, когда безопасность реализуют для уже разработанного продукта, защитные меры снижают функциональность, а безопасность обеспечивается не в полном объеме, оставляя существенные уязвимости.

## 1. Где нужно размещать безопасность?

Сегодня проблемы безопасности чаще всего рашаются с помощью таких защитных средств, как межсетевые экраны, системы выявления вторжений (IDS), контентная фильтрация, антивирусное программное обеспечение, сканеры уязвимостей и многого другого. Мы опираемся на все это множество защитных средств в основном потому, что используемое нами программное обеспечение содержит множество уязвимостей. Это приводит к тому, что внешний периметр безопасности является целостным и укрепленным, однако внутренняя среда и программное обеспечение содержат большое количество уязвимостей, которые несложно использовать при получении доступа во внутреннюю сеть.

В действительности, первопричиной большинства уязвимостей являются недостатки самого программного обеспечения. Ниже приведены несколько основных причин, поясняющих, почему сейчас чаще используются средства защиты периметра, а не обеспечение безопасности при разработке программного обеспечения:
- В прошлом, при разработке программного обеспечения не уделялось внимания вопросам безопасности, поскольку не было такой потребности. Из-за этого и сейчас многие программисты не задумываются о вопросах безопасности и не используют методы безопасного программирования
- Большинство специалистов по безопасности не являются разработчиками программного обеспечения
- Многие разработчики программного обеспечения, не уделяют достаточного внимания вопросам безопасности
- Производители программного обеспечения стараются как можно быстрее вывести свои продукты на рынок, говоря в первую очередь об их функциональности, но не о безопасности
- Компьютерное сообщество привыкло получать программное обеспечение с ошибками, а затем применять патчи
- Покупатели программного обеспечения не могут контролировать недостатки в нем, поэтому они вынуждены обеспечивать защиту периметра

## 2. Среда и приложения

Программные средства безопасности могут быть реализованы в операционной системе, приложении или в системе управления базами данных (СУБД). Как правило, средства безопасности реализуются на всех указанных уровнях и используются совместно, дополняя друг друга. Каждый уровень имеет свои сильные и слабые стороны, но если все они хорошо изучены, правильно настроены и работают согласованно, можно избежать многих сценариев и разновидностей нарушения безопасности. Однако во многих случаях полагаются только на средства безопасности, реализованные в операционной системе. Такой подход имеет существенный минус, поскольку операционная система может эффективно контролировать, управлять и ограничивать доступ субъекта только к объектам в рамках самой операционной системы, но она далеко не всегда может делать это в приложениях. Если в программном коде приложения существуют недостатки в обеспечении безопасности, на уровне операционной системы крайне сложно будет реализовать эффективную защиту от компрометации приложения посредством этой уязвимости. Операционная система – это среда для работы приложений, не следует ожидать от нее учета всех нюансов работы различных приложений и реализованных в них механизмов.

Сейчас безопасность обеспечивается в основном за счет специализированных программных и аппаратных продуктов безопасности, а также устройств защиты периметра сети, но не за счет средств безопасности, встроенных в приложения. Указанные продукты безопасности могут охватывать широкий спектр приложений, они могут иметь централизованную консоль управления. Однако такой подход не всегда обеспечивает необходимый уровень детализации, он не учитывает возможности нарушения безопасности, вызванные недостатками в используемых разработчиком процедурах разработки программного обеспечения. Межсетевые экраны и механизмы контроля доступа могут обеспечить определенный уровень защиты, не позволяя атакующим произвести атаку переполнения буфера, но реальная защита должна обеспечиваться на уровне основного источника проблем – недостатков программного кода самого приложения. Для этого разработчиками должны быть внедрены безопасные процедуры разработки программного обеспечения.

## 3. Безопасность и функциональность

Программист должен учитывать множетсво возможных источников проблем, которые могут оказать негативное влияние на безопасность. Такими испочниками проблем может быть сам код приложения, взаимодействие процедур, использование глобальных и локальных переменных, входящие данные, полученные от других программ, исходящие данные, отправляемые в другие приложения. Нужно попытаться предсказать возможные ошибки при вводе данных пользователями, ошибки в расчетах, установить соответствующие механизмы контроля и ограничения. Во многих случаях, попытки предусмотреть все «что-если» и проявление осторожности при программировании, могут привести к снижению общей функциональности приложения. А ограничение функциональности может, в свою очередь, ограничить сферу применения приложения и привести к снижению доли рынка и прибыли производителя. Чтобы избежать этого, всегда следует соблюдать определеный баланс между функциональностью и безопасностью. Однако следует учитывать, что для разработчиков программного обеспечения (и большинства их клиентов) пока наиболее важной является функциональность.

В большинстве приложений осуществляется обмен данными между различными частями программы, обмен данными с другими программами, с операционной системой, принимаются введенные пользователями данные. Каждый из маршрутов передачи (ввода) данных должен быть учтен, нужно проанализировать и протестировать каждый возможный сценарий взаимодействия, каждый вариант ввода данных. Только такой подход сможет обеспечить реально высокое качество приложения. Важно, чтобы была обеспечена возможность тестирования каждого модуля в отдельности, а также различных модулей при их взаимодействии между собой. Столь глубокий анализ и тестирование позволят сделать продукт более безопасным, заранее выявив недостатки, которые могут быть использованы злоумышленниками в дальнейшем.

## 4. Типы, форматы и размер данных

Мы рассматривали переполнение буфера в Домене 03 и говорили, что такая атака может быть осуществлена в случае, если программный код не проверяет фактическую длину принимаемых входных данных. Специально подготовленные атакующим данные, в действительности содержащие команды, могут переполнить выделенный для них буфер, что позволит этим командам выполниться в привилегированном режиме и даст атакующему возможность получить контроль над системой. Если программист пишет программу, которая ожидает входящие данные, объемом не более 5KB, он должен правильно реализовать это в коде, выделив для хранения данных буфер необходимого объема и предусмотрев функцию проверки объема реально полученных данных. Даже если атакующий передаст этой программе более 5КВ данных, программа должна автоматически отбросить лишние данные. Иначе атакующий может отправить 5KB данных и прибавить к ним еще 50KB кода, содержащего вредоносные команды, которые будут обработаны процессором.

Длина – это не единственное, о чем должны беспокоиться программисты, когда они разрабатывают компоненты программы, принимающие входные данные. Данные должны иметь правильный тип и находиться в нужном формате. Если программа ожидает получение символов ASCII, она не должна принимать шестнадцатеричные значения или Unicode.

Помимо этого, принимаемое значение должно быть корректным. Если программа запрашивает у пользователя ввод суммы, которую он хочет перевести со своего расчетного счета, она не должна позволять ввести в это поле текстовую строку. Принимаемые программой данные, должны быть в правильном формате, программист должен реализовать процедуры, которые будут контролировать вводимые пользователем данные, чтобы предотвратить очевидные ошибки, а не начинать проведение расчетов с заведомо некорректными данными.

## 5. Сбои и ошибки в приложениях

Многие обстоятельства непредсказуемы, поэтому очень трудно спланировать действия для реакции на них. Однако действия на случай подобных непредсказуемых ситуаций могут быть запланированы в общем виде, а не детально, для каждой ситуации в отдельности. Если в приложении возникает сбой по какой-либо причине, оно должно вернуться обратно в безопасное состояние. Для этого, например, может потребоваться перезагрузка операционной системы, после которой пользователь снова зарегистрируется в системе. Именно поэтому некоторые операционные системы в таких случаях отображают «синий экран» и / или автоматически перезагружаются. Когда в такой системе происходит что-то, что может перевести ее в неустойчивое или небезопасное состояние, система делает дамп содержимого оперативной памяти и выполняет полную перезагрузку.

## 6. Управление базами данных

Базы данных давно используются для хранения информации, представляющей ценность для компаний, в том числе являющейся интеллектуальной собственностью. Базы данных обычно работают в среде, скрытой ото всех, кроме сетевых администраторов и администраторов баз данных. Чем меньше людей знают о базах данных, тем лучше. Пользователи обычно работают с базами данных не напрямую, а через клиентский интерфейс, их действия ограничены в целях обеспечения конфиденциальности, целостности и доступности данных, хранящихся в базе данных, а также структуры самой базы данных.

Риски возрастают, если компания подключает свою сеть к Интернет, разрешает удаленным пользователям доступ во внутреннюю сеть, предоставляет все больше прав доступа внешним субъектам. Эти действия несут большой риск, поскольку они могут стать косвенной причиной получения злоумышленником доступа к серверу базы данных, находящемуся во внутренней сети компании. Раньше информация клиентов компании хранилась в базах данных, к которым имели доступ только сотрудники компании, а не сами клиенты. В наше время многие компании позволяют клиентам получать доступ к хранящейся в базах данных информации, через веб-браузер. Веб-браузер устанавливает соединение с промежуточным программным обеспечением (*middleware*) компании, которое соединяется с сервером базы данных. Это повышает сложность системы, а доступ к базам данных организуется новым способом.

Одним из таких примеров являются системы интернет-банкинга. Многие банки хотят идти в ногу со временем и предоставлять новые услуги, которые, по их мнению, будут востребованы у клиентов. Но интернет-банкинг – это не просто еще одна банковская услуга. Внутренняя среда большинства банков является закрытой (или полузакрытой), и организация доступа в нее из сети Интернет является очень сложной задачей. Нужно предусмотреть надежную защиту периметра сети, разработать (или закупить) промежуточное программное обеспечение (шину), настроить доступ к базе данных через межсетевой экран (а лучше – через два межсетевых экрана). Доступ к данным при этом обычно организуется с помощью компонентов шины, которые по запросам клиентов обращаются к базе данных для извлечения / записи в нее нужных данных.

Такой доступ к базе данных может быть ограничен администратором с помощью средств контроля доступа и предоставляться только нескольким разрешенным ролям. При этом каждой роли будут даны определенные права и разрешения, а затем эти роли будут назначены клиентам и сотрудникам. Пользователь, которому не назначена ни одна из таких ролей, не имеет доступа к базе данных. Таким образом, если злоумышленник сможет преодолеть защиту межсетевого экрана и других механизмов защиты периметра сети, и получит возможность выполнять запросы к базе данных, то при условии, что у него не будет учетной записи, которой назначена одна из таких ролей, база данных все еще будет находиться в безопасности. Этот процесс упрощает управление доступом и гарантирует, что ни один пользователь (в т.ч. злоумышленник) не сможет получить доступ к базе данных напрямую, а только с помощью учентной записи, которой назначена соответствующая роль.

![[Pasted image 20241126110132.png]]


### 6.1. Программное обеспечение для управления базами данных

База данных – это набор данных, хранящихся организованным способом, позволяющим множеству пользователей и приложений обращаться к данным, просматривать и изменять их по мере необходимости. Управление базами данных осуществляется специальным программным обеспечением, которое реализует соответствующую функциональность. Это программное обеспечение также реализует возможности для управления доступом, установки ограничений, обеспечивает целостность и избыточность данных, позволяет использовать различные процедуры для управления данными. Это программное обеспечение называется системой управления базами данных (СУБД), как правило, его администрированием занимается администратор баз данных. Базы данных не только хранят данные, они также могут обрабатывать их и представлять в более удобном и логичном виде. СУБД реализует интерфейс для взаимодействия приложений и пользователей с данными, хранящимися в базе данных. СУБД помогает эффективно и рационально организовывать хранение, извлекать и записывать информацию в базу данных.

База данных предоставляет структуру для хранения собранных данных. Сама эта структура может отличаться для каждой реальной базы данных, поскольку различные компании и приложения работают с различными данными, типами данных, им необходимо выполнять различные действия с информацией. Различные приложения используют различные способы обработки данных, в различных базах данных устанавливаются различные отношения между данными, базы данных могут работать на различных платформах, к ним могут предъявляться различные эксплуатационные требования, а также требования по обеспечению безопасности.

Однако любая база данных должна иметь следующие характеристики:
- Обеспечивать централизацию, позволяя не организовывать хранение данные на нескольких различных серверах по всей сети
- Позволять упростить процедуры резервного копирования
- Обеспечивать транзакционную устойчивость (transaction persistence)
- Позволять организовать работу более упорядоченно, поскольку все данные хранятся и сопровождаются в одном централизованном месте
- Обеспечивать отказоустойчивость и возможности для восстановления
- Позволять множеству пользователей совместно использовать данные
- Предоставлять механизмы безопасности, которые осуществляют контроль целостности, управление доступом, обеспечивают необходимый уровень конфиденциальности

### 6.2. Модели баз данных

Модель базы данных определяет отношения между различными элементами данных, указывает, каким образом может осуществляться доступ к данным, определяет допустимые операции, предлагаемый тип целостности, а также определяет, каким образом будут организованы данные. Модель дает формальный способ представления данных в концептуальной форме и предоставляет необходимые средства для работы с данными, хранящимися в базе данных. Базы данных могут быть реализованы на основе следующих моделей:
- Реляционная
- Иерархическая
- Сетевая
- Объектно-ориентированная
- Объектно-реляционная

**Реляционная модель базы данных** (relational database model) для хранения и организации информации использует **атрибуты** (**столбцы**) и **записи** (**строки**) Реляционная модель базы данных в настоящее время является наиболее широко используемой моделью. Реляционная база данных состоит из двумерных таблиц, каждая таблица содержит уникальные строки, столбцы и ячейки (пересечение строки и столбца). Каждая ячейка содержит только одно значение данных, представляющее собой конкретное значение атрибута соответствующей записи. Элементы данных связаны отношениями. Отношения между элементами данных предоставляют основу для организации данных. **Первичный ключ** (primary key) – это поле, которое содержит уникальное значение, не повторяющееся в других записях, и позволяющее связать все данные в рамках одной записи в одно уникальное значение. Например, в таблице на, первичными ключами являются продукты `G345` и `G978`. Когда приложение или другая запись ссылается на этот первичный ключ, в действительности она ссылается на все данные в рамках этой строки.

![[Pasted image 20241126110752.png]]

**Иерархическая модель базы данных** (hierarchial data model) объединяет связанные записи и поля в логическую древовидную структуру. Эта структура и взаимосвязи между элементами данных, отличаются от тех, которые используются в реляционной базе данных. В иерархической базе данных родительские элементы могут иметь дочерние элементы (один, несколько или ни одного). Древовидная структура имеет ветви, каждая ветвь имеет множество листьев – полей данных. В таких базах данных есть хорошо известные, заранее определенные пути доступа к данным, но они не настолько гибки при создании отношений между элементами данных, по сравнению с реляционными базами данных. Иерархические базы данных целесообразно использовать для хранения данных, имеющих отношения «*один-ко-многим*».

![[Pasted image 20241126110910.png]]

Иерархическая структура базы данных была одной из первых разработанных моделей, но она не получила такого распространения, как реляционные базы данных. Чтобы получить доступ к элементу данных в иерархической базе данных, необходимо знать с какой ветви начинать и по какому маршруту проходить через каждый уровень, пока не будет достигнут уровень, на котором хранятся нужные данные. В таких базах данных процедуры поиска не используют индексы, в отличие от реляционных баз данных. Кроме того, ссылки (отношения) не могут быть созданы между различными ветвями и листьями на разных уровнях. 

Наиболее часто используемой реализацией иерархической модели является модель `LDAP`. Также, иерархическая модель используется в структуре системного реестра Windows и различных файловых системах, но в новых реализациях баз данных она обычно не используется.

**Сетевая модель базы данных** (network database model) построена на основе иерархической модели данных. Чтобы обойти ограничения иерархической модели, требующие для получения элемента данных знать маршрут перехода с одной ветви в другую, а затем от родительского элемента к дочернему, в сетевой модели каждому элементу данных разрешается иметь несколько родительских и дочерних записей. Это создает избыточную, похожую на сеть структуру, а не жесткую древовидную структуру.

**Объектно-ориентированная база данных** (object-oriented database) предназначена для работы с различными типами данными (изображения, аудио, документы, видео). Система управления объектно-ориентированными базами данных (ODBMS - object-oriented database management system) более динамична по своей природе, чем реляционная СУБД, поскольку она создает объекты при необходимости, а данные и процедуры (называемые методами) при запросе объекта предоставляются вместе с ним. При работе с реляционной базой данных, приложение должно использовать свои собственные процедуры для получения данных из базы данных и их обработки. Реляционная база данных не предоставляет процедур, как это делает объектно-ориентированная база данных. Объектно-ориентированная база данных использует классы для определения атрибутов и процедур ее объектов.

![[Pasted image 20241126111202.png]]

> Жаргон баз данных. Ниже приведены некоторые ключевые понятия, используемые при работе с базами данных:
> - Запись (Record) – набор связанных элементов данных
> - Файл (File) – набор однотипных записей
> - База данных (Database) – набор данных, связанных с перекрестными ссылками (crossreferenced)
> - СУБД (DBMS) – система управления и работы с базой данных
> - Запись (Tuple) – строка в двумерной базе данных
> - Атрибут (Attribute) – столбец в двумерной базе данных
> - Первичный ключ (Primary key) – столбец, который делает каждую строку уникальной (каждая строка таблицы должна содержать первичный ключ)
> - Представление (View) – виртуальное представление информации, определенное администратором для ограничения просмотра субъектами определенных данных
> - Внешний ключ (Foreign key) – атрибут одной таблицы, связаный с первичным ключом другой таблицы
> - Ячейка (Cell) – пересечение строки и столбца
> - Схема (Schema) – определяет структуру базы данных
> - Словарь данных (Data dictionary) – центральное хранилище (репозиторий) элементов данных и их взаимосвязей

### 6.4. Компоненты реляционной базы данных

Как и любое программное обеспечение, базы данных разрабатываются с помощью языков программирования. Большинство языков программирования баз данных включает язык описания данных (DDL – data definition language), который определяет схему; язык манипулирования данными (DML – data manipulation language), который анализирует данные и определяет, как эти данные могут обрабатываться в базе данных; язык управления данными (DCL – data control language), который определяет внутреннюю организацию базы данных; специальный язык запросов (QL – query language), который определяет запросы, позволяющие пользователям получить доступ к данным в базе данных.

Каждая модель базы данных может иметь множество других отличий, обусловленных, в том числе, разными подходами различных производителей. Однако большинство из них включает следующую базовую функциональность:
- **Язык описания данных** (`DDL`) определяет структуру и схему базы данных. Структуру может определять размер таблицы, размещение ключа, представления, отношения элементов данных. Схема описывает тип данных, которые будут храниться и обрабатываться, а также их свойства. `DDL` определяет структуру базы данных, операции доступа и процедуры целостности.
- **Язык манипулирования данными** (`DML`) содержит все команды, позволяющие пользователю просматривать, управлять и использовать базу данных (команды `view`,  `add`, `modify`, `sort`, `delete`).
- **Язык запросов** (`QL`) дает пользователям возможность делать запросы в базу данных.
- **Генератор отчетов** готовит печатные формы с данными определенным пользователем образом.

**Словарь данных** (data dictionary) является централизованным набором определений элементов данных, объеков схемы, а также ключей ссылок (reference keys). Объекты схемы могут содержать таблицы, представления, индексы, процедуры, функции и триггеры. Словарь данных может содержать значения по умолчанию для столбцов, информацию целостности, имена пользователей, привилегии и роли пользователей, информацию аудита. Это инструмент, используемый для централизованного управления частями базы данных посредством управления данными о данных (именуемыми метаданными) в базе данных. Он обеспечивает перекрестные ссылки между группами элементов данных и базами данных. Программное обеспечение, управляющее базой данных, создает и читает словарь данных, чтобы выяснить, какие существуют объекты схемы, а также проверить, имеют ли конкретные пользователи права доступа, необходимые для их просмотра. При просмотре пользователями базы данных, они могут быть ограничены определенными представлениями. Различные параметры представлений для каждого пользователя хранятся в словаре данных. При добавлении новых таблиц, новых строк, или новой схемы, словарь данных обновляется – в него вносятся соответствующие изменения.

![[Pasted image 20241126112231.png]]

**Первичный ключ** (primary key) – это идентификатор строки, он используется для индексации в реляционных базах данных. Каждая строка должна иметь уникальный первичный ключ, который должен представлять строку, как единое целое. Когда пользователь делает запрос на просмотр записи, база данных находит нужную запись по ее уникальному первичному ключу. Если первичный ключ не был бы уникальным, база данных не знала бы, какие записи нужно предоставить пользователю.

Первичный ключ отличается от внешнего ключа, хотя они тесно связаны между собой. Если атрибут в одной таблице, имеет значение, соответствующее первичному ключу в другой таблице, и между этими двумя таблицами установлены отношения, этот атрибут называется **внешним ключом** (foreign key). Этот внешний ключ не обязательно является первичным ключом в своей таблице. Просто он должен содержать ту же информацию, которая содержится в первичном ключе другой таблицы, и быть связанным с первичным ключом в этой другой таблице.

![[Pasted image 20241126112427.png]]

### 6.5. Целостность

Как и другие сетевые ресурсы, базы данных могут столкнуться с проблемами **конкуренции**. Проблемы конкуренции возникают, когда определенные ресурсы или данные должны быть доступны одновременно нескольким пользователям и/или приложениям.

Рассмотрим следующий пример. Две группы пользователей используют один и тот же файл, содержащий таблицу товаров с ценами, чтобы знать, какой объем поставок нужен на следующей неделе, а также рассчитать ожидаемую прибыль. Если Дэн и Элизабет копируют этой файл с файлового сервера, на свои рабочие станции, у каждого из них есть копия оригинального файла. Предположим, что Дэн измененил объем складского запаса книг о компьютерах от 120 до 5, поскольку их компания продала 115 книг в течение последних трех дней. Затем он на основе текущих цен, указанных в файле, рассчитывает ожидаемую прибыль на следующую неделю. Элизабет снижает цены на ряд программных пакетов в своей копии файла и видит, что объем складских запасов книг о компьютерах еще более 100 единиц, поэтому она решает не заказывать их на следующую неделю. Дэн и Элизабет не сообщают эту информацию друг другу, а просто загружают свои копии исправленного файла на сервер для общего просмотра и использования. Сначала Дэн копирует свои изменения на файл-сервер, а затем, через 30 секунд после Дэна, Элизабет копирует свои изменения. Как вы понимаете, теперь на файловом сервере хранится файл, в котором указаны только изменения, произведенные Элизабет, т.к. она записала свой файл поверх файла Дэна. Они не синхронизировали свои изменения и оба воспользовались неверными данными. Расчеты прибыли Дэна неверны, т.к. он не знал, что Элизабет снизила цены на следующую неделю, а у Элизабет не будет компьютерных книг, потому что она не знала, что их остаток упал до пяти единиц.

То же самое происходит и в базах данных. Если в ней не реализован соответствующий контроль, два пользователя могут одновременно использовать и изменять одни и те же данные, что может иметь пагубные последствия для динамичной среды. Чтобы исключить проблемы конкуренции, процессы могут **блокировать** таблицы в базе данных, вносить изменения, а затем снимать программную блокировку. При этом когда следующий процесс будет обращаться к таблице, он получит обновленную информацию. Применение блокировки гарантирует, что два процесса не получат одновременный доступ к одной и той же таблице, а обновления будут выполняться по одному за раз. Блокировка может быть выполнена для отдельных страниц, таблиц, строк и полей, что обеспечит возможность предоставления каждому процессу и пользователю правильной и точной информации.

Программное обеспечение базы данных реализует три основных типа механизмов обеспечения целостности: **семантический**, **ссылочный** и **логический**. Механизм **семантической целостности** (semantic integrity) обеспечивает реализацию структурных и семантических правил. Эти правила относятся к типам данных, логическим значениям, требованиям уникальности, а также операциям, которые могут оказать негативное воздействие на структуру базы данных. Данные в базе данных должны изменяться таким образом, чтобы не нарушалась установленная между ними смысловая (семантическая) связь. В базе данных обеспечивается **ссылочная целостность** (referential integrity), если все внешние ключи ссылаются на существующие первичные ключи. Должен быть реализован механизм, который обеспечивает отсутствие внешних ключей, содержих ссылку на первичный ключ несуществующей записи или на пустое значение. **Логическая целостность** (entity integrity) гарантирует, что записи уникально идентифицируются по значениям первичного ключа. В рассмотренном ранее примере первичными ключами являются клички собак. Для обеспечения логической целостности, в базе данных не должно существовать двух собак с одинаковыми кличками. Каждая запись должна содержать один первичный ключ, т.к. если запись не имеет первичного ключа, на нее не может ссылаться база данных.

База данных не должна содержать **несогласованных значений** внешних ключей, т.е. не должна иметь внешних ключей, ссылающихся на несуществующие первичные ключи.

Существуют и другие настраиваемые операции, обеспечивающие защиту целостности данных в базе данных. Такими операциями являются функции отката, фиксации, точек сохранения, а также контрольных точек.

**Откат** (*rollback*) – это операция, которая прерывает текущую транзакцию и отменяет все произведенные в рамках этой транзакции изменения в базе данных. Эти изменения могут касаться самих данных или схемы. При выполнении операции отката, отмененяются все изменения и база данных возвращается в свое предыдущее состояние (точку сохранения). Откат может потребоваться в случае, если в базе данных произошел неожиданный сбой или внешний субъект нарушил последовательность обработки. Вместо того чтобы передавать и сохранять частичную или поврежденную информацию, база данных просто возвращается в исходное состояние, а в журнал регистрации событий записывается сообщение об ошибке и выполненных действиях, чтобы они могли быть проанализированы позднее.

Операция **фиксации** (*commit*) завершает транзакцию и применяет все изменения, сделанные пользователем, т.е. эта операция реально записывает все изменения в базу данных. Эти изменения могут относиться к данным или к схеме. После фиксации этих изменений, обновленные данные будут доступны для всех других приложений и пользователей. Если пользователь попытается выполнить операцию фиксации изменений, но эта операция не сможет завершиться правильно, выполняется откат. Это гарантирует отсутствие в базе данных частичных изменений и поврежденных данных.

**Точки сохранения** (*savepoints*) используются для того, чтобы обеспечить восстановление целостности базы данных в случае сбоев и ошибок. При возникновении сбоя или ошибки, база данных пытается вернуться к точке (состоянию), в которой она находилась непосредственно перед возникновением этого сбоя или ошибки.

> Чтобы понять основной принцип, рассмотрим следующий пример. Дэйв ввел текст «В 2010 году компанией получена прибыль в размере 1 млн.руб. Планы <точка сохранения> по прибыли выполнены на 115%». Сразу после этого произошел сбой электропитания, который привел к перезагрузке системы. Когда Дэйв снова запустил клиентское приложение базы данных, он увидел следующий текст: «В 2010 году компанией получена прибыль в размере 1 млн.руб. Планы », но дальше текст был потерян. Таким образом, точка сохранения обеспечила сохранность некоторой части его работы. Базы данных и другие приложения используют эту технологию, чтобы попытаться восстановить работу пользователей и состояние базы данных после сбоя, однако иногда происходят крупные сбои, которые невозможно исправить с помощью этой технологии.

Реализовать точки сохранения в базе данных или другом приложении легко, однако необходимо обеспечить баланс между слишком большим и слишком малым количеством точек сохранения. Использование слишком большого их количества может ухудшить производительность, тогда как недостаточное количество повышает риск потери данных и тем самым снижает продуктивность работы пользователей, т.к. потерянные данные им придется вводить заново. Точки сохранения могут создаваться через определенные промежутки времени, определенными действиями пользователя, либо при достижении определенного числа транзакций или изменений, внесенных в базу данных. Например, база данных может быть настроена на создание точки сохранения каждые 15 минут, после ввода каждых 20 операций, а также каждый раз, когда пользователь доходит до последней записи.

Точки сохранения позволяют восстанавить данные, давая пользователю возможность вернуться назад во времени до момента, когда система вышла из строя или произошла ошибка. Это может уменьшить количество проблем и помогает нам работать более эффективно.

Механизм **двухэтапной фиксации** (two-phase commit) – это еще одна защитная мера, которая применяется для обеспечения целостности данных в базе данных. Базы данных обычно работают в транзакционном режиме, что означает взаимодействие пользователя и базы данных в режиме реального времени. Противоположностью является режим пакетной обработки, при котором запросы на изменение базы данных ставятся в очередь и активируются все сразу, но не в тот же момент времени, когда пользователь делает каждый запрос. При выполнении транзакций, часто возникает потребность в обновлении более чем одной базы данных в рамках транзакции. Программное обеспечение должно убедиться, что в каждой базе данных выполнены необходимые изменения, либо не произошло никаких изменений ни в одной из баз данных. После подтверждения пользователем необходимости изменения базы данных, базы данных сначала выполняют временное сохранение этих изменений. Затем монитор транзакций отправляет команду «**предфиксации**» (pre-commit) каждой базе данных. Если все базы данных ответили подтверждением, монитор посылает каждой базе данных команду «**фиксации**» (commit). Это обеспечивает корректное и своевременное сохранение всех необходимых данных.

### 6.6. Вопросы безопасности баз данных

Двумя основными вопросами безопасности баз данных, которые рассмотрены в этом разделе, являются **агрегирование** и **предположения**. **Агрегирование** (aggregation) может выполняться, когда пользователь не имеет допуска или разрешения на доступ к определенной информации, но у него есть разрешение на доступ к частям этой информации. Ознакомившись со всеми частями, к которым у него есть доступ, он может догадаться об остальной информации и получить, таким образом, сведения ограниченного доступа. Также он может получить информацию из различных источников и объединить ее, чтобы узнать что-то, к чему у него нет допуска. 

Для предотвращения агрегирования, нужно предотвратить возможность доступа субъекта (и любого приложения или процесса, действующего от имени субъекта) ко всему набору, состоящему из независимых компонентов. Для этого объекты могут быть помещены в контейнеры, которым присвоены более высокие уровни классификации, что позволит исключить доступ к ним субъектов с менее высоким уровнем допуска. Также можно отслеживать запросы субъекта и применять системы контекстно-зависимого управления доступом. Для этого нужно сохранять историю доступа субъекта и на основании нее динамически ограничивать попытки доступа, если обнаружены признаки проведения атаки агрегирования.

Другая проблема безопасности заключается в **предположениях** (inference), являющихся результатом агрегирования. Субъект догадывается (предполагает, делает выводы) о полной истории на основе отдельных ее частей, которые он узнал в процессе агрегирования. Это может проявиться, когда данные на более низком уровне безопасности, косвенно отражают данные более высокого уровня безопасности.

> Рассмотрим следующий пример. Доступ военнослужащего к сведениям о планах передвижения войск, базирующихся в определенной стране, был ограничен. Но он имел доступ к документам с требованиями по поставкам продовольствия и распределению палаток. На основании информации, к которой у него был доступ, он мог догадаться о перемещении войск в конкретное место, зная, что туда направлено продовольствие и палатки. В рассматриваемом примере, документы, касающиеся продовольствия и палаток были отнесены к категории «конфиденциально», а сведения о перемещении войск имели гриф «совершенно секретно». Таким образом, этот военнослужащий мог получить доступ к сверхсекретной информации, которую он не должен знать.

Предотвратить подобный косвенный доступ субъекта (либо любого приложения или процесса, действующего от имени субъекта) к информации, которая позволяет сделать подобные умозаключения, является крайне сложной задачей. Обычно эта проблема учитывается на этапе разработки базы данных с помощью реализации контентно- и контекстно-зависимых правил управления доступом. Контентно-зависимое управление доступом основано на критичности данных. Чем более критичны данные, тем меньше группа лиц, которые могут получить доступ к ним

**Представления базы данных**

База данных может позволить одной группе или конкретному пользователю видеть определенную информацию, тогда как другой группе доступ к этой информации будет полностью ограничен. Это реализуется с помощью **представлений базы данных** (*database view*)

Представления баз данных являются логическим видом управления доступом. Доступ к представлениям может предоставляться на основе членства в группе, прав пользователя или меток безопасности. Если используется дискреционное управление доступом, группы и пользователи получают доступ к представлениям по результатам их идентификации, аутентификации и авторизации. Если внедрена система мандатного управления доступом, группам и пользователям доступ предоставляется на основе их допуска и уровня классификации данных.

![[Pasted image 20241126144819.png]]

**Многоэкземплярность**

Иногда компании не хотят, чтобы пользователи, находящиеся на низком уровне безопасности, имели доступ и изменяли данные на более высоком уровне. Это может реализовываться различными способами. Одним из подходов является отказ в доступе, если пользователь на более низком уровне пытается получить доступ к данным на более высоком уровне. Однако такой подход может давать этому пользователю косвенную информацию о том, что на том уровне, к которому он попытался получить доступ, есть что-то важное.

Другим подходом для реализации такого ограничения является **многоэкземплярность** (polyinstantiation), которая позволяет хранить в таблице несколько экземпляров записи, имеющих одинаковый первичный ключ, при этом каждому экземпляру будет присвоен свой уровень безопасности. После вставки информации в базу данных, доступ субъектов с низкого уровня должен быть ограничен. Однако вместо того, чтобы просто ограничить доступ, создается другой набор данных, целью которого является обман субъектов с нижнего уровня, которые в случае подобного запроса получат специально подготовленную недостоверную информацию.

> Например, если военно-морская база осуществляет поставки оружия из штата Делавер на Украину на судне Оклахома, сведения об этом могут быть классифицированы как «совершенно секретные». Только субъекты, имеющие допуск к «совершенно секретной» информации и выше должны иметь возможность ознакомиться с этой информацией. Для организации ограничения, создаются поддельные записи базы данных, в которых указано, что судно Оклахома осуществляет перевозку из Делавера в Африку продуктов питания, и этой информации присвается класс «неклассифицировано». Поскольку судно Оклахома стоит у берега и на него грузят какие-то контейнеры, всем понятно что оно будет осуществлять некие перевозки, однако люди с более низким уровнем допуска будут думать, что оно поплывет с продуктами в Африку, а не с оружием на Украину. Это также исключит какие-либо домыслы людей с низким уровнем допуска в отношении миссии этого судна. Все будут знать, что судно Оклахома занято, и при планировании своих перевозок будут рассматривать другие суда.

![[Pasted image 20241126145223.png]]

> Пример многоэкземплярности, дающий полную, но недостоверную информацию субъектам с низким уровнем допуска

**Обработка транзакций в режиме реального времени**

**Обработка транзакций в режиме реального времени** (`OLTP` – online transaction processing) обычно используется при кластеризации баз данных для обеспечения отказоустойчивости и высокой производительности. `OLTP` предоставляет механизмы, которые отслеживают возникновение проблем и надлежащим образом решают их. Например, если в программном процессе происходит сбой, и он прекращает функционирование, механизмы мониторинга `OLTP` могут обнаружить это и попытаться перезапустить этот процесс. Если перезапустить процесс не удается, производится откат транзакции, для предотвращения повреждения данных или выполнения только части транзакции. Любая выявленная ошибочная или некорректная транзакция должна быть записана в журнал транзакций. В этом журнале также сохраняются сведения об успешно выполненных транзакциях. Информация записывается в журнал до и после выполнения транзакции, создавая таким образом отчет о событиях.

Основной целью использование `OLTP` является обеспечение того, что транзакция либо выполняется правильно, либо не выполняется совсем. Транзакция обычно является неделимым набором связанных операций. Если не выполнена хотя бы одна операция из этого набора, должен быть произведен откат всей транзакции, что гарантирует сохранение целостности и правильности информации в базе данных.

`OLTP` может, при необходимости, выполнять балансировку нагрузки и распределять входящие запросы по системам, входящим в кластер. Если число запросов к базе данных возрастет и приведет к снижению производительности одной из систем, `OLTP` может перенаправить некоторые из этих запросов на другие системы. Это гарантирует обработку всех запросов, при этом пользователям не нужно будет долго ждать завершения транзакции.

> При использовании нескольких экземпляров базы данных, важно обеспечить наличие в них одинаковой информации. Рассмотрим следующий пример: Кэти идет в банк и снимает со своего счета 65 000 руб. из имеющихся 100 000 руб. База данных `А` получает запрос на изменение данных и сохраняет новый остаток по ее счету, составляющий 35 000 руб., но база данных `Б` не обновляется. В ней по-прежнему остается информация об остатке на счете Кэти в размере 100 000 руб. На следующий день Кэти обращается в банк с просьбой предоставить ей информацию об остатке на ее счете, и этот запрос направляется в базу `Б`, содержащую некорректную информацию, поскольку транзакция не была перенесена в эту базу данных. Чтобы избежать подобной ситуации, `OLTP` гарантирует, что транзакция не будет завершена до тех пор, пока все базы данных не получат и не сохранят все необходимые изменения.

`OLTP` записывает транзакции по мере их осуществления (т.е. в режиме реального времени), а в распределенной среде транзакции обычно затрагивают несколько баз данных. Это ведет к сложностям, которые, в свою очередь, могут стать причиной нарушения целостности данных, поэтому программное обеспечение базы данных должно соответствовать требованиям ACID:
- **Атомарность** (`Atomicity`). Разделяет транзакции на единицы выполнения и обеспечивает, что никакая транзакция не будет зафиксирована в базе данных частично. Либо изменения фиксируются в полном объеме, либо производится откат базы данных к предыдущему состоянию.
- **Согласованность** (`Consistency`). Транзакция должна следовать политике целостности, разработанной в отношении этой конкретной базы данных, и обеспечивать, что все данные в различных базах данных согласованы друг с другом.
- **Изоляция** (`Isolation`). Транзакции выполняются изолированно до момента их завершения, без взаимодействия с другими транзакциями. Результаты выполняемых транзакцией изменений недоступны, пока она не будет полностью завершена.
- **Надежность** (`Durability`). Только после того, как точность сохранения транзакции проверена во всех системах, она фиксируется, после чего откат базы данных к предыдущему состоянию становится невозможен.

## 7. Разработка систем

Для реализации наиболее эффективной системы безопасности, она должна планироваться и управляется на протяжении всего жизненного цикла программного обеспечения, а не реализовываться с помощью сторонних средств, интегрированных во фронтальную часть системы после ее разработки. На протяжении своего жизненного цикла, продукт сталкивается со множеством различных рисков безопасности и инцидентов, поэтому вопросы безопасности должны учитываться с самого начала, с этапа планирования продукта, и на всех последующих этапах – проектирования, кодирования, внедрения и эксплуатации. Если безопасность была добавлена на завершающем этапе разработки продукта, а не учитывалась на каждом этапе его жизненного цикла, стоимость и время, необходимые для обеспечения безопасности такого продукта, резко возрастают. Безопасность не следует рассматривать как короткий спринт, это длинный марафон со множеством препятствий.

Многие разработчики, программисты и архитекторы знают, что добавление безопасности на поздних этапах реализации системы значительно дороже и сложнее, чем ее интеграция в систему, начиная с этапов планирования и проектирования. Различные компоненты безопасности при их реализации на поздних этапах реализации системы, могут оказать негативное воздействие на многие аспекты ее функционирования, ограничивая ряд уже разработанных функций и заставляя систему работать нестандартными и не предусмотренными способами. Такой подход обходится дороже, поскольку разработчикам нужно вернуться к проектированию, внести изменения в код программы, пересмотреть отдельные аспекты архитектуры системы.

### 7.1. Управление разработкой

План обеспечения безопасности должен быть составлен в начале проекта разработки и интегрирован в функциональный план. Это гарантирует, что безопасность не будет забыта. Первоначальный план носит общий характер, охватывает весь проект и ссылается на документы, содержащие более подробную информацию. Он может ссылаться на компьютерные стандарты (RFC, стандарты IEEE и лучшие практики), документы, разработанные в рамках предыдущих проектов, политики безопасности, планы реагирования на инциденты, национальные или международные руководящие документы (Оранжевая книга, Красная книга, Общие Критерии и т.п.). Это поможет обеспечить эффективность плана.

У плана обеспечения безопасности должен быть собственный жизненный цикл. Он должен дополняться, изменяться и детализироваться по мере выполнения проекта. Важно поддерживать его в актуальном состоянии, чтобы на него можно было ссылаться в будущих проектах. Эффективно контролировать работы и решения при реализации крупного и сложного проекта – непростая задача.

### 7.2. Этапы жизненного цикла

Для разработки программного обеспечения может использоваться несколько различных типов моделей, которые используют различные жизненные циклы. В основном, каждая модель выполняет одно и то же, главное различие между ними заключается в том, как именно разбиты на части разработка и эксплуатация системы.

Проект может начинаться просто с хорошей идеи, что потребует импровизации от программистов и инженеров, либо проект может быть изначально тщательно продуман и структурирован, чтобы следовать определенным жизненным циклам, а программисты и инженеры должны следовать этому плану. Первый вариант вначале может показаться более интересным, поскольку команда может пропустить скучные требования, забыть про документацию и произвести продукт в более короткие сроки и в рамках бюджета. Однако команда, которая потратит время на проработку всех сценариев каждого из этапов жизненного цикла, в итоге получит больше удовольствия, т.к. ее продукт будет более качественным, клиенты будут больше доверять ему, а команда заработает больше денег в долгосрочной перспективе, ей не нужно будет хаотично разрабатывать и поддерживать патчи, закрывающие дыры в системе безопасности, пропущенные изначально.

Различные модели, так или иначе, содержат следующие этапы:
- Инициирование проекта
- Функциональное проектирование и планирование
- Техническое задание на разработку системы
- Разработка программного обеспечения
- Установка / внедрение
- Эксплуатация / сопровождение
- Удаление

**Инициирование проекта**

На этом этапе все пытаются понять, зачем нужен проект и каковы его границы. Проект может быть направлен на реализацию конкретных потребностей конкретного клиента, либо на удовлетворение возникшего на рынке спроса на новый продукт. На этом этапе команда управления проектом анализирует необходимые характеристики и функциональность нового продукта, проводит мозговые штурмы и рассматривает возможные ограничения.

Должно быть разработано концептуальное определение проекта, что обеспечит правильное понимание проекта всеми участниками, и позволит разрабатывать продукт более эффективно и результативно. На этом этапе может проводиться оценка уже имеющихся на рынке продуктов, определение требований, которым имеющиеся продукты не удовлетворяют. Также это может быть прямой запрос от клиента на разработку конкретного продукта. В любом случае, предназначен ли разрабатываемый продукт для конкретного клиента или для всего рынка, должен быть проведен первоначальный анализ продукта, должно быть сформулировано первоначальное высокоуровневое заявление, в котором будут указаны необходимые для реализации этого проекта ресурсы, прогнозируемые сроки разработки. Также должна быть проведена оценка ожидаемой прибыли от продукта. Эта информация должна быть представлена высшему руководству, которое будет принимать решение, нужно ли переходить к следующему этапу или требуется дополнительная информация.

На этом этапе должны быть определены потребности пользователя и подтверждены основные цели безопасности продукта. Должно быть установлено, будет ли продукт обрабатывать критичные данные, и, если да, должны быть определены уровни критичности данных. Должен быть проведен первоначальный анализ рисков, в рамках которого будут оценены угрозы и уязвимости, оценка соотношения стоимости и преимуществ различных мер безопасности. Необходимо учесть вопросы, относящиеся к безопасности: вопросы целостности, конфиденциальности и доступности. Должны появиться очертания целевого уровня для каждого атрибута безопасности.

**Управление рисками**

Одним из наиболее важных аспектов управления рисками, является умение задавать правильные вопросы. Управление рисками должно продолжаться на этапах разработки и внедрения программного обеспечения.

В процессе разработки программного обеспечения, обычно все фокусируются на создании богатой функциональности и скорейшем выпуске продукта на рынок. Очень часто безопасность не учитывается должным образом или она быстро отходит на второй план, когда начинают «поджимать» сроки. Для обеспечения безопасности продукта недостаточно только того, чтобы программисты знали о методах безопасного программирования, безопасность должна пронизывать весь проект. Разработчики программного обеспечения должны учесть сценарии реализации угроз безопасности и предусмотреть соответствующие решения. Однако в действительности безопасность никогда не рассматривается, как один из важных компонентов процесса разработки. Разработчики не вспоминают про безопасность, пока продукт не купят, а покупатели не столкнуться с успешными атаками, основанными на уязвимостях, вызванных организацией процесса разработки продукта. Но будет уже слишком поздно, чтобы надлежащим образом интегрировать безопасность в проект. Вместо этого разработчики подготовят и выпустят патч.

Первыми шагами в управлении рисками является выявление угроз и уязвимостей, расчет уровня риска. После оценки всех рисков, руководство должно принять решение о приемлемом уровне риска. Конечно, было бы неплохо, чтобы руководство не принимало вообще никаких рисков, чтобы продукт был разработан максимально качественно и всестороне протестирован и защищен «от дурака», однако это слишком сильно увеличило бы сроки разработки продукта и значтельно повысило бы его стоимость. Необходимо пойти на определенные компромиссы и принять соответствующие решения, чтобы обеспечить баланс между рисками и экономической целесообразностью.

**Анализ рисков**

Анализ рисков проводится для выявления рисков, связанных с продуктом, и возможных последствий их реализации, с которыми клиент может столкнуться при использовании этого разрабатываемого продукта. Обычно в рамках процесса анализа рисков задается множество вопросов, составляется длинный список уязвимостей и угроз, с указанием вероятности эксплуатации этих уязвимостей и последствий реализации каждой из угроз. Для различных продуктов задаются разные вопросы, они зависят от таких факторов, как цель продукта, ожидания в отношении среды, в которой он будет функционировать, задействованного персонала, а также типа бизнеса компаний, которые будут приобретать и использовать этот продукт. Ниже приводится краткий список вопросов, которые должны быть заданы в процессе анализа рисков программного обеспечения:
-  Существует ли возможность переполнения буфера, как ее избежать и протестировать?
- Выполняет ли продукт надлежащую проверку формата / правильности всех данных, вводимых пользователем?
- Какие источники угроз существуют во внешней и внутренней среде? Что это за источники?
- Бизнес какого типа зависит от этого продукта, в бизнесе какого типа может возникнуть ущерб, если продукт не будет работать некоторое время?
- Существуют ли угрозы утечки информации через скрытые каналы, которые должны быть учтены?
- Отказоустойчивость какого типа должен обеспечивать продукт, и когда реализация этого будет инициирована?
- Необходимо ли шифрование? Какого типа? Какая требуется стойкость?
- Нужны ли планы действий на случай экстренных ситуаций?
- Будет другая сторона (например, интернет-провайдер или хостинг-провайдер) сопровождать этот продукт для клиента?
- Необходим ли мобильный код? Зачем? Как он может быть реализован?
- Будет ли этот продукт работать в среде, подключенной к сети Интернет? Какие последствия это может иметь для продукта?
- Нужно ли этому продукту взаимодействовать с уязвимыми системами?
- Уязвим ли этот продукт к DoS-атакам?
- Уязвим ли этот продукт для вирусов?
- Необходимы ли механизмы предупреждения о вторжениях?
- Будут ли у сотрудников клиента или внешних лиц мотивы саботировать этот продукт?
- Будут ли у компаний-конкурентов клиента мотивы совершить мошенничество с помощью этого продукта? Зачем? Как может быть реализовано такое мошенничество?
- Какие другие системы будут затронуты, если этот продукт выйдет из строя?

**Функциональное проектирование и планирование**

На этом этапе план проекта уже разработан, определена архитектура программного обеспечения и действия, необходимые для обеспечения безопасности и создания контрольных точек безопасности, гарантирующих качество реализованных защитных мер определены процессы управления конфигурацией и изменениями. К данному моменту определены ресурсы проекта, начато формирование графиков тестирования, разработаны критерии оценки, позволяющие надлежащим образом проверить реализованные защитные меры. Формально оформлены функциональные требования, т.е. ожидания от продукта изложены официально (как правило, описаны в соответствующих документах). Разработан план тестирования, который будет актуализироваться на каждом этапе, что обеспечит надлежащую проверку всех вопросов. Требования безопасности могут быть получены из нескольких различных источников:
- Функциональные требования к программному обеспечению
- Государственные, международные или локальные (на уровне компании) стандарты и руководящие принципы
- Экспортные ограничения
- Уровень критичности обрабатываемых данных (например, военные стратегические данные или данные обычной коммерческой компании)
- Соответствующая политика безопасности
- Анализ затрат и выгод
- Требуемый уровень защиты для достижения целевого рейтинга уровня гарантий (assurance level rating)

**Техническое задание на разработку системы**

Требования к программному обеспечению могут исходить из трех моделей:
- **Информационная модель**. Указывает, какой тип информации будет обрабатываться, и как она будет обрабатываться.
- **Функциональная модель**. Определяет задачи и функции, которые должно выполнять приложение.
- **Поведенческая модель**. Описывает состояния, в которых приложение будет находиться в процессе и после определенных переходов.

Например, информационная модель антивирусного программного обеспечения определяет, какую информацию должна обрабатывать антивирусная программа: вирусные сигнатуры, модифицированные системные файлы, контрольные суммы критичных файлов и действия вирусов. Функциональная модель антивирусного программного обеспечения определяет, что программа должна быть способна сканировать жесткий диск, проверять сообщения электронной почты на наличие известных вирусов, контролировать критичные системные файлы, обновлять вирусные сигнатуры и собственный программный код. Поведенческая модель определяет, что при старте системы, антивирусная программа должна провести быстрое сканирование критичных областей. При этом переход компьютера в рабочее состояние будет событием, которое изменяет состояние антивирусной программы. Выявление вируса также будет событием, которое изменит состояние антивирусной программы, и она приступит к уничтожению вируса. Каждое из таких состояний должно быть учтено, чтобы гарантировать, что продукт не перейдет в небезопасное состояние и будет функционировать предсказуемым образом.

Техническое задание – это инструмент, применяемый для описания требований пользователей и внутреннего поведения системы. Эти два элемента связываются друг с другом, чтобы показать, как внутреннее поведение реально выполняет требования пользователей.

Этот этап нужен для того, чтобы увидеть больше деталей о продукте и среде, в которую он будет внедрен. Требуемая функциональность была определена на предыдущем этапе. Данный этап учитывает механизмы, необходимые для реализации этой функциональности, и определяет, как будет разрабатываться код продукта, как он будет тестироваться и внедряться. Необходимо учитывать модульность и возможность повторного использования продукта, или компонентов продукта. Код, который реализует критичные с точки зрения безопасности функции, должен быть максимально простым (чтобы в нем было проще обнаружить ошибки) и достаточно небольшим (чтобы можно было провести его всестороннее тестирование в различных ситуациях). Компоненты могут вызыватья и использоваться различными частями продукта или другими приложениями. Возможность повторного использования компонентов продукта помогает оптимизировать продукт и обеспечить более эффективную и структурированную среду разработки.

Решения, принятые на данном этапе проектирования, являются ключевыми шагами для этапа разработки. **Проектирование** – это единственный способ перевода требований клиента в программные компоненты, поэтому проектирование программного обеспечения является основой и значительно влияет на качество получаемого в результате продукта и его поддержки. Если продукт изначально не был хорошо спроектирован, последующие этапы станут гораздо более сложными.

**Разработка программного обеспечения**

Это этап, на котором к работе приступают программисты и разработчики. Обычно они участвуют в работе и до этого момента, указывая направления и давая советы, но на данном этапе на них падает вся основная работа. На этом этапе программисты должны разрабатывать код, используя методы безопасного программирования, не допускающие возможности компрометации программного обеспечения. Также, программисты должны добавлять в программу код для проверки длины входящих данных, чтобы предотвратить переполнение буфера; проверять код программы на отсутствие скрытых каналов; проверять правильность использования типов данных; убедиться, что пользователи не смогут обойти контрольные точки; проверять синтаксис команд, а также рассчитывать значения контрольных сумм. Следует пройти по различным сценариям атак, чтобы увидеть, каким образом код может быть атакован или несанкционированно изменен. Проведение отладки и анализа кода должно выполняться одинаковыми по уровню профессионализма разработчиками, и все должно быть четко задокументировано.

Разумеется, любые программные перехватчики и закладки, вставленные программистами для тестирования или внесения изменений, должны быть удалены из приложения до того, как оно начнет использоваться в реальной работе, поскольку они могут легко могут стать той дверью, через которую в продукт проникнут злоумышленники.

Не существует универсального рецепта для тестирования безопасности, поскольку программные продукты очень сильно различаются по своей функциональности и задачам безопасности. Важно связать риски безопасности с кодом и тестовыми задачами. Выполняя этот процесс линейно, можно выявлять уязвимость, готовить специальный тестовый сценарий, проводить тестирование, а затем анализировать код на предмет того, насколько хорошо он готов противодействовать реализации этой уязвимости. На этом этапе, должно быть проведено тестирование в близкой реальной среде, которая должна отражать производственную среду, что позволит убедиться в том, что код работает не только в лаборатории.

На данном этапе обычно проводятся атаки, пытающиеся скомпрометировать безопасность продукта, тесты на проникновение. Они направлены на выявление любых пропущенных уязвимостей. Оценивается функциональность, производительность приложения, а также его сопротивляемость попыткам взлома. Все необходимая функциональность продукта должна быть внесена в чек-лист для того, чтобы гарантировать, что в процессе тестирования учтена каждая функция.

Тесты безопасности должны быть проведены в отношение уязвимостей, выявленных ранее в процессе реализации проекта. Должны быть проведены попытки переполнения буфера, проведения атак, взлома программного обеспечения. Должна быть проверена реакция всех интерфейсов на ввод неожиданных данных, воздействие на систему DoS-атак, необычной работы пользователей. Если в программе происходит сбой, она должна надлежащим образом обработать эту ситуацию и вернуться обратно в безопасное состояние. Продукт должен быть проверен в различных средах с различными приложениями, конфигурациями и аппаратными платформами.

**Установка и внедрение**

Этап внедрения фокусируется на функционировании и эксплуатации разработанного программного обеспечения. На этом этапе клиент приобретает разработанный продукт и устанавливает его в своей среде. Затем продукт должен быть настроен для обеспечения требуемого уровня защиты. После этого дожна быть протестирована функциональность и производительность приложения, его средства безопасности должны быть проанализированы и сопоставлены с требованиями, предъявляемыми компанией к безопасности.

Настройки должны быть документированы производителем, документация должна поставляться вместе с продуктом для использования клиентами. Должны быть разработаны руководства для пользователей, а также руководства по эксплуатации и сопровождению продукта. Изучив их, пользователи будут знать, как правильно работать с системой, а технический персонал будет знать, как правильно настроить продукт. Функционирование средств безопасности системы должно контролироваться, чтобы быть уверенным в работе системы в соответствии с тем, что обещано в соглашении об уровне обслуживания.

В период между внедрением и началом эксплуатации системы должна быть проведена ее аккредитация. Этот процесс следует за процессом сертификации, в рамках которого формально или неформально тестируются все функции безопасности, чтобы определить, удовлетворяют ли они требованиям безопасности, предъявляемым компанией. Сертификация представляет собой процесс анализа и оценки средств и функций безопасности. Как правило, эта задача ставится перед независимым внешним экспертом

Для новой системы должен быть настроен и включен аудит, должен проводиться мониторинг происхоящих в ней событий, должны быть разработаны планы и процедуры восстановления в случае чрезвычайных ситуаций. Указанные планы и процедуры должны быть протестированы, чтобы убедиться, что система в случае сбоя или чрезвычайной ситуации реагирует так, как это было запланировано.

**Эксплуатация и сопровождение**

Когда вы дошли до этого этапа, не думайте, что теперь работы по безопасности завершены и все под контролем. Напротив, на этапе эксплуатации безопасность является такой же или даже более важной задачей, по сравнению с предыдущими этапами. Начальная часть этого этапа включает в себя настройку новой системы и ее правильную интеграцию с сетью и средой. Часто оказывается, что средства безопасности не включены или неправильно (для конкретной среды) настроены. Даже если они были изначально хорошо разработаны, это может оказаться совершенно не важным, если они не используются в действительности или используются ненадлежащим образом. Операционные гарантии (operational assurance) обеспечиваются путем постоянного проведения тестирования на уязвимости, аудита и мониторинга событий. Именно благодаря деятельности по обеспечению операционных гарантий, администратор узнает о новых уязвимостях или компрометациях безопасности, и может предпринимать нужные действия. Если в системе или среде происходят существенные изменения, может потребоваться провести новый анализ рисков, а также новую сертификацию и аккредитацию. Такими изменениями может быть добавление новых систем и / или приложений, переезд в другое здание или изменение уровня критичности обрабатываемых данных.

**Удаление**

Если пришло время заменять старое программное обеспечение на новое, должны быть выполнены определенные шаги, обеспечивающие безопасность такого перехода. Для этого могут потребоваться различные мероприятия, зависящие от уровня критичности данных, содержащихся в системе. Может потребоваться создать архивную копию информации или резервную копию всей системы вместе с данными, перед тем уничтожить данные выводимой из эксплуатации системы. Если удаляемые данные являются критичными, они должны быть уничтожены специальными методами, такими как многократная перезапись, размагничивание или физическое уничтожение носителя информации. Выбор способа уничтожения критичных данных зависит уровня их критичности, а также от политики компании по уничтожению информации.

**Виды тестирования**

Если нам нужна уверенность в качестве нашего программного обеспечения, мы должны протестировать его. Существуют различные виды тестов, через которые должно пройти программное обеспечение, направленные на поиск различных недостатков, которые могут быть в программе. Ниже приведены некоторые из наиболее часто используемых подходов к тестированию:
- **Тестирование модулей** (Unit testing). Отдельные компоненты помещаются в контролируемую среду, в которой программисты проверяют структуры данных, логику и граничные условия.
- **Интеграционное тестирование** (Integration testing). Проверка того, как компоненты работают вместе, и насколько их совместная работа соответствует описанию в проектной документации.
- **Приемочное тестирование** (Acceptance testing). Проверяет соответствие кода требованиям заказчика.
- **Регрессионное тестирование** (Regression testing). После внесения изменений в систему, проводится повторное тестирование, направленное на то, чтобы убедиться в функциональности, производительности и защите измененной системы.

В процессе тестирования программного обеспечения, мы должны подумать не только о том, что внутри и снаружи этого ящика, мы должны бросить ящик на пол, попинать его, покидать его об стены. Очень трудно представить себе все способы, которыми пользователи потенциально могут нанести вред программному продукту. Не менее трудно представить себе все способы, которые будут использовать хакеры, пытаясь взломать это программное обеспечение. Перечисленные ниже пункты, это лишь некоторые из вещей, которые должны быть сделаны в процессе тестирования программного обеспечения:
- Должны быть введены данные различных типов
- Должны быть введены данные из разных точек в пределах диапазона допустимых данных
	- Произвести проверку границ, чтобы выявить возможности для переполнения буфера
	- Проконтролировать процедуры проверки данных, чтобы убедиться, что программное обеспечение принимает данные только тех типов, которые ему нужны (т.е. приложение не должно принимать буквы в строке ввода числовой информации и т.п.)
- Ввести данные, выходящие за пределы допустимого диапазона
- Проверить реакцию программы на различные действия пользователя
- Проверить данные до и после обработки, чтобы выявить неправильные изменения
- Проверить отсутствие возможности (уязвимости) повторного использования объекта
- Субъект может получить несанкционированный доступ к остаточным данным в объекте или области памяти

### 7.3. Методы разработки программного обеспечения

За многие годы были созданы различные Методы разработки программного обеспечения (`SDM` – System Development Methods), направленные на удовлетворение различных требований разработчиков и поставщиков.

### 7.4. Методология безопасной разработки

Для создания безопасных приложений, важное значение имеет применение методов безопасной разработки. Неправильный подход к разработке легко может поставить под угрозу весь проект.

Безопасная разработка обеспечивает управление требованиями к конечному продукту. Она постоянно акцентирует внимание на анализе разработанного кода на предмет недостатков и уязвимостей, а не откладывает этот анализ до момента завершения разработки программы. В самом деле, общепризнанным фактом является то, что большинство уязвимостей дешевле исправить на раннем этапе проектирования или разработки, а не после того, как программное обеспечение уже было внедрено у заказчика.

Важной стратегией для обеспечения безопасности процесса разработки является включение в процесс программирования регулярного проведения анализа кода. Анализ кода позволяет раньше выявлять уязвимости, архитектурные ошибки, а также возможности улучшения. Он включает в себя процедуры проверки кода, как обычными программистами, так и специалистами по безопасности. Важно, чтобы все рекомендации, данные в результате таких проверок, были задокументированы, независимо от того, были ли они фактически реализованы.

Использование автоматизированных инструментов анализа кода сокращает трудозатраты на анализ больших сегментов кода, однако важно понимать, что анализаторы кода могут только отметить недостатки кода, логические ошибки не могут быть обнаружены без непосредственного участия человека.

## 8. Безопасность веб-приложений

Многие ситуации и угрозы, связанные с сетью Интернет и веб-приложениями, являются уникальными. К примеру, в сети Интернет нередко нужно учитывать угрозы, связанные с возможным вандализмом. Риски мошенничества при использовании веб-приложений значительно выше, что вызвано их всеобщей доступностью. С помощью Интернета, мы можем предоставить свой продукт или услугу максимально возможной аудитории. Наученные горьким опытом, мы размещаем веб-серверы в DMZ, поэтому злоумышленники, получившие несанкционированный доступ к этим веб-серверам, не получат прямого доступа к ресурсам нашей внутренней сети. Но мы вынуждены разрешать доступ к веб-серверам через Интернет по портам, на которых работают наши веб-приложения (обычно `80` и `443`), чтобы пользователи могли их использовать. Для этого мы открываем указанные порты на межсетевом экране, а это позволяет проводить атаки на веб-сервера через эти порты.

## 9. Вредоносное программное обеспечение 

Существует несколько видов вредоносного кода (malicious code) или вредоносного программного обеспечения (malware), такого как вирусы, черви, троянские кони и логические бомбы. Как правило, они ведут себя тихо, пока не будут активированы событием, инициированным пользователем или системой. Они могут распространяться по электронной почте, через совместно используемые носители информации (сменные диски, флеш-накопители), при совместном использовании документов и програм, либо при загрузке файлов из сети Интернет. Кроме того, они могут быть умышленно установлены злоумышленником.

Для противодействия вирусам, на компьютере должно быть установлено антивирусное программное обеспечение, которое будет выявлять вирусы на основе известных сигнатур, а также программная система выявления вторжений на уровне узла, которая может контролировать действия работающего на компьютере программного обеспечения и выявлять подозрительное поведение (например, доступ к критичным файлам, внесение изменений в системный реестр и т.п.), что также поможет выявить вредоносный код.

Вредоносный код может быть обнаружен по следующим косвенным признакам:
- Увеличение размера файла
- Неожиданно большое количество обращений к диску
- Изменение штампа времени последнего изменения файла
- Резкое сокращение объема свободного пространства на жестком диске
- Неожиданные и странные действия приложений
- Резкое увеличение сетевой активности

**Вирусы**

**Вирус** (virus) представляет собой небольшую программу, заражающую другие программы. Одной из основных функций вируса является самовоспроизведение («размножение»), а это требует наличия приложения-носителя. Иными словами, вирусы не могут «размножаться» самостоятельно. Вирус заражает файлы, вставляя или добавляя свою копию в каждый файл определенного типа. Другой функцией вируса является собственно вредоносное действие, которым может быть нарушение работы компьютера пользователя (например, путем удаления системных файлов), отображения графических изображений, внесение изменений в настройки системы пользователя и т. п.

**Черви**

**Черви** (worm) отличаются от вирусов тем, что они могут воспроизводить себя самостоятельно, не используя для этого какое-либо приложение на зараженном компьютере, и являются автономными программами. Червь может распространять свои копии через электронную почту, через веб-сайты и т.д. В настоящее время определения червей и вирусов все больше сливаются, различия между ними становятся все более размытыми.

**Троянские программы**

**Троянская программа** (Trojan horse) – это программа, которая скрывается под другой программой. Например, троянская программа может называться `Notepad.exe` и иметь такую же иконку, как обычная программа «Блокнот». Однако при запуске поддельной `Notepad.exe`, эта программа может удалить системные файлы. Троянские программы выполняют полезные функции в дополнение к вредоносной функциональности, выполняющейся в фоновом режиме. Троянская программа, названная «`Notepad.exe`» может также запустить и обычную программу «Блокнот» для пользователя, однако в фоновом режиме она будет удалять файлы или выполнять иные вредоносные действия. Для противодействия троянским программам может использоваться система IDS уровня узла, которая может быть настроена для контроля определенных файлов и выявления фактов увеличения их размеров, что часто является признаком троянской программы. Если оригинальный файл Notepad.exe имеет размер `50KB` и вдруг его размер вырос до `2МВ`, это может означать, что эта программа заражена трояном.

**Логические бомбы**

**Логическая бомба** (logic bomb) запускает программу или строку кода, когда происходит определенное событие или наступает определенная дата и время. Например, логическая бомба может быть настроена на событие запуска пользователем программного обеспечения для доступа к своему банковскому счету. При этом логическая бомба запускает программу, которая выполняет копирование реквизитов доступа к счету пользователя. Другим событием, на которое может быть настроена логическая бомба, является подключение пользователя к сети Интернет. При наступлении этого события она может послать злоумышленнику сообщение через Интернет, говоря ему, что пользователь подключен к сети и может быть атакован.

**Ботсети**

Слово «бот» – это сокращение от слова «робот». Бот представляет собой фрагмент кода, который выполняет некоторую функциональность для своего хозяина, являющегося автором этого кода. Боты (bot) являются разновидностью вредоносных программ, они установлены на тысячах компьютеров. Компьютер, на котором установлен бот, называют зомби (zombie). Бот получает команды от своего хозяина и заставляет зараженный компьютер выполнять их. Такими командами может быть рассылка спама, вирусов или проведение атак. Злоумышленник предпочитает выполнять такие действия с использованием ботов, а не своего компьютера, поскольку это позволяет ему избежать обнаружения и идентификации.

Совокупность скомпрометированных злоумышленником зомби-компьютеров, на которых установлены боты, называется ботсетью (botnet). Для создания ботсети хакеры взламывают тысячи систем, рассылая вредоносный код множеством различных методов: в виде вложений в сообщения электронной почты, через скомпрометированные веб-сайты, с помощью рассылки ссылок на вредоносные сайты, вложенных в сообщения электронной почты и т.д. В случае успешной установки на компьютере пользователя, вредоносный код направляет злоумышленнику сообщение о том, что система была взломана и теперь доступна злоумышленнику, который может использовать ее по своему желанию. Например, он может использовать созданную ботсеть для проведения мощной DDoS-атаки или сдавать ее в аренду спамерам. При этом большинство компьютеров, входящих в ботсеть, являются домашними компьютерами ничего не подозревающих пользователей.

### 9.1. Антивирусное программное обеспечение

Традиционное антивирусное программное обеспечение использует **сигнатуры** для обнаружения вредоносного кода. **Сигнатуры** – это «отпечатки пальцев» вредоносного кода, созданные производителем антивирусного программного обеспечения. Сигнатура представляет собой фрагменты кода, извлеченные из самого вируса. Антивирусная программа сканирует файлы, сообщения электронной почты и другие данные, проходящие через определенные протоколы, и сравнивает их со своей базой вирусных сигнатур. При выявлении совпадений, антивирусная программа выполняет заранее настроенное действие, которым может быть отправка зараженного файла в карантин, попытка «вылечить» файл (удалить вирус), отображение окна с предупреждением для пользователя и/или запись события в журнал регистрации событий.

**Выявление вредоносного кода на основе сигнатур** – это эффективный способ обнаружения вредоносного программного обеспечения, однако при этом существуют определенные задержки в части реагирования на новые угрозы. После первого обнаружения вируса, производитель антивируса должен изучить этот вирус, разработать и протестировать новые сигнатуры, выпустить обновление базы сигнатур, а все пользователи должны загрузить это обновление.

Поскольку новые вредоносные программы создаются ежедневно, производителям антивирусного программного обеспечения трудно не отставать. Технология использования вирусных сигнатур позволяет обнаруживать вирусы, которые уже были выявлены, и для которых была создана сигнатура. Но в связи с тем, что авторы вирусов очень плодовиты, а многие вирусы могут изменять свой код, очень важно, чтобы антивирусное программное обеспечение имело и другие механизмы, позволяющие обнаружить вредоносный код.

Другим методом, который используют почти все антивирусные программные продукты, является обнаружение вредоносного кода на основе **эвристического анализа** (heuristic detection). Этот метод анализирует общую структуру вредоносного кода, оценивает выполняемые кодом инструкции и алгоритмы, изучает типы данных, используемые вредоносной программой. Таким образом, он собирает большой объем информации о фрагменте кода и оценивает вероятность того, что он имеет вредоносный характер. Он использует некий «счетчик подозрительности», который увеличивается по мере того, как антивирусная программа находит в нем новые потенциально опасные (подозрительные) свойства. При достижении заранее определенного порогового значения, код считается опасным, и антивирусная программа инициирует соответствующие защитные механизмы. Это позволяет антивирусному программному обеспечению распознавать неизвестные вредоносные программы, а не только полагаться на сигнатуры.

> Рассмотрим следующую аналогию. Иван – полицейский, он работает, чтобы поймать плохих парней и запереть их. Если Иван собирается использовать метод сигнатур, он сравнивает стопки фотографий с каждым человеком, которого он видит на улице. Когда он видит совпадение, он быстро ловит плохого парня и сажает его в свою патрульную машину. Если он собирается использовать эвристический метод, он следит за подозрительными действиями. Например, если он видит человека в лыжной маске, стоящего перед входом в банк, он оценивает вероятность того, что это грабитель, а не просто замерзший парень, выпрашивающий мелочь у посетителей банка.

Некоторые антивирусные продукты создают искусственную среду, называемую виртуальной машиной или песочницей, и позволяют некоторой части подозрительного кода выполниться в защищенной среде. Это дает антивирусной программе возможность увидеть код в действий, что дает гораздо больше информации для принятия решения, является ли он вредоносным или нет.

Анализ информации о части кода называется статическим анализом, если выполняется запуск части кода на виртуальной машине, это называется динамическим анализом. Оба этих метода считаются эвристическими методами обнаружения.

Следующим этапом эволюции антивирусного программного обеспечения называют поведенческие блокираторы (behavior blocker). Антивирусное программное обеспечение, выполняющее блокировку на основе поведения, фактически позволяет подозрительному коду выполняться в незащищенной операционной системе и следит за его взаимодействием с операционной системой, обращая внимание на подозрительные действия. В частности, антивирусное программное обеспечение следит за следующими видами действий:
- Запись в автоматически загружаемые при запуске системы файлы или в разделы автозапуска в системном реестре
- Открытие, удаление или изменение файлов
- Включение скриптов в сообщения электронной почты для отправки исполняемого кода
- Подключение к сетевым ресурсам или общим папкам
- Изменение логики исполняемого кода
- Создание или изменение макросов и скриптов
- Форматирование жесткого диска или запись в загрузочный сектор

Если антивирусная программа выявляет некоторые из этих потенциально опасных действий, она может принудительно завершить такую программу и сообщить об этом пользователю. Новое поколение поведенческих блокаторов в действительности анализирует последовательность выполнения таких действий, прежде чем решить, что система заражена (поведенческие блокаторы первого поколения срабатывали просто на отдельные действия, что приводило к большому числу ложных срабатываний). Современное антивирусное программное обеспечение может перехватывать выполнение опасных частей кода и не позволяет им взаимодействовать с другими запущенными процессами. Также они могут обнаруживать руткиты. Некоторые из таких антивирусных программ позволяют выполнить «откат» системы до состояния, в котором она была перед заражением, «стирая» все изменения, выполненные вредоносным кодом.

Большинство антивирусных программ, используют сочетание всех этих технологий, чтобы обеспечить максимальную защиту, насколько это возможно.

![[Pasted image 20241126162733.png]]

### 9.2. Противодействие вредоносному коду

Защита компаний от большого списка различных вредоносных программ требует большего, чем просто антивирусное программное обеспечение. Как и с другими компонентами программы безопасности, требуется внедрить и поддерживать некоторые дополнительные административные, физические и технические защитные меры и средства. У компании должна быть отдельная антивирусная политика, либо вопросы антивирусной защиты должны учитываться в общей политикие безопасности. Должны быть разработаны стандарты, определяющие необходимые для использования в компании виды антивирусного и анти-шпионского программного обеспечения, а также основные параметры их конфигурации.

Сведения о вирусных атаках, используемых средствах антивирусной защиты, а также об ожидаемом от пользователей поведении должны быть предусмотрены в программе повышения осведомленности. Каждый пользователь должен знать, что он должен делать и куда обращаться, если на его компьютере будет обнаружен вирус. В стандарте должны быть рассмотрены все вопросы, касающиеся действий пользователя, связанных с вредоносным кодом, должно быть указано, что долженделать пользователь и что делать ему запрещается.

В частности, стандарт должен содержать следующие вопросы:
- На каждую рабочую станцию, сервер, коммуникатор, смартфон должно быть установлено антивирусное программное обеспечение.
- Для каждого из этих устройств должен быть реализован способ автоматического обновления антивирусных сигнатур, который должен быть включен и настроен на каждом устройстве.
- У пользователя не должно быть возможности отключить антивирусное программное обеспечение.
- Должен быть заранее разработан и спланирован процесс удаления вирусов, должно быть определено и назначено контактное лицо, на случай выявления вредоносного кода.
- Все внешние диски (USB-накопители и т.п.) должны сканироваться автоматически.
- Должны сканироваться файлы резервных копий.
- Должен проводиться ежегодный пересмотр антивирусных политик и процедур.
- Используемое антивирусное программное обеспечение должно обеспечивать защиту от загрузочных вирусов.
- Антивирусное сканирование должно независимо выполняться на шлюзе и на каждом отдельном устройстве.
- Антивирусное сканирование должно выполняться автоматически по расписанию. Не нужно расчитывать на то, что пользователи будут запускать сканирование вручную.
- Критичные системы должны быть физически защищены таким образом, чтобы локальная установка на них вредоносного программного обеспечения была невозможна.



